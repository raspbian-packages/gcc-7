# DP: updates from the 6 branch upto 20180201 (documentation).

svn diff svn://gcc.gnu.org/svn/gcc/tags/gcc_7_3_0_release svn://gcc.gnu.org/svn/gcc/branches/gcc-7-branch \
	| sed -r 's,^--- (\S+)\t(\S+)(.*)$,--- a/src/\1\t\2,;s,^\+\+\+ (\S+)\t(\S+)(.*)$,+++ b/src/\1\t\2,' \
	| awk '/^Index:.*\.texi/ {skip=0; print; next} /^Index:/ {skip=1; next} skip==0'

Index: gcc/doc/tm.texi
===================================================================
--- a/src/gcc/doc/tm.texi	(.../tags/gcc_7_3_0_release)
+++ b/src/gcc/doc/tm.texi	(.../branches/gcc-7-branch)
@@ -10645,8 +10645,12 @@
 
 @defmac WORD_REGISTER_OPERATIONS
 Define this macro to 1 if operations between registers with integral mode
-smaller than a word are always performed on the entire register.
-Most RISC machines have this property and most CISC machines do not.
+smaller than a word are always performed on the entire register.  To be
+more explicit, if you start with a pair of @code{word_mode} registers with
+known values and you do a subword, for example @code{QImode}, addition on
+the low part of the registers, then the compiler may consider that the
+result has a known value in @code{word_mode} too if the macro is defined
+to 1.  Most RISC machines have this property and most CISC machines do not.
 @end defmac
 
 @deftypefn {Target Hook} {unsigned int} TARGET_MIN_ARITHMETIC_PRECISION (void)
Index: gcc/doc/tm.texi.in
===================================================================
--- a/src/gcc/doc/tm.texi.in	(.../tags/gcc_7_3_0_release)
+++ b/src/gcc/doc/tm.texi.in	(.../branches/gcc-7-branch)
@@ -7581,8 +7581,12 @@
 
 @defmac WORD_REGISTER_OPERATIONS
 Define this macro to 1 if operations between registers with integral mode
-smaller than a word are always performed on the entire register.
-Most RISC machines have this property and most CISC machines do not.
+smaller than a word are always performed on the entire register.  To be
+more explicit, if you start with a pair of @code{word_mode} registers with
+known values and you do a subword, for example @code{QImode}, addition on
+the low part of the registers, then the compiler may consider that the
+result has a known value in @code{word_mode} too if the macro is defined
+to 1.  Most RISC machines have this property and most CISC machines do not.
 @end defmac
 
 @hook TARGET_MIN_ARITHMETIC_PRECISION
Index: gcc/doc/invoke.texi
===================================================================
--- a/src/gcc/doc/invoke.texi	(.../tags/gcc_7_3_0_release)
+++ b/src/gcc/doc/invoke.texi	(.../branches/gcc-7-branch)
@@ -1211,7 +1211,7 @@
 -mavx256-split-unaligned-load  -mavx256-split-unaligned-store @gol
 -malign-data=@var{type}  -mstack-protector-guard=@var{guard} @gol
 -mmitigate-rop  -mgeneral-regs-only @gol
--mindirect-branch=@var{choice} -mfunction-return==@var{choice} @gol
+-mindirect-branch=@var{choice} -mfunction-return=@var{choice} @gol
 -mindirect-branch-register}
 
 @emph{x86 Windows Options}

# DP: updates from the 7 branch upto 20190820 (r27450).

last_update()
{
	cat > ${dir}LAST_UPDATED <EOF
Tue Aug 20 17:29:25 CEST 2019
Tue Aug 20 15:29:25 UTC 2019 (revision 274750)
EOF
}

LANG=C svn diff svn://gcc.gnu.org/svn/gcc/tags/gcc_7_4_0_release svn://gcc.gnu.org/svn/gcc/branches/gcc-7-branch \
	| sed -r 's,^--- (\S+)\t(\S+)(.*)$,--- a/src/\1\t\2,;s,^\+\+\+ (\S+)\t(\S+)(.*)$,+++ b/src/\1\t\2,' \
	| awk '/^Index:.*\.(class|texi)/ {skip=1; next} /^Index:/ { skip=0 } skip==0'

Index: libitm/ChangeLog
===================================================================
--- a/src/libitm/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/libitm/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,11 @@
+2018-12-13  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backport from mainline
+	2018-12-13  Peter Bergner  <bergner@linux.ibm.com>
+
+	* config/powerpc/target.h (htm_available):  Add support for
+	PPC_FEATURE2_HTM_NO_SUSPEND.  Use __builtin_cpu_supports if available.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: libitm/config/powerpc/target.h
===================================================================
--- a/src/libitm/config/powerpc/target.h	(.../tags/gcc_7_4_0_release)
+++ b/src/libitm/config/powerpc/target.h	(.../branches/gcc-7-branch)
@@ -81,7 +81,20 @@
 static inline bool
 htm_available (void)
 {
-  return (getauxval (AT_HWCAP2) & PPC_FEATURE2_HAS_HTM) ? true : false;
+#ifdef __BUILTIN_CPU_SUPPORTS__
+  if (__builtin_cpu_supports ("htm-no-suspend")
+      || __builtin_cpu_supports ("htm"))
+    return true;
+#else
+  unsigned long htm_flags = PPC_FEATURE2_HAS_HTM
+#ifdef PPC_FEATURE2_HTM_NO_SUSPEND
+			    | PPC_FEATURE2_HTM_NO_SUSPEND
+#endif
+			    | 0;
+  if (getauxval (AT_HWCAP2) & htm_flags)
+    return true;
+#endif
+  return false;
 }
 
 static inline uint32_t
Index: libstdc++-v3/configure
===================================================================
--- a/src/libstdc++-v3/configure	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/configure	(.../branches/gcc-7-branch)
@@ -637,6 +637,7 @@
 XSL_STYLE_DIR
 XMLLINT
 XSLTPROC
+XMLCATALOG
 DOT
 DOXYGEN
 BUILD_INFO_FALSE
@@ -11605,7 +11606,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11608 "configure"
+#line 11609 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11711,7 +11712,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11714 "configure"
+#line 11715 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -15397,7 +15398,7 @@
   # Fake what AC_TRY_COMPILE does.
 
     cat > conftest.$ac_ext << EOF
-#line 15400 "configure"
+#line 15401 "configure"
 int main()
 {
   typedef bool atomic_type;
@@ -15432,7 +15433,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15435 "configure"
+#line 15436 "configure"
 int main()
 {
   typedef short atomic_type;
@@ -15467,7 +15468,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15470 "configure"
+#line 15471 "configure"
 int main()
 {
   // NB: _Atomic_word not necessarily int.
@@ -15503,7 +15504,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15506 "configure"
+#line 15507 "configure"
 int main()
 {
   typedef long long atomic_type;
@@ -15584,7 +15585,7 @@
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15587 "configure"
+#line 15588 "configure"
 int main()
 {
   _Decimal32 d1;
@@ -15626,7 +15627,7 @@
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15629 "configure"
+#line 15630 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
@@ -15660,7 +15661,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15663 "configure"
+#line 15664 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
@@ -80998,6 +80999,44 @@
 
 
 # Check for docbook
+# Extract the first word of "xmlcatalog", so it can be a program name with args.
+set dummy xmlcatalog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_XMLCATALOG+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$XMLCATALOG"; then
+  ac_cv_prog_XMLCATALOG="$XMLCATALOG" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_XMLCATALOG="yes"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_prog_XMLCATALOG" && ac_cv_prog_XMLCATALOG="no"
+fi
+fi
+XMLCATALOG=$ac_cv_prog_XMLCATALOG
+if test -n "$XMLCATALOG"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $XMLCATALOG" >&5
+$as_echo "$XMLCATALOG" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
 # Extract the first word of "xsltproc", so it can be a program name with args.
 set dummy xsltproc; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
@@ -81076,31 +81115,28 @@
 
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for docbook stylesheets for documentation creation" >&5
-$as_echo_n "checking for docbook stylesheets for documentation creation... " >&6; }
-glibcxx_stylesheets=no
-if test x${XSLTPROC} = xyes && echo '<title/>' | xsltproc --noout --nonet --xinclude http://docbook.sourceforge.net/release/xsl-ns/current/xhtml-1_1/docbook.xsl - 2>/dev/null; then
-  glibcxx_stylesheets=yes
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_stylesheets" >&5
-$as_echo "$glibcxx_stylesheets" >&6; }
+glibcxx_docbook_url=http://docbook.sourceforge.net/release/xsl-ns/current/
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for local stylesheet directory" >&5
 $as_echo_n "checking for local stylesheet directory... " >&6; }
 glibcxx_local_stylesheets=no
-if test x"$glibcxx_stylesheets" = x"yes"; then
-  if test -d /usr/share/sgml/docbook/xsl-ns-stylesheets; then
-    glibcxx_local_stylesheets=yes
-    XSL_STYLE_DIR=/usr/share/sgml/docbook/xsl-ns-stylesheets
-  fi
-  if test -d /usr/share/xml/docbook/stylesheet/docbook-xsl-ns; then
-    glibcxx_local_stylesheets=yes
-    XSL_STYLE_DIR=/usr/share/xml/docbook/stylesheet/docbook-xsl-ns
-  fi
-  if test -d /usr/share/xml/docbook/stylesheet/nwalsh5/current; then
-    glibcxx_local_stylesheets=yes
-    XSL_STYLE_DIR=/usr/share/xml/docbook/stylesheet/nwalsh5/current
-  fi
+if test x${XMLCATALOG} = xyes && xsl_style_dir=`xmlcatalog "" $glibcxx_docbook_url 2>/dev/null`
+then
+  XSL_STYLE_DIR=`echo $xsl_style_dir | sed -n 's;^file://;;p'`
+  glibcxx_local_stylesheets=yes
+else
+  for dir in \
+    /usr/share/sgml/docbook/xsl-ns-stylesheets \
+    /usr/share/xml/docbook/stylesheet/docbook-xsl-ns \
+    /usr/share/xml/docbook/stylesheet/nwalsh5/current \
+    /usr/share/xml/docbook/stylesheet/nwalsh/current
+  do
+    if test -d $dir; then
+      glibcxx_local_stylesheets=yes
+      XSL_STYLE_DIR=$dir
+      break
+    fi
+  done
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_local_stylesheets" >&5
 $as_echo "$glibcxx_local_stylesheets" >&6; }
@@ -81109,6 +81145,18 @@
 
   { $as_echo "$as_me:${as_lineno-$LINENO}: $XSL_STYLE_DIR" >&5
 $as_echo "$as_me: $XSL_STYLE_DIR" >&6;}
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for docbook stylesheets for documentation creation" >&5
+$as_echo_n "checking for docbook stylesheets for documentation creation... " >&6; }
+  glibcxx_stylesheets=no
+  if test x${XMLCATALOG} = xno || xmlcatalog "" $glibcxx_docbook_url/xhtml/docbook.xsl >/dev/null 2>&1; then
+    if test x${XSLTPROC} = xyes && echo '<title/>' | xsltproc --noout --nonet --xinclude $glibcxx_docbook_url/xhtml/docbook.xsl - 2>/dev/null; then
+      glibcxx_stylesheets=yes
+    fi
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_stylesheets" >&5
+$as_echo "$glibcxx_stylesheets" >&6; }
+
 else
   glibcxx_stylesheets=no
 fi
Index: libstdc++-v3/python/Makefile.in
===================================================================
--- a/src/libstdc++-v3/python/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/python/Makefile.in	(.../branches/gcc-7-branch)
@@ -234,6 +234,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/Makefile.in
===================================================================
--- a/src/libstdc++-v3/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/Makefile.in	(.../branches/gcc-7-branch)
@@ -232,6 +232,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/scripts/make_exports.pl
===================================================================
--- a/src/libstdc++-v3/scripts/make_exports.pl	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/scripts/make_exports.pl	(.../branches/gcc-7-branch)
@@ -103,6 +103,14 @@
     # Ignore undefined and local symbols.
     next if (/^([^ ]+) [Ua-z] /);
 
+    # GCC does not export construction vtables from shared libraries.
+    # However the symbols are marked hidden, for Darwin that makes them
+    # also external "private_extern", which means that they show up in
+    # this list.  When ld64 encounters them it generates a warning that
+    # they cannot be exported, so trim them from the set now.
+    next if (/^construction vtable.*$/);
+    next if (/^__ZTC.*$/);
+
     # $sym is the name of the symbol, $noeh_sym is the same thing with
     # any '.eh' suffix removed.
     die "unknown nm output $_" if (! /^([^ ]+) [A-Z] /);
Index: libstdc++-v3/src/c++17/Makefile.in
===================================================================
--- a/src/libstdc++-v3/src/c++17/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/src/c++17/Makefile.in	(.../branches/gcc-7-branch)
@@ -0,0 +1,754 @@
+# Makefile.in generated by automake 1.15.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994-2017 Free Software Foundation, Inc.
+
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+am__is_gnu_make = { \
+  if test -z '$(MAKELEVEL)'; then \
+    false; \
+  elif test -n '$(MAKE_HOST)'; then \
+    true; \
+  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
+    true; \
+  else \
+    false; \
+  fi; \
+}
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+subdir = src/c++17
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \
+	$(top_srcdir)/../config/enable.m4 \
+	$(top_srcdir)/../config/futex.m4 \
+	$(top_srcdir)/../config/hwcaps.m4 \
+	$(top_srcdir)/../config/iconv.m4 \
+	$(top_srcdir)/../config/lead-dot.m4 \
+	$(top_srcdir)/../config/lib-ld.m4 \
+	$(top_srcdir)/../config/lib-link.m4 \
+	$(top_srcdir)/../config/lib-prefix.m4 \
+	$(top_srcdir)/../config/lthostflags.m4 \
+	$(top_srcdir)/../config/multi.m4 \
+	$(top_srcdir)/../config/no-executables.m4 \
+	$(top_srcdir)/../config/override.m4 \
+	$(top_srcdir)/../config/stdint.m4 \
+	$(top_srcdir)/../config/unwind_ipinfo.m4 \
+	$(top_srcdir)/../libtool.m4 $(top_srcdir)/../ltoptions.m4 \
+	$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \
+	$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/crossconfig.m4 \
+	$(top_srcdir)/linkage.m4 $(top_srcdir)/acinclude.m4 \
+	$(top_srcdir)/../config/gc++filt.m4 \
+	$(top_srcdir)/../config/tls.m4 $(top_srcdir)/../config/gthr.m4 \
+	$(top_srcdir)/../config/cet.m4 $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+DIST_COMMON = $(srcdir)/Makefile.am
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libc__17convenience_la_LIBADD =
+@ENABLE_DUAL_ABI_TRUE@am__objects_1 = cow-fs_dir.lo cow-fs_ops.lo \
+@ENABLE_DUAL_ABI_TRUE@	cow-fs_path.lo
+am__objects_2 = fs_dir.lo fs_ops.lo fs_path.lo memory_resource.lo \
+	$(am__objects_1)
+@ENABLE_DUAL_ABI_TRUE@am__objects_3 = cow-string-inst.lo
+@ENABLE_EXTERN_TEMPLATE_TRUE@am__objects_4 = ostream-inst.lo \
+@ENABLE_EXTERN_TEMPLATE_TRUE@	string-inst.lo $(am__objects_3)
+am_libc__17convenience_la_OBJECTS = $(am__objects_2) $(am__objects_4)
+libc__17convenience_la_OBJECTS = $(am_libc__17convenience_la_OBJECTS)
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
+AM_V_CXX = $(am__v_CXX_@AM_V@)
+am__v_CXX_ = $(am__v_CXX_@AM_DEFAULT_V@)
+am__v_CXX_0 = @echo "  CXX     " $@;
+am__v_CXX_1 = 
+CXXLD = $(CXX)
+AM_V_CXXLD = $(am__v_CXXLD_@AM_V@)
+am__v_CXXLD_ = $(am__v_CXXLD_@AM_DEFAULT_V@)
+am__v_CXXLD_0 = @echo "  CXXLD   " $@;
+am__v_CXXLD_1 = 
+SOURCES = $(libc__17convenience_la_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
+ETAGS = etags
+CTAGS = ctags
+ABI_TWEAKS_SRCDIR = @ABI_TWEAKS_SRCDIR@
+ACLOCAL = @ACLOCAL@
+ALLOCATOR_H = @ALLOCATOR_H@
+ALLOCATOR_NAME = @ALLOCATOR_NAME@
+AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
+AR = @AR@
+AS = @AS@
+ATOMICITY_SRCDIR = @ATOMICITY_SRCDIR@
+ATOMIC_FLAGS = @ATOMIC_FLAGS@
+ATOMIC_WORD_SRCDIR = @ATOMIC_WORD_SRCDIR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+BASIC_FILE_CC = @BASIC_FILE_CC@
+BASIC_FILE_H = @BASIC_FILE_H@
+CC = @CC@
+CCODECVT_CC = @CCODECVT_CC@
+CCOLLATE_CC = @CCOLLATE_CC@
+CCTYPE_CC = @CCTYPE_CC@
+CFLAGS = @CFLAGS@
+CLOCALE_CC = @CLOCALE_CC@
+CLOCALE_H = @CLOCALE_H@
+CLOCALE_INTERNAL_H = @CLOCALE_INTERNAL_H@
+CMESSAGES_CC = @CMESSAGES_CC@
+CMESSAGES_H = @CMESSAGES_H@
+CMONEY_CC = @CMONEY_CC@
+CNUMERIC_CC = @CNUMERIC_CC@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPU_DEFINES_SRCDIR = @CPU_DEFINES_SRCDIR@
+CPU_OPT_BITS_RANDOM = @CPU_OPT_BITS_RANDOM@
+CPU_OPT_EXT_RANDOM = @CPU_OPT_EXT_RANDOM@
+CSTDIO_H = @CSTDIO_H@
+CTIME_CC = @CTIME_CC@
+CTIME_H = @CTIME_H@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXFILT = @CXXFILT@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+C_INCLUDE_DIR = @C_INCLUDE_DIR@
+DBLATEX = @DBLATEX@
+DEBUG_FLAGS = @DEBUG_FLAGS@
+DEFS = @DEFS@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+ERROR_CONSTANTS_SRCDIR = @ERROR_CONSTANTS_SRCDIR@
+EXEEXT = @EXEEXT@
+EXTRA_CFLAGS = @EXTRA_CFLAGS@
+EXTRA_CXX_FLAGS = @EXTRA_CXX_FLAGS@
+FGREP = @FGREP@
+GLIBCXX_INCLUDES = @GLIBCXX_INCLUDES@
+GLIBCXX_LIBS = @GLIBCXX_LIBS@
+GREP = @GREP@
+HWCAP_CFLAGS = @HWCAP_CFLAGS@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LONG_DOUBLE_COMPAT_FLAGS = @LONG_DOUBLE_COMPAT_FLAGS@
+LTLIBICONV = @LTLIBICONV@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OPTIMIZE_CXXFLAGS = @OPTIMIZE_CXXFLAGS@
+OPT_LDFLAGS = @OPT_LDFLAGS@
+OS_INC_SRCDIR = @OS_INC_SRCDIR@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PDFLATEX = @PDFLATEX@
+RANLIB = @RANLIB@
+SECTION_FLAGS = @SECTION_FLAGS@
+SECTION_LDFLAGS = @SECTION_LDFLAGS@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+SYMVER_FILE = @SYMVER_FILE@
+TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@
+USE_NLS = @USE_NLS@
+VERSION = @VERSION@
+VTV_CXXFLAGS = @VTV_CXXFLAGS@
+VTV_CXXLINKFLAGS = @VTV_CXXLINKFLAGS@
+VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
+WARN_FLAGS = @WARN_FLAGS@
+XMLCATALOG = @XMLCATALOG@
+XMLLINT = @XMLLINT@
+XSLTPROC = @XSLTPROC@
+XSL_STYLE_DIR = @XSL_STYLE_DIR@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__leading_dot = @am__leading_dot@
+am__tar = @am__tar@
+am__untar = @am__untar@
+baseline_dir = @baseline_dir@
+baseline_subdir_switch = @baseline_subdir_switch@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+check_msgfmt = @check_msgfmt@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_shared = @enable_shared@
+enable_static = @enable_static@
+exec_prefix = @exec_prefix@
+get_gcc_base_ver = @get_gcc_base_ver@
+glibcxx_MOFILES = @glibcxx_MOFILES@
+glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@
+glibcxx_POFILES = @glibcxx_POFILES@
+glibcxx_builddir = @glibcxx_builddir@
+glibcxx_compiler_pic_flag = @glibcxx_compiler_pic_flag@
+glibcxx_compiler_shared_flag = @glibcxx_compiler_shared_flag@
+glibcxx_cxx98_abi = @glibcxx_cxx98_abi@
+glibcxx_localedir = @glibcxx_localedir@
+glibcxx_lt_pic_flag = @glibcxx_lt_pic_flag@
+glibcxx_prefixdir = @glibcxx_prefixdir@
+glibcxx_srcdir = @glibcxx_srcdir@
+glibcxx_toolexecdir = @glibcxx_toolexecdir@
+glibcxx_toolexeclibdir = @glibcxx_toolexeclibdir@
+gxx_include_dir = @gxx_include_dir@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+libtool_VERSION = @libtool_VERSION@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_host_flags = @lt_host_flags@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+multi_basedir = @multi_basedir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+port_specific_symbol_files = @port_specific_symbol_files@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+python_mod_dir = @python_mod_dir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+thread_header = @thread_header@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+toplevel_builddir = @toplevel_builddir@
+toplevel_srcdir = @toplevel_srcdir@
+
+# May be used by various substitution variables.
+gcc_version := $(shell @get_gcc_base_ver@ $(top_srcdir)/../gcc/BASE-VER)
+MAINT_CHARSET = latin1
+mkinstalldirs = $(SHELL) $(toplevel_srcdir)/mkinstalldirs
+PWD_COMMAND = $${PWDCMD-pwd}
+STAMP = echo timestamp >
+toolexecdir = $(glibcxx_toolexecdir)
+toolexeclibdir = $(glibcxx_toolexeclibdir)
+@ENABLE_WERROR_FALSE@WERROR_FLAG = 
+@ENABLE_WERROR_TRUE@WERROR_FLAG = -Werror
+@ENABLE_EXTERN_TEMPLATE_FALSE@XTEMPLATE_FLAGS = 
+@ENABLE_EXTERN_TEMPLATE_TRUE@XTEMPLATE_FLAGS = -fno-implicit-templates
+
+# These bits are all figured out from configure.  Look in acinclude.m4
+# or configure.ac to see how they are set.  See GLIBCXX_EXPORT_FLAGS.
+CONFIG_CXXFLAGS = \
+	$(SECTION_FLAGS) $(HWCAP_CFLAGS) -frandom-seed=$@
+
+WARN_CXXFLAGS = \
+	$(WARN_FLAGS) $(WERROR_FLAG) -fdiagnostics-show-location=once 
+
+
+# -I/-D flags to pass when compiling.
+AM_CPPFLAGS = $(GLIBCXX_INCLUDES) $(CPPFLAGS)
+
+# Convenience library for C++17 runtime.
+noinst_LTLIBRARIES = libc++17convenience.la
+headers = 
+@ENABLE_DUAL_ABI_FALSE@extra_string_inst_sources = 
+@ENABLE_DUAL_ABI_TRUE@extra_string_inst_sources = cow-string-inst.cc
+@ENABLE_DUAL_ABI_FALSE@extra_fs_sources = 
+@ENABLE_DUAL_ABI_TRUE@extra_fs_sources = \
+@ENABLE_DUAL_ABI_TRUE@	cow-fs_dir.cc \
+@ENABLE_DUAL_ABI_TRUE@	cow-fs_ops.cc \
+@ENABLE_DUAL_ABI_TRUE@	cow-fs_path.cc
+
+# XTEMPLATE_FLAGS =
+@ENABLE_EXTERN_TEMPLATE_FALSE@inst_sources = 
+
+# XTEMPLATE_FLAGS = -fno-implicit-templates
+@ENABLE_EXTERN_TEMPLATE_TRUE@inst_sources = \
+@ENABLE_EXTERN_TEMPLATE_TRUE@	ostream-inst.cc \
+@ENABLE_EXTERN_TEMPLATE_TRUE@	string-inst.cc \
+@ENABLE_EXTERN_TEMPLATE_TRUE@	$(extra_string_inst_sources)
+
+sources = \
+	fs_dir.cc \
+	fs_ops.cc \
+	fs_path.cc \
+	memory_resource.cc \
+	$(extra_fs_sources)
+
+libc__17convenience_la_SOURCES = $(sources)  $(inst_sources)
+
+# AM_CXXFLAGS needs to be in each subdirectory so that it can be
+# modified in a per-library or per-sub-library way.  Need to manually
+# set this option because CONFIG_CXXFLAGS has to be after
+# OPTIMIZE_CXXFLAGS on the compile line so that -O2 can be overridden
+# as the occasion calls for it.
+AM_CXXFLAGS = \
+	-std=gnu++17 \
+	$(glibcxx_lt_pic_flag) $(glibcxx_compiler_shared_flag) \
+	$(XTEMPLATE_FLAGS) $(VTV_CXXFLAGS) \
+	$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS) $(CONFIG_CXXFLAGS) \
+	-fimplicit-templates
+
+AM_MAKEFLAGS = \
+	"gxx_include_dir=$(gxx_include_dir)"
+
+
+# Libtool notes
+
+# 1) In general, libtool expects an argument such as `--tag=CXX' when
+# using the C++ compiler, because that will enable the settings
+# detected when C++ support was being configured.  However, when no
+# such flag is given in the command line, libtool attempts to figure
+# it out by matching the compiler name in each configuration section
+# against a prefix of the command line.  The problem is that, if the
+# compiler name and its initial flags stored in the libtool
+# configuration file don't match those in the command line, libtool
+# can't decide which configuration to use, and it gives up.  The
+# correct solution is to add `--tag CXX' to LTCXXCOMPILE and maybe
+# CXXLINK, just after $(LIBTOOL), so that libtool doesn't have to
+# attempt to infer which configuration to use.
+#
+# The second tag argument, `--tag disable-shared` means that libtool
+# only compiles each source once, for static objects. In actuality,
+# glibcxx_lt_pic_flag and glibcxx_compiler_shared_flag are added to
+# the libtool command that is used create the object, which is
+# suitable for shared libraries.  The `--tag disable-shared` must be
+# placed after --tag CXX lest things CXX undo the affect of
+# disable-shared.
+
+# 2) Need to explicitly set LTCXXCOMPILE so that EXTRA_CXX_FLAGS is
+# last. (That way, things like -O2 passed down from the toplevel can
+# be overridden by --enable-debug.)
+LTCXXCOMPILE = \
+	$(LIBTOOL) --tag CXX --tag disable-shared \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CXX) $(TOPLEVEL_INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) $(EXTRA_CXX_FLAGS)
+
+LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))
+
+# 3) We'd have a problem when building the shared libstdc++ object if
+# the rules automake generates would be used.  We cannot allow g++ to
+# be used since this would add -lstdc++ to the link line which of
+# course is problematic at this point.  So, we get the top-level
+# directory to configure libstdc++-v3 to use gcc as the C++
+# compilation driver.
+CXXLINK = \
+	$(LIBTOOL) --tag CXX --tag disable-shared \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CXX) \
+	$(VTV_CXXLINKFLAGS) \
+	$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .cc .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/fragment.am $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign --ignore-deps src/c++17/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign --ignore-deps src/c++17/Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+$(top_srcdir)/fragment.am $(am__empty):
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; \
+	locs=`for p in $$list; do echo $$p; done | \
+	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
+	      sort -u`; \
+	test -z "$$locs" || { \
+	  echo rm -f $${locs}; \
+	  rm -f $${locs}; \
+	}
+
+libc++17convenience.la: $(libc__17convenience_la_OBJECTS) $(libc__17convenience_la_DEPENDENCIES) $(EXTRA_libc__17convenience_la_DEPENDENCIES) 
+	$(AM_V_CXXLD)$(CXXLINK)  $(libc__17convenience_la_OBJECTS) $(libc__17convenience_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+.cc.o:
+	$(AM_V_CXX)$(CXXCOMPILE) -c -o $@ $<
+
+.cc.obj:
+	$(AM_V_CXX)$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+
+.cc.lo:
+	$(AM_V_CXX)$(LTCXXCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
+
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	set x; \
+	here=`pwd`; \
+	$(am__define_uniq_tagged_files); \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES cscopelist-am ctags \
+	ctags-am distclean distclean-compile distclean-generic \
+	distclean-libtool distclean-tags dvi dvi-am html html-am info \
+	info-am install install-am install-data install-data-am \
+	install-dvi install-dvi-am install-exec install-exec-am \
+	install-html install-html-am install-info install-info-am \
+	install-man install-pdf install-pdf-am install-ps \
+	install-ps-am install-strip installcheck installcheck-am \
+	installdirs maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \
+	uninstall-am
+
+.PRECIOUS: Makefile
+
+
+vpath % $(top_srcdir)/src/c++17
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: libstdc++-v3/src/Makefile.in
===================================================================
--- a/src/libstdc++-v3/src/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/src/Makefile.in	(.../branches/gcc-7-branch)
@@ -267,6 +267,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/src/filesystem/path.cc
===================================================================
--- a/src/libstdc++-v3/src/filesystem/path.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/src/filesystem/path.cc	(.../branches/gcc-7-branch)
@@ -333,6 +333,28 @@
   if (_M_pathname.empty())
     return;
 
+  {
+    // Approximate count of components, to reserve space in _M_cmpts vector:
+    int count = 1;
+    bool saw_sep_last = _S_is_dir_sep(_M_pathname[0]);
+    bool saw_non_sep = !saw_sep_last;
+    for (value_type c : _M_pathname)
+      {
+       if (_S_is_dir_sep(c))
+         saw_sep_last = true;
+       else if (saw_sep_last)
+         {
+           ++count;
+           saw_sep_last = false;
+           saw_non_sep = true;
+         }
+      }
+    if (saw_non_sep && saw_sep_last)
+      ++count; // empty filename after trailing slash
+    if (count > 1)
+      _M_cmpts.reserve(count);
+  }
+
   size_t pos = 0;
   const size_t len = _M_pathname.size();
 
@@ -355,9 +377,13 @@
 	      pos = 3;
 	      while (pos < len && !_S_is_dir_sep(_M_pathname[pos]))
 		++pos;
+	      if (pos == len)
+		{
+		  _M_type = _Type::_Root_name;
+		  return;
+		}
 	      _M_add_root_name(pos);
-	      if (pos < len) // also got root directory
-		_M_add_root_dir(pos);
+	      _M_add_root_dir(pos);
 	    }
 	  else
 	    {
@@ -366,6 +392,11 @@
 	      _M_add_root_dir(0);
 	    }
 	}
+      else if (len == 1) // got root directory only
+	{
+	  _M_type = _Type::_Root_dir;
+	  return;
+	}
       else // got root directory
 	_M_add_root_dir(0);
       ++pos;
@@ -374,6 +405,11 @@
   else if (len > 1 && _M_pathname[1] == L':')
     {
       // got disk designator
+      if (len == 2)
+	{
+	  _M_type = _Type::_Root_name;
+	  return;
+	}
       _M_add_root_name(2);
       if (len > 2 && _S_is_dir_sep(_M_pathname[2]))
 	_M_add_root_dir(2);
@@ -380,6 +416,17 @@
       pos = 2;
     }
 #endif
+  else
+    {
+      size_t n = 1;
+      for (; n < _M_pathname.size() && !_S_is_dir_sep(_M_pathname[n]); ++n)
+	{ }
+      if (n == _M_pathname.size())
+	{
+	  _M_type = _Type::_Filename;
+	  return;
+	}
+    }
 
   size_t back = pos;
   while (pos < len)
Index: libstdc++-v3/src/filesystem/Makefile.in
===================================================================
--- a/src/libstdc++-v3/src/filesystem/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/src/filesystem/Makefile.in	(.../branches/gcc-7-branch)
@@ -246,6 +246,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/src/c++98/Makefile.in
===================================================================
--- a/src/libstdc++-v3/src/c++98/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/src/c++98/Makefile.in	(.../branches/gcc-7-branch)
@@ -238,6 +238,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/src/c++11/Makefile.in
===================================================================
--- a/src/libstdc++-v3/src/c++11/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/src/c++11/Makefile.in	(.../branches/gcc-7-branch)
@@ -242,6 +242,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/configure.host
===================================================================
--- a/src/libstdc++-v3/configure.host	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/configure.host	(.../branches/gcc-7-branch)
@@ -230,16 +230,15 @@
     os_include_dir="os/newlib"
     OPT_LDFLAGS="${OPT_LDFLAGS} \$(lt_host_flags)"
     ;;
-  darwin | darwin[1-7] | darwin[1-7].*)
-    # On Darwin, performance is improved if libstdc++ is single-module.
-    # Up to at least 10.3.7, -flat_namespace is required for proper
-    # treatment of coalesced symbols.
+  darwin[4-7] | darwin[4-7].*)
+    # For earlier Darwin, performance is improved if libstdc++ is
+    # single-module. Up to at least 10.3.7, -flat_namespace is required
+    # for proper treatment of coalesced symbols.
     OPT_LDFLAGS="${OPT_LDFLAGS} -Wl,-single_module -Wl,-flat_namespace"
     os_include_dir="os/bsd/darwin"
     ;;
-  darwin[89] | darwin[89].* | darwin[1-9][0-9]* )
-    # On Darwin, performance is improved if libstdc++ is single-module,
-    # and on 8+ compatibility is better if not -flat_namespace.
+  darwin8 | darwin8.* )
+    # For 8+ compatibility is better if not -flat_namespace.
     OPT_LDFLAGS="${OPT_LDFLAGS} -Wl,-single_module"
     case "${host_cpu}" in
       i[34567]86 | x86_64)
@@ -248,6 +247,10 @@
     esac
     os_include_dir="os/bsd/darwin"
     ;;
+  darwin*)
+    # Post Darwin8, defaults should be sufficient.
+    os_include_dir="os/bsd/darwin"
+    ;;
   *djgpp*)      # leading * picks up "msdosdjgpp"
     os_include_dir="os/djgpp"
     error_constants_dir="os/djgpp"
Index: libstdc++-v3/configure.ac
===================================================================
--- a/src/libstdc++-v3/configure.ac	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/configure.ac	(.../branches/gcc-7-branch)
@@ -436,6 +436,7 @@
 AC_CHECK_PROG([DOT], dot, yes, no)
 
 # Check for docbook
+AC_CHECK_PROG([XMLCATALOG], xmlcatalog, yes, no)
 AC_CHECK_PROG([XSLTPROC], xsltproc, yes, no)
 AC_CHECK_PROG([XMLLINT], xmllint, yes, no)
 GLIBCXX_CONFIGURE_DOCBOOK
Index: libstdc++-v3/doc/xml/manual/status_cxx2017.xml
===================================================================
--- a/src/libstdc++-v3/doc/xml/manual/status_cxx2017.xml	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/doc/xml/manual/status_cxx2017.xml	(.../branches/gcc-7-branch)
@@ -381,7 +381,7 @@
 	</link>
       </entry>
       <entry align="center"> 7.1 </entry>
-      <entry><code> </code></entry>
+      <entry><code>__cpp_lib_raw_memory_algorithms &gt;= 201606L</code></entry>
     </row>
 
     <row>
@@ -789,7 +789,32 @@
              <code> __cpp_lib_to_chars >= 201611 </code></entry>
     </row>
 
+    <row>
+      <entry> Homogeneous interface for variant, any and optional </entry>
+      <entry>
+	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0032r3.pdf">
+	P0032R3
+	</link>
+      </entry>
+      <entry align="center"> 7.1  </entry>
+      <entry>
+             <code> __cpp_lib_any >= 201606 </code>,
+             <code> __cpp_lib_optional >= 201606 </code>,
+             <code> __cpp_lib_variant >= 201606 </code>
+      </entry>
+    </row>
 
+    <row>
+      <entry> Making Optional Greater Equal Again </entry>
+      <entry>
+	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0307r2.pdf">
+	P0307R2
+	</link>
+      </entry>
+      <entry align="center"> 7.1  </entry>
+      <entry> <code> __cpp_lib_optional >= 201606 </code> </entry>
+    </row>
+
   </tbody>
 </tgroup>
 </table>
Index: libstdc++-v3/doc/Makefile.in
===================================================================
--- a/src/libstdc++-v3/doc/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/doc/Makefile.in	(.../branches/gcc-7-branch)
@@ -204,6 +204,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 
 # Validate existing XML structure.
 XMLLINT = xmllint
Index: libstdc++-v3/doc/html/manual/status.html
===================================================================
--- a/src/libstdc++-v3/doc/html/manual/status.html	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/doc/html/manual/status.html	(.../branches/gcc-7-branch)
@@ -657,7 +657,7 @@
 	<a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0040r3.html" target="_top">
 	P0040R3
 	</a>
-      </td><td align="center"> 7.1 </td><td align="left"><code class="code"> </code></td></tr><tr><td align="left"> <code class="code">shared_ptr::weak_type</code></td><td align="left">
+      </td><td align="center"> 7.1 </td><td align="left"><code class="code">__cpp_lib_raw_memory_algorithms &gt;= 201606L</code></td></tr><tr><td align="left"> <code class="code">shared_ptr::weak_type</code></td><td align="left">
 	<a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0163r0.html" target="_top">
 	P0163R0
 	</a>
@@ -811,7 +811,19 @@
 	P0067R5
 	</a>
       </td><td align="center"> 8 (only integral types supported) </td><td align="left"><code class="code"> __has_include(&lt;charconv&gt;) </code>
-             <code class="code"> __cpp_lib_to_chars &gt;= 201611 </code></td></tr></tbody></table></div></div><br class="table-break" /><p>
+             <code class="code"> __cpp_lib_to_chars &gt;= 201611 </code></td></tr><tr><td align="left"> Homogeneous interface for variant, any and optional </td><td align="left">
+	<a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0032r3.pdf" target="_top">
+	P0032R3
+	</a>
+      </td><td align="center"> 7.1  </td><td align="left">
+             <code class="code"> __cpp_lib_any &gt;= 201606 </code>,
+             <code class="code"> __cpp_lib_optional &gt;= 201606 </code>,
+             <code class="code"> __cpp_lib_variant &gt;= 201606 </code>
+      </td></tr><tr><td align="left"> Making Optional Greater Equal Again </td><td align="left">
+	<a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0307r2.pdf" target="_top">
+	P0307R2
+	</a>
+      </td><td align="center"> 7.1  </td><td align="left"> <code class="code"> __cpp_lib_optional &gt;= 201606 </code> </td></tr></tbody></table></div></div><br class="table-break" /><p>
 Note 1: This feature is supported in GCC 7.1 and 7.2 but before GCC 7.3 the
 <code class="code">__cpp_lib</code> macro is not defined, and compilation will fail if the
 header is included without using <code class="option">-std</code> to enable C++17 support.
Index: libstdc++-v3/po/Makefile.in
===================================================================
--- a/src/libstdc++-v3/po/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/po/Makefile.in	(.../branches/gcc-7-branch)
@@ -204,6 +204,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/include/Makefile.in
===================================================================
--- a/src/libstdc++-v3/include/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/include/Makefile.in	(.../branches/gcc-7-branch)
@@ -204,6 +204,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/include/std/optional
===================================================================
--- a/src/libstdc++-v3/include/std/optional	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/include/std/optional	(.../branches/gcc-7-branch)
@@ -51,7 +51,7 @@
    *  @{
    */
 
-#define __cpp_lib_optional 201603
+#define __cpp_lib_optional 201606L
 
   template<typename _Tp>
     class optional;
Index: libstdc++-v3/include/std/any
===================================================================
--- a/src/libstdc++-v3/include/std/any	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/include/std/any	(.../branches/gcc-7-branch)
@@ -66,7 +66,7 @@
 #endif
   }
 
-#define __cpp_lib_any 201603
+#define __cpp_lib_any 201606L
 
   /**
    *  @brief A type-safe container of any type.
@@ -513,20 +513,34 @@
     }
   // @}
 
+  /// @cond undocumented
   template<typename _Tp>
     void* __any_caster(const any* __any)
     {
-      if constexpr (is_copy_constructible_v<decay_t<_Tp>>)
+      // any_cast<T> returns non-null if __any->type() == typeid(T) and
+      // typeid(T) ignores cv-qualifiers so remove them:
+      using _Up = remove_cv_t<_Tp>;
+      // The contained value has a decayed type, so if decay_t<U> is not U,
+      // then it's not possible to have a contained value of type U:
+      if constexpr (!is_same_v<decay_t<_Up>, _Up>)
+	return nullptr;
+      // Only copy constructible types can be used for contained values:
+      else if constexpr (!is_copy_constructible_v<_Up>)
+	return nullptr;
+      // First try comparing function addresses, which works without RTTI
+      else if (__any->_M_manager == &any::_Manager<_Up>::_S_manage
+#if __cpp_rtti
+	  || __any->type() == typeid(_Tp)
+#endif
+	  )
 	{
-	  if (__any->_M_manager == &any::_Manager<decay_t<_Tp>>::_S_manage)
-	    {
-	      any::_Arg __arg;
-	      __any->_M_manager(any::_Op_access, __any, &__arg);
-	      return __arg._M_obj;
-	    }
+	  any::_Arg __arg;
+	  __any->_M_manager(any::_Op_access, __any, &__arg);
+	  return __arg._M_obj;
 	}
       return nullptr;
     }
+  /// @endcond
 
   /**
    * @brief Access the contained object.
@@ -542,8 +556,9 @@
   template<typename _ValueType>
     inline const _ValueType* any_cast(const any* __any) noexcept
     {
-      if (__any)
-	return static_cast<_ValueType*>(__any_caster<_ValueType>(__any));
+      if constexpr (is_object_v<_ValueType>)
+	if (__any)
+	  return static_cast<_ValueType*>(__any_caster<_ValueType>(__any));
       return nullptr;
     }
 
@@ -550,8 +565,9 @@
   template<typename _ValueType>
     inline _ValueType* any_cast(any* __any) noexcept
     {
-      if (__any)
-	return static_cast<_ValueType*>(__any_caster<_ValueType>(__any));
+      if constexpr (is_object_v<_ValueType>)
+	if (__any)
+	  return static_cast<_ValueType*>(__any_caster<_ValueType>(__any));
       return nullptr;
     }
   // @}
Index: libstdc++-v3/include/std/variant
===================================================================
--- a/src/libstdc++-v3/include/std/variant	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/include/std/variant	(.../branches/gcc-7-branch)
@@ -71,7 +71,7 @@
 
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-#define __cpp_lib_variant 201603
+#define __cpp_lib_variant 201606L
 
   template<typename... _Types> class tuple;
   template<typename... _Types> class variant;
Index: libstdc++-v3/include/experimental/any
===================================================================
--- a/src/libstdc++-v3/include/experimental/any	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/include/experimental/any	(.../branches/gcc-7-branch)
@@ -300,7 +300,8 @@
     _Storage _M_storage;
 
     template<typename _Tp>
-      friend void* __any_caster(const any* __any);
+      friend enable_if_t<is_object<_Tp>::value, void*>
+      __any_caster(const any* __any);
 
     // Manage in-place contained object.
     template<typename _Tp>
@@ -410,19 +411,45 @@
     }
   // @}
 
+  /// @cond undocumented
   template<typename _Tp>
-    void* __any_caster(const any* __any)
+    enable_if_t<is_object<_Tp>::value, void*>
+    __any_caster(const any* __any)
     {
-      struct _None { };
-      using _Up = decay_t<_Tp>;
-      using _Vp = conditional_t<is_copy_constructible<_Up>::value, _Up, _None>;
-      if (__any->_M_manager != &any::_Manager<_Vp>::_S_manage)
-	return nullptr;
-      any::_Arg __arg;
-      __any->_M_manager(any::_Op_access, __any, &__arg);
-      return __arg._M_obj;
+      // any_cast<T> returns non-null if __any->type() == typeid(T) and
+      // typeid(T) ignores cv-qualifiers so remove them:
+      using _Up = remove_cv_t<_Tp>;
+      // The contained value has a decayed type, so if decay_t<U> is not U,
+      // then it's not possible to have a contained value of type U.
+      using __does_not_decay = is_same<decay_t<_Up>, _Up>;
+      // Only copy constructible types can be used for contained values.
+      using __is_copyable = is_copy_constructible<_Up>;
+      // If the type _Tp could never be stored in an any we don't want to
+      // instantiate _Manager<_Tp>, so use _Manager<any::_Op> instead, which
+      // is explicitly specialized and has a no-op _S_manage function.
+      using _Vp = conditional_t<__and_<__does_not_decay, __is_copyable>::value,
+				_Up, any::_Op>;
+      // First try comparing function addresses, which works without RTTI
+      if (__any->_M_manager == &any::_Manager<_Vp>::_S_manage
+#if __cpp_rtti
+	  || __any->type() == typeid(_Tp)
+#endif
+	  )
+	{
+	  any::_Arg __arg;
+	  __any->_M_manager(any::_Op_access, __any, &__arg);
+	  return __arg._M_obj;
+	}
+      return nullptr;
     }
 
+  // This overload exists so that std::any_cast<void(*)()>(a) is well-formed.
+  template<typename _Tp>
+    enable_if_t<!is_object<_Tp>::value, _Tp*>
+    __any_caster(const any*) noexcept
+    { return nullptr; }
+  /// @endcond
+
   /**
    * @brief Access the contained object.
    *
@@ -517,6 +544,14 @@
       }
     }
 
+  // Dummy specialization used by __any_caster.
+  template<>
+    struct any::_Manager_internal<any::_Op>
+    {
+      static void
+      _S_manage(_Op, const any*, _Arg*) { }
+    };
+
   // @} group any
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace fundamentals_v1
Index: libstdc++-v3/include/experimental/bits/fs_path.h
===================================================================
--- a/src/libstdc++-v3/include/experimental/bits/fs_path.h	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/include/experimental/bits/fs_path.h	(.../branches/gcc-7-branch)
@@ -182,7 +182,8 @@
     path(path&& __p) noexcept
     : _M_pathname(std::move(__p._M_pathname)), _M_type(__p._M_type)
     {
-      _M_split_cmpts();
+      if (_M_type == _Type::_Multi)
+	_M_split_cmpts();
       __p.clear();
     }
 
@@ -456,7 +457,7 @@
 	return _S_convert_loc(__tmp.data(), __tmp.data()+__tmp.size(), __loc);
       }
 
-    bool _S_is_dir_sep(value_type __ch)
+    static bool _S_is_dir_sep(value_type __ch)
     {
 #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
       return __ch == L'/' || __ch == preferred_separator;
Index: libstdc++-v3/include/bits/stl_uninitialized.h
===================================================================
--- a/src/libstdc++-v3/include/bits/stl_uninitialized.h	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/include/bits/stl_uninitialized.h	(.../branches/gcc-7-branch)
@@ -827,6 +827,8 @@
 #endif
 
 #if __cplusplus > 201402L
+# define __cpp_lib_raw_memory_algorithms 201606L
+
   template <typename _ForwardIterator>
     inline void
     uninitialized_default_construct(_ForwardIterator __first,
Index: libstdc++-v3/include/bits/char_traits.h
===================================================================
--- a/src/libstdc++-v3/include/bits/char_traits.h	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/include/bits/char_traits.h	(.../branches/gcc-7-branch)
@@ -246,7 +246,7 @@
     __constant_char_array_p(const _CharT* __a, size_t __n)
     {
       size_t __i = 0;
-      while (__builtin_constant_p(__a[__i]) && __i < __n)
+      while (__i < __n && __builtin_constant_p(__a[__i]))
 	__i++;
       return __i == __n;
     }
Index: libstdc++-v3/include/bits/forward_list.tcc
===================================================================
--- a/src/libstdc++-v3/include/bits/forward_list.tcc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/include/bits/forward_list.tcc	(.../branches/gcc-7-branch)
@@ -381,7 +381,7 @@
       auto __iy = __ly.cbegin();
       while (__ix != __lx.cend() && __iy != __ly.cend())
         {
-          if (*__ix != *__iy)
+          if (!(*__ix == *__iy))
             return false;
           ++__ix;
           ++__iy;
@@ -451,9 +451,9 @@
                         __p = static_cast<_Node*>(__p->_M_next);
                         --__psize;
                       }
-                    else if (__comp(*__p->_M_valptr(), *__q->_M_valptr()))
+                    else if (!__comp(*__q->_M_valptr(), *__p->_M_valptr()))
                       {
-                        // First node of p is lower; e must come from p.
+                        // First node of q is not lower; e must come from p.
                         __e = __p;
                         __p = static_cast<_Node*>(__p->_M_next);
                         --__psize;
Index: libstdc++-v3/libsupc++/Makefile.in
===================================================================
--- a/src/libstdc++-v3/libsupc++/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/libsupc++/Makefile.in	(.../branches/gcc-7-branch)
@@ -277,6 +277,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/libsupc++/hash_bytes.cc
===================================================================
--- a/src/libstdc++-v3/libsupc++/hash_bytes.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/libsupc++/hash_bytes.cc	(.../branches/gcc-7-branch)
@@ -139,7 +139,7 @@
 
     // Remove the bytes not divisible by the sizeof(size_t).  This
     // allows the main loop to process the data as 64-bit integers.
-    const int len_aligned = len & ~0x7;
+    const size_t len_aligned = len & ~(size_t)0x7;
     const char* const end = buf + len_aligned;
     size_t hash = seed ^ (len * mul);
     for (const char* p = buf; p != end; p += 8)
Index: libstdc++-v3/ChangeLog
===================================================================
--- a/src/libstdc++-v3/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,173 @@
+2019-06-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-05-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90634
+	* include/experimental/bits/fs_path.h (path::path(path&&)): Only call
+	_M_split_cmpts() for a path with multiple components.
+	(path::_S_is_dir_sep()): Add missing 'static' keyword to function.
+	* src/filesystem/path.cc (path::_M_split_cmpts()): Count number of
+	components and reserve space in vector. Return early when there is
+	only one component.
+	* testsuite/experimental/filesystem/path/construct/90634.cc: New test.
+
+2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-02-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/89466
+	* acinclude.m4 (GLIBCXX_CONFIGURE_DOCBOOK): Reorder check for local
+	stylesheet directories before check for xsltproc. Try to use
+	xmlcatalog to find local stylesheet directory before trying hardcoded
+	paths. Add path used by suse to hardcoded paths. Adjust xsltproc
+	check to look for the same stylesheet as doc/Makefile.am uses. Don't
+	use xsltproc if xmlcatalog fails to find a local stylesheet.
+	* configure.ac: Check for xmlcatalog.
+	* Makefile.in: Regenerate.
+	* configure: Likewise.
+	* doc/Makefile.in: Likewise.
+	* include/Makefile.in: Likewise.
+	* libsupc++/Makefile.in: Likewise.
+	* po/Makefile.in: Likewise.
+	* python/Makefile.in: Likewise.
+	* src/Makefile.in: Likewise.
+	* src/c++11/Makefile.in: Likewise.
+	* src/c++17/Makefile.in: Likewise.
+	* src/c++98/Makefile.in: Likewise.
+	* src/filesystem/Makefile.in: Likewise.
+	* testsuite/Makefile.in: Likewise.
+
+2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-01-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/88740
+	* testsuite/util/testsuite_hooks.h [stderr] (VERIFY): Use fprintf to
+	write to stderr instead of using printf.
+
+2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/experimental/any (__any_caster): Use RTTI if comparing
+	addresses fails, to support non-unique addresses in shared libraries.
+	* include/std/any (__any_caster): Likewise.
+	* testsuite/experimental/any/misc/any_cast_neg.cc: Use 0 for dg-error
+	line number.
+
+2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90220
+	* include/experimental/any (__any_caster): Constrain to only be
+	callable for object types. Use remove_cv_t instead of decay_t.
+	If the type decays or isn't copy constructible, compare the manager
+	function to a dummy specialization.
+	(__any_caster): Add overload constrained for non-object types.
+	(any::_Manager_internal<_Op>): Add dummy specialization.
+	* testsuite/experimental/any/misc/any_cast.cc: Test function types
+	and array types.
+
+	Backport from mainline
+	2019-04-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90220
+	* include/std/any (__any_caster): Use remove_cv_t instead of decay_t.
+	Avoid a runtime check for types that can never be stored in std::any.
+	* testsuite/20_util/any/misc/any_cast.cc: Test std::any_cast with
+	array types.
+
+	Backport from mainline
+	2019-04-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90220 (partial)
+	* include/std/any (any_cast<T>(any*), any_cast<T>(const any*)): Do
+	not attempt ill-formed static_cast to pointers to non-object types.
+	* testsuite/20_util/any/misc/any_cast.cc: Test std::any_cast with
+	function types.
+
+2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from mainline
+	2019-01-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/status_cxx2017.xml: Document P0032R3 and P0307R2
+	status.
+	* include/bits/stl_uninitialized.h (__cpp_lib_raw_memory_algorithms):
+	Define.
+	* include/std/any (__cpp_lib_any): Define as 201606L, because P0032R3
+	changes are supported.
+	* include/std/optional (__cpp_lib_optional): Likewise.
+	* include/std/variant (__cpp_lib_variant): Likewise.
+
+2019-05-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-04-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90105
+	* include/bits/forward_list.tcc (operator==): Do not use operator!= to
+	compare elements.
+	(forward_list<T, A>::sort(Comp)): When elements are equal take the one
+	earlier in the list, so that sort is stable.
+	* testsuite/23_containers/forward_list/operations/90105.cc: New test.
+	* testsuite/23_containers/forward_list/comparable.cc: Test with
+	types that meet the minimum EqualityComparable and LessThanComparable
+	requirements. Remove irrelevant comment.
+
+	Backport from mainline
+	2019-03-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/89629
+	* libsupc++/hash_bytes.cc [__SIZEOF_SIZE_T__ == 8] (_Hash_bytes):
+	Use correct type for len_aligned.
+	* testsuite/20_util/hash/89629.cc: New test.
+
+2019-02-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/89446
+	* include/bits/char_traits.h (__constant_char_array): Check index is
+	in range before dereferencing.
+	* testsuite/21_strings/basic_string_view/operators/char/89446.cc:
+	New test.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-12-06  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* scripts/make_exports.pl (check names): Don’t try to export
+	construction vtable symbols.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-12-06  Jonathan Wakely  <jwakely@redhat.com>
+		    Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR libstdc++/64883
+	* testsuite/17_intro/headers/c++1998/all_attributes.cc: Don't test
+	always_inline on Darwin.
+	* testsuite/17_intro/headers/c++2011/all_attributes.cc: Likewise.
+	* testsuite/17_intro/headers/c++2014/all_attributes.cc: Likewise.
+	* testsuite/17_intro/headers/c++2017/all_attributes.cc: Likewise.
+	* testsuite/17_intro/headers/c++2020/all_attributes.cc: Likewise.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-08-25  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR libstdc++/70694
+	* configure.host (OPT_LDFLAGS): Don't append
+	-fvisibility-inlines-hidden for newer Darwin.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: libstdc++-v3/testsuite/Makefile.in
===================================================================
--- a/src/libstdc++-v3/testsuite/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/Makefile.in	(.../branches/gcc-7-branch)
@@ -204,6 +204,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/testsuite/23_containers/forward_list/operations/90105.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/23_containers/forward_list/operations/90105.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/23_containers/forward_list/operations/90105.cc	(.../branches/gcc-7-branch)
@@ -0,0 +1,60 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <forward_list>
+#include <testsuite_hooks.h>
+
+// PR libstdc++/90105 - std::forward_list::sort() is not "stable"
+
+struct X
+{
+  int key;
+  int val;
+};
+
+bool operator<(const X& l, const X& r)
+{ return l.key < r.key; }
+
+bool operator==(const X& l, const X& r)
+{ return l.key == r.key && l.val == r.val; }
+
+void
+test01()
+{
+  std::forward_list<X> l{ {1, 1}, {2, 2}, {1, 3}, {0, 4}, {2, 5}, {0, 6} };
+  l.sort();
+  std::forward_list<X> exp{ {0, 4}, {0, 6}, {1, 1}, {1, 3}, {2, 2}, {2, 5} };
+  VERIFY( l == exp );
+}
+
+void
+test02()
+{
+  std::forward_list<X> l{ {1, 1}, {1, 2}, {1, 3}, {1, 4}, {1, 5}, {1, 6} };
+  const std::forward_list<X> exp = l;
+  l.sort();
+  VERIFY( l == exp );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
Index: libstdc++-v3/testsuite/23_containers/forward_list/comparable.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/23_containers/forward_list/comparable.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/23_containers/forward_list/comparable.cc	(.../branches/gcc-7-branch)
@@ -17,15 +17,11 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-
-// NOTE: This makes use of the fact that we know how moveable
-// is implemented on list (via swap). If the implementation changed
-// this test may begin to fail.
-
 #include <forward_list>
 #include <testsuite_hooks.h>
 
-int main()
+void
+test01()
 {
   std::forward_list<double> a = {0.0, 1.0, 2.0, 3.0, 4.0};
   std::forward_list<double> b = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0};
@@ -43,6 +39,40 @@
   VERIFY((b >  a) == true);
   VERIFY((b >= a) == true);
   VERIFY((b <= a) == false);
+}
 
-  return 0;
+void
+test02()
+{
+  // The EqualityComparable requirements only require ==
+  struct X {
+    bool operator==(const X&) const { return true; }
+  };
+
+  std::forward_list<X> a(2);
+  const auto b = a;
+  VERIFY( a == b );
 }
+
+void
+test03()
+{
+  // The LessThanComparable requirements only require <
+  struct X {
+    bool operator<(const X&) const { return false; }
+  };
+
+  std::forward_list<X> a(2);
+  const auto b = a;
+  VERIFY( !(a < b) );
+  VERIFY( !(a > b) );
+  VERIFY( a <= b );
+  VERIFY( a >= b );
+}
+
+int main()
+{
+  test01();
+  test02();
+  test03();
+}
Index: libstdc++-v3/testsuite/21_strings/basic_string_view/operators/char/89446.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/21_strings/basic_string_view/operators/char/89446.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/21_strings/basic_string_view/operators/char/89446.cc	(.../branches/gcc-7-branch)
@@ -0,0 +1,28 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17 -fexceptions -fnon-call-exceptions -O1" }
+// { dg-do run { target { powerpc*-*-linux* i?86-*-linux* x86_64-*-linux* } } }
+// { dg-require-effective-target c++1z }
+
+#include <string_view>
+
+int main()
+{
+  std::string_view s1, s2;
+  return s1 != s2;
+}
Index: libstdc++-v3/testsuite/experimental/any/misc/any_cast.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/any/misc/any_cast.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/experimental/any/misc/any_cast.cc	(.../branches/gcc-7-branch)
@@ -24,6 +24,7 @@
 
 using std::experimental::any;
 using std::experimental::any_cast;
+using std::experimental::bad_any_cast;
 
 void test01()
 {
@@ -56,7 +57,6 @@
 
 void test02()
 {
-  using std::experimental::bad_any_cast;
   any x(1);
   auto p = any_cast<double>(&x);
   VERIFY(p == nullptr);
@@ -105,7 +105,7 @@
   MoveDeleted&& md3 = any_cast<MoveDeleted&&>(any(std::move(md)));
 }
 
-void test04()
+void test05()
 {
   // PR libstdc++/69321
   struct noncopyable {
@@ -117,10 +117,60 @@
   VERIFY( p == nullptr );
 }
 
+void test06()
+{
+  // The contained value of a std::any is always an object type,
+  // but any_cast does not forbid checking for function types.
+
+  any a(1);
+  void (*p1)() = any_cast<void()>(&a);
+  VERIFY( p1 == nullptr );
+  int (*p2)(int) = any_cast<int(int)>(&a);
+  VERIFY( p2 == nullptr );
+  int (*p3)() = any_cast<int()>(&const_cast<const any&>(a));
+  VERIFY( p3 == nullptr );
+
+  try {
+    any_cast<int(&)()>(a);
+    VERIFY( false );
+  } catch (const bad_any_cast&) {
+  }
+
+  try {
+    any_cast<int(&)()>(std::move(a));
+    VERIFY( false );
+  } catch (const bad_any_cast&) {
+  }
+
+  try {
+    any_cast<int(&)()>(const_cast<const any&>(a));
+    VERIFY( false );
+  } catch (const bad_any_cast&) {
+  }
+}
+
+void test07()
+{
+  int arr[3];
+  any a(arr);
+  VERIFY( a.type() == typeid(int*) );	// contained value is decayed
+
+  int (*p1)[3] = any_cast<int[3]>(&a);
+  VERIFY( a.type() != typeid(int[3]) ); // so any_cast should return nullptr
+  VERIFY( p1 == nullptr );
+  int (*p2)[] = any_cast<int[]>(&a);
+  VERIFY( a.type() != typeid(int[]) );	// so any_cast should return nullptr
+  VERIFY( p2 == nullptr );
+  const int (*p3)[] = any_cast<int[]>(&const_cast<const any&>(a));
+  VERIFY( p3 == nullptr );
+}
+
 int main()
 {
   test01();
   test02();
   test03();
-  test04();
+  test05();
+  test06();
+  test07();
 }
Index: libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc	(.../branches/gcc-7-branch)
@@ -25,5 +25,5 @@
   using std::experimental::any_cast;
 
   const any y(1);
-  any_cast<int&>(y); // { dg-error "qualifiers" "" { target { *-*-* } } 357 }
+  any_cast<int&>(y); // { dg-error "qualifiers" "" { target { *-*-* } } 0 }
 }
Index: libstdc++-v3/testsuite/experimental/filesystem/path/construct/90634.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/filesystem/path/construct/90634.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/experimental/filesystem/path/construct/90634.cc	(.../branches/gcc-7-branch)
@@ -0,0 +1,75 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-DUSE_FILESYSTEM_TS -lstdc++fs" }
+// { dg-do run { target c++11 } }
+// { dg-require-filesystem-ts "" }
+
+#include <experimental/filesystem>
+#include <cstdlib>
+#include <testsuite_hooks.h>
+
+std::size_t bytes_allocated = 0;
+
+void* operator new(std::size_t n)
+{
+  bytes_allocated += n;
+  return std::malloc(n);
+}
+
+void operator delete(void* p) noexcept { std::free(p); }
+#if __cpp_sized_deallocation
+void operator delete(void* p, std::size_t) noexcept { std::free(p); }
+#endif
+
+void
+test01()
+{
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  std::wstring s0;
+  std::wstring s1 = L"/";
+  std::wstring s2 = L"file";
+  std::wstring s3 = L"C:";
+  std::wstring s4 = L"\\";
+#else
+  std::string s0;
+  std::string s1 = "/";
+  std::string s2 = "file";
+  std::string s3 = "C:";
+  std::string s4 = "\\";
+#endif
+
+  using std::experimental::filesystem::path;
+
+  bytes_allocated = 0;
+  path p0 = std::move(s0);
+  VERIFY( bytes_allocated == 0 );
+  path p1 = std::move(s1);
+  VERIFY( bytes_allocated == 0 );
+  path p2 = std::move(s2);
+  VERIFY( bytes_allocated == 0 );
+  path p3 = std::move(s3);
+  VERIFY( bytes_allocated == 0 );
+  path p4 = std::move(s4);
+  VERIFY( bytes_allocated == 0 );
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/17_intro/headers/c++2014/all_attributes.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/17_intro/headers/c++2014/all_attributes.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/17_intro/headers/c++2014/all_attributes.cc	(.../branches/gcc-7-branch)
@@ -21,9 +21,9 @@
 // Ensure the library only uses the __name__ form for attributes.
 // Don't test 'const' and 'noreturn' because they are reserved anyway.
 #define abi_tag 1
-#define always_inline 1
 #ifndef __APPLE__
 // darwin headers use these, see PR 64883
+# define always_inline 1
 # define deprecated 1
 # define visibility 1
 #endif
Index: libstdc++-v3/testsuite/17_intro/headers/c++1998/all_attributes.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/17_intro/headers/c++1998/all_attributes.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/17_intro/headers/c++1998/all_attributes.cc	(.../branches/gcc-7-branch)
@@ -21,9 +21,9 @@
 // Ensure the library only uses the __name__ form for attributes.
 // Don't test 'const' because it is reserved anyway.
 #define abi_tag 1
-#define always_inline 1
 #ifndef __APPLE__
 // darwin headers use these, see PR 64883
+# define always_inline 1
 # define deprecated 1
 # define noreturn 1
 # define visibility 1
Index: libstdc++-v3/testsuite/17_intro/headers/c++2011/all_attributes.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/17_intro/headers/c++2011/all_attributes.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/17_intro/headers/c++2011/all_attributes.cc	(.../branches/gcc-7-branch)
@@ -21,11 +21,11 @@
 // Ensure the library only uses the __name__ form for attributes.
 // Don't test 'const' and 'noreturn' because they are reserved anyway.
 #define abi_tag 1
-#define always_inline 1
 #ifndef __APPLE__
 // darwin headers use these, see PR 64883
+# define always_inline 1
+# define deprecated 1
 # define visibility 1
-# define deprecated 1
 #endif
 #define packed 1
 #define pure 1
Index: libstdc++-v3/testsuite/util/testsuite_hooks.h
===================================================================
--- a/src/libstdc++-v3/testsuite/util/testsuite_hooks.h	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/util/testsuite_hooks.h	(.../branches/gcc-7-branch)
@@ -46,18 +46,25 @@
 #include <bits/c++config.h>
 #include <bits/functexcept.h>
 #include <ctime>
+#include <stdio.h>
 
 #ifdef _GLIBCXX_HAVE_SYS_STAT_H
 #include <sys/stat.h>
 #endif
 
+#ifdef stderr
+# define _VERIFY_PRINT(S, F, L, P, C) __builtin_fprintf(stderr, S, F, L, P, C)
+#else
+# define _VERIFY_PRINT(S, F, L, P, C) __builtin_printf(S, F, L, P, C)
+#endif
+
 #define VERIFY(fn)                                                      \
   do                                                                    \
   {                                                                     \
     if (! (fn))								\
       {									\
-	__builtin_printf("%s:%d: %s: Assertion '%s' failed.\n",		\
-			 __FILE__, __LINE__, __PRETTY_FUNCTION__, #fn); \
+	_VERIFY_PRINT("%s:%d: %s: Assertion '%s' failed.\n",		\
+		      __FILE__, __LINE__, __PRETTY_FUNCTION__, #fn);	\
 	__builtin_abort();						\
       }									\
   } while (false)
Index: libstdc++-v3/testsuite/20_util/hash/89629.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/hash/89629.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/hash/89629.cc	(.../branches/gcc-7-branch)
@@ -0,0 +1,43 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target { lp64 || llp64 } } }
+// { dg-require-effective-target c++11 }
+// { dg-require-effective-target run_expensive_tests }
+
+#include <functional>
+#include <string>
+
+void
+test01()
+{
+  const std::size_t big = std::size_t(1) << 31;
+  std::string s;
+  try {
+    s.resize(big, 'a');
+  } catch (const std::bad_alloc&) {
+    return; // try to avoid a FAIL if memory allocation fails
+  }
+  // PR libstdc++/89629
+  (void) std::hash<std::string>{}(s);
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/20_util/any/misc/any_cast.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/any/misc/any_cast.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/any/misc/any_cast.cc	(.../branches/gcc-7-branch)
@@ -20,6 +20,7 @@
 
 #include <any>
 #include <string>
+#include <utility>
 #include <cstring>
 #include <testsuite_hooks.h>
 
@@ -130,6 +131,54 @@
   VERIFY( p == nullptr );
 }
 
+void test06()
+{
+  // The contained value of a std::any is always an object type,
+  // but std::any_cast does not forbid checking for function types.
+
+  any a(1);
+  void (*p1)() = any_cast<void()>(&a);
+  VERIFY( p1 == nullptr );
+  int (*p2)(int) = any_cast<int(int)>(&a);
+  VERIFY( p2 == nullptr );
+  int (*p3)() = any_cast<int()>(&std::as_const(a));
+  VERIFY( p3 == nullptr );
+
+  try {
+    any_cast<int(&)()>(a);
+    VERIFY( false );
+  } catch (const std::bad_any_cast&) {
+  }
+
+  try {
+    any_cast<int(&)()>(std::move(a));
+    VERIFY( false );
+  } catch (const std::bad_any_cast&) {
+  }
+
+  try {
+    any_cast<int(&)()>(std::as_const(a));
+    VERIFY( false );
+  } catch (const std::bad_any_cast&) {
+  }
+}
+
+void test07()
+{
+  int arr[3];
+  any a(arr);
+  VERIFY( a.type() == typeid(int*) );	// contained value is decayed
+
+  int (*p1)[3] = any_cast<int[3]>(&a);
+  VERIFY( a.type() != typeid(int[3]) ); // so any_cast should return nullptr
+  VERIFY( p1 == nullptr );
+  int (*p2)[] = any_cast<int[]>(&a);
+  VERIFY( a.type() != typeid(int[]) );	// so any_cast should return nullptr
+  VERIFY( p2 == nullptr );
+  const int (*p3)[] = any_cast<int[]>(&std::as_const(a));
+  VERIFY( p3 == nullptr );
+}
+
 int main()
 {
   test01();
@@ -137,4 +186,6 @@
   test03();
   test04();
   test05();
+  test06();
+  test07();
 }
Index: libstdc++-v3/acinclude.m4
===================================================================
--- a/src/libstdc++-v3/acinclude.m4	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/acinclude.m4	(.../branches/gcc-7-branch)
@@ -642,28 +642,27 @@
 dnl
 AC_DEFUN([GLIBCXX_CONFIGURE_DOCBOOK], [
 
-AC_MSG_CHECKING([for docbook stylesheets for documentation creation])
-glibcxx_stylesheets=no
-if test x${XSLTPROC} = xyes && echo '<title/>' | xsltproc --noout --nonet --xinclude http://docbook.sourceforge.net/release/xsl-ns/current/xhtml-1_1/docbook.xsl - 2>/dev/null; then
-  glibcxx_stylesheets=yes
-fi
-AC_MSG_RESULT($glibcxx_stylesheets)
+glibcxx_docbook_url=http://docbook.sourceforge.net/release/xsl-ns/current/
 
 AC_MSG_CHECKING([for local stylesheet directory])
 glibcxx_local_stylesheets=no
-if test x"$glibcxx_stylesheets" = x"yes"; then
-  if test -d /usr/share/sgml/docbook/xsl-ns-stylesheets; then
-    glibcxx_local_stylesheets=yes
-    XSL_STYLE_DIR=/usr/share/sgml/docbook/xsl-ns-stylesheets
-  fi
-  if test -d /usr/share/xml/docbook/stylesheet/docbook-xsl-ns; then
-    glibcxx_local_stylesheets=yes
-    XSL_STYLE_DIR=/usr/share/xml/docbook/stylesheet/docbook-xsl-ns
-  fi
-  if test -d /usr/share/xml/docbook/stylesheet/nwalsh5/current; then
-    glibcxx_local_stylesheets=yes
-    XSL_STYLE_DIR=/usr/share/xml/docbook/stylesheet/nwalsh5/current
-  fi
+if test x${XMLCATALOG} = xyes && xsl_style_dir=`xmlcatalog "" $glibcxx_docbook_url 2>/dev/null`
+then
+  XSL_STYLE_DIR=`echo $xsl_style_dir | sed -n 's;^file://;;p'`
+  glibcxx_local_stylesheets=yes
+else
+  for dir in \
+    /usr/share/sgml/docbook/xsl-ns-stylesheets \
+    /usr/share/xml/docbook/stylesheet/docbook-xsl-ns \
+    /usr/share/xml/docbook/stylesheet/nwalsh5/current \
+    /usr/share/xml/docbook/stylesheet/nwalsh/current
+  do
+    if test -d $dir; then
+      glibcxx_local_stylesheets=yes
+      XSL_STYLE_DIR=$dir
+      break
+    fi
+  done
 fi
 AC_MSG_RESULT($glibcxx_local_stylesheets)
 
@@ -670,6 +669,16 @@
 if test x"$glibcxx_local_stylesheets" = x"yes"; then
   AC_SUBST(XSL_STYLE_DIR)
   AC_MSG_NOTICE($XSL_STYLE_DIR)
+
+  AC_MSG_CHECKING([for docbook stylesheets for documentation creation])
+  glibcxx_stylesheets=no
+  if test x${XMLCATALOG} = xno || xmlcatalog "" $glibcxx_docbook_url/xhtml/docbook.xsl >/dev/null 2>&1; then
+    if test x${XSLTPROC} = xyes && echo '<title/>' | xsltproc --noout --nonet --xinclude $glibcxx_docbook_url/xhtml/docbook.xsl - 2>/dev/null; then
+      glibcxx_stylesheets=yes
+    fi
+  fi
+  AC_MSG_RESULT($glibcxx_stylesheets)
+
 else
   glibcxx_stylesheets=no
 fi
Index: libiberty/simple-object-elf.c
===================================================================
--- a/src/libiberty/simple-object-elf.c	(.../tags/gcc_7_4_0_release)
+++ b/src/libiberty/simple-object-elf.c	(.../branches/gcc-7-branch)
@@ -479,6 +479,14 @@
       return NULL;
     }
 
+  if (eor->shstrndx == 0)
+    {
+      *errmsg = "invalid ELF shstrndx == 0";
+      *err = 0;
+      XDELETE (eor);
+      return NULL;
+    }
+
   return (void *) eor;
 }
 
Index: libiberty/ChangeLog
===================================================================
--- a/src/libiberty/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/libiberty/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,12 @@
+2019-07-25  Richard Biener  <rguenther@suse.de>
+
+	PR lto/90924
+	Backport from mainline
+	2019-07-12  Ren Kimura  <rkx1209dev@gmail.com>
+
+	* simple-object-elf.c (simple_object_elf_match): Check zero value
+	shstrndx.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: contrib/ChangeLog
===================================================================
--- a/src/contrib/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/contrib/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,7 @@
+2019-08-16  Uros Bizjak  <ubizjak@gmail.com>
+
+	* test_summary: Do not escape "=".
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: contrib/test_summary
===================================================================
--- a/src/contrib/test_summary	(.../tags/gcc_7_4_0_release)
+++ b/src/contrib/test_summary	(.../branches/gcc-7-branch)
@@ -126,7 +126,7 @@
   if (lang == "") lang = " "$2" "; else lang = " ";
 }
 $2 == "version" { save = $0; $1 = ""; $2 = ""; version = $0; gsub(/^ */, "", version); gsub(/\r$/, "", version); $0 = save; }
-/\===.*Summary/ { print ""; print; blanks=1; }
+/===.*Summary/ { print ""; print; blanks=1; }
 /tests ===/ || /^(Target|Host|Native)/ || $2 == "version" { print; blanks=1; }
 /^(XPASS|FAIL|UNRESOLVED|WARNING|ERROR|# of )/ { sub ("\r", ""); print; }
 /^using:/ { print ""; print; print ""; }
Index: gcc/ipa-icf-gimple.c
===================================================================
--- a/src/gcc/ipa-icf-gimple.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ipa-icf-gimple.c	(.../branches/gcc-7-branch)
@@ -994,6 +994,9 @@
   if (gimple_asm_input_p (g1) != gimple_asm_input_p (g2))
     return false;
 
+  if (gimple_asm_inline_p (g1) != gimple_asm_inline_p (g2))
+    return false;
+
   if (gimple_asm_ninputs (g1) != gimple_asm_ninputs (g2))
     return false;
 
Index: gcc/opts-common.c
===================================================================
--- a/src/gcc/opts-common.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/opts-common.c	(.../branches/gcc-7-branch)
@@ -438,7 +438,8 @@
 
   extra_args = 0;
 
-  opt_index = find_opt (argv[0] + 1, lang_mask);
+  const char *opt_value = argv[0] + 1;
+  opt_index = find_opt (opt_value, lang_mask);
   i = 0;
   while (opt_index == OPT_SPECIAL_unknown
 	 && i < ARRAY_SIZE (option_map))
@@ -641,7 +642,24 @@
   /* Check if this is a switch for a different front end.  */
   if (!option_ok_for_language (option, lang_mask))
     errors |= CL_ERR_WRONG_LANG;
+  else if (strcmp (option->opt_text, "-Werror=") == 0
+	   && strchr (opt_value, ',') == NULL)
+    {
+      /* Verify that -Werror argument is a valid warning
+	 for a language.  */
+      char *werror_arg = xstrdup (opt_value + 6);
+      werror_arg[0] = 'W';
 
+      size_t warning_index = find_opt (werror_arg, lang_mask);
+      if (warning_index != OPT_SPECIAL_unknown)
+	{
+	  const struct cl_option *warning_option
+	    = &cl_options[warning_index];
+	  if (!option_ok_for_language (warning_option, lang_mask))
+	    errors |= CL_ERR_WRONG_LANG;
+	}
+    }
+
   /* Convert the argument to lowercase if appropriate.  */
   if (arg && option->cl_tolower)
     {
Index: gcc/c-family/ChangeLog
===================================================================
--- a/src/gcc/c-family/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/c-family/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,8 @@
+2019-04-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* c-ada-spec.c (print_destructor): Deal with deleting destructors.
+	(dump_ada_declaration) <FUNCTION_DECL>: Likewise.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: gcc/c-family/c-ada-spec.c
===================================================================
--- a/src/gcc/c-family/c-ada-spec.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/c-family/c-ada-spec.c	(.../branches/gcc-7-branch)
@@ -2663,6 +2663,8 @@
   tree decl_name = DECL_NAME (DECL_ORIGIN (t));
 
   pp_string (buffer, "Delete_");
+  if (strncmp (IDENTIFIER_POINTER (DECL_NAME (t)), "__del", 5) == 0)
+    pp_string (buffer, "And_Free_");
   pp_ada_tree_identifier (buffer, decl_name, t, false);
 }
 
@@ -2915,8 +2917,9 @@
 	  if (DECL_ARTIFICIAL (t))
 	    return 0;
 
-	  /* Only consider constructors/destructors for complete objects.  */
-	  if (strncmp (IDENTIFIER_POINTER (decl_name), "__comp", 6) != 0)
+	  /* Only consider complete constructors and deleting destructors.  */
+	  if (strncmp (IDENTIFIER_POINTER (decl_name), "__comp", 6) != 0
+	      && strncmp (IDENTIFIER_POINTER (decl_name), "__del", 5) != 0)
 	    return 0;
 	}
 
Index: gcc/c/ChangeLog
===================================================================
--- a/src/gcc/c/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/c/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,67 @@
+2019-01-16  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from mainline
+	2019-01-07  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/88720
+	PR c/88726
+	* c-decl.c (pop_scope): Use TREE_PUBLIC and b->nested to determine
+	whether a function is nested, not DECL_EXTERNAL.  Diagnose inline
+	functions declared but never defined only for external scope, not
+	for other scopes.
+
+2018-01-02  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR inline-asm/55681
+	* c-parser.c (c_parser_asm_statement): Update grammar.  Allow any
+	combination of volatile and goto, in any order, without repetitions.
+
+	Backport from trunk
+	2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* c-parser.c (c_parser_asm_statement): Detect the inline keyword
+	after asm.  Pass a flag for it to build_asm_expr.
+	* c-tree.h (build_asm_expr): Update declaration.
+	* c-typeck.c (build_asm_stmt): Add is_inline parameter.  Use it to
+	set ASM_INLINE_P.
+
+	Backport from trunk
+	2018-12-08  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* c-parser (c_parser_asm_statement) [RID_INLINE]: Delete stray line
+	setting "quals".
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* c-parser.c (c_parser_asm_statement): Rewrite the loop to work without
+	"done" boolean variable.
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* c-parser.c (c_parser_asm_statement): Keep track of the location each
+	asm qualifier is first seen; use that to give nicer "duplicate asm
+	qualifier" messages.  Delete 'quals" variable, instead pass the
+	"is_volatile_ flag to build_asm_stmt directly.
+	* c-tree.h (build_asm_stmt): Make the first arg bool instead of tree.
+	* c-typeck.c (build_asm_stmt): Ditto; adjust.
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* c-parser.c (c_parser_asm_statement) <RID_CONST, RID_RESTRICT>: Give
+	a more specific error message (instead of just falling through).
+
+	And extra for the backport
+	2019-01-02  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* c-parser.c (c_parser_asm_statement): Output a warning instead of an
+	error for const and restrict.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: gcc/c/c-parser.c
===================================================================
--- a/src/gcc/c/c-parser.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/c/c-parser.c	(.../branches/gcc-7-branch)
@@ -6089,61 +6089,104 @@
 }
 
 /* Parse an asm statement, a GNU extension.  This is a full-blown asm
-   statement with inputs, outputs, clobbers, and volatile tag
-   allowed.
+   statement with inputs, outputs, clobbers, and volatile, inline, and goto
+   tags allowed.
 
+   asm-qualifier:
+     volatile
+     inline
+     goto
+
+   asm-qualifier-list:
+     asm-qualifier-list asm-qualifier
+     asm-qualifier
+
    asm-statement:
-     asm type-qualifier[opt] ( asm-argument ) ;
-     asm type-qualifier[opt] goto ( asm-goto-argument ) ;
+     asm asm-qualifier-list[opt] ( asm-argument ) ;
 
    asm-argument:
      asm-string-literal
      asm-string-literal : asm-operands[opt]
      asm-string-literal : asm-operands[opt] : asm-operands[opt]
-     asm-string-literal : asm-operands[opt] : asm-operands[opt] : asm-clobbers[opt]
-
-   asm-goto-argument:
+     asm-string-literal : asm-operands[opt] : asm-operands[opt] \
+       : asm-clobbers[opt]
      asm-string-literal : : asm-operands[opt] : asm-clobbers[opt] \
        : asm-goto-operands
 
-   Qualifiers other than volatile are accepted in the syntax but
-   warned for.  */
+   The form with asm-goto-operands is valid if and only if the
+   asm-qualifier-list contains goto, and is the only allowed form in that case.
+   Duplicate asm-qualifiers are not allowed.  */
 
 static tree
 c_parser_asm_statement (c_parser *parser)
 {
-  tree quals, str, outputs, inputs, clobbers, labels, ret;
-  bool simple, is_goto;
+  tree str, outputs, inputs, clobbers, labels, ret;
+  bool simple;
   location_t asm_loc = c_parser_peek_token (parser)->location;
   int section, nsections;
 
   gcc_assert (c_parser_next_token_is_keyword (parser, RID_ASM));
   c_parser_consume_token (parser);
-  if (c_parser_next_token_is_keyword (parser, RID_VOLATILE))
+
+  /* Handle the asm-qualifier-list.  */
+  location_t volatile_loc = UNKNOWN_LOCATION;
+  location_t inline_loc = UNKNOWN_LOCATION;
+  location_t goto_loc = UNKNOWN_LOCATION;
+  for (;;)
     {
-      quals = c_parser_peek_token (parser)->value;
-      c_parser_consume_token (parser);
-    }
-  else if (c_parser_next_token_is_keyword (parser, RID_CONST)
-	   || c_parser_next_token_is_keyword (parser, RID_RESTRICT))
-    {
-      warning_at (c_parser_peek_token (parser)->location,
-		  0,
-		  "%E qualifier ignored on asm",
-		  c_parser_peek_token (parser)->value);
-      quals = NULL_TREE;
-      c_parser_consume_token (parser);
-    }
-  else
-    quals = NULL_TREE;
+      c_token *token = c_parser_peek_token (parser);
+      location_t loc = token->location;
+      switch (token->keyword)
+	{
+	case RID_VOLATILE:
+	  if (volatile_loc)
+	    {
+	      error_at (loc, "duplicate asm qualifier %qE", token->value);
+	      inform (volatile_loc, "first seen here");
+	    }
+	  else
+	    volatile_loc = loc;
+	  c_parser_consume_token (parser);
+	  continue;
 
-  is_goto = false;
-  if (c_parser_next_token_is_keyword (parser, RID_GOTO))
-    {
-      c_parser_consume_token (parser);
-      is_goto = true;
+	case RID_INLINE:
+	  if (inline_loc)
+	    {
+	      error_at (loc, "duplicate asm qualifier %qE", token->value);
+	      inform (inline_loc, "first seen here");
+	    }
+	  else
+	    inline_loc = loc;
+	  c_parser_consume_token (parser);
+	  continue;
+
+	case RID_GOTO:
+	  if (goto_loc)
+	    {
+	      error_at (loc, "duplicate asm qualifier %qE", token->value);
+	      inform (goto_loc, "first seen here");
+	    }
+	  else
+	    goto_loc = loc;
+	  c_parser_consume_token (parser);
+	  continue;
+
+	case RID_CONST:
+	case RID_RESTRICT:
+	  warning_at (loc, 0, "%qE is not an asm qualifier", token->value);
+	  c_parser_consume_token (parser);
+	  continue;
+
+	default:
+	  break;
+	}
+      break;
     }
 
+  bool is_volatile = (volatile_loc != UNKNOWN_LOCATION);
+  bool is_inline = (inline_loc != UNKNOWN_LOCATION);
+  bool is_goto = (goto_loc != UNKNOWN_LOCATION);
+
   /* ??? Follow the C++ parser rather than using the
      lex_untranslated_string kludge.  */
   parser->lex_untranslated_string = true;
@@ -6216,8 +6259,9 @@
   if (!c_parser_require (parser, CPP_SEMICOLON, "expected %<;%>"))
     c_parser_skip_to_end_of_block_or_statement (parser);
 
-  ret = build_asm_stmt (quals, build_asm_expr (asm_loc, str, outputs, inputs,
-					       clobbers, labels, simple));
+  ret = build_asm_stmt (is_volatile,
+			build_asm_expr (asm_loc, str, outputs, inputs,
+					clobbers, labels, simple, is_inline));
 
  error:
   parser->lex_untranslated_string = false;
Index: gcc/c/c-typeck.c
===================================================================
--- a/src/gcc/c/c-typeck.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/c/c-typeck.c	(.../branches/gcc-7-branch)
@@ -9669,9 +9669,9 @@
    (guaranteed to be 'volatile' or null) and ARGS (represented using
    an ASM_EXPR node).  */
 tree
-build_asm_stmt (tree cv_qualifier, tree args)
+build_asm_stmt (bool is_volatile, tree args)
 {
-  if (!ASM_VOLATILE_P (args) && cv_qualifier)
+  if (is_volatile)
     ASM_VOLATILE_P (args) = 1;
   return add_stmt (args);
 }
@@ -9680,10 +9680,12 @@
    some INPUTS, and some CLOBBERS.  The latter three may be NULL.
    SIMPLE indicates whether there was anything at all after the
    string in the asm expression -- asm("blah") and asm("blah" : )
-   are subtly different.  We use a ASM_EXPR node to represent this.  */
+   are subtly different.  We use a ASM_EXPR node to represent this.
+   LOC is the location of the asm, and IS_INLINE says whether this
+   is asm inline.  */
 tree
 build_asm_expr (location_t loc, tree string, tree outputs, tree inputs,
-		tree clobbers, tree labels, bool simple)
+		tree clobbers, tree labels, bool simple, bool is_inline)
 {
   tree tail;
   tree args;
@@ -9801,6 +9803,7 @@
      as volatile.  */
   ASM_INPUT_P (args) = simple;
   ASM_VOLATILE_P (args) = (noutputs == 0);
+  ASM_INLINE_P (args) = is_inline;
 
   return args;
 }
Index: gcc/c/c-tree.h
===================================================================
--- a/src/gcc/c/c-tree.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/c/c-tree.h	(.../branches/gcc-7-branch)
@@ -659,8 +659,9 @@
 extern void check_compound_literal_type (location_t, struct c_type_name *);
 extern tree c_start_case (location_t, location_t, tree, bool);
 extern void c_finish_case (tree, tree);
-extern tree build_asm_expr (location_t, tree, tree, tree, tree, tree, bool);
-extern tree build_asm_stmt (tree, tree);
+extern tree build_asm_expr (location_t, tree, tree, tree, tree, tree, bool,
+			    bool);
+extern tree build_asm_stmt (bool, tree);
 extern int c_types_compatible_p (tree, tree);
 extern tree c_begin_compound_stmt (bool);
 extern tree c_end_compound_stmt (location_t, tree, bool);
Index: gcc/c/c-decl.c
===================================================================
--- a/src/gcc/c/c-decl.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/c/c-decl.c	(.../branches/gcc-7-branch)
@@ -1235,8 +1235,9 @@
 	      && DECL_ABSTRACT_ORIGIN (p) != 0
 	      && DECL_ABSTRACT_ORIGIN (p) != p)
 	    TREE_ADDRESSABLE (DECL_ABSTRACT_ORIGIN (p)) = 1;
-	  if (!DECL_EXTERNAL (p)
+	  if (!TREE_PUBLIC (p)
 	      && !DECL_INITIAL (p)
+	      && !b->nested
 	      && scope != file_scope
 	      && scope != external_scope)
 	    {
@@ -1252,7 +1253,7 @@
 		 in the same translation unit."  */
 	      if (!flag_gnu89_inline
 		  && !lookup_attribute ("gnu_inline", DECL_ATTRIBUTES (p))
-		  && scope != external_scope)
+		  && scope == external_scope)
 		pedwarn (input_location, 0,
 			 "inline function %q+D declared but never defined", p);
 	      DECL_EXTERNAL (p) = 1;
Index: gcc/DATESTAMP
===================================================================
--- a/src/gcc/DATESTAMP	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/DATESTAMP	(.../branches/gcc-7-branch)
@@ -1 +1 @@
-20181206
+20190820
Index: gcc/lra.c
===================================================================
--- a/src/gcc/lra.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/lra.c	(.../branches/gcc-7-branch)
@@ -1670,10 +1670,12 @@
 
     case SCRATCH:
     case CONST_DOUBLE:
-    case CONST_INT:
     case CONST_VECTOR:
       return val;
 
+    case CONST_INT:
+      return val + UINTVAL (x);
+
     default:
       break;
     }
Index: gcc/tree.h
===================================================================
--- a/src/gcc/tree.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree.h	(.../branches/gcc-7-branch)
@@ -1231,6 +1231,9 @@
    ASM_OPERAND with no operands.  */
 #define ASM_INPUT_P(NODE) (ASM_EXPR_CHECK (NODE)->base.static_flag)
 #define ASM_VOLATILE_P(NODE) (ASM_EXPR_CHECK (NODE)->base.public_flag)
+/* Nonzero if we want to consider this asm as minimum length and cost
+   for inlining decisions.  */
+#define ASM_INLINE_P(NODE) (ASM_EXPR_CHECK (NODE)->base.protected_flag)
 
 /* COND_EXPR accessors.  */
 #define COND_EXPR_COND(NODE)	(TREE_OPERAND (COND_EXPR_CHECK (NODE), 0))
Index: gcc/ipa-cp.c
===================================================================
--- a/src/gcc/ipa-cp.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ipa-cp.c	(.../branches/gcc-7-branch)
@@ -810,7 +810,7 @@
   topo->stack = XCNEWVEC (struct cgraph_node *, symtab->cgraph_count);
 
   gcc_checking_assert (topo->stack_top == 0);
-  topo->nnodes = ipa_reduced_postorder (topo->order, true, true, NULL);
+  topo->nnodes = ipa_reduced_postorder (topo->order, true, NULL);
 }
 
 /* Free information about strongly connected components and the arrays in
@@ -1072,7 +1072,6 @@
   if (TREE_CODE_CLASS (code) == tcc_binary)
     {
       tree type = TREE_TYPE (operand);
-      gcc_assert (INTEGRAL_TYPE_P (type));
       widest_int o_value, o_mask;
       get_value_and_mask (operand, &o_value, &o_mask);
 
@@ -2819,12 +2818,19 @@
   estimate_ipcp_clone_size_and_time (node, known_csts, known_contexts,
 				     known_aggs_ptrs, &size, &time,
 				     &hints);
-  time_benefit = base_time - time
-    + devirtualization_time_bonus (node, known_csts, known_contexts,
-				   known_aggs_ptrs)
-    + hint_time_bonus (hints)
-    + removable_params_cost + est_move_cost;
 
+  /* Extern inline functions have no cloning local time benefits because they
+     will be inlined anyway.  The only reason to clone them is if it enables
+     optimization in any of the functions they call.  */
+  if (DECL_EXTERNAL (node->decl) && DECL_DECLARED_INLINE_P (node->decl))
+    time_benefit = 0;
+  else
+    time_benefit = base_time - time
+      + devirtualization_time_bonus (node, known_csts, known_contexts,
+				     known_aggs_ptrs)
+      + hint_time_bonus (hints)
+      + removable_params_cost + est_move_cost;
+
   gcc_checking_assert (size >=0);
   /* The inliner-heuristics based estimates may think that in certain
      contexts some functions do not have any size at all but we want
Index: gcc/tree-scalar-evolution.c
===================================================================
--- a/src/gcc/tree-scalar-evolution.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-scalar-evolution.c	(.../branches/gcc-7-branch)
@@ -280,6 +280,7 @@
 #include "params.h"
 #include "tree-ssa-propagate.h"
 #include "gimple-fold.h"
+#include "tree-into-ssa.h"
 
 static tree analyze_scalar_evolution_1 (struct loop *, tree, tree);
 static tree analyze_scalar_evolution_for_address_of (struct loop *loop,
@@ -1532,7 +1533,10 @@
 follow_copies_to_constant (tree var)
 {
   tree res = var;
-  while (TREE_CODE (res) == SSA_NAME)
+  while (TREE_CODE (res) == SSA_NAME
+	 /* We face not updated SSA form in multiple places and this walk
+	    may end up in sibling loops so we have to guard it.  */
+	 && !name_registered_for_update_p (res))
     {
       gimple *def = SSA_NAME_DEF_STMT (res);
       if (gphi *phi = dyn_cast <gphi *> (def))
Index: gcc/rtlanal.c
===================================================================
--- a/src/gcc/rtlanal.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/rtlanal.c	(.../branches/gcc-7-branch)
@@ -357,10 +357,10 @@
   if (to == from)
     return 0;
 
-  /* It is not safe to call INITIAL_ELIMINATION_OFFSET
-     before the reload pass.  We need to give at least
-     an estimation for the resulting frame size.  */
-  if (! reload_completed)
+  /* It is not safe to call INITIAL_ELIMINATION_OFFSET before the epilogue
+     is completed, but we need to give at least an estimate for the stack
+     pointer based on the frame size.  */
+  if (!epilogue_completed)
     {
       offset1 = crtl->outgoing_args_size + get_frame_size ();
 #if !STACK_GROWS_DOWNWARD
Index: gcc/input.c
===================================================================
--- a/src/gcc/input.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/input.c	(.../branches/gcc-7-branch)
@@ -3480,6 +3480,34 @@
   ASSERT_EQ (num_cases_tested, 2 * 12);
 }
 
+/* Verify that when presented with a consecutive pair of locations with
+   a very large line offset, we don't attempt to consolidate them into
+   a single ordinary linemap where the line offsets within the line map
+   would lead to overflow (PR lto/88147).  */
+
+static void
+test_line_offset_overflow ()
+{
+  line_table_test ltt (line_table_case (5, 0));
+
+  linemap_add (line_table, LC_ENTER, false, "foo.c", 0);
+  linemap_line_start (line_table, 1, 100);
+  location_t loc_a = linemap_line_start (line_table, 2578, 255);
+  assert_loceq ("foo.c", 2578, 0, loc_a);
+
+  const line_map_ordinary *ordmap_a = LINEMAPS_LAST_ORDINARY_MAP (line_table);
+  ASSERT_EQ (ordmap_a->m_column_and_range_bits, 13);
+  ASSERT_EQ (ordmap_a->m_range_bits, 5);
+
+  location_t loc_b = linemap_line_start (line_table, 404198, 512);
+  assert_loceq ("foo.c", 404198, 0, loc_b);
+
+  /* We should have started a new linemap, rather than attempting to store
+     a very large line offset.  */
+  const line_map_ordinary *ordmap_b = LINEMAPS_LAST_ORDINARY_MAP (line_table);
+  ASSERT_NE (ordmap_a, ordmap_b);
+}
+
 /* Run all of the selftests within this file.  */
 
 void
@@ -3518,6 +3546,8 @@
   for_each_line_table_case (test_lexer_char_constants);
 
   test_reading_source_line ();
+
+  test_line_offset_overflow ();
 }
 
 } // namespace selftest
Index: gcc/ipa-reference.c
===================================================================
--- a/src/gcc/ipa-reference.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ipa-reference.c	(.../branches/gcc-7-branch)
@@ -730,7 +730,7 @@
      the global information.  All the nodes within a cycle will have
      the same info so we collapse cycles first.  Then we can do the
      propagation in one pass from the leaves to the roots.  */
-  order_pos = ipa_reduced_postorder (order, true, true, ignore_edge_p);
+  order_pos = ipa_reduced_postorder (order, true, ignore_edge_p);
   if (dump_file)
     ipa_print_order (dump_file, "reduced", order, order_pos);
 
Index: gcc/tree-ssa-sccvn.c
===================================================================
--- a/src/gcc/tree-ssa-sccvn.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssa-sccvn.c	(.../branches/gcc-7-branch)
@@ -2029,6 +2029,7 @@
       base2 = get_ref_base_and_extent (gimple_assign_lhs (def_stmt),
 				       &offset2, &size2, &maxsize2,
 				       &reverse);
+      tree def_rhs = gimple_assign_rhs1 (def_stmt);
       if (!reverse
 	  && maxsize2 != -1
 	  && maxsize2 == size2
@@ -2041,11 +2042,14 @@
 	     according to endianness.  */
 	  && (! INTEGRAL_TYPE_P (vr->type)
 	      || ref->size == TYPE_PRECISION (vr->type))
-	  && ref->size % BITS_PER_UNIT == 0)
+	  && ref->size % BITS_PER_UNIT == 0
+	  && (! INTEGRAL_TYPE_P (TREE_TYPE (def_rhs))
+	      || (TYPE_PRECISION (TREE_TYPE (def_rhs))
+		  == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (def_rhs))))))
 	{
 	  code_helper rcode = BIT_FIELD_REF;
 	  tree ops[3];
-	  ops[0] = SSA_VAL (gimple_assign_rhs1 (def_stmt));
+	  ops[0] = SSA_VAL (def_rhs);
 	  ops[1] = bitsize_int (ref->size);
 	  ops[2] = bitsize_int (offset - offset2);
 	  tree val = vn_nary_build_or_lookup (rcode, vr->type, ops);
@@ -3572,7 +3576,17 @@
 		  ops[0] = vn_nary_op_lookup_pieces
 		      (2, gimple_assign_rhs_code (def), type, ops, NULL);
 		  /* We have wider operation available.  */
-		  if (ops[0])
+		  if (ops[0]
+		      /* If the leader is a wrapping operation we can
+			 insert it for code hoisting w/o introducing
+			 undefined overflow.  If it is not it has to
+			 be available.  See PR86554.  */
+		      && (TYPE_OVERFLOW_WRAPS (TREE_TYPE (ops[0]))
+			  || TREE_CODE (ops[0]) != SSA_NAME
+			  || SSA_NAME_IS_DEFAULT_DEF (ops[0])
+			  || dominated_by_p_w_unex
+			       (gimple_bb (stmt),
+				gimple_bb (SSA_NAME_DEF_STMT (ops[0])))))
 		    {
 		      unsigned lhs_prec = TYPE_PRECISION (type);
 		      unsigned rhs_prec = TYPE_PRECISION (TREE_TYPE (rhs1));
Index: gcc/ChangeLog
===================================================================
--- a/src/gcc/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,878 @@
+2019-08-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/91347
+	* dse.c (scan_insn): Call add_wild_read for non-const/memset tail calls
+	before reload if HARD_FRAME_POINTER_IS_ARG_POINTER.
+
+2019-07-22  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-07-22  Martin Liska  <mliska@suse.cz>
+
+	PR driver/91172
+	* opts-common.c (decode_cmdline_option): Decode
+	argument of -Werror and check it for a wrong language.
+	* opts-global.c (complain_wrong_lang): Remove such case.
+
+2019-07-16  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	Backport from mainline
+	2019-03-05  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	PR target/89222
+	* config/arm/arm.md (movsi): Use targetm.cannot_force_const_mem
+	to decide when to split off a non-zero offset from a symbol.
+	* config/arm/arm.c (arm_cannot_force_const_mem): Disallow offsets
+	in function symbols.
+
+2019-07-15  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-07-01  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/vector.md: Fix shift count operand printing.
+
+2019-07-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/91136
+	* df-core.c (ACCESSING REFS): Fix typos in comment.
+	* resource.c (mark_target_live_reg): Add artificial defs that occur at
+	the beginning of the block to the initial set of live registers.
+
+2019-06-28  Jeff Law  <law@redhat.com>
+
+	Backport from mainline
+	2019-06-21  Jeff Law  <law@redhat.com>
+
+	PR tree-optimization/90949
+	* tree-ssa-copy.c (fini_copy_prop): Use reset_flow_sensitive_info.
+	* tree-ssanames.c (reset_flow_sensitive_info): Reset non-null state.
+
+2019-06-27  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-06-25  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/90939
+	* ipa-cp.c (ipcp_bits_lattice::meet_with): Remove assert.
+
+2019-06-16  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR middle-end/64242
+	* config/pa/pa.md (nonlocal_goto): Restore frame pointer last.  Add
+	frame clobbers and schedule block.
+	(builtin_longjmp): Likewise.
+
+2019-05-24  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/90530
+	* config/pa/pa.c (pa_cannot_change_mode_class): Accept mode changes
+	from DImode to SImode in floating-point registers on 64-bit target.
+	* config/pa/pa.md (umulsidi3): Change nonimmediate_operand to
+	register_operand in xmpyu patterns.
+
+2019-05-23  Uroš Bizjak  <ubizjak@gmail.com>
+
+	Backported from mainline
+	2019-05-21  Uroš Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/cpuid.h (__cpuid): For 32bit targets, zero
+	%ebx and %ecx bafore calling cpuid with leaf 1 or
+	non-constant leaf argument.
+
+	2019-05-21  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/90547
+	* config/i386/i386.md (anddi_1 to andsi_1_zext splitter):
+	Avoid calling gen_lowpart with CONST operand.
+
+2019-05-20  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-05-07  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/89765
+	* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):
+	In handling of ALTIVEC_BUILTIN_VEC_INSERT, use modular arithmetic
+	to compute vector element selector for both constant and variable
+	operands.
+
+2019-01-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/86215
+	Backport from mainline
+	2017-09-25  Iain Sandoe  <iain@codesourcery.com>
+
+	PR target/80556
+	* config/i386/darwin.h (REAL_LIB_SPEC): New; put libSystem ahead
+	of libgcc_eh for m64.
+	* config/i386/darwin64.h: Likewise.
+
+2019-05-15  David Edelsohn  <dje.gcc@gmail.com>
+
+	Backport from mainline
+	2019-04-11  David Edelsohn  <dje.gcc@gmail.com>
+	* xcoffout.h (xcoff_private_rodata_section_name): Declare.
+	* xcoffout.c (xcoff_private_rodata_section_name): Define.
+	* config/rs6000/rs6000.c (rs6000_xcoff_asm_init_sections): Create
+	read_only_private_data_section using coff_private_rodata_section_name.
+	(rs6000_xcoff_file_start): Generate coff_private_rodata_section_name.
+
+	2018-12-04  David Edelsohn  <dje.gcc@gmail.com>
+	2018-12-13  David Edelsohn  <dje.gcc@gmail.com>
+	PR target/61976
+	* config/rs6000/rs6000.c (rs6000_function_arg): Don't pass aggregates
+	in FPRs on AIX. Ensure type is non-NULL.
+	(rs6000_arg_partial_bytes): Same.
+
+2019-05-15  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config/arm/t-rtems: Replace -march=armv7-m multilibs with
+	-mcpu=cortex-m3 and -mcpu=cortex-m4 multilibs.
+
+2019-05-13  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-05-06  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/89424
+	* config/rs6000/rs6000.c (rs6000_expand_vector_extract): Add
+	handling of V1TImode.
+
+2019-05-07  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline:
+	2019-01-25  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR middle-end/89037
+	* varasm.c (output_constructor_bitfield): Use wi::extract_uhwi
+	instead of accessing TREE_INT_CST_ELT directly.
+
+2019-05-01  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	Backport from mainline.
+        2019-04-30  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+	PR target/86538
+	* config/aarch64/aarch64-c.c (aarch64_update_cpp_builtins):
+	Define __ARM_FEATURE_ATOMICS
+
+2019-04-30  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	PR target/90075
+	* config/aarch64/iterators.md (V_INT_EQUIV): Add mode for
+	integer equivalent of floating point values.
+
+	Backport from mainline
+	2018-12-11  Richard Earnshaw  <Richard.Earnshaw@arm.com>
+	PR target/37369
+	* config/aarch64/iterators.md (sizem1): Add sizes for
+	SFmode and DFmode.
+	(Vbtype): Add SFmode mapping.
+	* config/aarch64/aarch64.md (copysigndf3, copysignsf3): Delete.
+	(copysign<GPF:mode>3): New expand pattern.
+	(copysign<GPF:mode>3_insn): New insn pattern.
+
+2019-04-22  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-03-15  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/87532
+	* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):
+	When handling vec_extract, use modular arithmetic to allow
+	constant selectors greater than vector length.
+	* config/rs6000/rs6000.c (rs6000_expand_vector_extract): Allow
+	V1TImode vectors to have constant selector values greater than 0.
+	Use modular arithmetic to compute vector index.
+	(rs6000_split_vec_extract_var): Use modular arithmetic to compute
+	index for in-memory vectors.  Correct code generation for
+	in-register vectors.  Use inner mode of vector rather than mode of
+	destination for move instruction.
+	(altivec_expand_vec_ext_builtin): Use modular arithmetic to
+	compute index.
+
+	2019-04-12  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/87532
+	* config/rs6000/vsx.md (*vsx_extract_<mode>_<VS_scalar>mode_var):
+	Use QI inner mode with V16QI vector mode.
+
+2019-04-19  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	Backport from trunk
+	2018-05-23  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* doc/sourcebuild.texi (Endianness): New subsubsection.
+
+2019-04-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-03-08  Martin Liska  <mliska@suse.cz>
+
+	PR target/86952
+	* config/i386/i386.c (ix86_option_override_internal): Disable
+	jump tables when retpolines are used.
+
+2019-04-10  Matthew Malcomson  <matthew.malcomson@arm.com>
+
+	PR target/90024
+	* config/arm/arm.c (neon_valid_immediate): Disallow VOIDmode parameter.
+	* config/arm/constraints.md (Dm, DN, Dn): Split previous Dn constraint
+	into three.
+	* config/arm/neon.md (*neon_mov<mode>): Account for TImode and DImode
+	differences directly.
+	(*smax<mode>3_neon, vashl<mode>3, vashr<mode>3_imm): Use Dm constraint.
+
+2019-04-07  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/89945
+	* config/i386/i386.md (anddi_1 to andsi_1_zext splitter):
+	Avoid calling gen_lowpart with SYMBOL_REF and LABEL_REF operand.
+
+2019-04-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2019-02-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* rtlanal.c (get_initial_register_offset): Fall back to the estimate
+	as long as the epilogue isn't completed.
+
+2019-04-03  Richard Biener  <rguenther@suse.de>
+
+	PR lto/89896
+	* lto-wrapper.c (run_gcc): Avoid implicit rules making
+	the all target phony.
+
+2019-04-02  Xiong Hu Luo <luoxhu@linux.ibm.com>
+
+	Backport from trunk r250477.
+
+	2017-07-24  Carl Love  <cel@us.ibm.com>
+
+	* config/rs6000/rs6000-c.c: Add support for built-in functions
+	vector float vec_extract_fp32_from_shorth (vector unsigned short);
+	vector float vec_extract_fp32_from_shortl (vector unsigned short);
+	* config/rs6000/altivec.h (vec_extract_fp_from_shorth,
+	vec_extract_fp_from_shortl): Add defines for the two builtins.
+	* config/rs6000/rs6000-builtin.def (VEXTRACT_FP_FROM_SHORTH,
+	VEXTRACT_FP_FROM_SHORTL): Add BU_P9V_OVERLOAD_1 and BU_P9V_VSX_1
+	new builtins.
+	* config/rs6000/vsx.md vsx_xvcvhpsp): Add define_insn.
+	(vextract_fp_from_shorth, vextract_fp_from_shortl): Add define_expands.
+	* doc/extend.texi: Update the built-in documentation file for the
+	new built-in function.
+
+	Backport from trunk r255555.
+
+	2017-12-11  Carl Love  <cel@us.ibm.com>
+
+	* config/rs6000/altivec.h (vec_extract_fp32_from_shorth,
+	vec_extract_fp32_from_shortl]): Add #defines.
+	* config/rs6000/rs6000-builtin.def (VSLDOI_2DI): Add macro expansion.
+	* config/rs6000/rs6000-c.c (ALTIVEC_BUILTIN_VEC_UNPACKH,
+	ALTIVEC_BUILTIN_VEC_UNPACKL, ALTIVEC_BUILTIN_VEC_AND,
+	ALTIVEC_BUILTIN_VEC_SLD, ALTIVEC_BUILTIN_VEC_SRL,
+	ALTIVEC_BUILTIN_VEC_SRO, ALTIVEC_BUILTIN_VEC_SLD,
+	ALTIVEC_BUILTIN_VEC_SLL): Add expansions.
+	* doc/extend.texi: Add documentation for the added builtins.
+
+2019-03-28  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-11-05  Martin Liska  <mliska@suse.cz>
+
+	PR web/87829
+	* doc/invoke.texi: Remove options that are
+	not disabled with -Os.
+
+2019-02-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-02-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89253
+	* tree-ssa-loop-split.c (tree_ssa_split_loops): Check we can
+	duplicate the loop.
+
+	2019-02-08  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89223
+	* tree-data-ref.c (initialize_matrix_A): Fail if constant
+	doesn't fit in HWI.
+	(analyze_subscript_affine_affine): Handle failure from
+	initialize_matrix_A.
+
+	2019-01-28  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/88739
+	* tree-ssa-sccvn.c (vn_reference_lookup_3): Avoid generating
+	BIT_FIELD_REFs of non-mode-precision integral operands.
+
+2019-03-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-01-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/86554
+	* tree-ssa-sccvn.c (visit_nary_op): When value-numbering to
+	expressions with different overflow behavior make sure there's an
+	available expression on the path.
+
+	2018-11-20  Richard Biener  <rguenther@suse.de>
+ 
+	PR tree-optimization/88105
+	* tree-ssa-dom.c (pass_dominator::execute): Do not walk
+	backedges.
+
+	2018-03-08  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/84552
+	* tree-scalar-evolution.c: Include tree-into-ssa.h.
+	(follow_copies_to_constant): Do not follow SSA names registered
+	for update.
+
+2019-03-21  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+        * config/rs6000/rs6000.c (rs6000_analyze_swaps): Rebuild
+        ud- and du-chains between phases.
+
+2019-03-21  Matthias Klose  <doko@ubuntu.com>
+
+	Backport from mainline
+	2019-02-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89505
+	* tree-ssa-structalias.c (compute_dependence_clique): Make sure
+	to handle restrict pointed-to vars with multiple subvars
+	correctly.
+
+2019-03-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2019-03-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/89523
+	* config/i386/i386.c (ix86_print_operand): Handle 'M' to add
+	addr32 prefix to VSIB address for X32.
+	* config/i386/sse.md (*avx512pf_gatherpf<mode>sf_mask): Prepend
+	"%M2" to opcode.
+	(*avx512pf_gatherpf<mode>df_mask): Likewise.
+	(*avx512pf_scatterpf<mode>sf_mask): Likewise.
+	(*avx512pf_scatterpf<mode>df_mask): Likewise.
+	(*avx2_gathersi<mode>): Prepend "%M3" to opcode.
+	(*avx2_gathersi<mode>_2): Prepend "%M2" to opcode.
+	(*avx2_gatherdi<mode>): Prepend "%M3" to opcode.
+	(*avx2_gatherdi<mode>_2): Prepend "%M2" to opcode.
+	(*avx2_gatherdi<mode>_3): Prepend "%M3" to opcode.
+	(*avx2_gatherdi<mode>_4): Prepend "%M2" to opcode.`
+	(*avx512f_gathersi<mode>): Prepend "%M4" to opcode.
+	(*avx512f_gathersi<mode>_2): Prepend "%M3" to opcode.
+	(*avx512f_gatherdi<mode>): Prepend "%M4" to opcode.
+	(*avx512f_gatherdi<mode>_2): Prepend "%M3" to opcode.
+	(*avx512f_scattersi<mode>): Prepend "%M0" to opcode.
+	(*avx512f_scatterdi<mode>): Likewise.
+
+2019-03-14  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-03-07  Martin Jambor  <mjambor@suse.cz>
+
+	PR lto/87525
+	* ipa-cp.c (perform_estimation_of_a_value): Account zero time benefit
+	for extern inline functions.
+
+2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-02-16  Jakub Jelinek  <jakub@redhat.com>
+ 
+	PR target/84272
+	* config/aarch64/cortex-a57-fma-steering.c (fma_forest::merge_forest):
+	Use ++iter rather than iter++ for std::list iterators.
+	(func_fma_steering::dfs): Likewise.  Don't delete nodes right away,
+	defer deleting them until all nodes in the forest are processed.  Do
+	free even leaf nodes.  Change to_process into auto_vec.
+
+2019-03-13  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2019-03-08  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* config/arm/arm.h (TARGET_FP16_TO_DOUBLE): Add TARGET_VFP_DOUBLE
+	requirement.
+
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-11  David Malcolm  <dmalcolm@redhat.com>
+
+	PR lto/88147
+	* input.c (selftest::test_line_offset_overflow): New selftest.
+	(selftest::input_c_tests): Call it.
+
+2019-03-07  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	Backport of r268834 from mainline to gcc-7-branch.
+	2019-02-13  Xiong Hu Luo  <luoxhu@linux.vnet.ibm.com>
+
+	* config/rs6000/altivec.h (vec_sbox_be, vec_cipher_be,
+	vec_cipherlast_be, vec_ncipher_be, vec_ncipherlast_be): New #defines.
+	* config/rs6000/crypto.md (CR_vqdi): New define_mode_iterator.
+	(crypto_vsbox_<mode>, crypto_<CR_insn>_<mode>): New define_insns.
+	* config/rs6000/rs6000-builtin.def (VSBOX_BE): New BU_CRYPTO_1.
+	(VCIPHER_BE, VCIPHERLAST_BE, VNCIPHER_BE, VNCIPHERLAST_BE):
+	New BU_CRYPTO_2.
+	* config/rs6000/rs6000.c (builtin_function_type)
+	<CRYPTO_BUILTIN_VSBOX_BE, CRYPTO_BUILTIN_VCIPHER_BE,
+	CRYPTO_BUILTIN_VCIPHERLAST_BE, CRYPTO_BUILTIN_VNCIPHER_BE,
+	CRYPTO_BUILTIN_VNCIPHERLAST_BE>: New switch options.
+	* doc/extend.texi (vec_sbox_be, vec_cipher_be, vec_cipherlast_be,
+	vec_ncipher_be, vec_ncipherlast_be): New builtin functions.
+
+2019-02-27  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/89397
+	* config/i386/i386.c (ix86_atomic_assign_expand_fenv): Check
+	TARGET_SSE in addition to TARGET_SSE_MATH.
+
+	(ix86_excess_precision): Ditto.
+	(ix86_float_exceptions_rounding_supported_p): Ditto.
+	(use_rsqrt_p): Ditto.
+	* config/i386/sse.md (rsqrt<mode>2): Ditto.
+
+2019-02-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-14  Martin Liska  <mliska@suse.cz>
+
+	PR rtl-optimization/89242
+	* dce.c (delete_unmarked_insns): Call free_dominance_info we
+	process a transformation.
+
+2019-02-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-11  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/89009
+	* ipa-cp.c (build_toporder_info): Remove usage of a param.
+	* ipa-inline.c (inline_small_functions): Likewise.
+	* ipa-pure-const.c (propagate_pure_const): Likewise.
+	(propagate_nothrow): Likewise.
+	* ipa-reference.c (propagate): Likewise.
+	* ipa-utils.c (struct searchc_env): Remove unused field.
+	(searchc): Always search across AVAIL_INTERPOSABLE.
+	(ipa_reduced_postorder): Always allow AVAIL_INTERPOSABLE as
+	the only called IPA pure const can properly not propagate
+	across interposable boundary.
+	* ipa-utils.h (ipa_reduced_postorder): Remove param.
+
+2019-02-11  Stefan Agner  <stefan@agner.ch>
+
+	Backport from mainline.
+	2019-01-10  Stefan Agner  <stefan@agner.ch>
+
+	PR target/88648
+	* config/arm/arm.c (arm_option_override_internal): Force
+	opts->x_inline_asm_unified to true only if TARGET_THUMB2_P.
+
+2019-02-09  Alan Modra  <amodra@gmail.com>
+
+	PR target/88343
+	* config/rs6000/rs6000.c (rs6000_reg_live_or_pic_offset_p): Match
+	logic in rs6000_emit_prologue emitting pic_offset_table setup.
+
+2019-02-08  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2018-06-11  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/85755
+	* config/rs6000/rs6000.md (*movdi_internal32): Put constraint modifiers
+	on the correct operand.
+	(*movdi_internal64): Ditto.
+
+2019-02-06  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-01-30  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+	* config/rs6000/rs6000-c.c (altivec-resolve_overloaded_builtin):
+	Change handling of ALTIVEC_BUILTIN_VEC_EXTRACT.  Coerce result to
+	type of vector element when vec_extract is implemented by direct
+	move.
+
+2019-02-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/i386/i386.c (ix86_expand_prologue): Emit a memory blockage
+	after restoring registers saved to allocate the frame on Windows.
+
+2019-02-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-02-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	PR target/88856
+	* config/s390/s390.md: Remove load and test FP splitter.
+
+2019-02-04  Bill Schmidt  <wshmidt@linux.ibm.com>
+
+	PR target/87064
+	Backport from mainline
+
+	2019-01-30  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/87064
+	* config/rs6000/vsx.md (*vsx_reduc_<VEC_reduc_name>_v4sf_scalar):
+	Disable for little-endian.
+
+	2019-01-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/87064
+	* config/rs6000/vsx.md (*vsx_reduc_<VEC_reduc_name>_v2df_scalar):
+	Disable for little endian.
+
+2018-01-31  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	Backport from mainline
+	2018-01-31  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR tree-optimization/89008
+	* gimple-ssa-strength-reduction.c (slsr_process_mul): Don't
+	process anything of the form X * 0.
+
+2019-01-31  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-01-31  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/89115
+	* lra.c (lra_rtx_hash): Properly hash CONST_INT values.
+
+	2019-01-30  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/89115
+	* opts.c (default_options_optimization): Reduce
+	PARAM_MAX_DSE_ACTIVE_LOCAL_STORES by a factor of 10 at -O1.
+	Make PARAM_LOOP_INVARIANT_MAX_BBS_IN_LOOP reduction relative
+	to the default.
+
+2019-01-30  Kewen Lin  <linkw@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-01-17  Kewen Lin  <linkw@gcc.gnu.org>
+
+	* doc/extend.texi: Add four new prototypes for vec_ld and seven new
+	prototypes for vec_st.
+	* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Add entries
+	for scalar address type variants of altivec_vec_ld/altivec_vec_st,
+	mainly on signed/unsigned long long and double.
+
+2019-01-27  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/88948
+	* rtl.h (prepare_copy_insn): New prototype.
+	* gcse.c (prepare_copy_insn): New function, split out from
+	process_insert_insn.
+	(process_insert_insn): Use prepare_copy_insn.
+	* store-motion.c (replace_store_insn): Use prepare_copy_insn
+	instead of gen_move_insn.
+
+2019-01-24  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/88998
+	* config/i386/sse.md (sse2_cvtpi2pd): Add SSE alternatives.
+	Disparage MMX alternative.
+	(sse2_cvtpd2pi): Ditto.
+	(sse2_cvttpd2pi): Ditto.
+
+2019-01-24  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-01-23  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89008
+	* tree-ssa-reassoc.c (eliminate_using_constants): For * 0 do
+	not leave another stray operand.
+
+2019-01-22  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/88938
+	* config/i386/i386.c (ix86_expand_builtin) [case IX86_BUILTIN_BEXTRI32,
+	case IX86_BUILTIN_BEXTRI64]: Sanitize operands.
+
+2019-01-18  Uroš Bizjak  <ubizjak@gmail.com>
+
+	* config/alpha/alpha.c (alpha_gimplify_va_arg):
+	Handle split indirect COMPLEX_TYPE arguments.
+
+2019-01-16  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from mainline
+	2018-12-10  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/88214
+	* ipa-prop.c (determine_locally_known_aggregate_parts): Make sure
+	we check pointers against pointers.
+
+2019-01-09  Eric Botcazou  <ebotcazou@adacore.com>
+	    James Clarke  <jrtc27@jrtc27.com>
+
+	PR target/84010
+	* config/sparc/sparc.c (sparc_legitimize_tls_address): Only use Pmode
+	consistently in TLS address generation and adjust code to the renaming
+	of patterns.  Mark calls to __tls_get_addr as const.
+	* config/sparc/sparc.md (tgd_hi22): Turn into...
+	(tgd_hi22<P:mode>): ...this and use Pmode throughout.
+	(tgd_lo10): Turn into...
+	(tgd_lo10<P:mode>): ...this and use Pmode throughout.
+	(tgd_add32): Merge into...
+	(tgd_add64): Likewise.
+	(tgd_add<P:mode>): ...this and use Pmode throughout.
+	(tldm_hi22): Turn into...
+	(tldm_hi22<P:mode>): ...this and use Pmode throughout.
+	(tldm_lo10): Turn into...
+	(tldm_lo10<P:mode>): ...this and use Pmode throughout.
+	(tldm_add32): Merge into...
+	(tldm_add64): Likewise.
+	(tldm_add<P:mode>): ...this and use Pmode throughout.
+	(tldm_call32): Merge into...
+	(tldm_call64): Likewise.
+	(tldm_call<P:mode>): ...this and use Pmode throughout.
+	(tldo_hix22): Turn into...
+	(tldo_hix22<P:mode>): ...this and use Pmode throughout.
+	(tldo_lox10): Turn into...
+	(tldo_lox10<P:mode>): ...this and use Pmode throughout.
+	(tldo_add32): Merge into...
+	(tldo_add64): Likewise.
+	(tldo_add<P:mode>): ...this and use Pmode throughout.
+	(tie_hi22): Turn into...
+	(tie_hi22<P:mode>): ...this and use Pmode throughout.
+	(tie_lo10): Turn into...
+	(tie_lo10<P:mode>): ...this and use Pmode throughout.
+	(tie_ld64): Use DImode throughout.
+	(tie_add32): Merge into...
+	(tie_add64): Likewise.
+	(tie_add<P:mode>): ...this and use Pmode throughout.
+	(tle_hix22_sp32): Merge into...
+	(tle_hix22_sp64): Likewise.
+	(tle_hix22<P:mode>): ...this and use Pmode throughout.
+	(tle_lox22_sp32): Merge into...
+	(tle_lox22_sp64): Likewise.
+	(tle_lox22<P:mode>): ...this and use Pmode throughout.
+	(*tldo_ldub_sp32): Merge into...
+	(*tldo_ldub_sp64): Likewise.
+	(*tldo_ldub<P:mode>): ...this and use Pmode throughout.
+	(*tldo_ldub1_sp32): Merge into...
+	(*tldo_ldub1_sp64): Likewise.
+	(*tldo_ldub1<P:mode>): ...this and use Pmode throughout.
+	(*tldo_ldub2_sp32): Merge into...
+	(*tldo_ldub2_sp64): Likewise.
+	(*tldo_ldub2<P:mode>): ...this and use Pmode throughout.
+	(*tldo_ldsb1_sp32): Merge into...
+	(*tldo_ldsb1_sp64): Likewise.
+	(*tldo_ldsb1<P:mode>): ...this and use Pmode throughout.
+	(*tldo_ldsb2_sp32): Merge into...
+	(*tldo_ldsb2_sp64): Likewise.
+	(*tldo_ldsb2<P:mode>): ...this and use Pmode throughout.
+	(*tldo_ldub3_sp64): Use DImode throughout.
+	(*tldo_ldsb3_sp64): Likewise.
+	(*tldo_lduh_sp32): Merge into...
+	(*tldo_lduh_sp64): Likewise.
+	(*tldo_lduh<P:mode>): ...this and use Pmode throughout.
+	(*tldo_lduh1_sp32): Merge into...
+	(*tldo_lduh1_sp64): Likewise.
+	(*tldo_lduh1<P:mode>): ...this and use Pmode throughout.
+	(*tldo_ldsh1_sp32): Merge into...
+	(*tldo_ldsh1_sp64): Likewise.
+	(*tldo_ldsh1<P:mode>): ...this and use Pmode throughout.
+	(*tldo_lduh2_sp64): Use DImode throughout.
+	(*tldo_ldsh2_sp64): Likewise.
+	(*tldo_lduw_sp32): Merge into...
+	(*tldo_lduw_sp64): Likewise.
+	(*tldo_lduw<P:mode>): ...this and use Pmode throughout.
+	(*tldo_lduw1_sp64): Use DImode throughout.
+	(*tldo_ldsw1_sp64): Likewise.
+	(*tldo_ldx_sp64): Likewise.
+	(*tldo_stb_sp32): Merge into...
+	(*tldo_stb_sp64): Likewise.
+	(*tldo_stb<P:mode>): ...this and use Pmode throughout.
+	(*tldo_sth_sp32): Merge into...
+	(*tldo_sth_sp64): Likewise.
+	(*tldo_sth<P:mode>): ...this and use Pmode throughout.
+	(*tldo_stw_sp32): Merge into...
+	(*tldo_stw_sp64): Likewise.
+	(*tldo_stw<P:mode>): ...this and use Pmode throughout.
+	(*tldo_stx_sp64): Use DImode throughout.
+
+2019-01-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* doc/invoke.texi (-Os): Add reference to -finline-functions.
+	(-finline-small-functions): Add references to -O3 and -Os.
+	(-findirect-inlining): Likewise.
+	(-finline-functions): Add references to -Os, -fprofile-use and
+	-fauto-profile.
+
+2019-01-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	revert:
+	2018-12-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	backport from mainline.
+	2018-12-12 Segher Boessenkool  <segher@kernel.crashing.org>
+		   Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/88343
+	* config/rs6000/rs6000.c (save_reg_p): Do not save the picbase reg
+	unless it has been used.
+	(first_reg_to_save): Remove dead code.
+
+2019-01-02  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR inline-asm/55681
+	* doc/extend.texi (Basic Asm): Update grammar.
+	(Extended Asm): Update grammar.
+
+	Backport from trunk
+	2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* doc/extend.texi (Using Assembly Language with C): Document asm inline.
+	(Size of an asm): Fix typo.  Document asm inline.
+	* gimple-pretty-print.c (dump_gimple_asm): Handle asm inline.
+	* gimple.h (enum gf_mask): Add GF_ASM_INLINE.
+	(gimple_asm_set_volatile): Fix typo.
+	(gimple_asm_inline_p): New.
+	(gimple_asm_set_inline): New.
+	* gimplify.c (gimplify_asm_expr): Propagate the asm inline flag from
+	tree to gimple.
+	* ipa-icf-gimple.c (func_checker::compare_gimple_asm): Compare the
+	gimple_asm_inline_p flag, too.
+	* tree-core.h (tree_base): Document that protected_flag is ASM_INLINE_P
+	in an ASM_EXPR.
+	* tree-inline.c (estimate_num_insns): If gimple_asm_inline_p return
+	a minimum size for an asm.
+	* tree.h (ASM_INLINE_P): New.
+
+2018-12-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	backport from mainline.
+	2018-12-12 Segher Boessenkool  <segher@kernel.crashing.org>
+		   Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/88343
+	* config/rs6000/rs6000.c (save_reg_p): Do not save the picbase reg
+	unless it has been used.
+	(first_reg_to_save): Remove dead code.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-12-06  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR c++/87380
+	* config/darwin.h (TARGET_WEAK_NOT_IN_ARCHIVE_TOC) Remove, use the
+	default.
+	* config/rs6000/darwin7.h (TARGET_WEAK_NOT_IN_ARCHIVE_TOC): New.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-12-06  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/78444
+	* config/i386/darwin.h (STACK_BOUNDARY): Remove macro.
+	* config/i386/i386.c (ix86_compute_frame_layout): Ensure at least 128b
+	stack alignment in non-leaf functions.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-08-15  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/81685
+	* config/darwin.h: (DEBUG_STR_OFFSETS_SECTION, DEBUG_LOCLISTS_SECTION,
+	DEBUG_RNGLISTS_SECTION) new macros.  (DEBUG_PUBNAMES_SECTION,
+	DEBUG_PUBTYPES_SECTION) update to include GNU variant.
+
+2018-12-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2018-12-10  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/88418
+	* config/i386/i386.c (ix86_expand_sse_cmp): For vector modes,
+	check operand 1 with vector_operand predicate.
+	(ix86_expand_sse_movcc): For vector modes, check op_true with
+	vector_operand, not nonimmediate_operand.
+
+2018-12-19  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	Backport from mainline
+	2018-12-18  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	* doc/extend.texi (PowerPC Altivec/VSX Built-in Functions):
+	Describe when a typedef name can be used as the type specifier for
+	a vector type, and when it cannot.
+
+2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/88213
+	* config/rs6000/vsx.md (*vsx_extract_<P:mode>_<VSX_D:mode>_load):
+	Require TARGET_POWERPC64.
+
+2018-12-17  Senthil Kumar Selvaraj  <senthilkumar.selvaraj@microchip.com>
+
+	Backport from trunk
+	2018-12-17  Senthil Kumar Selvaraj  <senthilkumar.selvaraj@microchip.com>
+
+	PR rtl-optimization/88253
+	* combine.c (combine_simplify_rtx): Test for side-effects before
+	substituting by zero.
+
+2018-12-15  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2018-12-14  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR rtl-optimization/88001
+	* function.c (match_asm_constraints_1): Don't invalidly share RTL.
+
+2018-12-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2018-12-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/s390-builtins.def (s390_vec_double_s64): Map to
+	s390_vec_double_s64 instead of s390_vcdgb.
+	(s390_vec_double_u64): Map to s390_vec_double_u64 instead of
+	s390_vcdlgb.
+
+2018-12-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2018-12-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/vx-builtins.md ("vec_ctd_s64", "vec_ctd_u64")
+	("vec_ctsl", "vec_ctul"): Replace 0 with VEC_NOINEXACT.
+	("vec_double_s64", "vec_double_u64"): Replace 4 with VEC_INEXACT.
+
+2018-12-12  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backport from mainline
+	2018-12-07  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/87496
+	* config/rs6000/rs6000.c (rs6000_option_override_internal): Disallow
+	-mabi=ieeelongdouble and -mabi=ibmlongdouble without -mlong-double-128.
+	Do not error for -mabi=ibmlongdouble and no ISA 2.06 support.
+	* doc/invoke.texi: Document -mabi=ibmlongdouble and -mabi=ieeelongdouble
+	require -mlong-double-128.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
@@ -19,13 +898,13 @@
 	* gcc/dwarf2out.c (FUNC_SECOND_SECT_LABEL): New.
 	(dwarf2out_switch_text_section): Generate a local label for the second
 	function sub-section and apply it as the second FDE start label.
-	* gcc/final.c (final_scan_insn_1): Emit second FDE label after the second
-	sub-section start.
+	* gcc/final.c (final_scan_insn_1): Emit second FDE label after the
+	second sub-section start.
 
 2018-11-26  Iain Sandoe  <iain@sandoe.co.uk>
 
 	2018-08-15  Iain Sandoe  <iain@sandoe.co.uk>
- 
+
 	* config/darwin.c
 	(darwin_function_switched_text_sections): Delete.
 	* gcc/config/darwin.h
Index: gcc/testsuite/gcc.target/powerpc/vsx-vector-6.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.c	(.../branches/gcc-7-branch)
@@ -1,81 +0,0 @@
-/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
-/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
-/* { dg-require-effective-target powerpc_vsx_ok } */
-/* { dg-options "-mvsx -O2" } */
-
-#include <altivec.h>
-
-void foo (vector double *out, vector double *in, vector long *p_l, vector bool long *p_b, vector unsigned char *p_uc, int *i)
-{
-  vector double in0 = in[0];
-  vector double in1 = in[1];
-  vector double in2 = in[2];
-  vector long inl = *p_l;
-  vector bool long inb = *p_b;
-  vector unsigned char uc = *p_uc;
-
-  *out++ = vec_abs (in0);
-  *out++ = vec_add (in0, in1);
-  *out++ = vec_and (in0, in1);
-  *out++ = vec_and (in0, inb);
-  *out++ = vec_and (inb, in0);
-  *out++ = vec_andc (in0, in1);
-  *out++ = vec_andc (in0, inb);
-  *out++ = vec_andc (inb, in0);
-  *out++ = vec_ceil (in0);
-  *p_b++ = vec_cmpeq (in0, in1);
-  *p_b++ = vec_cmpgt (in0, in1);
-  *p_b++ = vec_cmpge (in0, in1);
-  *p_b++ = vec_cmplt (in0, in1);
-  *p_b++ = vec_cmple (in0, in1);
-  *out++ = vec_div (in0, in1);
-  *out++ = vec_floor (in0);
-  *out++ = vec_madd (in0, in1, in2);
-  *out++ = vec_msub (in0, in1, in2);
-  *out++ = vec_max (in0, in1);
-  *out++ = vec_min (in0, in1);
-  *out++ = vec_msub (in0, in1, in2);
-  *out++ = vec_mul (in0, in1);
-  *out++ = vec_nearbyint (in0);
-  *out++ = vec_nmadd (in0, in1, in2);
-  *out++ = vec_nmsub (in0, in1, in2);
-  *out++ = vec_nor (in0, in1);
-  *out++ = vec_or (in0, in1);
-  *out++ = vec_or (in0, inb);
-  *out++ = vec_or (inb, in0);
-  *out++ = vec_perm (in0, in1, uc);
-  *out++ = vec_rint (in0);
-  *out++ = vec_sel (in0, in1, inl);
-  *out++ = vec_sel (in0, in1, inb);
-  *out++ = vec_sub (in0, in1);
-  *out++ = vec_sqrt (in0);
-  *out++ = vec_trunc (in0);
-  *out++ = vec_xor (in0, in1);
-  *out++ = vec_xor (in0, inb);
-  *out++ = vec_xor (inb, in0);
-
-  *i++ = vec_all_eq (in0, in1);
-  *i++ = vec_all_ge (in0, in1);
-  *i++ = vec_all_gt (in0, in1);
-  *i++ = vec_all_le (in0, in1);
-  *i++ = vec_all_lt (in0, in1);
-  *i++ = vec_all_nan (in0);
-  *i++ = vec_all_ne (in0, in1);
-  *i++ = vec_all_nge (in0, in1);
-  *i++ = vec_all_ngt (in0, in1);
-  *i++ = vec_all_nle (in0, in1);
-  *i++ = vec_all_nlt (in0, in1);
-  *i++ = vec_all_numeric (in0);
-  *i++ = vec_any_eq (in0, in1);
-  *i++ = vec_any_ge (in0, in1);
-  *i++ = vec_any_gt (in0, in1);
-  *i++ = vec_any_le (in0, in1);
-  *i++ = vec_any_lt (in0, in1);
-  *i++ = vec_any_nan (in0);
-  *i++ = vec_any_ne (in0, in1);
-  *i++ = vec_any_nge (in0, in1);
-  *i++ = vec_any_ngt (in0, in1);
-  *i++ = vec_any_nle (in0, in1);
-  *i++ = vec_any_nlt (in0, in1);
-  *i++ = vec_any_numeric (in0);
-}
Index: gcc/testsuite/gcc.target/powerpc/altivec-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/altivec-7.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/altivec-7.c	(.../branches/gcc-7-branch)
@@ -1,46 +0,0 @@
-/* Origin: Aldy Hernandez  <aldyh@redhat.com>  */
-
-/* { dg-do compile { target powerpc*-*-* } } */
-/* { dg-require-effective-target powerpc_altivec_ok } */
-/* { dg-options "-maltivec" } */
-
-#include <altivec.h>
-
-int **intp;
-int *var_int;
-unsigned int **uintp;
-vector pixel *varpixel;
-vector signed char *vecchar;
-vector signed int *vecint;
-vector signed short *vecshort;
-vector unsigned char *vecuchar;
-vector unsigned int *vecuint;
-vector unsigned short *vecushort;
-vector float *vecfloat;
-
-int main ()
-{
-  *vecfloat++ = vec_andc((vector bool int)vecint[0], vecfloat[1]);
-  *vecfloat++ = vec_andc(vecfloat[0], (vector bool int)vecint[1]);
-  *vecfloat++ = vec_vxor((vector bool int)vecint[0], vecfloat[1]);
-  *vecfloat++ = vec_vxor(vecfloat[0], (vector bool int)vecint[1]);
-  *varpixel++ = vec_packpx(vecuint[0], vecuint[1]);
-  *varpixel++ = vec_vpkpx(vecuint[0], vecuint[1]);
-  *vecshort++ = vec_vmulosb(vecchar[0], vecchar[1]);
-  *vecint++ = vec_ld(var_int[0], intp[1]);
-  *vecint++ = vec_lde(var_int[0], intp[1]);
-  *vecint++ = vec_ldl(var_int[0], intp[1]);
-  *vecint++ = vec_lvewx(var_int[0], intp[1]);
-  *vecint++ = vec_unpackh(vecshort[0]);
-  *vecint++ = vec_unpackl(vecshort[0]);
-  *vecushort++ = vec_andc((vector bool short)vecshort[0], vecushort[1]);
-  *vecushort++ = vec_andc(vecushort[0], (vector bool short)vecshort[1]);
-  *vecushort++ = vec_vxor((vector bool short)vecshort[0], vecushort[1]);
-  *vecushort++ = vec_vxor(vecushort[0], (vector bool short)vecshort[1]);
-  *vecuint++ = vec_ld(var_int[0], uintp[1]);
-  *vecuint++ = vec_lvx(var_int[0], uintp[1]);
-  *vecuint++ = vec_vmsumubm(vecuchar[0], vecuchar[1], vecuint[2]);
-  *vecuchar++ = vec_xor(vecuchar[0], (vector unsigned char)vecchar[1]);
-
-  return 0;
-}
Index: gcc/testsuite/gcc.target/powerpc/altivec-7.h
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/altivec-7.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/altivec-7.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,47 @@
+/* Origin: Aldy Hernandez  <aldyh@redhat.com>  */
+
+/* This test code is included into altivec-7-be.c and altivec-7-le.c.  
+   The two files have the tests for the number of instructions generated for
+   LE versus BE.  */
+
+#include <altivec.h>
+
+int **intp;
+int *var_int;
+unsigned int **uintp;
+vector pixel *varpixel;
+vector signed char *vecchar;
+vector signed int *vecint;
+vector signed short *vecshort;
+vector unsigned char *vecuchar;
+vector unsigned int *vecuint;
+vector unsigned short *vecushort;
+vector float *vecfloat;
+
+int main ()
+{
+  *vecfloat++ = vec_andc((vector bool int)vecint[0], vecfloat[1]);
+  *vecfloat++ = vec_andc(vecfloat[0], (vector bool int)vecint[1]);
+  *vecfloat++ = vec_vxor((vector bool int)vecint[0], vecfloat[1]);
+  *vecfloat++ = vec_vxor(vecfloat[0], (vector bool int)vecint[1]);
+  *varpixel++ = vec_packpx(vecuint[0], vecuint[1]);
+  *varpixel++ = vec_vpkpx(vecuint[0], vecuint[1]);
+  *vecshort++ = vec_vmulesb(vecchar[0], vecchar[1]);
+  *vecshort++ = vec_vmulosb(vecchar[0], vecchar[1]);
+  *vecint++ = vec_ld(var_int[0], intp[1]);
+  *vecint++ = vec_lde(var_int[0], intp[1]);
+  *vecint++ = vec_ldl(var_int[0], intp[1]);
+  *vecint++ = vec_lvewx(var_int[0], intp[1]);
+  *vecint++ = vec_unpackh(vecshort[0]);
+  *vecint++ = vec_unpackl(vecshort[0]);
+  *vecushort++ = vec_andc((vector bool short)vecshort[0], vecushort[1]);
+  *vecushort++ = vec_andc(vecushort[0], (vector bool short)vecshort[1]);
+  *vecushort++ = vec_vxor((vector bool short)vecshort[0], vecushort[1]);
+  *vecushort++ = vec_vxor(vecushort[0], (vector bool short)vecshort[1]);
+  *vecuint++ = vec_ld(var_int[0], uintp[1]);
+  *vecuint++ = vec_lvx(var_int[0], uintp[1]);
+  *vecuint++ = vec_vmsumubm(vecuchar[0], vecuchar[1], vecuint[2]);
+  *vecuchar++ = vec_xor(vecuchar[0], (vector unsigned char)vecchar[1]);
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr87496-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr87496-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr87496-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,10 @@
+/* PR target/87496 */
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
+/* { dg-options "-O2 -mcpu=power7 -mabi=ieeelongdouble -mlong-double-64 -Wno-psabi" } */
+
+int i;
+
+/* { dg-error "'-mabi=ieeelongdouble' requires '-mlong-double-128'" "PR87496" { target *-*-* } 0 } */
+/* { dg-warning "using IEEE extended precision long double" "" { target *-*-* } 0 } */
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-19b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,109 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned long long int e0 (vector unsigned long long int v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned long long int e3 (vector unsigned long long int v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+unsigned long long int me0 (vector unsigned long long int *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned long long int me3 (vector unsigned long long int *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned long long int ei (vector unsigned long long int v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+unsigned long long int mei (vector unsigned long long int *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned long long int dv = { CONST0, CONST1 };
+  unsigned long long int d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/altivec-13.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/altivec-13.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/altivec-13.c	(.../branches/gcc-7-branch)
@@ -1,6 +1,7 @@
 /* { dg-do compile { target powerpc*-*-* } } */
 /* { dg-require-effective-target powerpc_altivec_ok } */
 /* { dg-options "-maltivec" } */
+
 /* Author: Ziemowit Laski  <zlaski@apple.com>  */
 
 /* This test case exercises intrinsic/argument combinations that,
@@ -7,15 +8,70 @@
    while not in the Motorola AltiVec PIM, have nevertheless crept
    into the AltiVec vernacular over the years.  */
 
+/* Tests requiring VSX support (vector long long and vector double) have
+   been moved over to vsx-13.c.  */
+
 #include <altivec.h>
 
-void foo (void) 
+void foo (void)
 {
   vector bool int boolVec1 = (vector bool int) vec_splat_u32(3);
   vector bool short boolVec2 = (vector bool short) vec_splat_u16(3);
   vector bool char boolVec3 = (vector bool char) vec_splat_u8(3);
-
+  vector signed char vsc1, vsc2, vscz;
+  vector unsigned char vuc1, vuc2, vucz;
+  vector signed short int vssi1, vssi2, vssiz;
+  vector signed int vsi1, vsi2, vsiz;
+  vector unsigned int vui1, vui2, vuiz;
+  vector unsigned short int vusi1, vusi2, vusiz;
+  vector pixel vp1, vp2, vpz;
+  vector float vf1, vf2, vfz;
+  
   boolVec1 = vec_sld( boolVec1, boolVec1, 4 );
   boolVec2 = vec_sld( boolVec2, boolVec2, 2 );
   boolVec3 = vec_sld( boolVec3, boolVec3, 1 );
+
+  vscz = vec_sld( vsc1, vsc2, 1 );
+  vucz = vec_sld( vuc1, vuc2, 1 );
+  vsiz = vec_sld( vsi1, vsi2, 1 );
+  vuiz = vec_sld( vui1, vui2, 1 );
+  vssiz = vec_sld( vssi1, vssi2, 1 );
+  vusiz = vec_sld( vusi1, vusi2, 1 );
+  
+  vfz = vec_sld( vf1, vf2, 1 );
+
+  vpz = vec_sld( vp1, vp2, 1 );
+
+  vucz = vec_srl(vuc1, vuc2);
+  vsiz = vec_srl(vsi1, vuc2);
+  vuiz = vec_srl(vui1, vuc2);
+  vpz = vec_srl(vp1, vuc2);
+  vssiz = vec_srl(vssi1, vuc2);
+  vusiz = vec_srl(vusi1, vuc2);
+
+  vscz = vec_sro(vsc1, vsc2);
+  vscz = vec_sro(vsc1, vuc2);
+  vucz = vec_sro(vuc1, vsc2);
+  vucz = vec_sro(vuc1, vuc2);
+  vsiz = vec_sro(vsi1, vsc2);
+  vsiz = vec_sro(vsi1, vuc2);
+  vuiz = vec_sro(vui1, vsc2);
+  vuiz = vec_sro(vui1, vuc2);
+  vpz = vec_sro(vp1, vsc2);
+  vpz = vec_sro(vp1, vuc2);
+  vssiz = vec_sro(vssi1, vsc2);
+  vssiz = vec_sro(vssi1, vuc2);
+  vusiz = vec_sro(vusi1, vsc2);
+  vusiz = vec_sro(vusi1, vuc2);
+  vfz = vec_sro(vf1, vsc2);
+  vfz = vec_sro(vf1, vuc2);
 }
+
+/* Expected results:
+   vec_sld          vsldoi
+   vec_srl          vsr
+   vec_sro          vsro  */
+
+/* { dg-final { scan-assembler-times "vsldoi" 11 } } */
+/* { dg-final { scan-assembler-times "vsr " 6 } } */
+/* { dg-final { scan-assembler-times "vsro" 16 } } */
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-18d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18d.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18d.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,148 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Unsigned Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned int s3 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector unsigned int s1 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector unsigned int s21 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector unsigned int s30 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned int ms3 (vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector unsigned int ms1(vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector unsigned int ms21(vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector unsigned int ms30(vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned int ci (vector unsigned int v, int i, unsigned int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned int mci(vector unsigned int *vp, int i, unsigned int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, unsigned char *argv[]) {
+  vector unsigned int sv = { CONST0, CONST1, CONST2, CONST3 };
+
+  sv = s3 (sv, CONST2);
+  if (sv [3] != CONST2)
+    abort ();
+
+  sv = s1 (sv, CONST2);
+  if (sv [1] != CONST2)
+    abort ();
+
+  sv = s21 (sv, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = s30 (sv, CONST1);
+  if (sv [2] != CONST1)
+    abort ();
+
+  sv = ms3 (&sv, CONST0);
+  if (sv [3] != CONST0)
+    abort ();
+
+  sv = ms1 (&sv, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = ms21 (&sv, CONST1);
+  if (sv [1] != CONST1)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [2] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = ci (sv, 2, CONST0);
+  if (sv [2] != CONST0)
+    abort ();
+
+  sv = ci (sv, 15, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = ci (sv, 28, CONST3);
+  if (sv [0] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 5, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = mci (&sv, 12, CONST2);
+  if (sv [0] != CONST2)
+    abort ();
+
+  sv = mci (&sv, 25, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 16, CONST1);
+  if (sv [0] != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr87496-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr87496-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr87496-3.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,9 @@
+/* PR target/87496 */
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-options "-O2 -mabi=ibmlongdouble -mlong-double-64 -Wno-psabi" } */
+
+int i;
+
+/* { dg-error "'-mabi=ibmlongdouble' requires '-mlong-double-128'" "PR87496" { target *-*-* } 0 } */
+/* { dg-warning "using IBM extended precision long double" "" { target *-*-* } 0 } */
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-19c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19c.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,122 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+#define CONST2		(3 * 31415926539LL)
+#define CONST3		(4 * 31415926539LL)
+#define CONST4		(5 * 31415926539LL)
+#define CONST5		(6 * 31415926539LL)
+#define CONST6		(7 * 31415926539LL)
+#define CONST7		(8 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned long long int
+e0 (vector unsigned long long int v, unsigned long long int x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector unsigned long long int
+e3 (vector unsigned long long int v, unsigned long long int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned long long int
+me0 (vector unsigned long long int *vp, unsigned long long int x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector unsigned long long int
+me3 (vector unsigned long long int *vp, unsigned long long int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned long long int
+ei (vector unsigned long long int v, int i, unsigned long long int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned long long int
+mei (vector unsigned long long int *vp, int i, unsigned long long int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned long long int dv = { CONST0, CONST1 };
+  unsigned long long int d;
+
+  dv = e0 (dv, CONST7);
+  if (dv [0] != CONST7)
+    abort ();
+
+  dv = e3 (dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = me0 (&dv, CONST4);
+  if (dv [0] != CONST4)
+    abort ();
+
+  dv = me3 (&dv, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = ei (dv, 0, CONST5);
+  if (dv [0] != CONST5)
+    abort ();
+
+  dv = ei (dv, 1, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = ei (dv, 2, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 3, CONST6);
+  if (dv [1] != CONST6)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 3, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-10a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+short s3 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 3);
+}
+
+short s7 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 7);
+}
+
+short s21 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 21);
+}
+
+short s30 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+short ms3 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 3);
+}
+
+short ms7 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 7);
+}
+
+short ms21 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 21);
+}
+
+short ms30 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+short ci (vector short v, int i)
+{
+  return __builtin_vec_ext_v8hi (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+short mci (vector short *vp, int i)
+{
+  return __builtin_vec_ext_v8hi (*vp, i);
+}
+
+
+int main (int argc, short *argv[]) {
+  vector short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  short s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s7 (sv);
+  if (s != CONST7)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST5)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms7 (&sv);
+  if (s != CONST7)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST5)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST7)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/builtins-3-p8.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/builtins-3-p8.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/builtins-3-p8.c	(.../branches/gcc-7-branch)
@@ -17,6 +17,34 @@
   return vec_pack (x, y);
 }
 
+vector unsigned char
+test_vsi_packs_vusi_vusi (vector unsigned short x,
+                          vector unsigned short y)
+{
+  return vec_packs (x, y);
+}
+
+vector signed char
+test_vsi_packs_vssi_vssi (vector signed short x,
+                          vector signed short y)
+{
+  return vec_packs (x, y);
+}
+
+vector signed short int
+test_vsi_packs_vsi_vsi (vector signed int x,
+			vector signed int y)
+{
+  return vec_packs (x, y);
+}
+
+vector unsigned short int
+test_vsi_packs_vui_vui (vector unsigned int x,
+			vector unsigned int y)
+{
+  return vec_packs (x, y);
+}
+
 vector long long
 test_nabs_long_long (vector long long x)
 {
@@ -37,6 +65,48 @@
   return vec_packs (x, y);
 }
 
+vector unsigned char
+test_vsi_packsu_vssi_vssi (vector signed short x,
+			   vector signed short y)
+{
+  return vec_packsu (x, y);
+}
+
+vector unsigned char
+test_vsi_packsu_vusi_vusi (vector unsigned short x,
+			   vector unsigned short y)
+{
+  return vec_packsu (x, y);
+}
+
+vector unsigned int
+test_vsi_packsu_vsll_vsll (vector signed long long x,
+			   vector signed long long y)
+{
+  return vec_packsu (x, y);
+}
+
+vector unsigned int
+test_vsi_packsu_vull_vull (vector unsigned long long x,
+			   vector unsigned long long y)
+{
+  return vec_packsu (x, y);
+}
+
+vector unsigned short int
+test_vsi_packsu_vsi_vsi (vector signed int x,
+			 vector signed int y)
+{
+  return vec_packsu (x, y);
+}
+
+vector unsigned short int
+test_vsi_packsu_vui_vui (vector unsigned int x,
+			 vector unsigned int y)
+{
+  return vec_packsu (x, y);
+}
+
 /* Expected test results:
 
      test_eq_long_long          1 vcmpequd inst
@@ -43,7 +113,9 @@
      test_pack_float            1 vpkudum inst
      test_nabs_long_long        1 vspltisw, 1 vsubudm, 1 vminsd
      test_vsi_packs_vsll_vsll   1 vpksdss
-     test_vui_packs_vull_vull   1 vpkudus */
+     test_vui_packs_vull_vull   1 vpkudus
+     test_vui_packs_vssi_vssi   1 vpkshss
+     test_vsi_packsu_vssi_vssi  1 vpkshus */
 
 /* { dg-final { scan-assembler-times "vcmpequd" 1 } } */
 /* { dg-final { scan-assembler-times "vpkudum"  1 } } */
@@ -51,4 +123,9 @@
 /* { dg-final { scan-assembler-times "vsubudm"  1 } } */
 /* { dg-final { scan-assembler-times "vminsd"   1 } } */
 /* { dg-final { scan-assembler-times "vpksdss"  1 } } */
-/* { dg-final { scan-assembler-times "vpkudus"  1 } } */  
+/* { dg-final { scan-assembler-times "vpkudus"  2 } } */  
+/* { dg-final { scan-assembler-times "vpkuhus"  2 } } */
+/* { dg-final { scan-assembler-times "vpkshss"  1 } } */
+/* { dg-final { scan-assembler-times "vpkshus"  1 } } */
+/* { dg-final { scan-assembler-times "vpksdus"  1 } } */
+/* { dg-final { scan-assembler-times "vpkuwus"  2 } } */
Index: gcc/testsuite/gcc.target/powerpc/vsx-vector-6.h
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,167 @@
+/* This test code is included into vsx-vector-6-be.c and vsx-vector-6-le.c.  
+   The two files have the tests for the number of instructions generated for
+   LE versus BE.  */
+
+#include <altivec.h>
+
+void foo (vector double *out, vector double *in, vector long *p_l, vector bool long *p_b,
+	  vector unsigned char *p_uc, int *i, vector float *p_f,
+	  vector bool char *outbc, vector bool int *outbi,
+	  vector bool short *outbsi, vector int *outsi,
+	  vector unsigned int *outui, vector signed char *outsc,
+	  vector unsigned char *outuc)
+{
+  vector double in0 = in[0];
+  vector double in1 = in[1];
+  vector double in2 = in[2];
+  vector long inl = *p_l;
+  vector bool long inb = *p_b;
+  vector bool long long inbl0;
+  vector bool long long inbl1;
+  vector unsigned char uc = *p_uc;
+  vector float inf0;
+  vector float inf1;
+  vector float inf2;
+  vector char inc0;
+  vector char inc1;
+  vector bool char inbc0;
+  vector bool char inbc1;
+  vector bool short inbs0;
+  vector bool short inbs1;
+  vector bool int inbi0;
+  vector bool int inbi1;
+  vector signed short int inssi0, inssi1;
+  vector unsigned short int inusi0, inusi1;
+  vector signed int insi0, insi1;
+  vector unsigned int inui0, inui1;
+  vector unsigned char inuc0, inuc1;
+  
+  *out++ = vec_abs (in0);
+  *out++ = vec_add (in0, in1);
+  *out++ = vec_and (in0, in1);
+  *out++ = vec_and (in0, inb);
+  *out++ = vec_and (inb, in0);
+  *out++ = vec_andc (in0, in1);
+  *out++ = vec_andc (in0, inb);
+  *out++ = vec_andc (inb, in0);
+  *out++ = vec_andc (inbl0, in0);
+  *out++ = vec_andc (in0, inbl0);
+
+  *out++ = vec_ceil (in0);
+  *p_b++ = vec_cmpeq (in0, in1);
+  *p_b++ = vec_cmpgt (in0, in1);
+  *p_b++ = vec_cmpge (in0, in1);
+  *p_b++ = vec_cmplt (in0, in1);
+  *p_b++ = vec_cmple (in0, in1);
+  *out++ = vec_div (in0, in1);
+  *out++ = vec_floor (in0);
+  *out++ = vec_madd (in0, in1, in2);
+  *out++ = vec_msub (in0, in1, in2);
+  *out++ = vec_max (in0, in1);
+  *out++ = vec_min (in0, in1);
+  *out++ = vec_msub (in0, in1, in2);
+  *out++ = vec_mul (in0, in1);
+  *out++ = vec_nearbyint (in0);
+  *out++ = vec_nmadd (in0, in1, in2);
+  *out++ = vec_nmsub (in0, in1, in2);
+  *out++ = vec_nor (in0, in1);
+  *out++ = vec_or (in0, in1);
+  *out++ = vec_or (in0, inb);
+  *out++ = vec_or (inb, in0);
+  *out++ = vec_perm (in0, in1, uc);
+  *out++ = vec_rint (in0);
+  *out++ = vec_sel (in0, in1, inl);
+  *out++ = vec_sel (in0, in1, inb);
+  *out++ = vec_sub (in0, in1);
+  *out++ = vec_sqrt (in0);
+  *out++ = vec_trunc (in0);
+  *out++ = vec_xor (in0, in1);
+  *out++ = vec_xor (in0, inb);
+  *out++ = vec_xor (inb, in0);
+
+  *i++ = vec_all_eq (in0, in1);
+  *i++ = vec_all_ge (in0, in1);
+  *i++ = vec_all_gt (in0, in1);
+  *i++ = vec_all_le (in0, in1);
+  *i++ = vec_all_lt (in0, in1);
+  *i++ = vec_all_nan (in0);
+  *i++ = vec_all_ne (in0, in1);
+  *i++ = vec_all_nge (in0, in1);
+  *i++ = vec_all_ngt (in0, in1);
+  *i++ = vec_all_nle (in0, in1);
+  *i++ = vec_all_nlt (in0, in1);
+  *i++ = vec_all_numeric (in0);
+  *i++ = vec_any_eq (in0, in1);
+  *i++ = vec_any_ge (in0, in1);
+  *i++ = vec_any_gt (in0, in1);
+  *i++ = vec_any_le (in0, in1);
+  *i++ = vec_any_lt (in0, in1);
+  *i++ = vec_any_nan (in0);
+  *i++ = vec_any_ne (in0, in1);
+  *i++ = vec_any_nge (in0, in1);
+  *i++ = vec_any_ngt (in0, in1);
+  *i++ = vec_any_nle (in0, in1);
+  *i++ = vec_any_nlt (in0, in1);
+  *i++ = vec_any_numeric (in0);
+
+  *p_f++ = vec_msub (inf0, inf1, inf2);
+  *p_f++ = vec_nmsub (inf0, inf1, inf2);
+  *p_f++ = vec_nmadd (inf0, inf1, inf2);
+  *p_f++ = vec_or (inf0, inf1);
+  *p_f++ = vec_trunc (inf0);
+  
+  *out++ = vec_or (inbl0, in0);
+  *out++ = vec_or (in0, inbl0);
+
+  *out++ = vec_nor (in0, in1);
+
+  *outbc++ = vec_nor (inbc0, inbc1);
+  *outbc++ = vec_andc (inbc0, inbc1);
+  *outbc++ = vec_or (inbc0, inbc1);
+
+  *outuc++ = vec_max (inuc0, inuc1);
+
+  *outbi++ = vec_andc (inbi0, inbi1);
+  *outbsi++ = vec_andc (inbs0, inbs1);
+
+  *outbsi++ = vec_andc (inbs0, inbs1);
+
+  *outbi++ = vec_nor (inbi0, inbi1);
+  *outbi++ = vec_or (inbi0, inbi1);
+
+  *outbsi++ = vec_nor (inbs0, inbs1);
+  *outbsi++ = vec_or (inbs0, inbs1);
+
+  *outsi++ = vec_msums(inssi0, inssi1, insi0);
+  *outui++ = vec_msums(inusi0, inusi1, inui0);
+
+  *p_f++ = vec_nor (inf0, inf1);
+
+  *p_f++ = vec_andc (inf0, inf1);
+  *p_f++ = vec_andc (inbi0, inf0);
+  *p_f++ = vec_andc (inf0, inbi0);
+
+  *in++ = vec_andc (inbl0, in1);
+  *in++ = vec_andc (in0, inbl1);
+}
+
+int main()
+{
+  vector double *out;
+  vector double *in;
+  vector long *p_l;
+  vector bool long *p_b;
+  vector unsigned char *p_uc;
+  int *i;
+  vector float *p_f;
+  vector bool char *outbc;
+  vector bool int *outbi;
+  vector bool short *outbsi;
+  vector int *outsi;
+  vector unsigned int *outui;
+  vector signed char *outsc;
+  vector unsigned char *outuc;
+
+  foo (out, in, p_l, p_b, p_uc, i, p_f, outbc,
+       outbi, outbsi, outsi, outui, outsc, outuc);
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-19d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19d.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19d.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,122 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+#define CONST2		(3 * 31415926539LL)
+#define CONST3		(4 * 31415926539LL)
+#define CONST4		(5 * 31415926539LL)
+#define CONST5		(6 * 31415926539LL)
+#define CONST6		(7 * 31415926539LL)
+#define CONST7		(8 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned long long int
+e0 (vector unsigned long long int v, unsigned long long int x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector unsigned long long int
+e3 (vector unsigned long long int v, unsigned long long int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned long long int
+me0 (vector unsigned long long int *vp, unsigned long long int x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector unsigned long long int
+me3 (vector unsigned long long int *vp, unsigned long long int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned long long int
+ei (vector unsigned long long int v, int i, unsigned long long int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned long long int
+mei (vector unsigned long long int *vp, int i, unsigned long long int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned long long int dv = { CONST0, CONST1 };
+  unsigned long long int d;
+
+  dv = e0 (dv, CONST7);
+  if (dv [0] != CONST7)
+    abort ();
+
+  dv = e3 (dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = me0 (&dv, CONST4);
+  if (dv [0] != CONST4)
+    abort ();
+
+  dv = me3 (&dv, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = ei (dv, 0, CONST5);
+  if (dv [0] != CONST5)
+    abort ();
+
+  dv = ei (dv, 1, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = ei (dv, 2, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 3, CONST6);
+  if (dv [1] != CONST6)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 3, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-10b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+short s3 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 3);
+}
+
+short s7 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 7);
+}
+
+short s21 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 21);
+}
+
+short s30 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+short ms3 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 3);
+}
+
+short ms7 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 7);
+}
+
+short ms21 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 21);
+}
+
+short ms30 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+short ci (vector short v, int i)
+{
+  return __builtin_vec_ext_v8hi (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+short mci (vector short *vp, int i)
+{
+  return __builtin_vec_ext_v8hi (*vp, i);
+}
+
+
+int main (int argc, short *argv[]) {
+  vector short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  short s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s7 (sv);
+  if (s != CONST7)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST5)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms7 (&sv);
+  if (s != CONST7)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST5)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST7)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-11a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+int s3 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 3);
+}
+
+int s1 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 1);
+}
+
+int s21 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 21);
+}
+
+int s30 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+int ms3 (vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 3);
+}
+
+int ms1(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 1);
+}
+
+int ms21(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 21);
+}
+
+int ms30(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+int ci (vector int v, int i)
+{
+  return __builtin_vec_ext_v4si (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+int mci(vector int *vp, int i)
+{
+  return __builtin_vec_ext_v4si (*vp, i);
+}
+
+
+int main (int argc, int *argv[]) {
+  vector int sv = { CONST0, CONST1, CONST2, CONST3 };
+  int s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s1 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms1 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST3)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-9a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,164 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+signed char c0 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 0);
+}
+
+signed char c9 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 9);
+}
+
+signed char c21 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 21);
+}
+
+signed char c30 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+signed char mc0 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 0);
+}
+
+signed char mc9 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 9);
+}
+
+signed char mc21 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 21);
+}
+
+signed char mc30 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+signed char ci (vector signed char v, int i)
+{
+  return __builtin_vec_ext_v16qi (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+signed char mci(vector signed char *vp, int i) {
+  return __builtin_vec_ext_v16qi (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector signed char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  signed char c;
+
+  c = c0 (cv);
+  if (c != CONST0)
+    abort ();
+
+  c = c9 (cv);
+  if (c != CONST9)
+    abort ();
+
+  c = c21 (cv);
+  if (c != CONST5)
+    abort ();
+
+  c = c30 (cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = mc0 (&cv);
+  if (c != CONST0)
+    abort ();
+
+  c = mc9 (&cv);
+  if (c != CONST9)
+    abort ();
+
+  c = mc21 (&cv);
+  if (c != CONST5)
+    abort ();
+
+  c = mc30 (&cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = ci (cv, 8);
+  if (c != CONST8)
+    abort ();
+
+  c = ci (cv, 13);
+  if (c != CONSTD)
+    abort ();
+
+  c = ci (cv, 23);
+  if (c != CONST7)
+    abort ();
+
+  c = ci (cv, 31);
+  if (c != CONSTF)
+    abort ();
+
+  c = mci (&cv, 5);
+  if (c != CONST5)
+    abort ();
+
+  c = mci (&cv, 12);
+  if (c != CONSTC)
+    abort ();
+
+  c = mci (&cv, 25);
+  if (c != CONST9)
+    abort ();
+
+  c = mci (&cv, 16);
+  if (c != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-20a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+/* Define this after PR89424 is addressed.  */
+#define PR89424
+
+extern void abort (void);
+
+#define CONST0		(((unsigned __int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned __int128 e0 (vector unsigned __int128 v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned __int128 e3 (vector unsigned __int128 v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+unsigned __int128 me0 (vector unsigned __int128 *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned __int128 me3 (vector unsigned __int128 *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+#ifdef PR89424
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned __int128 ei (vector unsigned __int128 v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+unsigned __int128 mei (vector unsigned __int128 *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+#endif
+
+int main (int argc, char *argv[]) {
+  vector unsigned __int128 dv = { CONST0 };
+  unsigned __int128 d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST0)
+    abort ();
+
+#ifdef PR89424
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+#endif
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-10c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10c.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector short s3 (vector short v, short x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector short s7 (vector short v, short x)
+{
+  return vec_insert (x, v, 7);
+}
+
+vector short s21 (vector short v, short x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector short s30 (vector short v, short x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector short ms3 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector short ms7 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 7);
+}
+
+vector short ms21 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector short ms30 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector short ci (vector short v, int i, short x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector short mci (vector short *vp, int i, short x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, short *argv[]) {
+  vector short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  short s;
+
+  sv = s3 (sv, CONST6);
+  if (sv [3] != CONST6)
+    abort ();
+
+  sv = s7 (sv, CONST4);
+  if (sv [7] != CONST4)
+    abort ();
+
+  sv = s21 (sv, CONST3);
+  if (sv [5] != CONST3)
+    abort ();
+
+  sv = s30 (sv, CONST2);
+  if (sv [6] != CONST2)
+    abort ();
+
+  sv = ms3 (&sv, CONST5);
+  if (sv [3] != CONST5)
+    abort ();
+
+  sv = ms7 (&sv, CONST1);
+  if (sv [7] != CONST1)
+    abort ();
+
+  sv = ms21 (&sv, CONST2);
+  if (sv [5] != CONST2)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [6] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST6);
+  if (sv [5] != CONST6)
+    abort ();
+
+  sv = ci (sv, 2, CONST4);
+  if (sv [2] != CONST4)
+    abort ();
+
+  sv = ci (sv, 15, CONST3);
+  if (sv [7] != CONST3)
+    abort ();
+
+  sv = ci (sv, 28, CONST3);
+  if (sv [4] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 5, CONST3);
+  if (sv [5] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 12, CONST7);
+  if (sv [4] != CONST7)
+    abort ();
+
+  sv = mci (&sv, 25, CONST6);
+  if (sv [1] != CONST6)
+    abort ();
+
+  sv = mci (&sv, 16, CONST5);
+  if (sv [0] != CONST5)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/altivec_vld_vst_addr-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/altivec_vld_vst_addr-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/altivec_vld_vst_addr-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,184 @@
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-maltivec" } */
+
+/* Test vec_ld and vec_st can support both scalar and vector
+   type address points, the list is:
+     - address of unsigned char/short/int
+     - address of signed char/short/int
+     - address of float
+     - address of vector unsigned char/short/int
+     - address of vector signed char/short/int
+     - address of vector float */
+#include <altivec.h>
+
+/* Test vec_ld can allow scalar and vector type address. */
+vector unsigned char
+test_vld_scalar_uc (const unsigned char *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector unsigned short
+test_vld_scalar_us (const unsigned short *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector unsigned int
+test_vld_scalar_ui (const unsigned int *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector signed char
+test_vld_scalar_sc (const signed char *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector signed short
+test_vld_scalar_ss (const signed short *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector signed int
+test_vld_scalar_si (const signed int *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector float
+test_vld_scalar_f (const float *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector unsigned char
+test_vld_vector_uc (const vector unsigned char *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector unsigned short
+test_vld_vector_us (const vector unsigned short *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector unsigned int
+test_vld_vector_ui (const vector unsigned int *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector signed char
+test_vld_vector_sc (const vector signed char *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector signed short
+test_vld_vector_ss (const vector signed short *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector signed int
+test_vld_vector_si (const vector signed int *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector float
+test_vld_vector_f (const vector float *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+/* Test vec_st can allow scalar and vector type address. */
+
+void
+test_vst_scalar_uc (vector unsigned char v, unsigned char *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_scalar_us (vector unsigned short v, unsigned short *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_scalar_ui (vector unsigned int v, unsigned int *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_scalar_sc (vector signed char v, signed char *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_scalar_ss (vector signed short v, signed short *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_scalar_si (vector signed int v, signed int *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_scalar_f (vector float v, float *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_uc (vector unsigned char v, vector unsigned char *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_us (vector unsigned short v, vector unsigned short *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_ui (vector unsigned int v, vector unsigned int *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_sc (vector signed char v, vector signed char *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_ss (vector signed short v, vector signed short *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_si (vector signed int v, vector signed int *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_f (vector float v, vector float *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
Index: gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c	(.../branches/gcc-7-branch)
@@ -4,6 +4,7 @@
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
 /* { dg-options "-mcpu=power8 -O2 -ftree-vectorize -fvect-cost-model=dynamic -fno-unroll-loops -fno-unroll-all-loops" } */
 
+#include <altivec.h>
 typedef vector unsigned long long	crypto_t;
 typedef vector unsigned long long	v2di_t;
 typedef vector unsigned int		v4si_t;
@@ -10,31 +11,56 @@
 typedef vector unsigned short		v8hi_t;
 typedef vector unsigned char		v16qi_t;
 
-crypto_t crpyto1 (crypto_t a)
+crypto_t crypto1 (crypto_t a)
 {
   return __builtin_crypto_vsbox (a);
 }
 
+v16qi_t crypto1_be (v16qi_t a)
+{
+  return vec_sbox_be (a);
+}
+
 crypto_t crypto2 (crypto_t a, crypto_t b)
 {
   return __builtin_crypto_vcipher (a, b);
 }
 
+v16qi_t crypto2_be (v16qi_t a, v16qi_t b)
+{
+  return vec_cipher_be (a, b);
+}
+
 crypto_t crypto3 (crypto_t a, crypto_t b)
 {
   return __builtin_crypto_vcipherlast (a, b);
 }
 
+v16qi_t crypto3_be (v16qi_t a, v16qi_t b)
+{
+  return vec_cipherlast_be (a, b);
+}
+
 crypto_t crypto4 (crypto_t a, crypto_t b)
 {
   return __builtin_crypto_vncipher (a, b);
 }
 
+v16qi_t crypto4_be (v16qi_t a, v16qi_t b)
+{
+  return vec_ncipher_be (a, b);
+}
+
 crypto_t crypto5 (crypto_t a, crypto_t b)
 {
   return __builtin_crypto_vncipherlast (a, b);
 }
 
+v16qi_t crypto5_be (v16qi_t a, v16qi_t b)
+{
+  return vec_ncipherlast_be (a, b);
+}
+
 v16qi_t crypto6a (v16qi_t a, v16qi_t b, v16qi_t c)
 {
   return __builtin_crypto_vpermxor (a, b, c);
@@ -117,15 +143,15 @@
 
 /* Note space is used after the instruction so that vcipherlast does not match
    vcipher.  */
-/* { dg-final { scan-assembler-times "vcipher "      1 } } */
-/* { dg-final { scan-assembler-times "vcipherlast "  1 } } */
-/* { dg-final { scan-assembler-times "vncipher "     1 } } */
-/* { dg-final { scan-assembler-times "vncipherlast " 1 } } */
+/* { dg-final { scan-assembler-times "vcipher "      2 } } */
+/* { dg-final { scan-assembler-times "vcipherlast "  2 } } */
+/* { dg-final { scan-assembler-times "vncipher "     2 } } */
+/* { dg-final { scan-assembler-times "vncipherlast " 2 } } */
 /* { dg-final { scan-assembler-times "vpermxor "     4 } } */
 /* { dg-final { scan-assembler-times "vpmsumb "      2 } } */
 /* { dg-final { scan-assembler-times "vpmsumd "      2 } } */
 /* { dg-final { scan-assembler-times "vpmsumh "      2 } } */
 /* { dg-final { scan-assembler-times "vpmsumw "      2 } } */
-/* { dg-final { scan-assembler-times "vsbox "        1 } } */
+/* { dg-final { scan-assembler-times "vsbox "        2 } } */
 /* { dg-final { scan-assembler-times "vshasigmad "   2 } } */
 /* { dg-final { scan-assembler-times "vshasigmaw "   2 } } */
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-11b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+int s3 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 3);
+}
+
+int s1 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 1);
+}
+
+int s21 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 21);
+}
+
+int s30 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+int ms3 (vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 3);
+}
+
+int ms1(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 1);
+}
+
+int ms21(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 21);
+}
+
+int ms30(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+int ci (vector int v, int i)
+{
+  return __builtin_vec_ext_v4si (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+int mci(vector int *vp, int i)
+{
+  return __builtin_vec_ext_v4si (*vp, i);
+}
+
+
+int main (int argc, int *argv[]) {
+  vector int sv = { CONST0, CONST1, CONST2, CONST3 };
+  int s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s1 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms1 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST3)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-uint128-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-uint128-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-uint128-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,27 @@
+/* Test to verify that the vec_extract from a vector of
+   unsigned __int128s remains unsigned.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(unsigned __int128 ul) {
+
+  vector unsigned __int128 v = vec_splats(ul);
+
+  if (vec_extract (v, 0) < ul)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (((__int128) 0xf600000000000000LL) << 64);
+  test1 (((__int128) 0x7600000000000000LL) << 64);
+  test1 (((__int128) 0x0600000000000000LL) << 64);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-9b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,164 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+signed char c0 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 0);
+}
+
+signed char c9 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 9);
+}
+
+signed char c21 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 21);
+}
+
+signed char c30 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+signed char mc0 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 0);
+}
+
+signed char mc9 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 9);
+}
+
+signed char mc21 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 21);
+}
+
+signed char mc30 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+signed char ci (vector signed char v, int i)
+{
+  return __builtin_vec_ext_v16qi (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+signed char mci(vector signed char *vp, int i) {
+  return __builtin_vec_ext_v16qi (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector signed char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  signed char c;
+
+  c = c0 (cv);
+  if (c != CONST0)
+    abort ();
+
+  c = c9 (cv);
+  if (c != CONST9)
+    abort ();
+
+  c = c21 (cv);
+  if (c != CONST5)
+    abort ();
+
+  c = c30 (cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = mc0 (&cv);
+  if (c != CONST0)
+    abort ();
+
+  c = mc9 (&cv);
+  if (c != CONST9)
+    abort ();
+
+  c = mc21 (&cv);
+  if (c != CONST5)
+    abort ();
+
+  c = mc30 (&cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = ci (cv, 8);
+  if (c != CONST8)
+    abort ();
+
+  c = ci (cv, 13);
+  if (c != CONSTD)
+    abort ();
+
+  c = ci (cv, 23);
+  if (c != CONST7)
+    abort ();
+
+  c = ci (cv, 31);
+  if (c != CONSTF)
+    abort ();
+
+  c = mci (&cv, 5);
+  if (c != CONST5)
+    abort ();
+
+  c = mci (&cv, 12);
+  if (c != CONSTC)
+    abort ();
+
+  c = mci (&cv, 25);
+  if (c != CONST9)
+    abort ();
+
+  c = mci (&cv, 16);
+  if (c != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-20b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+/* Define this after PR89424 is addressed.  */
+#define PR89424
+
+extern void abort (void);
+
+#define CONST0		(((unsigned __int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned __int128 e0 (vector unsigned __int128 v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned __int128 e3 (vector unsigned __int128 v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+unsigned __int128 me0 (vector unsigned __int128 *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned __int128 me3 (vector unsigned __int128 *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+#ifdef PR89424
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned __int128 ei (vector unsigned __int128 v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+unsigned __int128 mei (vector unsigned __int128 *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+#endif
+
+int main (int argc, char *argv[]) {
+  vector unsigned __int128 dv = { CONST0 };
+  unsigned __int128 d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST0)
+    abort ();
+
+#ifdef PR89424
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+#endif
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-12a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,109 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+long long int e0 (vector long long int v)
+{
+  return __builtin_vec_ext_v2di (v, 0);
+}
+
+long long int e3 (vector long long int v)
+{
+  return __builtin_vec_ext_v2di (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+long long int me0 (vector long long int *vp)
+{
+  return __builtin_vec_ext_v2di (*vp, 0);
+}
+
+long long int me3 (vector long long int *vp)
+{
+  return __builtin_vec_ext_v2di (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+long long int ei (vector long long int v, int i)
+{
+  return __builtin_vec_ext_v2di (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+long long int mei (vector long long int *vp, int i)
+{
+  return __builtin_vec_ext_v2di (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector long long int dv = { CONST0, CONST1 };
+  long long int d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-10d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10d.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10d.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector short s3 (vector short v, short x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector short s7 (vector short v, short x)
+{
+  return vec_insert (x, v, 7);
+}
+
+vector short s21 (vector short v, short x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector short s30 (vector short v, short x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector short ms3 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector short ms7 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 7);
+}
+
+vector short ms21 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector short ms30 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector short ci (vector short v, int i, short x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector short mci (vector short *vp, int i, short x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, short *argv[]) {
+  vector short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  short s;
+
+  sv = s3 (sv, CONST6);
+  if (sv [3] != CONST6)
+    abort ();
+
+  sv = s7 (sv, CONST4);
+  if (sv [7] != CONST4)
+    abort ();
+
+  sv = s21 (sv, CONST3);
+  if (sv [5] != CONST3)
+    abort ();
+
+  sv = s30 (sv, CONST2);
+  if (sv [6] != CONST2)
+    abort ();
+
+  sv = ms3 (&sv, CONST5);
+  if (sv [3] != CONST5)
+    abort ();
+
+  sv = ms7 (&sv, CONST1);
+  if (sv [7] != CONST1)
+    abort ();
+
+  sv = ms21 (&sv, CONST2);
+  if (sv [5] != CONST2)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [6] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST6);
+  if (sv [5] != CONST6)
+    abort ();
+
+  sv = ci (sv, 2, CONST4);
+  if (sv [2] != CONST4)
+    abort ();
+
+  sv = ci (sv, 15, CONST3);
+  if (sv [7] != CONST3)
+    abort ();
+
+  sv = ci (sv, 28, CONST3);
+  if (sv [4] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 5, CONST3);
+  if (sv [5] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 12, CONST7);
+  if (sv [4] != CONST7)
+    abort ();
+
+  sv = mci (&sv, 25, CONST6);
+  if (sv [1] != CONST6)
+    abort ();
+
+  sv = mci (&sv, 16, CONST5);
+  if (sv [0] != CONST5)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/altivec_vld_vst_addr-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/altivec_vld_vst_addr-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/altivec_vld_vst_addr-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,92 @@
+/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-options "-mvsx" } */
+
+/* Note that vector long long and vector double type require vsx support. */
+
+/* Test vec_ld and vec_st can support both scalar and vector
+   type address points, the list is:
+     - address of unsigned long long
+     - address of signed long long
+     - address of double
+     - address of vector unsigned long long
+     - address of vector signed long long
+     - address of vector double */
+#include <altivec.h>
+
+/* Test vec_ld can allow scalar and vector type address. */
+
+vector unsigned long long
+test_vld_scalar_ul (const unsigned long long *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector signed long long
+test_vld_scalar_sl (const signed long long *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector double
+test_vld_scalar_d (const double *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector unsigned long long
+test_vld_vector_ul (const vector unsigned long long *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector signed long long
+test_vld_vector_sl (const vector signed long long *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector double
+test_vld_vector_d (const vector double *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+/* Test vec_st can allow scalar and vector type address. */
+
+void
+test_vst_scalar_ul (vector unsigned long long v, unsigned long long *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_scalar_sl (vector signed long long v, signed long long *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_scalar_d (vector double v, double *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_ul (vector unsigned long long v,
+		    vector unsigned long long *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_sl (vector signed long long v, vector signed long long *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_d (vector double v, vector double *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-slong-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-slong-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-slong-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,27 @@
+/* Test to verify that the vec_extract from a vector of
+   signed longs remains signed.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(signed long long int sl) {
+
+  vector signed long long int v = vec_splats(sl);
+
+  if (vec_extract (v, 0) > sl)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (0xf600000000000000LL);
+  test1 (0x7600000000000000LL);
+  test1 (0x0600000000000000LL);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-ushort-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-ushort-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-ushort-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,29 @@
+/* Test to verify that the vec_extract from a vector of
+   signed shorts remains signed.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(unsigned short us) {
+  int use;
+
+  vector unsigned short v = vec_splats(us);
+  use = vec_extract(v,0);
+
+  if (use != us)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (0xf600);
+  test1 (0x7600);
+  test1 (0x0600);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-11c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11c.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector int s3 (vector int v, int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector int s1 (vector int v, int x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector int s21 (vector int v, int x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector int s30 (vector int v, int x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector int ms3  (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector int ms1 (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector int ms21 (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector int ms30 (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector int ci (vector int v, int i, int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector int mci(vector int *vp, int i, int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, int *argv[]) {
+  vector int sv = { CONST0, CONST1, CONST2, CONST3 };
+  int s;
+
+  sv = s3 (sv, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = s1 (sv, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = s21 (sv, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = s30 (sv, CONST1);
+  if (sv [2] != CONST1)
+    abort ();
+
+  sv = ms3 (&sv, CONST2);
+  if (sv [3] != CONST2)
+    abort ();
+
+  sv = ms1 (&sv, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = ms21 (&sv, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [2] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = ci (sv, 2, CONST3);
+  if (sv [2] != CONST3)
+    abort ();
+
+  sv = ci (sv, 15, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = ci (sv, 28, CONST3);
+  if (sv [0] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 5, CONST2);
+  if (sv [1] != CONST2)
+    abort ();
+
+  sv = mci (&sv, 12, CONST1);
+  if (sv [0] != CONST1)
+    abort ();
+
+  sv = mci (&sv, 25, CONST2);
+  if (sv [1] != CONST2)
+    abort ();
+
+  sv = mci (&sv, 16, CONST3);
+  if (sv [0] != CONST3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/builtins-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/builtins-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/builtins-3.c	(.../branches/gcc-7-branch)
@@ -59,6 +59,170 @@
 	return vec_nabs (x);
 }
 
+vector signed char
+test_sll_vsc_vsc_vsuc (vector signed char x, vector unsigned char y)
+{
+	return vec_sll (x, y);
+}
+
+vector unsigned char
+test_sll_vuc_vuc_vuc (vector unsigned char x, vector unsigned char y)
+{
+	return vec_sll (x, y);
+}
+
+vector signed int
+test_sll_vsi_vsi_vuc (vector signed int x, vector unsigned char y)
+{
+	return vec_sll (x, y);
+}
+
+vector unsigned int
+test_sll_vui_vui_vuc (vector unsigned int x, vector unsigned char y)
+{
+	return vec_sll (x, y);
+}
+
+vector bool long long
+test_sll_vbll_vbll_vuc (vector bool long long x,
+			vector unsigned char y)
+{
+	return vec_sll (x, y);
+}
+
+vector bool long long
+test_sll_vbll_vbll_vull (vector bool long long x,
+			vector unsigned long long y)
+{
+	return vec_sll (x, y);
+}
+
+vector bool long long
+test_sll_vbll_vbll_vus (vector bool long long x,
+			vector unsigned short y)
+{
+	return vec_sll (x, y);
+}
+vector pixel
+test_sll_vp_vp_vuc (vector pixel x, vector unsigned char y)
+{
+	return vec_sll (x, y);
+}
+
+vector signed short int
+test_sll_vssi_vssi_vuc (vector signed short x, vector unsigned char y)
+{
+	return vec_sll (x, y);
+}
+
+vector unsigned short int
+test_sll_vusi_vusi_vuc (vector unsigned short x, vector unsigned char y)
+{
+	return vec_sll (x, y);
+}
+
+vector signed char
+test_slo_vsc_vsc_vsc (vector signed char x, vector signed char y)
+{
+	return vec_slo (x, y);
+}
+
+vector signed char
+test_slo_vsc_vsc_vuc (vector signed char x, vector unsigned char y)
+{
+	return vec_slo (x, y);
+}
+
+vector unsigned char
+test_slo_vuc_vuc_vsc (vector unsigned char x, vector signed char y)
+{
+	return vec_slo (x, y);
+}
+
+vector unsigned char
+test_slo_vuc_vuc_vuc (vector unsigned char x, vector unsigned char y)
+{
+	return vec_slo (x, y);
+}
+
+vector signed int
+test_slo_vsi_vsi_vsc (vector signed int x, vector signed char y)
+{
+	return vec_slo (x, y);
+}
+
+vector signed int
+test_slo_vsi_vsi_vuc (vector signed int x, vector unsigned char y)
+{
+	return vec_slo (x, y);
+}
+
+vector unsigned int
+test_slo_vui_vui_vsc (vector unsigned int x, vector signed char y)
+{
+	return vec_slo (x, y);
+}
+
+vector unsigned int
+test_slo_vui_vui_vuc (vector unsigned int x, vector unsigned char y)
+{
+	return vec_slo (x, y);
+}
+
+vector pixel
+test_slo_vp_vp_vsc (vector pixel int x, vector signed char y)
+{
+	return vec_slo (x, y);
+}
+
+vector pixel
+test_slo_vp_vp_vuc (vector pixel int x, vector unsigned char y)
+{
+	return vec_slo (x, y);
+}
+
+vector signed short int
+test_slo_vssi_vssi_vsc (vector signed short int x, vector signed char y)
+{
+	return vec_slo (x, y);
+}
+
+vector signed short int
+test_slo_vssi_vssi_vuc (vector signed short int x, vector unsigned char y)
+{
+	return vec_slo (x, y);
+}
+
+vector unsigned short int
+test_slo_vusi_vusi_vsc (vector unsigned short int x, vector signed char y)
+{
+	return vec_slo (x, y);
+}
+
+vector unsigned short int
+test_slo_vusi_vusi_vuc (vector unsigned short int x, vector unsigned char y)
+{
+	return vec_slo (x, y);
+}
+
+vector float
+test_slo_vf_vf_vsc (vector float x, vector signed char y)
+{
+	return vec_slo (x, y);
+}
+
+vector float
+test_slo_vf_vf_vuc (vector float x, vector unsigned char y)
+ {
+ 	return vec_slo (x, y);
+ }
+
+vector int
+test_cmpb_float (vector float x, vector float y)
+{
+	return vec_cmpb (x, y);
+}
+
 /* Expected test results:
 
      test_eq_char              1 vcmpequb inst
@@ -69,7 +233,8 @@
      test_nabs_short           1 vspltisw, 1 vsubuhm, 1 vminsh
      test_nabs_int             1 vspltisw, 1 vsubuwm, 1 vminsw
      test_nabs_float           1 xvnabssp
-     test_nabs_double          1 xvnabsdp */
+     test_nabs_double          1 xvnabsdp
+     test_cmpb_float           1 vcmpbfp */
 
 /* { dg-final { scan-assembler-times "vcmpequb" 1 } } */
 /* { dg-final { scan-assembler-times "vcmpequh" 1 } } */
@@ -84,4 +249,5 @@
 /* { dg-final { scan-assembler-times "vspltisw" 3 } } */
 /* { dg-final { scan-assembler-times "xvnabssp" 1 } } */
 /* { dg-final { scan-assembler-times "xvnabsdp" 1 } } */
+/* { dg-final { scan-assembler-times "vcmpbfp"  1 } } */
 
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-9c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9c.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,164 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector signed char c0 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector signed char c9 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 9);
+}
+
+vector signed char c21 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector signed char c30 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector signed char mc0 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector signed char mc9 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 9);
+}
+
+vector signed char mc21 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector signed char mc30 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector signed char ci (vector signed char v, int i, signed char x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector signed char mci(vector signed char *vp, int i, signed char x) {
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector signed char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  signed char c;
+
+  cv = c0 (cv, CONSTF);
+  if (cv [0] != CONSTF)
+    abort ();
+
+  cv = c9 (cv, CONST7);
+  if (cv [9] != CONST7)
+    abort ();
+
+  cv = c21 (cv, CONSTA);
+  if (cv [5] != CONSTA)
+    abort ();
+
+  cv = c30 (cv, CONSTC);
+  if (cv [14] != CONSTC)
+    abort ();
+
+  cv = mc0 (&cv, CONSTB);
+  if (cv [0] != CONSTB)
+    abort ();
+
+  cv = mc9 (&cv, CONST1);
+  if (cv [9] != CONST1)
+    abort ();
+
+  cv = mc21 (&cv, CONST7);
+  if (cv [5] != CONST7)
+    abort ();
+
+  cv = mc30 (&cv, CONST2);
+  if (cv [14] != CONST2)
+    abort ();
+
+  cv = ci (cv, 8, CONST4);
+  if (cv [8] != CONST4)
+    abort ();
+
+  cv = ci (cv, 13, CONSTB);
+  if (cv [13] != CONSTB)
+    abort ();
+
+  cv = ci (cv, 23, CONST3);
+  if (cv [7] != CONST3)
+    abort ();
+
+  cv = ci (cv, 31, CONST2);
+  if (cv [15] != CONST2)
+    abort ();
+
+  cv = mci (&cv, 5, CONST1);
+  if (cv [5] != CONST1)
+    abort ();
+
+  cv = mci (&cv, 12, CONST3);
+  if (cv [12] != CONST3)
+    abort ();
+
+  cv = mci (&cv, 25, CONST5);
+  if (cv [9] != CONST5)
+    abort ();
+
+  cv = mci (&cv, 16, CONSTD);
+  if (cv [0] != CONSTD)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-uint-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-uint-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-uint-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,29 @@
+/* Test to verify that the vec_extract from a vector of
+   unsigned ints remains unsigned.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(unsigned int ui) {
+  long long int uie;
+
+  vector unsigned int v = vec_splats(ui);
+  uie = vec_extract(v,0);
+
+  if (uie != ui)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (0xf6000000);
+  test1 (0x76000000);
+  test1 (0x06000000);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-20c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20c.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(((unsigned __int128) 31415926539) << 60)
+#define CONST1		(((unsigned __int128) 31415926539) << 54)
+#define CONST2		(((unsigned __int128) 31415926539) << 48)
+#define CONST3		(((unsigned __int128) 31415926539) << 32)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned __int128 e0 (vector unsigned __int128 v, unsigned __int128 x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector unsigned __int128 e3 (vector unsigned __int128 v, unsigned __int128 x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned __int128
+me0 (vector unsigned __int128 *vp, unsigned __int128 x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector unsigned __int128
+me3 (vector unsigned __int128 *vp, unsigned __int128 x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned __int128
+ei (vector unsigned __int128 v, int i, unsigned __int128 x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned __int128
+mei (vector unsigned __int128 *vp, int i, unsigned __int128 x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned __int128 dv = { CONST0 };
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e3 (dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me0 (&dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me3 (&dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 0, CONST0);
+  if (dv [0] != CONST0)
+    abort ();
+
+  dv = ei (dv, 1, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 2, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = ei (dv, 3, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 0, CONST0);
+  if (dv [0] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 1, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 2, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 3, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-12b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,109 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+long long int e0 (vector long long int v)
+{
+  return __builtin_vec_ext_v2di (v, 0);
+}
+
+long long int e3 (vector long long int v)
+{
+  return __builtin_vec_ext_v2di (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+long long int me0 (vector long long int *vp)
+{
+  return __builtin_vec_ext_v2di (*vp, 0);
+}
+
+long long int me3 (vector long long int *vp)
+{
+  return __builtin_vec_ext_v2di (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+long long int ei (vector long long int v, int i)
+{
+  return __builtin_vec_ext_v2di (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+long long int mei (vector long long int *vp, int i)
+{
+  return __builtin_vec_ext_v2di (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector long long int dv = { CONST0, CONST1 };
+  long long int d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-schar-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-schar-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-schar-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,29 @@
+/* Test to verify that the vec_extract from a vector of
+   signed chars remains signed.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(signed char sc) {
+  int sce;
+
+  vector signed char v = vec_splats(sc);
+  sce = vec_extract(v,0);
+
+  if (sce != sc)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (0xf6);
+  test1 (0x76);
+  test1 (0x06);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-13a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,124 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+/* Define this after PR89424 is addressed.  */
+#define PR89424
+
+/* Define this after PR89626 is addressed.  */
+#undef PR89626
+
+#ifdef PR89626
+#define SIGNED
+#else
+#define SIGNED signed
+#endif
+
+extern void abort (void);
+
+#define CONST0		(((SIGNED __int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+SIGNED __int128 e0 (vector SIGNED __int128 v)
+{
+  return __builtin_vec_ext_v1ti (v, 0);
+}
+
+SIGNED __int128 e3 (vector SIGNED __int128 v)
+{
+  return __builtin_vec_ext_v1ti (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+SIGNED __int128 me0 (vector SIGNED __int128 *vp)
+{
+  return __builtin_vec_ext_v1ti (*vp, 0);
+}
+
+SIGNED __int128 me3 (vector SIGNED __int128 *vp)
+{
+  return __builtin_vec_ext_v1ti (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+#ifdef PR89424
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+SIGNED __int128 ei (vector SIGNED __int128 v, int i)
+{
+  return __builtin_vec_ext_v1ti (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+SIGNED __int128 mei (vector SIGNED __int128 *vp, int i)
+{
+  return __builtin_vec_ext_v1ti (*vp, i);
+}
+#endif
+
+int main (int argc, char *argv[]) {
+  vector SIGNED __int128 dv = { CONST0 };
+  SIGNED __int128 d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST0)
+    abort ();
+
+#ifdef PR89424
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+#endif
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-11d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11d.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11d.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector int s3 (vector int v, int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector int s1 (vector int v, int x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector int s21 (vector int v, int x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector int s30 (vector int v, int x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector int ms3  (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector int ms1 (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector int ms21 (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector int ms30 (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector int ci (vector int v, int i, int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector int mci(vector int *vp, int i, int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, int *argv[]) {
+  vector int sv = { CONST0, CONST1, CONST2, CONST3 };
+  int s;
+
+  sv = s3 (sv, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = s1 (sv, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = s21 (sv, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = s30 (sv, CONST1);
+  if (sv [2] != CONST1)
+    abort ();
+
+  sv = ms3 (&sv, CONST2);
+  if (sv [3] != CONST2)
+    abort ();
+
+  sv = ms1 (&sv, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = ms21 (&sv, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [2] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = ci (sv, 2, CONST3);
+  if (sv [2] != CONST3)
+    abort ();
+
+  sv = ci (sv, 15, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = ci (sv, 28, CONST3);
+  if (sv [0] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 5, CONST2);
+  if (sv [1] != CONST2)
+    abort ();
+
+  sv = mci (&sv, 12, CONST1);
+  if (sv [0] != CONST1)
+    abort ();
+
+  sv = mci (&sv, 25, CONST2);
+  if (sv [1] != CONST2)
+    abort ();
+
+  sv = mci (&sv, 16, CONST3);
+  if (sv [0] != CONST3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p7.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p7.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,42 @@
+/* { dg-do compile { target { lp64 && be } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-options "-mvsx -O2 -mcpu=power7 -dp" } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
+
+/* Expected instruction counts for Power 7 */
+
+/* { dg-final { scan-assembler-times "xvabsdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvadddp" 1 } } */
+/* { dg-final { scan-assembler-times "xxlnor" 5 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpeqdp\s} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpeqdp\.\s} 5 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgtdp\s} 2 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgtdp\.\s} 5 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgedp\s} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgedp\.\s} 6 } } */
+/* { dg-final { scan-assembler-times "xvrdpim" 1 } } */
+/* { dg-final { scan-assembler-times "xvmaddadp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmsubadp" 1 } } */
+/* { dg-final { scan-assembler-times "xvsubdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmaxdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmindp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmuldp" 1 } } */
+/* { dg-final { scan-assembler-times "vperm" 2 } } */
+/* { dg-final { scan-assembler-times "xvrdpic" 2 } } */
+/* { dg-final { scan-assembler-times "xvsqrtdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvrdpiz" 1 } } */
+/* { dg-final { scan-assembler-times "xvmsubasp" 1 } } */
+/* { dg-final { scan-assembler-times "xvnmaddasp" 1 } } */
+/* { dg-final { scan-assembler-times "xvnmaddadp" 1 } } */
+/* { dg-final { scan-assembler-times "xvnmsubadp" 1 } } */
+/* { dg-final { scan-assembler-times "vmsumshs" 2 } } */
+/* { dg-final { scan-assembler-times "xxland" 13 } } */
+/* { dg-final { scan-assembler-times "xxlxor" 2 } } */
+/* { dg-final { scan-assembler-times "xxsel" 4 } } */
+/* { dg-final { scan-assembler-times "xvrdpip" 1 } } */
+/* { dg-final { scan-assembler-times "xvdivdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvrdpi" 7 } } */
+
+/* Source code for the test in vsx-vector-6.h */
+#include "vsx-vector-6.h"
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-9d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9d.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9d.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,164 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector signed char c0 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector signed char c9 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 9);
+}
+
+vector signed char c21 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector signed char c30 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector signed char mc0 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector signed char mc9 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 9);
+}
+
+vector signed char mc21 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector signed char mc30 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector signed char ci (vector signed char v, int i, signed char x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector signed char mci(vector signed char *vp, int i, signed char x) {
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector signed char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  signed char c;
+
+  cv = c0 (cv, CONSTF);
+  if (cv [0] != CONSTF)
+    abort ();
+
+  cv = c9 (cv, CONST7);
+  if (cv [9] != CONST7)
+    abort ();
+
+  cv = c21 (cv, CONSTA);
+  if (cv [5] != CONSTA)
+    abort ();
+
+  cv = c30 (cv, CONSTC);
+  if (cv [14] != CONSTC)
+    abort ();
+
+  cv = mc0 (&cv, CONSTB);
+  if (cv [0] != CONSTB)
+    abort ();
+
+  cv = mc9 (&cv, CONST1);
+  if (cv [9] != CONST1)
+    abort ();
+
+  cv = mc21 (&cv, CONST7);
+  if (cv [5] != CONST7)
+    abort ();
+
+  cv = mc30 (&cv, CONST2);
+  if (cv [14] != CONST2)
+    abort ();
+
+  cv = ci (cv, 8, CONST4);
+  if (cv [8] != CONST4)
+    abort ();
+
+  cv = ci (cv, 13, CONSTB);
+  if (cv [13] != CONSTB)
+    abort ();
+
+  cv = ci (cv, 23, CONST3);
+  if (cv [7] != CONST3)
+    abort ();
+
+  cv = ci (cv, 31, CONST2);
+  if (cv [15] != CONST2)
+    abort ();
+
+  cv = mci (&cv, 5, CONST1);
+  if (cv [5] != CONST1)
+    abort ();
+
+  cv = mci (&cv, 12, CONST3);
+  if (cv [12] != CONST3)
+    abort ();
+
+  cv = mci (&cv, 25, CONST5);
+  if (cv [9] != CONST5)
+    abort ();
+
+  cv = mci (&cv, 16, CONSTD);
+  if (cv [0] != CONSTD)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-20d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20d.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20d.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(((unsigned __int128) 31415926539) << 60)
+#define CONST1		(((unsigned __int128) 31415926539) << 54)
+#define CONST2		(((unsigned __int128) 31415926539) << 48)
+#define CONST3		(((unsigned __int128) 31415926539) << 32)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned __int128 e0 (vector unsigned __int128 v, unsigned __int128 x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector unsigned __int128 e3 (vector unsigned __int128 v, unsigned __int128 x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned __int128
+me0 (vector unsigned __int128 *vp, unsigned __int128 x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector unsigned __int128
+me3 (vector unsigned __int128 *vp, unsigned __int128 x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned __int128
+ei (vector unsigned __int128 v, int i, unsigned __int128 x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned __int128
+mei (vector unsigned __int128 *vp, int i, unsigned __int128 x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned __int128 dv = { CONST0 };
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e3 (dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me0 (&dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me3 (&dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 0, CONST0);
+  if (dv [0] != CONST0)
+    abort ();
+
+  dv = ei (dv, 1, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 2, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = ei (dv, 3, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 0, CONST0);
+  if (dv [0] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 1, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 2, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 3, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-12c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12c.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,112 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+#define CONST2		(3 * 31415926539LL)
+#define CONST3		(4 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector long long int e0 (vector long long int v, long long int x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector long long int e3 (vector long long int v, long long int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector long long int me0 (vector long long int *vp, long long int x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector long long int me3 (vector long long int *vp, long long int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector long long int ei (vector long long int v, int i, long long int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector long long int mei (vector long long int *vp, int i, long long int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector long long int dv = { CONST0, CONST1 };
+  long long int d;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e3 (dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = me0 (&dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me3 (&dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = ei (dv, 0, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 1, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = ei (dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 3, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 3, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-13b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,124 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+/* Define this after PR89424 is addressed.  */
+#define PR89424
+
+/* Define this after PR89626 is addressed.  */
+#undef PR89626
+
+#ifdef PR89626
+#define SIGNED
+#else
+#define SIGNED signed
+#endif
+
+extern void abort (void);
+
+#define CONST0		(((SIGNED __int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+SIGNED __int128 e0 (vector SIGNED __int128 v)
+{
+  return __builtin_vec_ext_v1ti (v, 0);
+}
+
+SIGNED __int128 e3 (vector SIGNED __int128 v)
+{
+  return __builtin_vec_ext_v1ti (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+SIGNED __int128 me0 (vector SIGNED __int128 *vp)
+{
+  return __builtin_vec_ext_v1ti (*vp, 0);
+}
+
+SIGNED __int128 me3 (vector SIGNED __int128 *vp)
+{
+  return __builtin_vec_ext_v1ti (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+#ifdef PR89424
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+SIGNED __int128 ei (vector SIGNED __int128 v, int i)
+{
+  return __builtin_vec_ext_v1ti (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+SIGNED __int128 mei (vector SIGNED __int128 *vp, int i)
+{
+  return __builtin_vec_ext_v1ti (*vp, i);
+}
+#endif
+
+int main (int argc, char *argv[]) {
+  vector SIGNED __int128 dv = { CONST0 };
+  SIGNED __int128 d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST0)
+    abort ();
+
+#ifdef PR89424
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+#endif
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p8.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p8.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p8.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,54 @@
+/* { dg-do compile { target lp64 } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-options "-mvsx -O2 -mcpu=power8" } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+/* Expected instruction counts for Power 8.  */
+
+/* { dg-final { scan-assembler-times "xvabsdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvadddp" 1 } } */
+/* { dg-final { scan-assembler-times "xxlnor" 6 { target le } } } */
+/* { dg-final { scan-assembler-times "xxlnor" 5 { target be } } } */
+
+/* We generate xxlor instructions for many reasons other than or'ing vector
+   operands or calling __builtin_vec_or(), which  means we cannot rely on
+   their usage counts being stable.  Therefore, we just ensure at least one
+   xxlor instruction was generated.  */
+/* { dg-final { scan-assembler "xxlor" } } */
+
+/* { dg-final { scan-assembler-times {\mxvcmpeqdp\s} 0 { target le } } } */
+/* { dg-final { scan-assembler-times {\mxvcmpeqdp\s} 1 { target be } } } */
+/* { dg-final { scan-assembler-times {\mxvcmpeqdp\.\s} 6 { target le } } } */
+/* { dg-final { scan-assembler-times {\mxvcmpeqdp\.\s} 5 { target be } } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgtdp\s} 2 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgtdp\.\s} 5 { target le } } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgtdp\.\s} 6 { target be } } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgedp\s} 2 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgedp\.\s} 4 } } */
+/* { dg-final { scan-assembler-times "xvrdpim" 1 } } */
+/* { dg-final { scan-assembler-times "xvmaddadp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmsubadp" 1 } } */
+/* { dg-final { scan-assembler-times "xvsubdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmaxdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmindp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmuldp" 1 } } */
+/* { dg-final { scan-assembler-times "vperm" 1 } } */
+/* { dg-final { scan-assembler-times "xvrdpic" 1 } } */
+/* { dg-final { scan-assembler-times "xvsqrtdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvrdpiz" 1 } } */
+/* { dg-final { scan-assembler-times "xvmsubasp" 1 } } */
+/* { dg-final { scan-assembler-times "xvnmaddasp" 1 } } */
+/* { dg-final { scan-assembler-times "xvnmaddadp" 1 } } */
+/* { dg-final { scan-assembler-times "xvnmsubadp" 1 } } */
+/* { dg-final { scan-assembler-times "vmsumshs" 1 } } */
+/* { dg-final { scan-assembler-times "xxland" 9 { target le } } } */
+/* { dg-final { scan-assembler-times "xxland" 13 { target be } } } */
+/* { dg-final { scan-assembler-times "xxlxor" 2 } } */
+/* { dg-final { scan-assembler-times "xxsel" 2 } } */
+/* { dg-final { scan-assembler-times "xvrdpip" 1 } } */
+/* { dg-final { scan-assembler-times "xvdivdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvrdpi" 5 } } */
+
+/* Source code for the test in vsx-vector-6.h */
+#include "vsx-vector-6.h"
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-14a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,126 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		((float) (3.1415926539))
+#define CONST1		((float) (3.1415926539 * 2))
+#define CONST2		((float) (3.1415926539 * 3))
+#define CONST3		((float) (3.1415926539 * 4))
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+float e0(vector float v){ return __builtin_vec_ext_v4sf (v, 0); }
+float e1(vector float v){ return __builtin_vec_ext_v4sf (v, 1); }
+float e7(vector float v){ return __builtin_vec_ext_v4sf (v, 7); }
+float e8(vector float v){ return __builtin_vec_ext_v4sf (v, 8); }
+
+/* Test for vector residing in memory.  */
+float me0(vector float *vp){ return __builtin_vec_ext_v4sf (*vp, 0); }
+float me1(vector float *vp){ return __builtin_vec_ext_v4sf (*vp, 1); }
+
+float me13(vector float *vp)
+{
+  return __builtin_vec_ext_v4sf (*vp, 13);
+}
+
+float me15(vector float *vp)
+{
+  return __builtin_vec_ext_v4sf (*vp, 15);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+float ei(vector float v, int i)
+{
+  return __builtin_vec_ext_v4sf (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+float mei(vector float *vp, int i)
+{
+  return __builtin_vec_ext_v4sf (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector float dv = { CONST0, CONST1, CONST2, CONST3 };
+  float d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e1 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = e7 (dv);
+  if (d != CONST3)
+    abort ();
+
+  d = e8 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me1 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me13 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me15 (&dv);
+  if (d != CONST3)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST2)
+    abort ();
+
+  d = ei (dv, 11);
+  if (d != CONST3)
+    abort ();
+
+  d = ei (dv, 17);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 15);
+  if (d != CONST3)
+    abort ();
+
+  d = mei (&dv, 6);
+  if (d != CONST2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-12d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12d.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12d.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,112 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+#define CONST2		(3 * 31415926539LL)
+#define CONST3		(4 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector long long int e0 (vector long long int v, long long int x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector long long int e3 (vector long long int v, long long int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector long long int me0 (vector long long int *vp, long long int x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector long long int me3 (vector long long int *vp, long long int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector long long int ei (vector long long int v, int i, long long int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector long long int mei (vector long long int *vp, int i, long long int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector long long int dv = { CONST0, CONST1 };
+  long long int d;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e3 (dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = me0 (&dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me3 (&dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = ei (dv, 0, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 1, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = ei (dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 3, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 3, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-13c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13c.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+#define SIGNED signed
+
+extern void abort (void);
+
+#define CONST0		(((SIGNED __int128) 31415926539) << 60)
+#define CONST1		(((SIGNED __int128) 31415926539) << 55)
+#define CONST2		(((SIGNED __int128) 31415926539) << 50)
+#define CONST3		(((SIGNED __int128) 31415926539) << 45)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector SIGNED __int128 e0 (vector SIGNED __int128 v, SIGNED __int128 x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector SIGNED __int128 e3 (vector SIGNED __int128 v, SIGNED __int128 x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector SIGNED __int128 me0 (vector SIGNED __int128 *vp, SIGNED __int128 x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector SIGNED __int128 me3 (vector SIGNED __int128 *vp, SIGNED __int128 x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector SIGNED __int128
+ei (vector SIGNED __int128 v, int i, SIGNED __int128 x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector SIGNED __int128
+mei (vector SIGNED __int128 *vp, int i, SIGNED __int128 x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector SIGNED __int128 dv = { CONST0 };
+  SIGNED __int128 d;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e3 (dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me0 (&dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me3 (&dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 1, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = ei (dv, 2, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 3, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 0, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 1, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 3, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p9.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p9.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p9.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,39 @@
+/* { dg-do compile { target lp64 } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-options "-mvsx -O2 -mcpu=power9" } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+
+/* Expected instruction counts for Power9. */
+
+/* { dg-final { scan-assembler-times "xvabsdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvadddp" 1 } } */
+/* { dg-final { scan-assembler-times "xxlnor" 5 } } */
+
+/* We generate xxlor instructions for many reasons other than or'ing vector
+   operands or calling __builtin_vec_or(), which  means we cannot rely on
+   their usage counts being stable.  Therefore, we just ensure at least one
+   xxlor instruction was generated.  */
+/* { dg-final { scan-assembler "xxlor" } } */
+
+/* { dg-final { scan-assembler-times "xvcmpeqdp" 7 } } */
+/* { dg-final { scan-assembler-times "xvcmpgtdp" 8 } } */
+/* { dg-final { scan-assembler-times "xvcmpgedp" 7 } } */
+/* { dg-final { scan-assembler-times "xvrdpim" 1 } } */
+/* { dg-final { scan-assembler-times "xvmaddadp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmsubadp" 1 } } */
+/* { dg-final { scan-assembler-times "xvsubdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmaxdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmindp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmuldp" 1 } } */
+/* { dg-final { scan-assembler-times "vperm" 1 } } */
+/* { dg-final { scan-assembler-times "xvrdpic" 1 } } */
+/* { dg-final { scan-assembler-times "xvsqrtdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvrdpiz" 1 } } */
+/* { dg-final { scan-assembler-times "xvmsubasp" 1 } } */
+/* { dg-final { scan-assembler-times "xvnmaddasp" 1 } } */
+/* { dg-final { scan-assembler-times "vmsumshs" 1 } } */
+/* { dg-final { scan-assembler-times "xxland" 13 } } */
+
+/* Source code for the test in vsx-vector-6.h */
+#include "vsx-vector-6.h"
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,14 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-O2 -mvsx" } */
+
+#define TYPE unsigned char
+/* ELEMENTS is number of elements in a vector of TYPE.  */
+#define ELEMENTS 16
+#define INITIAL \
+  {  3, 2, 3, 4, 5, 6, 7, 8, 240, 241, 242, 243, 244, 245, 246, 247 }
+
+#define DO_TRACE
+#define DISABLE_INLINE_OF_GET_AUTO_N
+
+#include "vec-extract-v16qiu-v2.h"
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-14b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,126 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		((float) (3.1415926539))
+#define CONST1		((float) (3.1415926539 * 2))
+#define CONST2		((float) (3.1415926539 * 3))
+#define CONST3		((float) (3.1415926539 * 4))
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+float e0(vector float v){ return __builtin_vec_ext_v4sf (v, 0); }
+float e1(vector float v){ return __builtin_vec_ext_v4sf (v, 1); }
+float e7(vector float v){ return __builtin_vec_ext_v4sf (v, 7); }
+float e8(vector float v){ return __builtin_vec_ext_v4sf (v, 8); }
+
+/* Test for vector residing in memory.  */
+float me0(vector float *vp){ return __builtin_vec_ext_v4sf (*vp, 0); }
+float me1(vector float *vp){ return __builtin_vec_ext_v4sf (*vp, 1); }
+
+float me13(vector float *vp)
+{
+  return __builtin_vec_ext_v4sf (*vp, 13);
+}
+
+float me15(vector float *vp)
+{
+  return __builtin_vec_ext_v4sf (*vp, 15);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+float ei(vector float v, int i)
+{
+  return __builtin_vec_ext_v4sf (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+float mei(vector float *vp, int i)
+{
+  return __builtin_vec_ext_v4sf (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector float dv = { CONST0, CONST1, CONST2, CONST3 };
+  float d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e1 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = e7 (dv);
+  if (d != CONST3)
+    abort ();
+
+  d = e8 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me1 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me13 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me15 (&dv);
+  if (d != CONST3)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST2)
+    abort ();
+
+  d = ei (dv, 11);
+  if (d != CONST3)
+    abort ();
+
+  d = ei (dv, 17);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 15);
+  if (d != CONST3)
+    abort ();
+
+  d = mei (&dv, 6);
+  if (d != CONST2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-15a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,113 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(3.1415926539)
+#define CONST1		(3.1415926539 * 2)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+double e0(vector double v){ return __builtin_vec_ext_v2df (v, 0); }
+double e1(vector double v){ return __builtin_vec_ext_v2df (v, 1); }
+double e2(vector double v){ return __builtin_vec_ext_v2df (v, 2); }
+double e3(vector double v){ return __builtin_vec_ext_v2df (v, 3); }
+
+/* Test for vector residing in memory.  */
+double me0(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 0); }
+double me1(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 1); }
+double me2(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 2); }
+double me3(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 3); }
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+double ei(vector double v, int i){ return __builtin_vec_ext_v2df (v, i); }
+
+/* Test for variable selector and vector residing in memory.  */
+double mei(vector double *vp, int i){ return __builtin_vec_ext_v2df (*vp, i); }
+
+
+int main (int argc, char *argv[]) {
+  vector double dv;
+  double d;
+  dv[0] = CONST0;
+  dv[1] = CONST1;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e1 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = e2 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me1 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me2 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-13d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13d.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13d.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+#define SIGNED signed
+
+extern void abort (void);
+
+#define CONST0		(((SIGNED __int128) 31415926539) << 60)
+#define CONST1		(((SIGNED __int128) 31415926539) << 55)
+#define CONST2		(((SIGNED __int128) 31415926539) << 50)
+#define CONST3		(((SIGNED __int128) 31415926539) << 45)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector SIGNED __int128 e0 (vector SIGNED __int128 v, SIGNED __int128 x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector SIGNED __int128 e3 (vector SIGNED __int128 v, SIGNED __int128 x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector SIGNED __int128 me0 (vector SIGNED __int128 *vp, SIGNED __int128 x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector SIGNED __int128 me3 (vector SIGNED __int128 *vp, SIGNED __int128 x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector SIGNED __int128
+ei (vector SIGNED __int128 v, int i, SIGNED __int128 x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector SIGNED __int128
+mei (vector SIGNED __int128 *vp, int i, SIGNED __int128 x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector SIGNED __int128 dv = { CONST0 };
+  SIGNED __int128 d;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e3 (dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me0 (&dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me3 (&dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 1, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = ei (dv, 2, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 3, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 0, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 1, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 3, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/p8vector-builtin-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/p8vector-builtin-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/p8vector-builtin-2.c	(.../branches/gcc-7-branch)
@@ -9,6 +9,14 @@
 typedef vector long long		v_sign;
 typedef vector unsigned long long	v_uns;
 typedef vector bool long long		v_bool;
+typedef vector bool char		v_bchar;
+typedef vector bool int 		v_bint;
+typedef vector bool short		v_bshort;
+typedef vector signed int		v_sint;
+typedef vector unsigned int		v_uint;
+typedef vector signed char		v_schar;
+typedef vector unsigned char		v_uchar;
+typedef vector float			v_float;
 
 v_sign sign_add_1 (v_sign a, v_sign b)
 {
@@ -191,6 +199,77 @@
   return vec_vsrad (a, b);
 }
 
+v_bchar vbchar_eq (v_bchar a, v_bchar b)
+{
+  return vec_cmpeq (a, b);
+}
+
+v_bchar vbschar_eq (v_schar a, v_schar b)
+{
+  return vec_cmpeq (a, b);
+}
+
+v_bchar vuchar_eq (v_uchar a, v_uchar b)
+{
+  return vec_cmpeq (a, b);
+}
+
+v_bint vbint_eq (v_bint a, v_bint b)
+{
+  return vec_cmpeq (a, b);
+}
+
+v_bint vsint_eq (v_sint a, v_sint b)
+{
+  return vec_cmpeq (a, b);
+}
+
+v_bint vuint_eq (v_uint a, v_uint b)
+{
+  return vec_cmpeq (a, b);
+}
+
+v_bool vbool_eq (v_bool a, v_bool b)
+{
+  return vec_cmpeq (a, b);
+}
+
+v_bint vbint_ne (v_bint a, v_bint b)
+{
+  return vec_cmpne (a, b);
+}
+
+v_bint vsint_ne (v_sint a, v_sint b)
+{
+  return vec_cmpne (a, b);
+}
+
+v_bint vuint_ne (v_uint a, v_uint b)
+{
+  return vec_cmpne (a, b);
+}
+
+v_bool vbool_ne (v_bool a, v_bool b)
+{
+  return vec_cmpne (a, b);
+}
+
+v_bool vsign_ne (v_sign a, v_sign b)
+{
+  return vec_cmpne (a, b);
+}
+
+v_bool vuns_ne (v_uns a, v_uns b)
+{
+  return vec_cmpne (a, b);
+}
+
+v_bshort vbshort_ne (v_bshort a, v_bshort b)
+{
+  return vec_cmpne (a, b);
+}
+
+
 /* { dg-final { scan-assembler-times "vaddudm" 	5 } } */
 /* { dg-final { scan-assembler-times "vsubudm" 	6 } } */
 /* { dg-final { scan-assembler-times "vmaxsd"  	4 } } */
@@ -197,9 +276,11 @@
 /* { dg-final { scan-assembler-times "vminsd"  	3 } } */
 /* { dg-final { scan-assembler-times "vmaxud"  	2 } } */
 /* { dg-final { scan-assembler-times "vminud"  	2 } } */
-/* { dg-final { scan-assembler-times "vcmpequd" 2 } } */
+/* { dg-final { scan-assembler-times "vcmpequd" 6 } } */
 /* { dg-final { scan-assembler-times "vcmpgtsd" 1 } } */
 /* { dg-final { scan-assembler-times "vcmpgtud" 1 } } */
 /* { dg-final { scan-assembler-times "vrld"     3 } } */
 /* { dg-final { scan-assembler-times "vsld"     5 } } */
 /* { dg-final { scan-assembler-times "vsrad"    3 } } */
+/* { dg-final { scan-assembler-times "vcmpequb" 3 } } */
+/* { dg-final { scan-assembler-times "vcmpequw" 6 } } */
Index: gcc/testsuite/gcc.target/powerpc/vsx-13.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-13.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-13.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,42 @@
+/* { dg-do compile { target powerpc*-*-* } } */
+/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-options "-mvsx" } */
+
+/* Variations of tests that require VSX support.  This is a variation of
+   the altivec-13.c testcase.  */
+
+#include <altivec.h>
+
+void foo (void)
+{
+
+  vector signed char vsc1, vsc2, vscz;
+  vector unsigned char vuc1, vuc2, vucz;
+  vector bool long long vubll1, vubll2, vubllz;
+  vector signed int long long vsill1, vsill2, vsillz;
+  vector unsigned int long long vuill1, vuill2, vuillz;
+  vector double vd1, vd2, vdz;
+
+  vubllz = vec_sld( vubll1, vubll2, 1 );
+  vsillz = vec_sld( vsill1, vsill2, 1 );
+  vuillz = vec_sld( vuill1, vuill2, 1 );
+
+  vsillz = vec_srl(vsill1, vuc2);
+  vuillz = vec_srl(vuill1, vuc2);
+
+  vsillz = vec_sro(vsill1, vsc2);
+  vsillz = vec_sro(vsill1, vuc2);
+  vuillz = vec_sro(vuill1, vsc2);
+  vuillz = vec_sro(vuill1, vuc2);
+
+  vdz = vec_sld( vd1, vd2, 1 );
+}
+
+/* Expected results:
+   vec_sld          vsldoi
+   vec_srl          vsr
+   vec_sro          vsro  */
+
+/* { dg-final { scan-assembler-times "vsldoi" 4 } } */
+/* { dg-final { scan-assembler-times "vsr " 2 } } */
+/* { dg-final { scan-assembler-times "vsro" 4 } } */
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,14 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-O2 -mvsx" } */
+
+#define TYPE unsigned char
+/* ELEMENTS is number of elements in a vector of TYPE.  */
+#define ELEMENTS 16
+#define INITIAL \
+  {  3, 2, 3, 4, 5, 6, 7, 8, 240, 241, 242, 243, 244, 245, 246, 247 }
+
+#define DO_TRACE
+#undef DISABLE_INLINE_OF_GET_AUTO_N
+
+#include "vec-extract-v16qiu-v2.h"
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-14c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14c.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		((float) (3.1415926539))
+#define CONST1		((float) (3.1415926539 * 2))
+#define CONST2		((float) (3.1415926539 * 3))
+#define CONST3		((float) (3.1415926539 * 4))
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector float e0(vector float v, float x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector float e1(vector float v, float x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector float e7(vector float v, float x)
+{
+  return vec_insert (x, v, 7);
+}
+
+vector float e8(vector float v, float x)
+{
+  return vec_insert (x, v, 8);
+}
+
+/* Test for vector residing in memory.  */
+vector float me0(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector float me1(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector float me13(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 13);
+}
+
+vector float me15(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 15);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector float ei(vector float v, int i, float x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector float mei(vector float *vp, int i, float x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector float dv = { CONST0, CONST1, CONST2, CONST3 };
+  float d;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e1 (dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = e7 (dv, CONST2);
+  if (dv [3] != CONST2)
+    abort ();
+
+  dv = e8 (dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me0 (&dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me1 (&dv, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = me13 (&dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = me15 (&dv, CONST1);
+  if (dv [3] != CONST1)
+    abort ();
+
+  dv = ei (dv, 0, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 2, CONST1);
+  if (dv [2] != CONST1)
+    abort ();
+
+  dv = ei (dv, 11, CONST0);
+  if (dv [3] != CONST0)
+    abort ();
+
+  dv = ei (dv, 17, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 15, CONST1);
+  if (dv [3] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 6, CONST0);
+  if (dv [2] != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr87532.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr87532.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr87532.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,72 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <stdlib.h>
+#include <stddef.h>
+#include <altivec.h>
+#include <stdio.h>
+
+static void
+check (unsigned char, unsigned char) __attribute__((__noinline__));
+
+static __attribute__((altivec(vector__))) unsigned char
+deoptimize (__attribute__((altivec(vector__))) unsigned char)
+__attribute__((__noinline__));
+
+static __attribute__((altivec(vector__))) unsigned char
+deoptimize (__attribute__((altivec(vector__))) unsigned char a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+// Toggle this attribute inline/noinline to see pass/fail.
+// fails with the noinline attribute applied.
+__attribute__ ((__noinline__))
+unsigned char
+get_auto_n (__attribute__((altivec(vector__))) unsigned char a, size_t n)
+{
+  return (unsigned char) __builtin_vec_extract (a, n);
+}
+
+void
+do_auto (__attribute__((altivec(vector__))) unsigned char a)
+{
+  size_t i;
+  for (i = 1; i < 3 ; i++)
+  {
+    do
+      {
+	printf ("get_auto_n (a, %d) produces 0x0%x\n",
+		i, (int) get_auto_n (a, i));
+
+	if ((int) get_auto_n (a,i) > 250) abort();
+      } while (0);
+  }
+}
+
+int
+main (void)
+{
+  size_t i;
+  __attribute__((altivec(vector__))) unsigned char x =
+    { 3, 2, 3, 8, 5, 6, 7, 8, 240, 241, 242, 243, 244, 245, 246, 247 };
+  __attribute__((altivec(vector__))) unsigned char a;
+
+  printf (" first elements of x are: %d %d %d %d %d\n",
+	  x[0], x[1], x[2], x[3], x[4]);
+
+  a = deoptimize (x);
+
+  printf (" after deoptimization, first elements of a are: %d %d %d %d %d\n",
+	  a[0], a[1], a[2], a[3], a[4]);
+
+  do_auto (a);
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-15b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,113 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(3.1415926539)
+#define CONST1		(3.1415926539 * 2)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+double e0(vector double v){ return __builtin_vec_ext_v2df (v, 0); }
+double e1(vector double v){ return __builtin_vec_ext_v2df (v, 1); }
+double e2(vector double v){ return __builtin_vec_ext_v2df (v, 2); }
+double e3(vector double v){ return __builtin_vec_ext_v2df (v, 3); }
+
+/* Test for vector residing in memory.  */
+double me0(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 0); }
+double me1(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 1); }
+double me2(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 2); }
+double me3(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 3); }
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+double ei(vector double v, int i){ return __builtin_vec_ext_v2df (v, i); }
+
+/* Test for variable selector and vector residing in memory.  */
+double mei(vector double *vp, int i){ return __builtin_vec_ext_v2df (*vp, i); }
+
+
+int main (int argc, char *argv[]) {
+  vector double dv;
+  double d;
+  dv[0] = CONST0;
+  dv[1] = CONST1;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e1 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = e2 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me1 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me2 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-sint128-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-sint128-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-sint128-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,27 @@
+/* Test to verify that the vec_extract from a vector of
+   signed __int128s remains signed.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(signed __int128 st) {
+
+  vector signed __int128 v = vec_splats(st);
+
+  if (vec_extract (v, 0) > st)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (((__int128) 0xf600000000000000LL) << 64);
+  test1 (((__int128) 0x7600000000000000LL) << 64);
+  test1 (((__int128) 0x0600000000000000LL) << 64);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-16a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,165 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned char c0 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned char c9 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 9);
+}
+
+unsigned char c21 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned char c30 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned char mc0 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned char mc9 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 9);
+}
+
+unsigned char mc21 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned char mc30 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned char ci (vector unsigned char v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned char mci (vector unsigned char *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector unsigned char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  unsigned char c;
+
+  c = c0 (cv);
+  if (c != CONST0)
+    abort ();
+
+  c = c9 (cv);
+  if (c != CONST9)
+    abort ();
+
+  c = c21 (cv);
+  if (c != CONST5)
+    abort ();
+
+  c = c30 (cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = mc0 (&cv);
+  if (c != CONST0)
+    abort ();
+
+  c = mc9 (&cv);
+  if (c != CONST9)
+    abort ();
+
+  c = mc21 (&cv);
+  if (c != CONST5)
+    abort ();
+
+  c = mc30 (&cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = ci (cv, 8);
+  if (c != CONST8)
+    abort ();
+
+  c = ci (cv, 13);
+  if (c != CONSTD)
+    abort ();
+
+  c = ci (cv, 23);
+  if (c != CONST7)
+    abort ();
+
+  c = ci (cv, 31);
+  if (c != CONSTF)
+    abort ();
+
+  c = mci (&cv, 5);
+  if (c != CONST5)
+    abort ();
+
+  c = mci (&cv, 12);
+  if (c != CONSTC)
+    abort ();
+
+  c = mci (&cv, 25);
+  if (c != CONST9)
+    abort ();
+
+  c = mci (&cv, 16);
+  if (c != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-14d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14d.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14d.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		((float) (3.1415926539))
+#define CONST1		((float) (3.1415926539 * 2))
+#define CONST2		((float) (3.1415926539 * 3))
+#define CONST3		((float) (3.1415926539 * 4))
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector float e0(vector float v, float x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector float e1(vector float v, float x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector float e7(vector float v, float x)
+{
+  return vec_insert (x, v, 7);
+}
+
+vector float e8(vector float v, float x)
+{
+  return vec_insert (x, v, 8);
+}
+
+/* Test for vector residing in memory.  */
+vector float me0(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector float me1(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector float me13(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 13);
+}
+
+vector float me15(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 15);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector float ei(vector float v, int i, float x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector float mei(vector float *vp, int i, float x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector float dv = { CONST0, CONST1, CONST2, CONST3 };
+  float d;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e1 (dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = e7 (dv, CONST2);
+  if (dv [3] != CONST2)
+    abort ();
+
+  dv = e8 (dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me0 (&dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me1 (&dv, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = me13 (&dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = me15 (&dv, CONST1);
+  if (dv [3] != CONST1)
+    abort ();
+
+  dv = ei (dv, 0, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 2, CONST1);
+  if (dv [2] != CONST1)
+    abort ();
+
+  dv = ei (dv, 11, CONST0);
+  if (dv [3] != CONST0)
+    abort ();
+
+  dv = ei (dv, 17, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 15, CONST1);
+  if (dv [3] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 6, CONST0);
+  if (dv [2] != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-15c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15c.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,151 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(3.1415926539)
+#define CONST1		(3.1415926539 * 2)
+#define CONST2		(3.1415926539 * 3)
+#define CONST3		(3.1415926539 * 4)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector double e0(vector double v, double x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector double e1(vector double v, double x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector double e2(vector double v, double x)
+{
+  return vec_insert (x, v, 2);
+}
+
+vector double e3(vector double v, double x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector double me0(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector double me1(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector double me2(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 2);
+}
+
+vector double me3(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector double ei(vector double v, int i, double x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector double mei(vector double *vp, int i, double x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector double dv;
+  double d;
+  dv[0] = CONST0;
+  dv[1] = CONST1;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e1 (dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = e2 (dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = e3 (dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = me0 (&dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me1 (&dv, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = me2 (&dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me3 (&dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = ei (dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = ei (dv, 2, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 3, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 2, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 3, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-16b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,165 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned char c0 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned char c9 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 9);
+}
+
+unsigned char c21 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned char c30 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned char mc0 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned char mc9 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 9);
+}
+
+unsigned char mc21 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned char mc30 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned char ci (vector unsigned char v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned char mci (vector unsigned char *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector unsigned char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  unsigned char c;
+
+  c = c0 (cv);
+  if (c != CONST0)
+    abort ();
+
+  c = c9 (cv);
+  if (c != CONST9)
+    abort ();
+
+  c = c21 (cv);
+  if (c != CONST5)
+    abort ();
+
+  c = c30 (cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = mc0 (&cv);
+  if (c != CONST0)
+    abort ();
+
+  c = mc9 (&cv);
+  if (c != CONST9)
+    abort ();
+
+  c = mc21 (&cv);
+  if (c != CONST5)
+    abort ();
+
+  c = mc30 (&cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = ci (cv, 8);
+  if (c != CONST8)
+    abort ();
+
+  c = ci (cv, 13);
+  if (c != CONSTD)
+    abort ();
+
+  c = ci (cv, 23);
+  if (c != CONST7)
+    abort ();
+
+  c = ci (cv, 31);
+  if (c != CONSTF)
+    abort ();
+
+  c = mci (&cv, 5);
+  if (c != CONST5)
+    abort ();
+
+  c = mci (&cv, 12);
+  if (c != CONSTC)
+    abort ();
+
+  c = mci (&cv, 25);
+  if (c != CONST9)
+    abort ();
+
+  c = mci (&cv, 16);
+  if (c != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-sshort-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-sshort-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-sshort-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,29 @@
+/* Test to verify that the vec_extract from a vector of
+   signed shorts remains signed.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(signed short ss) {
+  int sse;
+
+  vector signed short v = vec_splats(ss);
+  sse = vec_extract(v,0);
+
+  if (sse != ss)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (0xf600);
+  test1 (0x7600);
+  test1 (0x0600);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2.h
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,253 @@
+#include <stdlib.h>
+#include <stddef.h>
+#include <altivec.h>
+
+#ifndef RTYPE
+#define RTYPE TYPE
+#endif
+
+#ifdef DO_TRACE
+#include <stdio.h>
+
+#define TRACE(STRING, NUM)						\
+do									\
+  {									\
+    fprintf (stderr, "%s: %2d\n", STRING, (int) NUM);			\
+    fflush (stderr);							\
+  }									\
+while (0)
+
+#ifndef FAIL_FORMAT
+#define FAIL_FORMAT "%ld"
+#define FAIL_CAST(X) ((long)(X))
+#endif
+
+#define FAIL(EXP, GOT)							 \
+do									 \
+  {									 \
+    fprintf (stderr, "Expected: " FAIL_FORMAT ", got " FAIL_FORMAT "\n", \
+	     FAIL_CAST (EXP), FAIL_CAST (GOT));				 \
+    fflush (stderr);							 \
+    abort ();								 \
+  }									 \
+while (0)
+
+#else
+#define TRACE(STRING, NUM)
+#define FAIL(EXP, GOT) abort ()
+#endif
+
+static void
+check (RTYPE, RTYPE) __attribute__((__noinline__));
+
+static vector TYPE
+deoptimize (vector TYPE) __attribute__((__noinline__));
+
+static vector TYPE
+*deoptimize_ptr (vector TYPE *)	__attribute__((__noinline__));
+
+static void
+check (RTYPE expected, RTYPE got)
+{
+  if (expected != got)
+    FAIL (expected, got);
+}
+
+static vector TYPE
+deoptimize (vector TYPE a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector TYPE *
+deoptimize_ptr (vector TYPE *p)
+{
+  __asm__ (" # %0" : "+r" (p));
+  return p;
+}
+
+
+RTYPE
+get_auto_0 (vector TYPE a)
+{
+  TRACE ("get_auto_", 0);
+  return (RTYPE) vec_extract (a, 0);
+}
+
+RTYPE
+get_auto_1 (vector TYPE a)
+{
+  TRACE ("get_auto_", 1);
+  return (RTYPE) vec_extract (a, 1);
+}
+
+#if ELEMENTS >= 4
+RTYPE
+get_auto_2 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 2);
+}
+
+RTYPE
+get_auto_3 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 3);
+}
+
+#if ELEMENTS >= 8
+RTYPE
+get_auto_4 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 4);
+}
+
+RTYPE
+get_auto_5 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 5);
+}
+
+RTYPE
+get_auto_6 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 6);
+}
+
+RTYPE
+get_auto_7 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 7);
+}
+
+#if ELEMENTS >= 16
+RTYPE
+get_auto_8 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 8);
+}
+
+RTYPE
+get_auto_9 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 9);
+}
+
+RTYPE
+get_auto_10 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 10);
+}
+
+RTYPE
+get_auto_11 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 11);
+}
+
+RTYPE
+get_auto_12 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 12);
+}
+
+RTYPE
+get_auto_13 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 13);
+}
+
+RTYPE
+get_auto_14 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 14);
+}
+
+RTYPE
+get_auto_15 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 15);
+}
+
+#endif
+#endif
+#endif
+
+
+/* Tests for the normal case of vec_extract where the vector is in a register
+   and returning the result in a register as a return value.  */
+#ifdef DISABLE_INLINE_OF_GET_AUTO_N
+__attribute__ ((__noinline__))
+#else
+/* gcc issues warning: always_inline function might not be inlinable
+
+   __attribute__ ((__always_inline__))
+*/
+#endif
+RTYPE
+get_auto_n (vector TYPE a, ssize_t n)
+{
+  return (RTYPE) vec_extract (a, n);
+}
+
+typedef RTYPE (*auto_func_type) (vector TYPE);
+
+static auto_func_type get_auto_const[] = {
+  get_auto_0,
+  get_auto_1,
+#if ELEMENTS >= 4
+  get_auto_2,
+  get_auto_3,
+#if ELEMENTS >= 8
+  get_auto_4,
+  get_auto_5,
+  get_auto_6,
+  get_auto_7,
+#if ELEMENTS >= 16
+  get_auto_8,
+  get_auto_9,
+  get_auto_10,
+  get_auto_11,
+  get_auto_12,
+  get_auto_13,
+  get_auto_14,
+  get_auto_15,
+#endif
+#endif
+#endif
+};
+
+extern void do_auto (vector TYPE a) __attribute__((__noinline__));
+
+void
+do_auto (vector TYPE a)
+{
+  size_t i;
+
+  for (i = 1; i < 40; i += 3)
+    {
+      TRACE ("do_auto, i: ", i);
+      TRACE ("  get_auto_const[i] returns: ",
+	     (*get_auto_const [i % ELEMENTS]) (a));
+      TRACE ("  get_auto_n returns", get_auto_n (a, i));
+      check (get_auto_n (a, i), (*get_auto_const [i % ELEMENTS]) (a));
+    }
+}
+
+
+
+/* Main program to test all of the possibilities.  */
+int
+main (void)
+{
+  size_t i;
+  vector TYPE x = INITIAL;
+  vector TYPE *p, *p2, a, y;
+  vector TYPE z[2];
+
+  a = deoptimize (x);
+
+  do_auto (a);
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-17a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned short s3 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+unsigned short s7 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 7);
+}
+
+unsigned short s21 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned short s30 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned short ms3 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+unsigned short ms7 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 7);
+}
+
+unsigned short ms21 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned short ms30 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned short ci (vector unsigned short v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned short mci (vector unsigned short *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+int main (int argc, unsigned short *argv[]) {
+  vector unsigned short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  unsigned short s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s7 (sv);
+  if (s != CONST7)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST5)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms7 (&sv);
+  if (s != CONST7)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST5)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST7)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-15d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15d.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15d.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,151 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(3.1415926539)
+#define CONST1		(3.1415926539 * 2)
+#define CONST2		(3.1415926539 * 3)
+#define CONST3		(3.1415926539 * 4)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector double e0(vector double v, double x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector double e1(vector double v, double x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector double e2(vector double v, double x)
+{
+  return vec_insert (x, v, 2);
+}
+
+vector double e3(vector double v, double x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector double me0(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector double me1(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector double me2(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 2);
+}
+
+vector double me3(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector double ei(vector double v, int i, double x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector double mei(vector double *vp, int i, double x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector double dv;
+  double d;
+  dv[0] = CONST0;
+  dv[1] = CONST1;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e1 (dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = e2 (dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = e3 (dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = me0 (&dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me1 (&dv, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = me2 (&dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me3 (&dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = ei (dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = ei (dv, 2, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 3, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 2, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 3, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-7.h
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-7.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-7.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,18 @@
+
+/* This test code is included into vsx-7-be.c.
+ * this is meant to supplement code in altivec-7.h.  */
+
+#include <altivec.h>
+
+
+vector float *vecfloat;
+vector double *vecdouble;
+
+int main2 ()
+{
+
+  *vecdouble++ = vec_unpackl(vecfloat[0]);
+  *vecdouble++ = vec_unpackh(vecfloat[0]);
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-16c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16c.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,180 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <stdio.h>
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned char c0 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector unsigned char c9 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 9);
+}
+
+vector unsigned char c21 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector unsigned char c30 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned char mc0 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector unsigned char mc9 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 9);
+}
+
+vector unsigned char mc21 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector unsigned char mc30 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned char ci (vector unsigned char v, int i, unsigned char x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned char mci (vector unsigned char *vp, int i, unsigned char x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector unsigned char cv = { CONST0, CONST1, CONST2, CONST3,
+			      CONST4, CONST5, CONST6, CONST7,
+			      CONST8, CONST9, CONSTA, CONSTB,
+			      CONSTC, CONSTD, CONSTE, CONSTF };
+  printf ("A\n");
+  cv = c0 (cv, CONST3);
+  if (cv [0] != CONST3)
+    abort ();
+
+  printf ("B\n");
+  cv = c9 (cv, CONST2);
+  if (cv [9] != CONST2)
+    abort ();
+
+  printf ("C\n");
+  cv = c21 (cv, CONSTF);
+  if (cv [5] != CONSTF)
+    abort ();
+
+  printf ("D\n");
+  cv = c30 (cv, CONST3);
+  if (cv [14] != CONST3)
+    abort ();
+
+  printf ("E\n");
+  cv = mc0 (&cv, CONST4);
+  if (cv [0] != CONST4)
+    abort ();
+
+  printf ("F\n");
+  cv = mc9 (&cv, CONST3);
+  if (cv [9] != CONST3)
+    abort ();
+
+  printf ("G\n");
+  cv = mc21 (&cv, CONST1);
+  if (cv [5] != CONST1)
+    abort ();
+
+  printf ("H\n");
+  cv = mc30 (&cv, CONSTC);
+  if (cv [14] != CONSTC)
+    abort ();
+
+  printf ("I\n");
+  cv = ci (cv, 8, CONSTD);
+  if (cv [8] != CONSTD)
+    abort ();
+
+  printf ("J\n");
+  cv = ci (cv, 13, CONST5);
+  if (cv [13] != CONST5)
+    abort ();
+
+  printf ("K\n");
+  cv = ci (cv, 23, CONST6);
+  if (cv [7] != CONST6)
+    abort ();
+
+  printf ("L\n");
+  cv = ci (cv, 31, CONST7);
+  if (cv [15] != CONST7)
+    abort ();
+
+  printf ("M\n");
+  cv = mci (&cv, 5, CONST8);
+  if (cv [5] != CONST8)
+    abort ();
+
+  printf ("N\n");
+  cv = mci (&cv, 12, CONST9);
+  if (cv [12] != CONST9)
+    abort ();
+
+  printf ("O\n");
+  cv = mci (&cv, 25, CONSTA);
+  if (cv [9] != CONSTA)
+    abort ();
+
+  printf ("P\n");
+  cv = mci (&cv, 16, CONSTB);
+  if (cv [0] != CONSTB)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-ulong-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-ulong-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-ulong-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,27 @@
+/* Test to verify that the vec_extract from a vector of
+   unsigned longs remains unsigned.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(unsigned long long int ul) {
+
+  vector unsigned long long int v = vec_splats(ul);
+
+  if (vec_extract (v, 0) < ul)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (0xf600000000000000LL);
+  test1 (0x7600000000000000LL);
+  test1 (0x0600000000000000LL);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-17b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned short s3 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+unsigned short s7 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 7);
+}
+
+unsigned short s21 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned short s30 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned short ms3 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+unsigned short ms7 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 7);
+}
+
+unsigned short ms21 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned short ms30 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned short ci (vector unsigned short v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned short mci (vector unsigned short *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+int main (int argc, unsigned short *argv[]) {
+  vector unsigned short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  unsigned short s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s7 (sv);
+  if (s != CONST7)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST5)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms7 (&sv);
+  if (s != CONST7)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST5)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST7)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-18a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Unsigned Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned int s3 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+unsigned int s1 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 1);
+}
+
+unsigned int s21 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned int s30 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned int ms3 (vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+unsigned int ms1(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 1);
+}
+
+unsigned int ms21(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned int ms30(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned int ci (vector unsigned int v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned int mci(vector unsigned int *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+unsigned int main (int argc, unsigned char *argv[]) {
+  vector unsigned int sv = { CONST0, CONST1, CONST2, CONST3 };
+  unsigned int s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s1 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms1 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST3)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-16d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16d.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16d.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,163 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned char c0 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector unsigned char c9 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 9);
+}
+
+vector unsigned char c21 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector unsigned char c30 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned char mc0 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector unsigned char mc9 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 9);
+}
+
+vector unsigned char mc21 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector unsigned char mc30 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned char ci (vector unsigned char v, int i, unsigned char x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned char mci (vector unsigned char *vp, int i, unsigned char x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector unsigned char cv = { CONST0, CONST1, CONST2, CONST3,
+			      CONST4, CONST5, CONST6, CONST7,
+			      CONST8, CONST9, CONSTA, CONSTB,
+			      CONSTC, CONSTD, CONSTE, CONSTF };
+  cv = c0 (cv, CONST3);
+  if (cv [0] != CONST3)
+    abort ();
+
+  cv = c9 (cv, CONST2);
+  if (cv [9] != CONST2)
+    abort ();
+
+  cv = c21 (cv, CONSTF);
+  if (cv [5] != CONSTF)
+    abort ();
+
+  cv = c30 (cv, CONST3);
+  if (cv [14] != CONST3)
+    abort ();
+
+  cv = mc0 (&cv, CONST4);
+  if (cv [0] != CONST4)
+    abort ();
+
+  cv = mc9 (&cv, CONST3);
+  if (cv [9] != CONST3)
+    abort ();
+
+  cv = mc21 (&cv, CONST1);
+  if (cv [5] != CONST1)
+    abort ();
+
+  cv = mc30 (&cv, CONSTC);
+  if (cv [14] != CONSTC)
+    abort ();
+
+  cv = ci (cv, 8, CONSTD);
+  if (cv [8] != CONSTD)
+    abort ();
+
+  cv = ci (cv, 13, CONST5);
+  if (cv [13] != CONST5)
+    abort ();
+
+  cv = ci (cv, 23, CONST6);
+  if (cv [7] != CONST6)
+    abort ();
+
+  cv = ci (cv, 31, CONST7);
+  if (cv [15] != CONST7)
+    abort ();
+
+  cv = mci (&cv, 5, CONST8);
+  if (cv [5] != CONST8)
+    abort ();
+
+  cv = mci (&cv, 12, CONST9);
+  if (cv [12] != CONST9)
+    abort ();
+
+  cv = mci (&cv, 25, CONSTA);
+  if (cv [9] != CONSTA)
+    abort ();
+
+  cv = mci (&cv, 16, CONSTB);
+  if (cv [0] != CONSTB)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-uchar-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-uchar-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-uchar-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,29 @@
+/* Test to verify that the vec_extract from a vector of
+   unsigned chars remains unsigned.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(unsigned char uc) {
+  int uce;
+
+  vector unsigned char v = vec_splats(uc);
+  uce = vec_extract(v,0);
+
+  if (uce != uc)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (0xf6);
+  test1 (0x76);
+  test1 (0x06);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-17c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17c.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,154 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned short s3 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector unsigned short s7 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 7);
+}
+
+vector unsigned short s21 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector unsigned short s30 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned short ms3 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector unsigned short ms7 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 7);
+}
+
+vector unsigned short ms21 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector unsigned short ms30 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned short ci (vector unsigned short v, int i, unsigned short x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned short mci (vector unsigned short *vp, int i, unsigned short x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, unsigned short *argv[]) {
+  vector unsigned short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+
+  sv = s3 (sv, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = s7 (sv, CONST2);
+  if (sv [7] != CONST2)
+    abort ();
+
+  sv = s21 (sv, CONST3);
+  if (sv [5] != CONST3)
+    abort ();
+
+  sv = s30 (sv, CONST4);
+  if (sv [6] != CONST4)
+    abort ();
+
+  sv = ms3 (&sv, CONST5);
+  if (sv [3] != CONST5)
+    abort ();
+
+  sv = ms7 (&sv, CONST6);
+  if (sv [7] != CONST6)
+    abort ();
+
+  sv = ms21 (&sv, CONST7);
+  if (sv [5] != CONST7)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [6] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST1);
+  if (sv [5] != CONST1)
+    abort ();
+
+  sv = ci (sv, 2, CONST3);
+  if (sv [2] != CONST3)
+    abort ();
+
+  sv = ci (sv, 15, CONST2);
+  if (sv [7] != CONST2)
+    abort ();
+
+  sv = ci (sv, 28, CONST5);
+  if (sv [4] != CONST5)
+    abort ();
+
+  sv = mci (&sv, 5, CONST4);
+  if (sv [5] != CONST4)
+    abort ();
+
+  sv = mci (&sv, 12, CONST6);
+  if (sv [4] != CONST6)
+    abort ();
+
+  sv = mci (&sv, 25, CONST7);
+  if (sv [1] != CONST7)
+    abort ();
+
+  sv = mci (&sv, 16, CONST4);
+  if (sv [0] != CONST4)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-sint-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-sint-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-sint-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,29 @@
+/* Test to verify that the vec_extract from a vector of
+   signed ints remains signed.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(signed int si) {
+  long long int sie;
+
+  vector signed int v = vec_splats(si);
+  sie = vec_extract(v,0);
+
+  if (sie != si)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (0xf6000000);
+  test1 (0x76000000);
+  test1 (0x06000000);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr89765-mc.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr89765-mc.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr89765-mc.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,400 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O2" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <stdlib.h>
+#include <stddef.h>
+#include <altivec.h>
+
+#include <stdio.h>
+
+static vector unsigned __int128
+deoptimize_uint128 (vector unsigned __int128  a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned long long int
+deoptimize_ulong (vector unsigned long long int a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned int
+deoptimize_uint (vector unsigned int a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned char
+deoptimize_uchar (vector unsigned char a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned short
+deoptimize_ushort (vector unsigned short a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+__attribute ((noinline))
+vector unsigned __int128
+set_auto_n_uint128 (vector unsigned __int128 a, int n, unsigned __int128 x)
+{
+  return vec_insert (x, a, n);
+}
+
+__attribute ((noinline))
+vector unsigned long long int
+set_auto_n_ulong (vector unsigned long long int a, int n,
+		  unsigned long long int x)
+{
+  return vec_insert (x, a, n);
+}
+
+__attribute ((noinline))
+vector unsigned int
+set_auto_n_uint (vector unsigned int a, int n, unsigned int x)
+{
+  return vec_insert (x, a, n);
+}
+
+__attribute ((noinline))
+vector unsigned char
+set_auto_n_uchar (vector unsigned char a, int n, unsigned char x)
+{
+  return vec_insert (x, a, n);
+}
+
+__attribute ((noinline))
+vector unsigned short
+set_auto_n_ushort (vector unsigned short a, int n, unsigned short x)
+{
+  return vec_insert (x, a, n);
+}
+
+__attribute ((noinline))
+unsigned __int128
+get_auto_n_uint128 (vector unsigned __int128 a, int n)
+{
+  return vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned long long int
+get_auto_n_ulong (vector unsigned long long int a, int n)
+{
+  return vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned int
+get_auto_n_uint (vector unsigned int a, int n)
+{
+  return vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned char
+get_auto_n_uchar (vector unsigned char a, int n)
+{
+  return vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned short
+get_auto_n_ushort (vector unsigned short a, int n)
+{
+  return vec_extract (a, n);
+}
+
+int check_uint128_element (int i, unsigned __int128 entry)
+{
+  printf ("checking uint128 entry at index %d\n", i);
+
+  return (entry == ((((unsigned __int128) 0xffeeddccbbaa9988ULL) << 64)
+		    | 0x0706050403020100ULL));
+}
+
+unsigned __int128 get_uint128_element (int i)
+{
+  return ((((unsigned __int128) 0xffeeddccbbaa9988ULL) << 64)
+	  | 0x0706050403020100ULL);
+}
+
+int check_ulong_element (int i, unsigned long long int entry)
+{
+  printf ("checking ulong entry 0x%llx at index %d\n", entry, i);
+
+  switch (i % 2)
+    {
+      case 0: return (entry == 0x9999901010ULL);
+      case 1: return (entry == 0x7777733333ULL);
+      default:
+	return 0;
+    }
+}
+
+unsigned long long int get_ulong_element (int i)
+{
+  switch (i % 2)
+    {
+    case 0: return 0x9999901010ULL;
+    case 1: return 0x7777733333ULL;
+    }
+}
+
+int check_uint_element (int i, unsigned int entry)
+{
+  printf ("checking uint entry 0x%x at index %d\n", entry, i);
+
+  switch (i % 4)
+    {
+    case 0: return (entry == 0x99999);
+    case 1: return (entry == 0x01010);
+    case 2: return (entry == 0x77777);
+    case 3: return (entry == 0x33333);
+    default:
+      return 0;
+    }
+}
+
+unsigned int get_uint_element (int i)
+{
+  switch (i % 4)
+    {
+    case 0: return 0x99999;
+    case 1: return 0x01010;
+    case 2: return 0x77777;
+    case 3: return 0x33333;
+    }
+}
+
+int check_uchar_element (int i, unsigned char entry)
+{
+  printf ("checking uchar entry 0x%x at index %d\n", entry, i);
+  switch (i % 16)
+    {
+    case 0: return (entry == 0x90);
+    case 1: return (entry == 0x80);
+    case 2: return (entry == 0x70);
+    case 3: return (entry == 0x60);
+    case 4: return (entry == 0x50);
+    case 5: return (entry == 0x40);
+    case 6: return (entry == 0x30);
+    case 7: return (entry == 0x20);
+    case 8: return (entry == 0x10);
+    case 9: return (entry == 0xf0);
+    case 10: return (entry == 0xe0);
+    case 11: return (entry == 0xd0);
+    case 12: return (entry == 0xc0);
+    case 13: return (entry == 0xb0);
+    case 14: return (entry == 0xa0);
+    case 15: return (entry == 0xff);
+    default:
+      return 0;
+    }
+}
+
+unsigned char get_uchar_element (int i)
+{
+  switch (i % 16)
+    {
+    case 0: return 0x90;
+    case 1: return 0x80;
+    case 2: return 0x70;
+    case 3: return 0x60;
+    case 4: return 0x50;
+    case 5: return 0x40;
+    case 6: return 0x30;
+    case 7: return 0x20;
+    case 8: return 0x10;
+    case 9: return 0xf0;
+    case 10: return 0xe0;
+    case 11: return 0xd0;
+    case 12: return 0xc0;
+    case 13: return 0xb0;
+    case 14: return 0xa0;
+    case 15: return 0xff;
+    }
+}
+
+int check_ushort_element (int i, unsigned short entry)
+{
+  printf ("checking ushort entry 0x%x at index %d\n", entry, i);
+  switch (i % 8)
+    {
+    case 0: return (entry == 0x9988);
+    case 1: return (entry == 0x8877);
+    case 2: return (entry == 0x7766);
+    case 3: return (entry == 0x6655);
+    case 4: return (entry == 0x5544);
+    case 5: return (entry == 0x4433);
+    case 6: return (entry == 0x3322);
+    case 7: return (entry == 0x2211);
+    default:
+      return 0;
+    }
+}
+
+unsigned short get_ushort_element (int i)
+{
+  switch (i % 8)
+    {
+    case 0: return 0x9988;
+    case 1: return 0x8877;
+    case 2: return 0x7766;
+    case 3: return 0x6655;
+    case 4: return 0x5544;
+    case 5: return 0x4433;
+    case 6: return 0x3322;
+    case 7: return 0x2211;
+    }
+}
+
+vector unsigned __int128
+init_auto_uint128 (vector unsigned __int128 a)
+{
+  int i;
+  for (i = 0; i < 32; i += 3)
+    a = set_auto_n_uint128 (a, i, get_uint128_element (i));
+  return a;
+}
+
+void do_auto_uint128 (vector unsigned __int128 a)
+{
+  int i;
+  unsigned __int128 c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uint128 (a, i);
+      if (!check_uint128_element (i, c)) abort ();
+    }
+}
+
+vector unsigned long long int
+init_auto_ulong (vector unsigned long long int a)
+{
+  int i;
+  for (i = 0; i < 32; i += 3)
+    a = set_auto_n_ulong (a, i, get_ulong_element (i));
+  return a;
+}
+
+void do_auto_ulong (vector unsigned long long int a)
+{
+  int i;
+  unsigned long long int c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_ulong (a, i);
+      if (!check_ulong_element (i, c)) abort ();
+    }
+ }
+
+vector unsigned int init_auto_uint (vector unsigned int a)
+{
+  int i;
+  for (i = 0; i < 32; i += 3)
+    a = set_auto_n_uint (a, i, get_uint_element (i));
+  return a;
+}
+
+void do_auto_uint (vector unsigned int a)
+{
+  int i;
+  unsigned int c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uint (a, i);
+      if (!check_uint_element (i, c)) abort ();
+    }
+ }
+
+vector unsigned short init_auto_ushort ( vector unsigned short a )
+{
+  int i;
+  for (i = 0; i < 32; i += 3)
+    a = set_auto_n_ushort (a, i, get_ushort_element (i));
+  return a;
+}
+
+void do_auto_ushort (vector unsigned short a)
+{
+  int i;
+  unsigned short c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_ushort (a, i);
+      if (!check_ushort_element (i, c)) abort ();
+    }
+}
+
+vector unsigned char init_auto_uchar (vector unsigned char a)
+{
+  int i;
+  for (i = 0; i < 32; i += 3)
+    a = set_auto_n_uchar (a, i, get_uchar_element (i));
+  return a;
+}
+
+void do_auto_uchar (vector unsigned char a)
+{
+  int i;
+  unsigned char c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uchar (a, i);
+      if (!check_uchar_element (i, c)) abort ();
+    }
+}
+
+int
+main (void)
+{
+  size_t i;
+
+  vector unsigned __int128 u = { 0 };
+  vector unsigned __int128 du;
+
+  vector unsigned long long int v = { 0, 0 };
+  vector unsigned long long int dv;
+
+  vector unsigned int x = { 0, 0, 0, 0 };
+  vector unsigned int dx;
+
+  vector unsigned char y = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+  vector unsigned char dy;
+
+  vector unsigned short z = { 0, 0, 0, 0, 0, 0, 0, 0 };
+  vector unsigned short dz;
+
+  du = init_auto_uint128 (u);
+  dv = init_auto_ulong (v);
+  dx = init_auto_uint (x);
+  dy = init_auto_uchar (y);
+  dz = init_auto_ushort (z);
+
+  du = deoptimize_uint128 (du);
+  dv = deoptimize_ulong (dv);
+  dx = deoptimize_uint (dx);
+  dy = deoptimize_uchar (dy);
+  dz = deoptimize_ushort (dz);
+
+  do_auto_uint128 (du);
+  do_auto_ulong (dv);
+  do_auto_uint (dx);
+  do_auto_uchar (dy);
+  do_auto_ushort (dz);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-18b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Unsigned Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned int s3 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+unsigned int s1 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 1);
+}
+
+unsigned int s21 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned int s30 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned int ms3 (vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+unsigned int ms1(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 1);
+}
+
+unsigned int ms21(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned int ms30(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned int ci (vector unsigned int v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned int mci(vector unsigned int *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+unsigned int main (int argc, unsigned char *argv[]) {
+  vector unsigned int sv = { CONST0, CONST1, CONST2, CONST3 };
+  unsigned int s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s1 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms1 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST3)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr87532-mc.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr87532-mc.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr87532-mc.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,258 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O2" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <stdlib.h>
+#include <stddef.h>
+#include <altivec.h>
+
+#include <stdio.h>
+
+static vector unsigned __int128
+deoptimize_uint128 (vector unsigned __int128  a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned long long int
+deoptimize_ulong (vector unsigned long long int a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned int
+deoptimize_uint (vector unsigned int a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned char
+deoptimize_uchar (vector unsigned char a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned short
+deoptimize_ushort (vector unsigned short a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+__attribute ((noinline)) unsigned __int128
+get_auto_n_uint128 (vector unsigned __int128 a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+__attribute ((noinline)) unsigned long long int
+get_auto_n_ulong (vector unsigned long long int a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned int get_auto_n_uint (vector unsigned int a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned char get_auto_n_uchar (vector unsigned char a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned short get_auto_n_ushort (vector unsigned short a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+
+int check_uint128_element (int i, unsigned __int128 entry)
+{
+  printf ("checking uint128 entry at index %d\n", i);
+
+  return (entry == ((((unsigned __int128) 0xffeeddccbbaa9988ULL) << 64)
+		    | 0x0706050403020100ULL));
+}
+
+int check_ulong_element (int i, unsigned long long int entry)
+{
+  printf ("checking ulong entry 0x%llx at index %d\n", entry, i);
+
+  switch (i % 2)
+    {
+      case 0: return (entry == 0x9999901010ULL);
+      case 1: return (entry == 0x7777733333ULL);
+      default:
+	return 0;
+    }
+}
+
+int check_uint_element (int i, unsigned int entry)
+{
+  printf ("checking uint entry 0x%x at index %d\n", entry, i);
+
+  switch (i % 4)
+    {
+    case 0: return (entry == 0x99999);
+    case 1: return (entry == 0x01010);
+    case 2: return (entry == 0x77777);
+    case 3: return (entry == 0x33333);
+    default:
+      return 0;
+    }
+}
+
+int check_uchar_element (int i, unsigned char entry)
+{
+  printf ("checking uchar entry 0x%x at index %d\n", entry, i);
+  switch (i % 16)
+    {
+    case 0: return (entry == 0x90);
+    case 1: return (entry == 0x80);
+    case 2: return (entry == 0x70);
+    case 3: return (entry == 0x60);
+    case 4: return (entry == 0x50);
+    case 5: return (entry == 0x40);
+    case 6: return (entry == 0x30);
+    case 7: return (entry == 0x20);
+    case 8: return (entry == 0x10);
+    case 9: return (entry == 0xf0);
+    case 10: return (entry == 0xe0);
+    case 11: return (entry == 0xd0);
+    case 12: return (entry == 0xc0);
+    case 13: return (entry == 0xb0);
+    case 14: return (entry == 0xa0);
+    case 15: return (entry == 0xff);
+    default:
+      return 0;
+    }
+}
+
+int check_ushort_element (int i, unsigned short entry)
+{
+  printf ("checking ushort entry 0x%x at index %d\n", entry, i);
+  switch (i % 8)
+    {
+    case 0: return (entry == 0x9988);
+    case 1: return (entry == 0x8877);
+    case 2: return (entry == 0x7766);
+    case 3: return (entry == 0x6655);
+    case 4: return (entry == 0x5544);
+    case 5: return (entry == 0x4433);
+    case 6: return (entry == 0x3322);
+    case 7: return (entry == 0x2211);
+    default:
+      return 0;
+    }
+}
+
+void do_auto_uint128 ( vector unsigned __int128 a )
+{
+  int i;
+  unsigned __int128 c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uint128 (a,i);
+      if (!check_uint128_element (i, c)) abort ();
+    }
+ }
+
+void do_auto_ulong ( vector unsigned long long int a )
+{
+  int i;
+  unsigned long long int c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_ulong (a,i);
+      if (!check_ulong_element (i, c)) abort ();
+    }
+ }
+
+void do_auto_uint ( vector unsigned int a )
+{
+  int i;
+  unsigned int c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uint (a,i);
+      if (!check_uint_element (i, c)) abort ();
+    }
+ }
+
+void do_auto_ushort ( vector unsigned short a )
+{
+  int i;
+  unsigned short c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_ushort (a,i);
+      if (!check_ushort_element (i, c)) abort ();
+    }
+}
+
+void do_auto_uchar ( vector unsigned char a )
+{
+  int i;
+  unsigned char c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uchar (a,i);
+      if (!check_uchar_element (i, c)) abort ();
+    }
+}
+
+int
+main (void)
+{
+  size_t i;
+
+  vector unsigned __int128 u = {
+    ((((unsigned __int128) 0xffeeddccbbaa9988ULL) << 64)
+     | 0x0706050403020100ULL) };
+  vector unsigned __int128 du;
+
+  vector unsigned long long int v = { 0x9999901010ULL, 0x7777733333ULL };
+  vector unsigned long long int dv;
+
+  vector unsigned int x = { 0x99999, 0x01010, 0x77777, 0x33333 };
+  vector unsigned int dx;
+
+  vector unsigned char y = { 0x90, 0x80, 0x70, 0x60, 0x50, 0x40, 0x30, 0x20,
+			     0x10, 0xf0, 0xe0, 0xd0, 0xc0, 0xb0, 0xa0, 0xff };
+  vector unsigned char dy;
+
+  vector unsigned short z = { 0x9988, 0x8877, 0x7766, 0x6655,
+			      0x5544, 0x4433, 0x3322, 0x2211 };
+  vector unsigned short dz;
+
+  do_auto_uint128 (u);
+  do_auto_ulong (v);
+  do_auto_uint (x);
+  do_auto_uchar (y);
+  do_auto_ushort (z);
+
+  du = deoptimize_uint128 (u);
+  dv = deoptimize_ulong (v);
+  dx = deoptimize_uint (x);
+  dy = deoptimize_uchar (y);
+  dz = deoptimize_ushort (z);
+
+  do_auto_uint128 (du);
+  do_auto_ulong (dv);
+  do_auto_uint (dx);
+  do_auto_uchar (dy);
+  do_auto_ushort (dz);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr87496-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr87496-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr87496-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,11 @@
+/* PR target/87496 */
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
+/* { dg-require-effective-target longdouble128 } */
+/* { dg-options "-O2 -mcpu=power7 -mabi=ieeelongdouble -mno-popcntd -Wno-psabi" } */
+
+int i;
+
+/* { dg-error "'-mabi=ieeelongdouble' requires full ISA 2.06 support" "PR87496" { target *-*-* } 0 } */
+/* { dg-warning "using IEEE extended precision long double" "" { target *-*-* } 0 } */
Index: gcc/testsuite/gcc.target/powerpc/ppc-fortran/ppc-fortran.exp
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/ppc-fortran/ppc-fortran.exp	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/ppc-fortran/ppc-fortran.exp	(.../branches/gcc-7-branch)
@@ -36,7 +36,7 @@
     global gfortran_test_path
     global gfortran_aux_module_flags
     if { [llength $args] != 2 } {
-	error "dg-set-target-env-var: needs one argument"
+	error "dg-compile-aux-modules: needs one argument"
 	return
     }
 
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-19a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,109 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned long long int e0 (vector unsigned long long int v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned long long int e3 (vector unsigned long long int v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+unsigned long long int me0 (vector unsigned long long int *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned long long int me3 (vector unsigned long long int *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned long long int ei (vector unsigned long long int v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+unsigned long long int mei (vector unsigned long long int *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned long long int dv = { CONST0, CONST1 };
+  unsigned long long int d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-17d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17d.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17d.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,154 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned short s3 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector unsigned short s7 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 7);
+}
+
+vector unsigned short s21 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector unsigned short s30 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned short ms3 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector unsigned short ms7 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 7);
+}
+
+vector unsigned short ms21 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector unsigned short ms30 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned short ci (vector unsigned short v, int i, unsigned short x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned short mci (vector unsigned short *vp, int i, unsigned short x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, unsigned short *argv[]) {
+  vector unsigned short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+
+  sv = s3 (sv, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = s7 (sv, CONST2);
+  if (sv [7] != CONST2)
+    abort ();
+
+  sv = s21 (sv, CONST3);
+  if (sv [5] != CONST3)
+    abort ();
+
+  sv = s30 (sv, CONST4);
+  if (sv [6] != CONST4)
+    abort ();
+
+  sv = ms3 (&sv, CONST5);
+  if (sv [3] != CONST5)
+    abort ();
+
+  sv = ms7 (&sv, CONST6);
+  if (sv [7] != CONST6)
+    abort ();
+
+  sv = ms21 (&sv, CONST7);
+  if (sv [5] != CONST7)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [6] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST1);
+  if (sv [5] != CONST1)
+    abort ();
+
+  sv = ci (sv, 2, CONST3);
+  if (sv [2] != CONST3)
+    abort ();
+
+  sv = ci (sv, 15, CONST2);
+  if (sv [7] != CONST2)
+    abort ();
+
+  sv = ci (sv, 28, CONST5);
+  if (sv [4] != CONST5)
+    abort ();
+
+  sv = mci (&sv, 5, CONST4);
+  if (sv [5] != CONST4)
+    abort ();
+
+  sv = mci (&sv, 12, CONST6);
+  if (sv [4] != CONST6)
+    abort ();
+
+  sv = mci (&sv, 25, CONST7);
+  if (sv [1] != CONST7)
+    abort ();
+
+  sv = mci (&sv, 16, CONST4);
+  if (sv [0] != CONST4)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/builtins-3-p9-runnable.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/builtins-3-p9-runnable.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/builtins-3-p9-runnable.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,35 @@
+/* { dg-do run { target { powerpc64*-*-* && { lp64 && p9vector_hw } } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-mcpu=power9 -O2 -mupper-regs-di" } */
+
+#include <altivec.h> // vector
+
+void abort (void);
+
+int main() {
+   int i;
+   vector float vfr, vfexpt;
+   vector unsigned short vusha;
+
+   /* 1.0, -2.0, 0.0, 8.5, 1.5, 0.5, 1.25, -0.25 */
+   vusha = (vector unsigned short){0B011110000000000, 0B1100000000000000,
+                                   0B000000000000000, 0B0100100001000000,
+                                   0B011111000000000, 0B0011100000000000,
+                                   0B011110100000000, 0B1011010000000000};
+   
+   vfexpt = (vector float){1.0, -2.0, 0.0, 8.5};
+   vfr = vec_extract_fp_from_shorth(vusha);
+
+   for (i=0; i<4; i++) {
+      if (vfr[i] != vfexpt[i])
+         abort();
+   }
+
+   vfexpt = (vector float){1.5, 0.5, 1.25, -0.25};
+   vfr = vec_extract_fp_from_shortl(vusha);
+
+   for (i=0; i<4; i++) {
+      if (vfr[i] != vfexpt[i])
+         abort();
+   }
+}
Index: gcc/testsuite/gcc.target/powerpc/pr89424-0.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr89424-0.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr89424-0.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,76 @@
+/* { dg-do run { target { powerpc*-*-* && lp64 } } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+/* Define PR89626 after that pr is addressed.  */
+#ifdef PR89626
+#define SIGNED
+#else
+#define SIGNED signed
+#endif
+
+#define CONST0		(((__int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+__int128 ei (vector SIGNED __int128 v, int i)
+{
+  return __builtin_vec_ext_v1ti (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__int128 mei (vector SIGNED __int128 *vp, int i)
+{
+  return __builtin_vec_ext_v1ti (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector SIGNED __int128 dv = { CONST0 };
+  __int128 d;
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-18c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18c.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,148 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Unsigned Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned int s3 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector unsigned int s1 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector unsigned int s21 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector unsigned int s30 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned int ms3 (vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector unsigned int ms1(vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector unsigned int ms21(vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector unsigned int ms30(vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned int ci (vector unsigned int v, int i, unsigned int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned int mci(vector unsigned int *vp, int i, unsigned int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, unsigned char *argv[]) {
+  vector unsigned int sv = { CONST0, CONST1, CONST2, CONST3 };
+
+  sv = s3 (sv, CONST2);
+  if (sv [3] != CONST2)
+    abort ();
+
+  sv = s1 (sv, CONST2);
+  if (sv [1] != CONST2)
+    abort ();
+
+  sv = s21 (sv, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = s30 (sv, CONST1);
+  if (sv [2] != CONST1)
+    abort ();
+
+  sv = ms3 (&sv, CONST0);
+  if (sv [3] != CONST0)
+    abort ();
+
+  sv = ms1 (&sv, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = ms21 (&sv, CONST1);
+  if (sv [1] != CONST1)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [2] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = ci (sv, 2, CONST0);
+  if (sv [2] != CONST0)
+    abort ();
+
+  sv = ci (sv, 15, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = ci (sv, 28, CONST3);
+  if (sv [0] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 5, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = mci (&sv, 12, CONST2);
+  if (sv [0] != CONST2)
+    abort ();
+
+  sv = mci (&sv, 25, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 16, CONST1);
+  if (sv [0] != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/arm/pr88648-asm-syntax-unified.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/pr88648-asm-syntax-unified.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/arm/pr88648-asm-syntax-unified.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,14 @@
+/* Test for unified syntax assembly generation.  */
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_arch_v7a_ok } */
+/* { dg-add-options arm_arch_v7a } */
+/* { dg-options "-marm -march=armv7-a -masm-syntax-unified" } */
+
+void test ()
+{
+  asm("nop");
+}
+
+/* { dg-final { scan-assembler-times {\.syntax\sunified} 3 } } */
+/* { dg-final { scan-assembler-not {\.syntax\sdivided} } } */
+
Index: gcc/testsuite/gcc.target/arm/pr89222.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/pr89222.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/arm/pr89222.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,32 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void g (void);
+
+void f1 (int x)
+{
+  if (x != (int) g + 3)
+    return;
+  g();
+}
+
+void (*a2)(void);
+
+void f2 (void)
+{
+  a2 = &g + 3;
+}
+
+typedef void (*__sighandler_t)(int);
+void handler (int);
+
+void f3 (int x)
+{
+  __sighandler_t h = &handler;
+  if (h != (__sighandler_t) 2 && h != (__sighandler_t) 1)
+    h (x);
+}
+
+/* { dg-final { scan-assembler-times {add(?:s)?\tr[0-9]+, r[0-9]+, #3} 2 } } */
+/* { dg-final { scan-assembler-not {.word\tg\+3} } } */
+/* { dg-final { scan-assembler-not {.word\thandler-1} } } */
Index: gcc/testsuite/gcc.target/arm/f16_f64_conv_no_dp.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/f16_f64_conv_no_dp.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/arm/f16_f64_conv_no_dp.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_fp16_ok } */
+/* { dg-skip-if "do not override fpu" { *-*-* } { "-mfpu=*" } { "-mfpu=fpv5-sp-d16" } } */
+/* { dg-skip-if "do not disable fpu" { *-*-* } { "-mfloat-abi=soft" } { * } } */
+/* { dg-skip-if "do not override fp16-format" { *-*-* } { "-mfp16-format=*" } { "-mfp16-format=ieee" } } */
+/* { dg-options "-O1 -mfpu=fpv5-sp-d16 -mfloat-abi=hard -mfp16-format=ieee" } */
+
+__fp16 foo (double a)
+{
+  return a;
+}
+
+double bar (__fp16 a)
+{
+  return a;
+}
Index: gcc/testsuite/gcc.target/avr/pr88253.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/avr/pr88253.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/avr/pr88253.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-Os -w" } */
+ 
+static int aRead() __attribute__((always_inline));
+static int aRead() {
+    unsigned char h,l;
+    l = (*(volatile unsigned char *)(0x78)) ;
+    h = (*(volatile unsigned char *)(0x79)) ;
+    return (h<<8) | l;
+}
+ 
+int main() {
+    volatile unsigned char x;
+     x = aRead()^42;
+ }
+ /* { dg-final { scan-assembler "lds r\\d+,121" } } */
Index: gcc/testsuite/gcc.target/s390/zvector/vec-double-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/zvector/vec-double-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/s390/zvector/vec-double-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -march=z13 -mzvector" } */
+
+#include <vecintrin.h>
+
+vector double
+test (vector unsigned long long x)
+{
+  return vec_double (x);
+}
+
+/* { dg-final { scan-assembler-times "vcdlgb\t" 1 } } */
Index: gcc/testsuite/gcc.target/s390/zvector/vec-double-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/zvector/vec-double-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/s390/zvector/vec-double-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -march=z13 -mzvector" } */
+
+#include <vecintrin.h>
+
+vector double
+test (vector long long x)
+{
+  return vec_double (x);
+}
+
+/* { dg-final { scan-assembler-times "vcdgb\t" 1 } } */
Index: gcc/testsuite/gcc.target/s390/vector/vec-shift-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/vector/vec-shift-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/s390/vector/vec-shift-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,24 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -mzarch -march=z13 --save-temps" } */
+
+/* { dg-final { scan-assembler-times "veslf" 1 } } */
+
+typedef __attribute__((vector_size(16))) signed int v4si;
+
+v4si __attribute__((noinline,noclone))
+shift_left_by_scalar (v4si in, int shift_count)
+{
+  return in << (3 + shift_count);
+}
+
+int
+main ()
+{
+  v4si a = { 1, 2, 3, 4 };
+  v4si result = shift_left_by_scalar (a, 1);
+
+  if (result[1] != 32)
+    __builtin_abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/sparc/tls-ld-int64.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sparc/tls-ld-int64.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/sparc/tls-ld-int64.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,24 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" }
+/* { dg-add-options tls } */
+/* { dg-require-effective-target lp64 } */
+
+#include <stdint.h>
+
+__thread int64_t var1 __attribute__((tls_model("local-dynamic")));
+__thread int64_t var2 __attribute__((tls_model("local-dynamic")));
+
+int64_t sum (void)
+{
+  return var1 + var2;
+}
+
+void set (int64_t i)
+{
+  var1 = i;
+  var2 = i;
+}
+
+/* { dg-final { scan-assembler-times "__tls_get_addr" 2 } } */
+/* { dg-final { scan-assembler-times "ldx\t\[^\n\]*tldo_add" 2 } } */
+/* { dg-final { scan-assembler-times "stx\t\[^\n\]*tldo_add" 2 } } */
Index: gcc/testsuite/gcc.target/sparc/tls-ld-uint16.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sparc/tls-ld-uint16.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/sparc/tls-ld-uint16.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,33 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" }
+/* { dg-add-options tls } */
+
+#include <stdint.h>
+
+__thread uint16_t var1 __attribute__((tls_model("local-dynamic")));
+__thread uint16_t var2 __attribute__((tls_model("local-dynamic")));
+
+uint16_t sum (void)
+{
+  return var1 + var2;
+}
+
+uint32_t ext32_sum (void)
+{
+  return (uint32_t)var1 + (uint32_t)var2;
+}
+
+unsigned long ext_sum (void)
+{
+  return (unsigned long)var1 + (unsigned long)var2;
+}
+
+void set (uint16_t i)
+{
+  var1 = i;
+  var2 = i;
+}
+
+/* { dg-final { scan-assembler-times "__tls_get_addr" 4 } } */
+/* { dg-final { scan-assembler-times "lduh\t\[^\n\]*tldo_add" 6 } } */
+/* { dg-final { scan-assembler-times "sth\t\[^\n\]*tldo_add" 2 } } */
Index: gcc/testsuite/gcc.target/sparc/tls-ld-int32.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sparc/tls-ld-int32.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/sparc/tls-ld-int32.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,36 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" }
+/* { dg-add-options tls } */
+
+#include <stdint.h>
+
+__thread int32_t var1 __attribute__((tls_model("local-dynamic")));
+__thread int32_t var2 __attribute__((tls_model("local-dynamic")));
+
+int32_t sum (void)
+{
+  return var1 + var2;
+}
+
+#if defined(__sparcv9) || defined(__arch64__)
+long ext_sum (void)
+{
+  return (long)var1 + (long)var2;
+}
+#else
+void *addr (void)
+{
+  return &var1;
+}
+#endif
+
+void set (int32_t i)
+{
+  var1 = i;
+  var2 = i;
+}
+
+/* { dg-final { scan-assembler-times "__tls_get_addr" 3 } } */
+/* { dg-final { scan-assembler-times "ld\t\[^\n\]*tldo_add" 2 } } */
+/* { dg-final { scan-assembler-times "ldsw\t\[^\n\]*tldo_add" 2 { target lp64 } } } */
+/* { dg-final { scan-assembler-times "st\t\[^\n\]*tldo_add" 2 } } */
Index: gcc/testsuite/gcc.target/sparc/tls-ld-uint8.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sparc/tls-ld-uint8.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/sparc/tls-ld-uint8.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,38 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" }
+/* { dg-add-options tls } */
+
+#include <stdint.h>
+
+__thread uint8_t var1 __attribute__((tls_model("local-dynamic")));
+__thread uint8_t var2 __attribute__((tls_model("local-dynamic")));
+
+uint8_t sum (void)
+{
+  return var1 + var2;
+}
+
+uint16_t ext16_sum (void)
+{
+  return (uint16_t)var1 + (uint16_t)var2;
+}
+
+uint32_t ext32_sum (void)
+{
+  return (uint32_t)var1 + (uint32_t)var2;
+}
+
+unsigned long ext_sum (void)
+{
+  return (unsigned long)var1 + (unsigned long)var2;
+}
+
+void set (uint8_t i)
+{
+  var1 = i;
+  var2 = i;
+}
+
+/* { dg-final { scan-assembler-times "__tls_get_addr" 5 } } */
+/* { dg-final { scan-assembler-times "ldub\t\[^\n\]*tldo_add" 8 } } */
+/* { dg-final { scan-assembler-times "stb\t\[^\n\]*tldo_add" 2 } } */
Index: gcc/testsuite/gcc.target/sparc/tls-ld-int8.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sparc/tls-ld-int8.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/sparc/tls-ld-int8.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,39 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" }
+/* { dg-add-options tls } */
+
+#include <stdint.h>
+
+__thread int8_t var1 __attribute__((tls_model("local-dynamic")));
+__thread int8_t var2 __attribute__((tls_model("local-dynamic")));
+
+int8_t sum (void)
+{
+  return var1 + var2;
+}
+
+int16_t ext16_sum (void)
+{
+  return (int16_t)var1 + (int16_t)var2;
+}
+
+int32_t ext32_sum (void)
+{
+  return (int32_t)var1 + (int32_t)var2;
+}
+
+long ext_sum (void)
+{
+  return (long)var1 + (long)var2;
+}
+
+void set (int8_t i)
+{
+  var1 = i;
+  var2 = i;
+}
+
+/* { dg-final { scan-assembler-times "__tls_get_addr" 5 } } */
+/* { dg-final { scan-assembler-times "ldub\t\[^\n\]*tldo_add" 2 } } */
+/* { dg-final { scan-assembler-times "ldsb\t\[^\n\]*tldo_add" 6 } } */
+/* { dg-final { scan-assembler-times "stb\t\[^\n\]*tldo_add" 2 } } */
Index: gcc/testsuite/gcc.target/sparc/tls-ld-int16.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sparc/tls-ld-int16.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/sparc/tls-ld-int16.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,34 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" }
+/* { dg-add-options tls } */
+
+#include <stdint.h>
+
+__thread int16_t var1 __attribute__((tls_model("local-dynamic")));
+__thread int16_t var2 __attribute__((tls_model("local-dynamic")));
+
+int16_t sum (void)
+{
+  return var1 + var2;
+}
+
+int32_t ext32_sum (void)
+{
+  return (int32_t)var1 + (int32_t)var2;
+}
+
+long ext_sum (void)
+{
+  return (long)var1 + (long)var2;
+}
+
+void set (int16_t i)
+{
+  var1 = i;
+  var2 = i;
+}
+
+/* { dg-final { scan-assembler-times "__tls_get_addr" 4 } } */
+/* { dg-final { scan-assembler-times "lduh\t\[^\n\]*tldo_add" 2 } } */
+/* { dg-final { scan-assembler-times "ldsh\t\[^\n\]*tldo_add" 4 } } */
+/* { dg-final { scan-assembler-times "sth\t\[^\n\]*tldo_add" 2 } } */
Index: gcc/testsuite/gcc.target/sparc/tls-ld-uint32.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sparc/tls-ld-uint32.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/sparc/tls-ld-uint32.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,36 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" }
+/* { dg-add-options tls } */
+
+#include <stdint.h>
+
+__thread uint32_t var1 __attribute__((tls_model("local-dynamic")));
+__thread uint32_t var2 __attribute__((tls_model("local-dynamic")));
+
+uint32_t sum (void)
+{
+  return var1 + var2;
+}
+
+#if defined(__sparcv9) || defined(__arch64__)
+unsigned long ext_sum (void)
+{
+  return (unsigned long)var1 + (unsigned long)var2;
+}
+#else
+void *addr (void)
+{
+  return &var1;
+}
+#endif
+
+void set (int32_t i)
+{
+  var1 = i;
+  var2 = i;
+}
+
+/* { dg-final { scan-assembler-times "__tls_get_addr" 3 } } */
+/* { dg-final { scan-assembler-times "ld\t\[^\n\]*tldo_add" 2 } } */
+/* { dg-final { scan-assembler-times "lduw\t\[^\n\]*tldo_add" 2 { target lp64 } } } */
+/* { dg-final { scan-assembler-times "st\t\[^\n\]*tldo_add" 2 } } */
Index: gcc/testsuite/gcc.target/sparc/struct-ret-check-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sparc/struct-ret-check-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/sparc/struct-ret-check-1.c	(.../branches/gcc-7-branch)
@@ -7,7 +7,7 @@
 
 /* Origin: Carlos O'Donell <carlos@codesourcery.com> */
 /* { dg-do run { target sparc*-*-solaris* sparc*-*-linux* sparc*-*-*bsd* } } */
-/* { dg-options "-mstd-struct-return" } */
+/* { dg-options "-mstd-struct-return -fno-pie" } */
 /* { dg-require-effective-target ilp32 } */
 #include <stdio.h>
 #include <stdlib.h>
Index: gcc/testsuite/gcc.target/aarch64/pr90075.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/pr90075.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/pr90075.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-O1" } */
+
+typedef struct {
+  float one, two;
+} twofloats;
+
+float
+bug (twofloats tf)
+{
+  float f1, f2;
+  union {
+    twofloats tfloats;
+    float arr[2];
+  } utfloats;
+
+  utfloats.tfloats = tf;
+  f1 = utfloats.arr[1];
+  f2 = __builtin_copysignf (0, f1);
+  return f2;
+}
Index: gcc/testsuite/gcc.target/i386/pr89523-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-4.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-4.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,36 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -march=haswell" } */
+/* { dg-final { scan-assembler-not "\tvgather" } } */
+/* { dg-final { scan-assembler "addr32 vgather" } } */
+
+typedef double __v2df __attribute__ ((__vector_size__ (16)));
+typedef int __v4si __attribute__ ((__vector_size__ (16)));
+typedef long long __v2di __attribute__ ((__vector_size__ (16)));
+
+typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));
+typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));
+
+extern __inline __m128d
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm_i32gather_pd (double const *__base, __m128i __index, const int __scale)
+{
+  __v2df __zero = { 0.0, 0.0 };
+  __v2df __mask = __builtin_ia32_cmpeqpd (__zero, __zero);
+  __v2df x = x;
+
+  return (__m128d) __builtin_ia32_gathersiv2df (x,
+						__base,
+						(__v4si)__index,
+						__mask,
+						__scale);
+}
+
+__m128d x;
+__m128i idx;
+
+void extern
+avx2_test (void)
+{
+  x = _mm_i32gather_pd ((void *) 0, idx, 1);
+}
Index: gcc/testsuite/gcc.target/i386/pr89523-5.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-5.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-5.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,39 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512pf" } */
+/* { dg-final { scan-assembler "\tvgather" } } */
+/* { dg-final { scan-assembler-not "addr32 vgather" } } */
+
+typedef int __v8si __attribute__ ((__vector_size__ (32)));
+typedef long long __m256i __attribute__ ((__vector_size__ (32),
+					  __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_prefetch_i32gather_pd (__m256i __index, void const *__addr,
+			      int __scale, int __hint)
+{
+  __builtin_ia32_gatherpfdpd ((__mmask8) 0xFF, (__v8si) __index, __addr,
+			      __scale, __hint);
+}
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_mask_prefetch_i32gather_pd (__m256i __index, __mmask8 __mask,
+				   void const *__addr, int __scale, int __hint)
+{
+  __builtin_ia32_gatherpfdpd (__mask, (__v8si) __index, __addr, __scale,
+			      __hint);
+}
+
+volatile __m256i idx;
+volatile __mmask8 m8;
+void *base;
+
+void extern
+avx512pf_test (void)
+{
+  _mm512_prefetch_i32gather_pd (idx, base, 8, 3);
+  _mm512_mask_prefetch_i32gather_pd (idx, m8, base, 8, 3);
+}
Index: gcc/testsuite/gcc.target/i386/pr90547.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr90547.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr90547.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,21 @@
+/* PR target/90547 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void
+foo ()
+{
+  void *g[] = {&&a, &&b};
+
+  for (unsigned c = 0x1F;; c >>= 1)
+    {
+      unsigned d = (long)("a"+1);
+      long e = 8;
+
+      while (e)
+        {
+          a: goto *g[c&d];
+          b: e--;
+        }
+    }
+}
Index: gcc/testsuite/gcc.target/i386/pr89523-6.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-6.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-6.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,38 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512pf" } */
+/* { dg-final { scan-assembler-not "\tvgather" } } */
+/* { dg-final { scan-assembler "addr32 vgather" } } */
+
+typedef int __v8si __attribute__ ((__vector_size__ (32)));
+typedef long long __m256i __attribute__ ((__vector_size__ (32),
+					  __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_prefetch_i32gather_pd (__m256i __index, void const *__addr,
+			      int __scale, int __hint)
+{
+  __builtin_ia32_gatherpfdpd ((__mmask8) 0xFF, (__v8si) __index, __addr,
+			      __scale, __hint);
+}
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_mask_prefetch_i32gather_pd (__m256i __index, __mmask8 __mask,
+				   void const *__addr, int __scale, int __hint)
+{
+  __builtin_ia32_gatherpfdpd (__mask, (__v8si) __index, __addr, __scale,
+			      __hint);
+}
+
+volatile __m256i idx;
+volatile __mmask8 m8;
+
+void extern
+avx512pf_test (void)
+{
+  _mm512_prefetch_i32gather_pd (idx, (void *) 0, 8, 3);
+  _mm512_mask_prefetch_i32gather_pd (idx, m8, (void *) 0, 8, 3);
+}
Index: gcc/testsuite/gcc.target/i386/pr88938.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr88938.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr88938.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,5 @@
+/* PR target/88938 */
+/* { dg-do compile } */
+/* { dg-options "-Og -fno-tree-ccp -fno-tree-fre -mtbm" } */
+
+#include "tbm-bextri-1.c"
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fno-pic -fjump-tables" } */
 
 void func0 (void);
 void func1 (void);
Index: gcc/testsuite/gcc.target/i386/pr89523-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-7.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-7.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,42 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512f" } */
+/* { dg-final { scan-assembler "\tvscatter" } } */
+/* { dg-final { scan-assembler-not "addr32 vscatter" } } */
+
+typedef int __v8si __attribute__ ((__vector_size__ (32)));
+typedef double __v8df __attribute__ ((__vector_size__ (64)));
+typedef long long __m256i __attribute__ ((__vector_size__ (32),
+					  __may_alias__));
+typedef double __m512d __attribute__ ((__vector_size__ (64), __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_i32scatter_pd (void *__addr, __m256i __index, __m512d __v1,
+		      int __scale)
+{
+  __builtin_ia32_scattersiv8df (__addr, (__mmask8) 0xFF,
+				(__v8si) __index, (__v8df) __v1, __scale);
+}
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_mask_i32scatter_pd (void *__addr, __mmask8 __mask,
+			   __m256i __index, __m512d __v1, int __scale)
+{
+  __builtin_ia32_scattersiv8df (__addr, __mask, (__v8si) __index,
+				(__v8df) __v1, __scale);
+}
+
+volatile __m512d src;
+volatile __m256i idx;
+volatile __mmask8 m8;
+double *addr;
+
+void extern
+avx512f_test (void)
+{
+  _mm512_i32scatter_pd (addr, idx, src, 8);
+  _mm512_mask_i32scatter_pd (addr, m8, idx, src, 8);
+}
Index: gcc/testsuite/gcc.target/i386/pr89523-8.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-8.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-8.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,41 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512f" } */
+/* { dg-final { scan-assembler "\tvscatter" } } */
+/* { dg-final { scan-assembler-not "addr32 vscatter" } } */
+
+typedef long long __v8di __attribute__ ((__vector_size__ (64)));
+typedef double __v8df __attribute__ ((__vector_size__ (64)));
+typedef long long __m512i __attribute__ ((__vector_size__ (64), __may_alias__));
+typedef double __m512d __attribute__ ((__vector_size__ (64), __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_i64scatter_pd (void *__addr, __m512i __index, __m512d __v1,
+		      int __scale)
+{
+  __builtin_ia32_scatterdiv8df (__addr, (__mmask8) 0xFF,
+				(__v8di) __index, (__v8df) __v1, __scale);
+}
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_mask_i64scatter_pd (void *__addr, __mmask8 __mask,
+			   __m512i __index, __m512d __v1, int __scale)
+{
+  __builtin_ia32_scatterdiv8df (__addr, __mask, (__v8di) __index,
+				(__v8df) __v1, __scale);
+}
+
+volatile __m512d src;
+volatile __m512i idx;
+volatile __mmask8 m8;
+double *addr;
+
+void extern
+avx512f_test (void)
+{
+  _mm512_i64scatter_pd (addr, idx, src, 8);
+  _mm512_mask_i64scatter_pd (addr, m8, idx, src, 8);
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fno-pic -fjump-tables" } */
 
 void func0 (void);
 void func1 (void);
Index: gcc/testsuite/gcc.target/i386/pr89523-1a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-1a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-1a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,24 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-maddress-mode=short -mx32 -Ofast -funroll-loops -march=haswell" } */
+/* { dg-final { scan-assembler-not "\tvgather" } } */
+/* { dg-final { scan-assembler "addr32 vgather" } } */
+
+void foo (void);
+
+extern float *ncost;
+
+float
+bar (int type, int num)
+{
+  int i;
+  float cost;
+
+  cost = 0;
+  for (i = 0; i < num; i++)
+    if (type)
+      cost += ncost[i];
+    else
+      foo ();
+  return (cost);
+}
Index: gcc/testsuite/gcc.target/i386/pr89945.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89945.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89945.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,21 @@
+/* PR target/89945 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void
+foo ()
+{
+  void *g[] = {&&a, &&b};
+
+  for (unsigned c = 0x1F;; c >>= 1)
+    {
+      unsigned d = (long)"a";
+      long e = 8;
+
+      while (e)
+        {
+          a: goto *g[c&d];
+          b: e--;
+        }
+    }
+}
Index: gcc/testsuite/gcc.target/i386/pr89523-9.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-9.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-9.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,30 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512f" } */
+/* { dg-final { scan-assembler-not "\tvscatter" } } */
+/* { dg-final { scan-assembler "addr32 vscatter" } } */
+
+typedef int __v8si __attribute__ ((__vector_size__ (32)));
+typedef double __v8df __attribute__ ((__vector_size__ (64)));
+typedef long long __m256i __attribute__ ((__vector_size__ (32),
+					  __may_alias__));
+typedef double __m512d __attribute__ ((__vector_size__ (64), __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_i32scatter_pd (void *__addr, __m256i __index, __m512d __v1,
+		      int __scale)
+{
+  __builtin_ia32_scattersiv8df (__addr, (__mmask8) 0xFF,
+				(__v8si) __index, (__v8df) __v1, __scale);
+}
+
+volatile __m512d src;
+volatile __m256i idx;
+
+void extern
+avx512f_test (void)
+{
+  _mm512_i32scatter_pd ((void *) 0, idx, src, 8);
+}
Index: gcc/testsuite/gcc.target/i386/pr89523-1b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-1b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-1b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,7 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-maddress-mode=long -mx32 -Ofast -funroll-loops -march=haswell" } */
+/* { dg-final { scan-assembler-not "\tvgather" } } */
+/* { dg-final { scan-assembler "addr32 vgather" } } */
+
+#include "pr89523-1a.c"
Index: gcc/testsuite/gcc.target/i386/pr88948.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr88948.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr88948.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,5 @@
+/* PR rtl-optimization/88948 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fgcse-sm -msse3 -mfpmath=387" } */
+
+#include "../../gcc.c-torture/execute/stdarg-3.c"
Index: gcc/testsuite/gcc.target/i386/pr88418.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr88418.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr88418.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,15 @@
+/* PR target/88418 */
+/* { dg-do compile } */
+/* { dg-options "-O1 -fpack-struct -msse4.1 -mno-avx" } */
+
+typedef long long v2di __attribute__ ((__vector_size__ (16)));
+
+union df {
+  v2di se[2];
+};
+
+void
+qg (union df *jz, union df *pl)
+{
+  jz->se[0] = jz->se[0] == pl->se[0];
+}
Index: gcc/testsuite/gcc.target/i386/pr89523-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,37 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -march=haswell" } */
+/* { dg-final { scan-assembler "\tvgather" } } */
+/* { dg-final { scan-assembler-not "addr32 vgather" } } */
+
+typedef double __v2df __attribute__ ((__vector_size__ (16)));
+typedef int __v4si __attribute__ ((__vector_size__ (16)));
+typedef long long __v2di __attribute__ ((__vector_size__ (16)));
+
+typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));
+typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));
+
+extern __inline __m128d
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm_i32gather_pd (double const *__base, __m128i __index, const int __scale)
+{
+  __v2df __zero = { 0.0, 0.0 };
+  __v2df __mask = __builtin_ia32_cmpeqpd (__zero, __zero);
+  __v2df x = x;
+
+  return (__m128d) __builtin_ia32_gathersiv2df (x,
+						__base,
+						(__v4si)__index,
+						__mask,
+						__scale);
+}
+
+__m128d x;
+double *base;
+__m128i idx;
+
+void extern
+avx2_test (void)
+{
+  x = _mm_i32gather_pd (base, idx, 1);
+}
Index: gcc/testsuite/gcc.target/i386/pr86952.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr86952.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr86952.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mindirect-branch=thunk" } */
+
+int global;
+
+int
+foo (int x)
+{
+  switch (x & 7)
+    {
+      case 0: ; return 1722;
+      case 1: global += 1; return 1060;
+      case 2: ; return 1990;
+      case 3: ; return 1242;
+      case 4: ; return 1466;
+      case 5: ; return 894;
+      case 6: ; return 570;
+      case 7: ; return 572;
+      default: return 0;
+    }
+}
+
+/* { dg-final { scan-assembler-not "jmp\[ \t\]\\*" } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic -fjump-tables" } */
 
 void func0 (void);
 void func1 (void);
Index: gcc/testsuite/gcc.target/i386/pr89523-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-3.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,36 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -march=haswell" } */
+/* { dg-final { scan-assembler "\tvgather" } } */
+/* { dg-final { scan-assembler-not "addr32 vgather" } } */
+
+typedef double __v2df __attribute__ ((__vector_size__ (16)));
+typedef int __v4si __attribute__ ((__vector_size__ (16)));
+typedef long long __v2di __attribute__ ((__vector_size__ (16)));
+
+typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));
+typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));
+
+extern __inline __m128d
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm_i64gather_pd (double const *__base, __m128i __index, const int __scale)
+{
+  __v2df __zero = { 0.0, 0.0 };
+  __v2df __mask = __builtin_ia32_cmpeqpd (__zero, __zero);
+
+  return (__m128d) __builtin_ia32_gatherdiv2df (__zero,
+						__base,
+						(__v2di)__index,
+						__mask,
+						__scale);
+}
+
+__m128d x;
+double *base;
+__m128i idx;
+
+void extern
+avx2_test (void)
+{
+  x = _mm_i64gather_pd (base, idx, 1);
+}
Index: gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support-darwin.s
===================================================================
--- a/src/gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support-darwin.s	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support-darwin.s	(.../branches/gcc-7-branch)
@@ -0,0 +1,77 @@
+	.file	"asm-support-darwin.s"
+	.text
+	.p2align 4,,15
+	.globl _snapshot
+_snapshot:
+LFB3:
+	movq	%rax, _rax(%rip)
+	movq	%rbx, _rbx(%rip)
+	movq	%rcx, _rcx(%rip)
+	movq	%rdx, _rdx(%rip)
+	movq	%rdi, _rdi(%rip)
+	movq	%rsi, _rsi(%rip)
+	movq	%rbp, _rbp(%rip)
+	movq	%rsp, _rsp(%rip)
+	movq	%r8, _r8(%rip)
+	movq	%r9, _r9(%rip)
+	movq	%r10, _r10(%rip)
+	movq	%r11, _r11(%rip)
+	movq	%r12, _r12(%rip)
+	movq	%r13, _r13(%rip)
+	movq	%r14, _r14(%rip)
+	movq	%r15, _r15(%rip)
+	vmovdqu	%ymm0, _ymm_regs+0(%rip)
+	vmovdqu	%ymm1, _ymm_regs+32(%rip)
+	vmovdqu	%ymm2, _ymm_regs+64(%rip)
+	vmovdqu	%ymm3, _ymm_regs+96(%rip)
+	vmovdqu	%ymm4, _ymm_regs+128(%rip)
+	vmovdqu	%ymm5, _ymm_regs+160(%rip)
+	vmovdqu	%ymm6, _ymm_regs+192(%rip)
+	vmovdqu	%ymm7, _ymm_regs+224(%rip)
+	vmovdqu	%ymm8, _ymm_regs+256(%rip)
+	vmovdqu	%ymm9, _ymm_regs+288(%rip)
+	vmovdqu	%ymm10, _ymm_regs+320(%rip)
+	vmovdqu	%ymm11, _ymm_regs+352(%rip)
+	vmovdqu	%ymm12, _ymm_regs+384(%rip)
+	vmovdqu	%ymm13, _ymm_regs+416(%rip)
+	vmovdqu	%ymm14, _ymm_regs+448(%rip)
+	vmovdqu	%ymm15, _ymm_regs+480(%rip)
+	jmp	*_callthis(%rip)
+LFE3:
+	.p2align 4,,15
+	.globl _snapshot_ret
+_snapshot_ret:
+	movq	%rdi, _rdi(%rip)
+	subq	$8, %rsp
+	call	*_callthis(%rip)
+	addq	$8, %rsp
+	movq	%rax, _rax(%rip)
+	movq	%rdx, _rdx(%rip)
+	vmovdqu	%ymm0, _ymm_regs+0(%rip)
+	vmovdqu	%ymm1, _ymm_regs+32(%rip)
+	fstpt	_x87_regs(%rip)
+	fstpt	_x87_regs+16(%rip)
+	fldt	_x87_regs+16(%rip)
+	fldt	_x87_regs(%rip)
+	ret
+
+	.comm	_callthis,8,3
+	.comm	_rax,8,3
+	.comm	_rbx,8,3
+	.comm	_rcx,8,3
+	.comm	_rdx,8,3
+	.comm	_rsi,8,3
+	.comm	_rdi,8,3
+	.comm	_rsp,8,3
+	.comm	_rbp,8,3
+	.comm	_r8,8,3
+	.comm	_r9,8,3
+	.comm	_r10,8,3
+	.comm	_r11,8,3
+	.comm	_r12,8,3
+	.comm	_r13,8,3
+	.comm	_r14,8,3
+	.comm	_r15,8,3
+	.comm	_ymm_regs,512,5
+	.comm	_x87_regs,128,5
+	.comm   _volatile_var,8,3
Index: gcc/testsuite/lib/target-supports.exp
===================================================================
--- a/src/gcc/testsuite/lib/target-supports.exp	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/lib/target-supports.exp	(.../branches/gcc-7-branch)
@@ -2365,6 +2365,22 @@
     }]
 }
 
+# Return 1 if we're generating code for big-endian memory order.
+
+proc check_effective_target_be { } {
+    return [check_no_compiler_messages be object {
+	int dummy[__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ ? 1 : -1];
+    }]
+}
+
+# Return 1 if we're generating code for little-endian memory order.
+
+proc check_effective_target_le { } {
+    return [check_no_compiler_messages le object {
+	int dummy[__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ ? 1 : -1];
+    }]
+}
+
 # Return 1 if we're generating 32-bit code using default options, 0
 # otherwise.
 
Index: gcc/testsuite/gfortran.dg/pr85798.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr85798.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr85798.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,14 @@
+! { dg-do compile }
+program p
+   type t
+      integer, allocatable :: a(:)
+   end type
+   type u
+      real x
+      type(t) y
+   end type
+   type(t) :: z
+   type(u) :: q
+   data z%a(1) / 789 /     ! { dg-error "Allocatable component" }
+   data q%y%a(1) / 789 /   ! { dg-error "Allocatable component" }
+end
Index: gcc/testsuite/gfortran.dg/pr89077.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr89077.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr89077.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,11 @@
+! { dg-do run }
+!
+! PR fortran/89077 - ICE using * as len specifier for character parameter
+
+program test
+  implicit none
+  integer :: i
+  character(*), parameter :: s = 'abcdef'
+  character(*), parameter :: t = transfer ([(s(i:i), i=1,len(s))], s)
+  if (len (t) /= len (s) .or. t /= s) stop 1
+end
Index: gcc/testsuite/gfortran.dg/dec_structure_15.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/dec_structure_15.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/dec_structure_15.f90	(.../branches/gcc-7-branch)
@@ -1,4 +1,4 @@
-! { dg-do "compile" }
+! { dg-do compile }
 ! { dg-options "" }
 !
 ! PR fortran/77584
Index: gcc/testsuite/gfortran.dg/c_funptr_1_mod.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/c_funptr_1_mod.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/c_funptr_1_mod.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,16 @@
+! { dg-do  run }
+! { dg-additional-sources c_funptr_1.f90 }
+! Additional module to go with c_funptr_1.f90
+module win32_types
+  use, intrinsic :: iso_c_binding, only: C_INT,C_FUNPTR
+  implicit none
+  private
+
+  public WNDCLASSEX_T
+  type, bind(C) :: WNDCLASSEX_T
+     integer(C_INT) :: cbSize
+     type(C_FUNPTR) :: lpfnWndProc
+
+  end type WNDCLASSEX_T
+
+end module win32_types
Index: gcc/testsuite/gfortran.dg/warn_undefined_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/warn_undefined_1.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/warn_undefined_1.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,28 @@
+! { dg-do compile }
+! { dg-options "-O2 -Wuninitialized" }
+! PR 67679 - this used to cause an undefined warning for
+! variables generated by the compiler.
+
+subroutine s(h, Gmin, r)
+
+   implicit none
+   real, intent(in) ::  Gmin(3), h(3)
+   integer, intent(inout) :: r
+
+   integer :: x_min(3), x_max(3), k, iStat
+   logical, dimension(:), allocatable :: check
+
+   do k = 1,1
+      x_min(k) = int(Gmin(k)*h(k))
+      x_max(k) = int(Gmin(k)*h(k))
+   end do
+
+   allocate(check(x_min(1):x_max(1)),stat=iStat)
+
+   check(:) = .false.
+
+   do k = x_min(1),x_max(1)
+            r = r + 1
+   end do
+
+end
Index: gcc/testsuite/gfortran.dg/pr88169_2.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr88169_2.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr88169_2.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,31 @@
+! { dg-do run }
+module foo_nml
+   implicit none
+   real :: x = -1
+   namelist /foo/ x
+end module
+!
+! Yes, implicit typing of local variable 'x'.
+!
+program main
+   use foo_nml, only: bar => foo
+   integer fd
+   x = 42
+   open(newunit=fd, file='tmp.dat', status='replace')
+   write(fd,nml=bar)
+   close(fd)
+   open(newunit=fd, file='tmp.dat', status='old')
+   read(fd,nml=bar)
+   close(fd)
+   call bah
+   if (x /= 42) stop 1
+end program
+
+subroutine bah
+   use foo_nml
+   integer fd
+   open(newunit=fd, file='tmp.dat', status='old')
+   read(fd,nml=foo)
+   if (x /= -1) stop 2
+   close(fd, status='delete')
+end subroutine bah
Index: gcc/testsuite/gfortran.dg/pr35031.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr35031.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr35031.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,10 @@
+! { dg-do compile }
+elemental subroutine sub2(x)
+   integer, intent(in) :: x
+   entry sub2_c(x) bind(c)    ! { dg-error "prohibited in an elemental" }
+end subroutine sub2
+
+elemental function func2(x)
+   integer, intent(in) :: x
+   entry func2_c(x) bind(c)   ! { dg-error "prohibited in an elemental" }
+end function func2
Index: gcc/testsuite/gfortran.dg/c_funptr_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/c_funptr_1.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/c_funptr_1.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,38 @@
+! { dg-do preprocess }
+! { dg-additional-options "-cpp" }
+! PR 57048 - this used not to compile. Original test case by Angelo
+! Graziosi.  Only works if compiled c_funptr_1_mod.f90, hence the
+! do-nothing directive above.
+module procs
+  
+  implicit none
+  private
+
+  public WndProc
+
+contains
+  function WndProc()
+    integer :: WndProc
+    
+    WndProc = 0
+  end function WndProc
+end module procs
+
+function WinMain()
+  use, intrinsic :: iso_c_binding, only: C_INT,c_sizeof,c_funloc
+  use win32_types
+  use procs
+  implicit none
+
+  integer :: WinMain
+
+  type(WNDCLASSEX_T) :: WndClass
+
+  WndClass%cbSize = int(c_sizeof(Wndclass),C_INT)
+  WndClass%lpfnWndProc = c_funloc(WndProc)
+
+  WinMain = 0
+end function WinMain
+
+program main
+end 
Index: gcc/testsuite/gfortran.dg/c_ptr_tests_19.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/c_ptr_tests_19.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/c_ptr_tests_19.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,36 @@
+! { dg-do run }
+
+! PR 71544 - this failed with some optimization options due to a
+! pointer not being marked as escaping.
+
+module store_cptr
+    use, intrinsic :: iso_c_binding
+    implicit none
+    public
+    type(c_ptr), save :: cptr
+end module store_cptr
+
+subroutine init()
+    use, intrinsic :: iso_c_binding
+    implicit none
+    integer(c_int), pointer :: a
+    allocate(a)
+    call save_cptr(c_loc(a))
+    a = 100
+end subroutine init
+
+subroutine save_cptr(cptr_in)
+    use store_cptr
+    implicit none
+    type(c_ptr), intent(in) :: cptr_in
+    cptr = cptr_in
+end subroutine save_cptr
+
+program init_fails
+    use store_cptr
+    implicit none
+    integer(c_int), pointer :: val
+    call init()
+    call c_f_pointer(cptr,val)
+    if (val /= 100) stop 1
+end program init_fails
Index: gcc/testsuite/gfortran.dg/public_private_module_10.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/public_private_module_10.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/public_private_module_10.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! PR 87734 - this used to issue spurious errors.
+
+module m_vstring
+  implicit none
+
+  public :: vstring_length
+
+contains
+
+  subroutine vstring_cast()
+    character ( len = vstring_length() ) :: char_string
+  end subroutine
+
+  pure integer function vstring_length ()
+  end function
+
+end module
Index: gcc/testsuite/gfortran.dg/proc_ptr_51.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/proc_ptr_51.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/proc_ptr_51.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,38 @@
+! { dg-do run }
+!
+! Test the fix for PR90786.
+!
+! Contributed by Andrew benson  <abensonca@gmail.com>
+!
+module f
+procedure(c), pointer :: c_
+
+ type :: s
+   integer :: i = 42
+ end type s
+ class(s), pointer :: res, tgt
+
+contains
+
+ function c()
+   implicit none
+   class(s), pointer ::  c
+   c => tgt
+   return
+ end function c
+
+ subroutine fs()
+   implicit none
+   c_ => c  ! This used to ICE
+   return
+ end subroutine fs
+
+end module f
+
+  use f
+  allocate (tgt, source = s(99))
+  call fs()
+  res => c_()
+  if (res%i .ne. 99) stop 1
+  deallocate (tgt)
+end
Index: gcc/testsuite/gfortran.dg/dependency_53.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/dependency_53.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/dependency_53.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,25 @@
+! { dg-do run }
+! PR fortran/66089 - used to ICE and, after that ICE was fixed,
+! gave wrong results.
+  type :: t
+    integer :: c
+  end type t
+
+  class(t), dimension(:), allocatable :: b,c
+
+  allocate (b(5), source=t(7))
+  allocate(c(5), source=t(13))
+  c = plus(c(1), b)
+  if (any(c%c /= 20)) stop 1
+  c = t(13)
+  c = plus(b, c(1))
+  if (any(c%c /= 20)) stop 2
+contains
+
+  elemental function plus(lhs, rhs)
+    class(t), intent(in) :: lhs, rhs
+    type(t)             :: plus
+    plus%c = lhs%c + rhs%c
+  end function plus
+
+end
Index: gcc/testsuite/gfortran.dg/debug/pr35154-stabs.f
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/debug/pr35154-stabs.f	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/debug/pr35154-stabs.f	(.../branches/gcc-7-branch)
@@ -1,7 +1,7 @@
 C     Test program for common block debugging.  G. Helffrich 11 July 2004.
 C { dg-do compile }
 C { dg-skip-if "No stabs" { aarch64*-*-* mmix-*-* alpha*-*-* hppa*64*-*-* ia64-*-* *-*-vxworks* } { "*" } { "" } }
-C { dg-skip-if "No stabs" {*-*-* } { "*" } { "-gstabs" } }
+C { dg-skip-if "No stabs" { *-*-* } { "*" } { "-gstabs" } }
       common i,j
       common /label/l,m
       i = 1
Index: gcc/testsuite/gfortran.dg/binding_label_tests_30.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/binding_label_tests_30.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/binding_label_tests_30.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! Make sure this error is flagged.
+subroutine foo() ! { dg-error "is already being used as a SUBROUTINE" }
+end subroutine foo
+
+subroutine bar() bind(C,name="foo") ! { dg-error "is already being used as a SUBROUTINE" }
+end subroutine bar
Index: gcc/testsuite/gfortran.dg/pr88155.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr88155.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr88155.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,9 @@
+! { dg-do compile }
+program p
+   type t
+      integer :: a
+   end type
+   type(t) :: x
+   data x /t()1/     ! { dg-error "No initializer for component" }
+   print *, x
+end
Index: gcc/testsuite/gfortran.dg/associate_44.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/associate_44.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/associate_44.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,23 @@
+! { dg-do compile }
+!
+! Test the fix for PR56386
+!
+! Contributed by Vladimir Fuka  <vladimir.fuka@gmail.com>
+!
+subroutine  CustomSolidBodies
+   implicit none
+
+    type inner
+      real :: elev
+    end type
+
+    type :: outer
+      type(inner),dimension(0) :: PrPoints
+    end type
+
+    type(outer) :: SB
+
+    associate (Prter=>SB%PrPoints)
+       PrTer%elev=0                  ! ICE here
+    end associate
+end subroutine  CustomSolidBodies
Index: gcc/testsuite/gfortran.dg/warn_conversion_10.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/warn_conversion_10.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/warn_conversion_10.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! { dg-options "-fno-range-check -Wconversion" }
+! PR 88298 - this used to warn unnecessarily.  Original test case by
+! Harald Anlauf.
+subroutine bug (j, js)
+  integer    :: j, js(3,2)
+  js(:,:) = cshift (js(:,:), shift=j, dim=1)
+end subroutine bug
Index: gcc/testsuite/gfortran.dg/pr85797.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr85797.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr85797.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,31 @@
+! { dg-do compile }
+! PR fortran/83515 - ICE: Invalid expression in gfc_element_size 
+! PR fortran/85797 - ICE in gfc_element_size, at fortran/target-memory.c:126
+! PR fortran/89904 - ICE in gfortran starting with r270045
+
+recursive subroutine a
+  c = transfer (a, b)           ! { dg-error "'SOURCE' argument of 'TRANSFER'" }
+end
+
+recursive subroutine d
+  c = transfer (b, d)           ! { dg-error "'MOLD' argument of 'TRANSFER'" }
+end
+
+subroutine f
+  use, intrinsic :: iso_c_binding
+  integer(c_intptr_t) :: b, c
+  procedure(), pointer :: a
+  c = transfer (a, b)
+  c = transfer (transfer (b, a), b)
+end
+
+module m
+contains
+  function f () result (z)
+    class(*), pointer :: z
+  end function f
+  recursive subroutine s (q)
+    procedure(f) :: q
+    call s (q)
+  end subroutine s
+end
Index: gcc/testsuite/gfortran.dg/dec_structure_14.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/dec_structure_14.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/dec_structure_14.f90	(.../branches/gcc-7-branch)
@@ -1,4 +1,4 @@
-  ! { dg-do "compile" }
+  ! { dg-do compile }
   ! { dg-options "-fdec-structure" }
   !
   ! Test that structures inside a common block do not require the
Index: gcc/testsuite/gfortran.dg/pr90344.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr90344.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr90344.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,25 @@
+! { dg-do compile }
+! { dg-additional-options "-ffrontend-optimize" }
+! PR 90344 - this used to ICE.
+! Test case by Urban Jost.
+module M_xterm
+contains
+   elemental function func1(ch) result(res)
+      character,intent(in) :: ch
+      logical              :: res
+      res=.true.
+   end function func1
+   elemental function func2(ch) result(res)
+      character,intent(in) :: ch
+      logical              :: res
+      res=.false.
+   end function func2
+   pure function s2a(string)  RESULT (array)
+      character(len=*),intent(in) :: string
+      character(len=1)            :: array(len(string))
+      forall(i=1:len(string)) array(i) = string(i:i)
+   end function s2a
+   subroutine sub1()
+      write(*,*)all(func1(s2a('ABCDEFG')).or.func2(s2a('ABCDEFG')))
+   end subroutine sub1
+end module M_xterm
Index: gcc/testsuite/gfortran.dg/coarray_data_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/coarray_data_1.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/coarray_data_1.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,11 @@
+! { dg-do  run }
+! { dg-options "-fcoarray=lib -lcaf_single " }
+! PR 71066 - this used to ICE
+program p
+   real :: a(2,2)[*]
+   integer :: b(2,2)[*]
+   data a /4*0.0/
+   data b /1234, 2345, 3456, 4567/
+   if (any (a /= 0.0)) stop 1
+   if (any (b /= reshape([1234, 2345, 3456, 4567],[2,2]))) stop 2
+end
Index: gcc/testsuite/gfortran.dg/pr88169_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr88169_1.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr88169_1.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,21 @@
+! { dg-do run }
+module foo_nml
+   implicit none
+   real :: x = -1
+   namelist /foo/ x
+end module
+
+program main
+   use foo_nml, only: bar => foo, x
+   implicit none
+   integer fd
+   x = 42
+   open(newunit=fd, file='tmp.dat', status='replace')
+   write(fd,nml=bar)
+   close(fd)
+   open(newunit=fd, file='tmp.dat', status='old')
+   read(fd,nml=bar)
+   if (x /= 42) stop 1
+   close(fd)
+end program
+! { dg-final { cleanup-modules "foo_nml" } }
Index: gcc/testsuite/gfortran.dg/pr89253.f
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr89253.f	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr89253.f	(.../branches/gcc-7-branch)
@@ -0,0 +1,19 @@
+! { dg-do compile }
+! { dg-additional-options "-fsplit-loops -fno-tree-dominator-opts -std=legacy -w" }
+      program jr
+      integer :: w5, pg, zh
+      w5 = 0
+      write (w5)
+      assign 0002 to w5
+      do pg = 1, 3
+         if (pg .eq. 1) then
+            do zh = 1, pg
+            end do
+         else
+            goto w5
+ 0001       zh = 0
+ 0002       zh = 0
+            assign 0001 to w5
+         endif
+      end do
+      end
Index: gcc/testsuite/gfortran.dg/coarray_allocate_11.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/coarray_allocate_11.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/coarray_allocate_11.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,15 @@
+! { dg-do compile }
+! { dg-additional-options -fcoarray=single }
+program p
+   integer, allocatable :: z[:,:]
+   integer :: i
+   allocate (z[1:,*]) ! { dg-error "Bad array specification in ALLOCATE statement" }
+   allocate (z[:2,*]) ! { dg-error "Bad array specification in ALLOCATE statement" }
+   allocate (z[2:1,*]) ! { dg-error "Upper cobound is less than lower cobound" }
+   allocate (z[:0,*]) ! { dg-error "Bad array specification in ALLOCATE statement" }
+   allocate (z[0,*]) ! { dg-error "Upper cobound is less than lower cobound" }
+   allocate (z[1,*]) ! This is OK
+   allocate (z[1:1,*]) ! This is OK
+   allocate (z[i:i,*]) ! This is OK
+   allocate (z[i:i-1,*]) ! { dg-error "Upper cobound is less than lower cobound" }
+end
Index: gcc/testsuite/gfortran.dg/pr51434.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr51434.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr51434.f90	(.../branches/gcc-7-branch)
@@ -6,7 +6,7 @@
    character(len=1), parameter :: s(n) = 'a'
    type :: a
       integer :: m = n
-      character(len=1):: t(n) = transfer('abcde             ', s)
+      character(len=1):: t(n) = transfer('abcde', s)
    end type a
 end module foo
 
Index: gcc/testsuite/gfortran.dg/pr88269.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr88269.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr88269.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,6 @@
+! { dg-do compile }
+! PR fortran/88269
+program p
+   write (end=1e1) ! { dg-error "tag not allowed" }
+end
+
Index: gcc/testsuite/gfortran.dg/ieee/ieee.exp
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/ieee/ieee.exp	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/ieee/ieee.exp	(.../branches/gcc-7-branch)
@@ -22,15 +22,15 @@
 load_lib gfortran-dg.exp
 load_lib target-supports.exp
 
-# Initialize `dg'.
-dg-init
-
-# Flags specified in each test
+# If a testcase doesn't have special options, use these.
 global DEFAULT_FFLAGS
 if ![info exists DEFAULT_FFLAGS] then {
-    set DEFAULT_FFLAGS ""
+    set DEFAULT_FFLAGS " -pedantic-errors"
 }
 
+# Initialize `dg'.
+dg-init
+
 # Flags for finding the IEEE modules
 if [info exists TOOL_OPTIONS] {
    set specpath [get_multilibs ${TOOL_OPTIONS}]
Index: gcc/testsuite/gfortran.dg/null_10.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/null_10.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/null_10.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! PR 71860 - this used to ICE
+! Original test case by Gerhard Steinmetz
+program p
+   class(*), pointer :: z
+   z => null(z)
+end
Index: gcc/testsuite/gfortran.dg/binding_label_tests_33.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/binding_label_tests_33.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/binding_label_tests_33.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,39 @@
+! { dg-do run }
+! PR 79485 - used to crash because the wrong routine was called.
+module fmod1
+
+  contains
+
+  subroutine foo(i)
+    implicit none
+
+    integer, intent(inout) :: i
+
+    i=i+1
+
+  end subroutine foo
+
+end module fmod1
+
+module fmod2
+  use iso_c_binding
+  use fmod1, only : foo_first => foo
+
+  contains
+
+  subroutine foo(i) bind(c)
+    implicit none
+
+    integer, intent(inout) :: i
+
+    i=i+2
+    call foo_first(i)
+
+  end subroutine foo
+
+end module fmod2
+
+  use fmod2
+  
+  call foo(i)
+end
Index: gcc/testsuite/gfortran.dg/charlen_17.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/charlen_17.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/charlen_17.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,14 @@
+! { dg-do compile }
+! PR 87673 - used to cause errors about non-pure functions.
+
+module x
+  implicit none
+contains
+  pure function foo() result(res)
+    character(len=:), allocatable :: res
+    allocate (character(bar()) :: res)
+  end function foo
+  pure integer function bar()
+    bar = 1
+  end function bar
+end module x
Index: gcc/testsuite/gfortran.dg/coarray_lock_7.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/coarray_lock_7.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/coarray_lock_7.f90	(.../branches/gcc-7-branch)
@@ -35,8 +35,8 @@
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_lock \\(caf_token.., 0, 0, 0B, 0B, 0B, 0\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_unlock \\(caf_token.., 0, 0, 0B, 0B, 0\\);" 1 "original" } }
 
-! { dg-final { scan-tree-dump-times "_gfortran_caf_lock \\(caf_token.., \\(3 - \\(integer\\(kind=4\\)\\) parm...dim\\\[0\\\].lbound\\) \\+ \\(integer\\(kind=4\\)\\) MAX_EXPR <\\(parm...dim\\\[0\\\].ubound - parm...dim\\\[0\\\].lbound\\) \\+ 1, 0> \\* \\(3 - \\(integer\\(kind=4\\)\\) parm...dim\\\[1\\\].lbound\\), 0, 0B, &ii, 0B, 0\\);|_gfortran_caf_lock \\(caf_token.1, \\(3 - parm...dim\\\[0\\\].lbound\\) \\+ MAX_EXPR <\\(parm...dim\\\[0\\\].ubound - parm...dim\\\[0\\\].lbound\\) \\+ 1, 0> \\* \\(3 - parm...dim\\\[1\\\].lbound\\), 0, 0B, &ii, 0B, 0\\);" 1 "original" } }
-! { dg-final { scan-tree-dump-times "_gfortran_caf_unlock \\(caf_token.., \\(2 - \\(integer\\(kind=4\\)\\) parm...dim\\\[0\\\].lbound\\) \\+ \\(integer\\(kind=4\\)\\) MAX_EXPR <\\(parm...dim\\\[0\\\].ubound - parm...dim\\\[0\\\].lbound\\) \\+ 1, 0> \\* \\(3 - \\(integer\\(kind=4\\)\\) parm...dim\\\[1\\\].lbound\\), 0, &ii, 0B, 0\\);|_gfortran_caf_unlock \\(caf_token.., \\(2 - parm...dim\\\[0\\\].lbound\\) \\+ MAX_EXPR <\\(parm...dim\\\[0\\\].ubound - parm...dim\\\[0\\\].lbound\\) \\+ 1, 0> \\* \\(3 - parm...dim\\\[1\\\].lbound\\), 0, &ii, 0B, 0\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "_gfortran_caf_lock \\(caf_token.., \\(3 - \\(integer\\(kind=4\\)\\) parm....dim\\\[0\\\].lbound\\) \\+ \\(integer\\(kind=4\\)\\) MAX_EXPR <\\(parm....dim\\\[0\\\].ubound - parm....dim\\\[0\\\].lbound\\) \\+ 1, 0> \\* \\(3 - \\(integer\\(kind=4\\)\\) parm....dim\\\[1\\\].lbound\\), 0, 0B, &ii, 0B, 0\\);|_gfortran_caf_lock \\(caf_token.1, \\(3 - parm....dim\\\[0\\\].lbound\\) \\+ MAX_EXPR <\\(parm....dim\\\[0\\\].ubound - parm....dim\\\[0\\\].lbound\\) \\+ 1, 0> \\* \\(3 - parm....dim\\\[1\\\].lbound\\), 0, 0B, &ii, 0B, 0\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "_gfortran_caf_unlock \\(caf_token.., \\(2 - \\(integer\\(kind=4\\)\\) parm....dim\\\[0\\\].lbound\\) \\+ \\(integer\\(kind=4\\)\\) MAX_EXPR <\\(parm....dim\\\[0\\\].ubound - parm....dim\\\[0\\\].lbound\\) \\+ 1, 0> \\* \\(3 - \\(integer\\(kind=4\\)\\) parm....dim\\\[1\\\].lbound\\), 0, &ii, 0B, 0\\);|_gfortran_caf_unlock \\(caf_token.., \\(2 - parm....dim\\\[0\\\].lbound\\) \\+ MAX_EXPR <\\(parm....dim\\\[0\\\].ubound - parm....dim\\\[0\\\].lbound\\) \\+ 1, 0> \\* \\(3 - parm....dim\\\[1\\\].lbound\\), 0, &ii, 0B, 0\\);" 1 "original" } }
 
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_lock \\(three.token, 0, 5 - \\(integer\\(kind=4\\)\\) three.dim\\\[0\\\].lbound, &acquired.\[0-9\]+, 0B, 0B, 0\\);|_gfortran_caf_lock \\(three.token, 0, 5 - three.dim\\\[0\\\].lbound, &acquired.\[0-9\]+, 0B, 0B, 0\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_unlock \\(three.token, 0, 8 - \\(integer\\(kind=4\\)\\) three.dim\\\[0\\\].lbound, &ii, 0B, 0\\);|_gfortran_caf_unlock \\(three.token, 0, 8 - three.dim\\\[0\\\].lbound, &ii, 0B, 0\\);" 1 "original" } }
Index: gcc/testsuite/gfortran.dg/pr88206.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr88206.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr88206.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/88206
+program p
+   integer, parameter :: z(4) = [1,2,3,4]
+   integer :: k = 2
+   print *, [real(z(k))]
+end
+
Index: gcc/testsuite/gfortran.dg/pointer_init_2.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pointer_init_2.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pointer_init_2.f90	(.../branches/gcc-7-branch)
@@ -18,7 +18,7 @@
   integer, pointer :: dp0 => 13  ! { dg-error "Error in pointer initialization" }
   integer, pointer :: dp1 => r   ! { dg-error "Different types in pointer assignment" }
   integer, pointer :: dp2 => v   ! { dg-error "Different ranks in pointer assignment" }
-  integer, pointer :: dp3 => i   ! { dg-error "is neither TARGET nor POINTER" }
+  integer, pointer :: dp3 => i   ! { dg-error "Pointer assignment target in initialization expression does not have the TARGET attribute" }
   integer, pointer :: dp4 => j   ! { dg-error "must have the SAVE attribute" }
   integer, pointer :: dp5 => a   ! { dg-error "must not be ALLOCATABLE" }
 
@@ -35,7 +35,7 @@
   end type t3
 
   type t4
-    integer, pointer :: dpc3 => i   ! { dg-error "Pointer assignment target is neither TARGET nor POINTER" }
+    integer, pointer :: dpc3 => i   ! { dg-error "Pointer assignment target in initialization expression does not have the TARGET attribute" }
   end type t4
 
   type t5
Index: gcc/testsuite/gfortran.dg/deferred_character_32.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/deferred_character_32.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/deferred_character_32.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,13 @@
+! { dg-do run }
+!
+! Test the fix for PR88117.
+!
+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>
+!
+program p
+   character(:), pointer :: z(:)
+   allocate (z, source  = ['abcd', 'bcde'])
+   z = (z) ! gimplifier choked here.
+   if (any (z .ne. ['abcd', 'bcde'])) stop 1
+   deallocate (z)
+end
Index: gcc/testsuite/gfortran.dg/class_66.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/class_66.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/class_66.f90	(.../branches/gcc-7-branch)
@@ -1,4 +1,4 @@
-! { dg- do run }
+! { dg-do run }
 !
 ! Test the fix for PR78641 in which an ICE occured on assignment
 ! of a class array constructor to a derived type array.
Index: gcc/testsuite/gfortran.dg/dg.exp
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/dg.exp	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/dg.exp	(.../branches/gcc-7-branch)
@@ -36,7 +36,7 @@
     global gfortran_test_path
     global gfortran_aux_module_flags
     if { [llength $args] != 2 } {
-	error "dg-set-target-env-var: needs one argument"
+	error "dg-compile-aux-modules: needs one argument"
 	return
     }
 
Index: gcc/testsuite/gfortran.dg/pointer_init_6.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pointer_init_6.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pointer_init_6.f90	(.../branches/gcc-7-branch)
@@ -13,7 +13,7 @@
  integer, target :: i
  type(t), target :: x
  integer, pointer :: p1 => i
- integer, pointer :: p2 => p1   ! { dg-error "must have the TARGET attribute" }
+ integer, pointer :: p2 => p1   ! { dg-error "Pointer assignment target in initialization expression does not have the TARGET attribute at" }
  integer, pointer :: p3 => x%p  ! { dg-error "must have the TARGET attribute" }
  integer, pointer :: p4 => x%i
  integer, pointer :: p5 => u    ! { dg-error "has no IMPLICIT type" }
Index: gcc/testsuite/gfortran.dg/pr88228.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr88228.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr88228.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! { dg-options "-fdec" }
+! PR fortran/88228
+program p
+   integer :: n = .not. 1
+   integer :: j = .true. .or. 1
+end
+
Index: gcc/testsuite/gfortran.dg/pr78259.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr78259.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr78259.f90	(.../branches/gcc-7-branch)
@@ -1,4 +1,4 @@
-! { dg-do "compile" }
+! { dg-do compile }
 ! { dg-options "-fdec-structure" }
 !
 ! PR fortran/78259
Index: gcc/testsuite/gfortran.dg/finalize_28.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/finalize_28.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/finalize_28.f90	(.../branches/gcc-7-branch)
@@ -21,4 +21,4 @@
     integer, intent(out) :: edges(:,:)
   end subroutine coo_dump_edges
 end module coo_graphs
-! { dg-final { scan-tree-dump-times "__builtin_free" 6 "original" } }
+! { dg-final { scan-tree-dump-times "__builtin_free" 5 "original" } }
Index: gcc/testsuite/gfortran.dg/pr70870_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr70870_1.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr70870_1.f90	(.../branches/gcc-7-branch)
@@ -1,4 +1,5 @@
 ! { dg-do compile }
+! { dg-options "-std=gnu" }
 ! PR fortran/70870
 ! Contributed by Vittorio Zecca <zeccav at gmail dot com >
       type t
Index: gcc/testsuite/gfortran.dg/altreturn_9_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/altreturn_9_1.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/altreturn_9_1.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! { dg-options "-std=gnu" }
+! See altreturn_9_0.f90
+subroutine sub(i, *, j)
+  if (i == 10 .and. j == 20) return 1
+  return
+end subroutine sub
Index: gcc/testsuite/gfortran.dg/power_7.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/power_7.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/power_7.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,27 @@
+! { dg-do run }
+! { dg-additional-options "-fdump-tree-original" }
+! PR 85544 - this used to ICE.
+program p
+   integer, parameter :: na = -3, ne = 10
+   integer :: i, a(na:ne), b(na:ne)
+   integer :: v
+   a = [(i, i=na, ne)]
+   b = [2**a]
+   if (any (b /= [0,0,0,1,2,4,8,16,32,64,128,256,512,1024])) stop 1
+   b = [1**a]
+   if (any (b /= 1)) stop 2
+   b = [(-1)**a]
+   if (any (b /= [-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1]) )stop 3
+   b = [8**a]
+   if (any (b /= [0,0,0,1,8,64,512,4096,32768,262144,2097152,16777216,&
+        134217728,1073741824])) stop 4
+   b = [4**a]
+   if (any (b /= [0,0,0,1,4,16,64,256,1024,4096,16384,65536,262144,1048576])) stop 5
+   
+   v = 1
+   do i=1,6
+      v = v * 16
+      if (v /= 16**i) stop 6 
+   end do
+ end program p
+! { dg-final { scan-tree-dump-not "_gfortran_pow" "original" } }
Index: gcc/testsuite/gfortran.dg/binding_label_tests_32.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/binding_label_tests_32.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/binding_label_tests_32.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,35 @@
+! { dg-do run }
+! PR 77746 - this used to crash during execution.
+! Original test case by Vladimir Fuka.
+module first
+  private
+  public execute
+  
+  interface execute
+    module procedure random_name
+  end interface
+  
+contains
+
+  subroutine random_name()
+  end subroutine
+end module
+
+module test
+  use first
+
+  implicit none
+
+contains
+
+  subroutine p_execute(i)  bind(C, name="random_name")
+    integer :: i
+
+    call execute()
+  end subroutine
+  
+end module
+
+  use test
+  call p_execute(1)
+end
Index: gcc/testsuite/gfortran.dg/array_function_5.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/array_function_5.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/array_function_5.f90	(.../branches/gcc-7-branch)
@@ -1,4 +1,4 @@
-! {  dg-do run }
+! { dg-do run }
 ! PR41278 internal compiler error related to matmul and transpose
 ! Test case prepared by Jerry DeLisle  <jvdelisle@gcc.gnu.org>
 ! Original test case by Chris <cmklaij@hetnet.nl>
Index: gcc/testsuite/gfortran.dg/pr81849.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr81849.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr81849.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,16 @@
+! { dg-do run }
+! PR fortran/81849
+program p
+   implicit none
+   integer  :: n=3
+   if (any(g() /= f())) stop 1
+   contains
+      function g()
+         real g(n)
+         g = 7
+      end function g
+      function f() result(r)
+         real r(n)
+         r = 7
+      end function f
+end program
Index: gcc/testsuite/gfortran.dg/dec_structure_12.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/dec_structure_12.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/dec_structure_12.f90	(.../branches/gcc-7-branch)
@@ -1,4 +1,4 @@
-! { dg-do "compile" }
+! { dg-do compile }
 ! { dg-options "-fdec-structure" }
 !
 ! Test a regression where multiple anonymous structures failed to
Index: gcc/testsuite/gfortran.dg/select_type_46.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/select_type_46.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/select_type_46.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,21 @@
+! { dg-do compile }
+!
+! Tests the fix for PR82077
+!
+! Contributed by Damian Rouson  <damian@sourceryinstitute.org>
+!
+    type parent
+    end type parent
+    type, extends(parent) :: child
+    end type
+    class(parent), allocatable :: foo(:,:)
+    allocate(child::foo(1,1))
+    select type(foo)
+      class is (child)
+        call gfortran7_ICE(foo(1,:))  ! ICEd here.
+    end select
+contains
+    subroutine gfortran7_ICE(bar)
+      class(child) bar(:)
+    end subroutine
+end
Index: gcc/testsuite/gfortran.dg/ptr_func_assign_5.f08
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/ptr_func_assign_5.f08	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/ptr_func_assign_5.f08	(.../branches/gcc-7-branch)
@@ -0,0 +1,45 @@
+! { dg-do run }
+!
+! Test the fix for PR77703, in which calls of the pointer function
+! caused an ICE in 'gfc_trans_auto_character_variable'.
+!
+! Contributed by Gerhard Steinmetz  <gerhard.steinmetz.fortran@t-online.de>
+!
+module m
+   implicit none
+   private
+   integer, parameter, public :: n = 2
+   integer, parameter :: ell = 6
+
+   character(len=n*ell), target, public :: s
+
+   public :: t
+contains
+   function t( idx ) result( substr )
+      integer, intent(in) :: idx
+      character(len=ell), pointer  :: substr
+
+      if ( (idx < 0).or.(idx > n) ) then
+         error stop
+      end if
+      substr => s((idx-1)*ell+1:idx*ell)
+   end function t
+end module m
+
+program p
+   use m, only : s, t, n
+   integer :: i
+
+   ! Define 's'
+   s = "123456789012"
+
+   ! Then perform operations involving 't'
+   if (t(1) .ne. "123456") stop 1
+   if (t(2) .ne. "789012") stop 2
+
+   ! Do the pointer function assignments
+   t(1) = "Hello "
+   if (s .ne. "Hello 789012") Stop 3
+   t(2) = "World!"
+   if (s .ne. "Hello World!") Stop 4
+end program p
Index: gcc/testsuite/gfortran.dg/alloc_comp_assign_16.f03
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/alloc_comp_assign_16.f03	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/alloc_comp_assign_16.f03	(.../branches/gcc-7-branch)
@@ -0,0 +1,37 @@
+! { dg-do run }
+!
+! Test the fix for PR88393 in which a segfault occurred as indicated.
+!
+! Contributed by Janus Weil  <janus@gcc.gnu.org>
+!
+module m
+   implicit none
+   type :: t
+      character(len=:), allocatable :: cs
+   contains
+      procedure :: ass
+      generic :: assignment(=) => ass
+   end type
+contains
+   subroutine ass(a, b)
+      class(t), intent(inout) :: a
+      class(t), intent(in)    :: b
+      a%cs = b%cs
+      print *, "ass"
+   end subroutine
+end module
+
+program p
+   use m
+   implicit none
+   type :: t2
+      type(t) :: c
+   end type
+   type(t2), dimension(1:2) :: arr
+   arr(1)%c%cs = "abcd"
+   arr(2)%c = arr(1)%c  ! Segfault here.
+   print *, "done", arr(2)%c%cs, arr(2)%c%cs
+! Make sure with valgrind that there are no memory leaks.
+   deallocate (arr(1)%c%cs)
+   deallocate (arr(2)%c%cs)
+end
Index: gcc/testsuite/gfortran.dg/pr88205.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr88205.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr88205.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,14 @@
+! { dg-do compile }
+! PR fortran/88205
+subroutine s1
+   real, parameter :: status = 0
+   open (newunit=n, status=status)        ! { dg-error "STATUS requires" }
+end
+subroutine s2
+   complex, parameter :: status = 0
+   open (newunit=n, status=status)        ! { dg-error "STATUS requires" }
+end
+program p
+  logical, parameter :: status = .false.
+  open (newunit=a, status=status)         ! { dg-error "STATUS requires" }
+end
Index: gcc/testsuite/gfortran.dg/interface_abstract_5.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/interface_abstract_5.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/interface_abstract_5.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,32 @@
+! { dg-do compile }
+!
+! PR 71861: [7/8/9 Regression] [F03] ICE in write_symbol(): bad module symbol
+!
+! Contributed by Gerhard Steinmetz <gerhard.steinmetz.fortran@t-online.de>
+
+module m1
+   intrinsic abs
+   abstract interface
+      function abs(x)    ! { dg-error "ABSTRACT attribute conflicts with INTRINSIC attribute" }
+         real :: abs, x
+      end
+   end interface
+end
+
+module m2
+   abstract interface
+      function abs(x)
+         real :: abs, x
+      end
+   end interface
+   intrinsic abs    ! { dg-error "ABSTRACT attribute conflicts with INTRINSIC attribute" }
+end
+
+module m3
+   abstract interface
+      function f(x)
+         real :: f, x
+      end
+   end interface
+   intrinsic f    ! { dg-error "ABSTRACT attribute conflicts with INTRINSIC attribute" }
+end
Index: gcc/testsuite/gfortran.dg/pr58968.f
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr58968.f	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr58968.f	(.../branches/gcc-7-branch)
@@ -1,5 +1,5 @@
 C PR rtl-optimization/58968.f
-C { dg-do compile { target powerpc*-*-*} }
+C { dg-do compile { target powerpc*-*-* } }
 C { dg-options "-mcpu=power7 -O3 -w -ffast-math  -funroll-loops" }
       SUBROUTINE MAKTABS(IW,SOME,LBOX1,LBOX2,LBOX3,NSPACE,NA,NB,
      *            LBST,X,
Index: gcc/testsuite/gfortran.dg/extends_11.f03
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/extends_11.f03	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/extends_11.f03	(.../branches/gcc-7-branch)
@@ -37,4 +37,4 @@
   recruit%service%education%person%ss = 9
 end
 
-! { dg-final { scan-tree-dump-times " +recruit\\.service\\.education\\.person\\.ss =" 8 "original"} }
+! { dg-final { scan-tree-dump-times " +recruit\\.service\\.education\\.person\\.ss =" 8 "original" } }
Index: gcc/testsuite/gfortran.dg/coarray/caf.exp
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/coarray/caf.exp	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/coarray/caf.exp	(.../branches/gcc-7-branch)
@@ -51,11 +51,21 @@
     global gfortran_test_path
     global gfortran_aux_module_flags
     if { [llength $args] != 2 } {
-	error "dg-set-target-env-var: needs one argument"
+	error "dg-compile-aux-modules: needs one argument"
 	return
     }
+
+    set level [info level]
+    if { [info procs dg-save-unknown] != [list] } {
+	rename dg-save-unknown dg-save-unknown-level-$level
+    }
+
     dg-test $gfortran_test_path/[lindex $args 1] "" $gfortran_aux_module_flags
-    # cleanup-modules isn't intentionally invoked here.
+    # cleanup-modules is intentionally not invoked here.
+
+    if { [info procs dg-save-unknown-level-$level] != [list] } {
+	rename dg-save-unknown-level-$level dg-save-unknown
+    }
 }
 
 # Add -latomic only where supported.  Assume built-in support elsewhere.
Index: gcc/testsuite/gfortran.dg/coarray/event_3.f08
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/coarray/event_3.f08	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/coarray/event_3.f08	(.../branches/gcc-7-branch)
@@ -3,9 +3,9 @@
 ! Check PR fortran/70696 is fixed.
 
 program global_event
-  use iso_fortran_env , only : event_type
+  use iso_fortran_env, only : event_type
   implicit none
-  type(event_type) :: x[*]
+  type(event_type), save :: x[*]
   
   call exchange
   contains
Index: gcc/testsuite/gfortran.dg/lto/20091028-1_0.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/lto/20091028-1_0.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/lto/20091028-1_0.f90	(.../branches/gcc-7-branch)
@@ -1,5 +1,5 @@
 ! { dg-lto-do link }
-! { dg-extra-ld-options "-r -nostdlib -finline-functions" }
+! { dg-extra-ld-options "-r -nostdlib -finline-functions -Wno-lto-type-mismatch" }
 
 SUBROUTINE int_gen_ti_header_char( hdrbuf, hdrbufsize, itypesize, &
                               DataHandle, Element, VarName, Data, code )
Index: gcc/testsuite/gfortran.dg/lto/20091028-2_0.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/lto/20091028-2_0.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/lto/20091028-2_0.f90	(.../branches/gcc-7-branch)
@@ -1,5 +1,5 @@
 ! { dg-lto-do link }
-! { dg-extra-ld-options "-r -nostdlib -finline-functions" }
+! { dg-extra-ld-options "-r -nostdlib -finline-functions -Wno-lto-type-mismatch" }
 
 SUBROUTINE int_gen_ti_header_char( hdrbuf, hdrbufsize, itypesize, &
                               DataHandle, Element, VarName, Data, code )
Index: gcc/testsuite/gfortran.dg/lto/pr87689_0.f
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/lto/pr87689_0.f	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/lto/pr87689_0.f	(.../branches/gcc-7-branch)
@@ -0,0 +1,13 @@
+! { dg-lto-run }
+! PR 87689 - this used to fail for POWER, plus it used to
+! give warnings about mismatches with LTO.
+! Original test case by Judicaël Grasset.
+      program main
+        implicit none
+        character :: c
+        character(len=20) :: res, doesntwork_p8
+        external doesntwork_p8
+        c = 'o'
+        res = doesntwork_p8(c,1,2,3,4,5,6)
+        if (res /= 'foo') stop 3
+      end program main
Index: gcc/testsuite/gfortran.dg/lto/pr87689_1.f
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/lto/pr87689_1.f	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/lto/pr87689_1.f	(.../branches/gcc-7-branch)
@@ -0,0 +1,11 @@
+      function doesntwork_p8(c,a1,a2,a3,a4,a5,a6)
+        implicit none
+        character(len=20) :: doesntwork_p8
+        character :: c
+        integer :: a1,a2,a3,a4,a5,a6
+        if (a1 /= 1 .or. a2 /= 2 .or. a3 /= 3 .or. a4 /= 4 .or. a5 /= 5
+     &       .or. a6 /= 6) stop 1
+       if (c /= 'o ') stop 2
+       doesntwork_p8 = 'foo'
+       return
+       end
Index: gcc/testsuite/gfortran.dg/pr88169_3.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr88169_3.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr88169_3.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,15 @@
+! { dg-do compile }
+! { dg-options "-std=f95" }
+module foo_nml
+   implicit none
+   real :: x = -1
+   namelist /foo/ x
+end module
+
+program main
+   use foo_nml, only: bar => foo, x
+   implicit none
+   real a
+   namelist /bar/a  ! { dg-error "already is USE associated" }
+end program
+! { dg-final { cleanup-modules "foo_nml" } }
Index: gcc/testsuite/gfortran.dg/finalize_34.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/finalize_34.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/finalize_34.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,25 @@
+! { dg-do compile }
+! { dg-additional-options "-fdump-tree-original" }
+! PR 87352 - this used to cause an excessive number of deallocations.
+module testmodule
+  implicit none
+  public
+
+  type :: evtlist_type
+     real,  allocatable, dimension(:) :: p1
+     real,  allocatable, dimension(:) :: p2
+     real,  allocatable, dimension(:) :: p3
+     real,  allocatable, dimension(:) :: p4
+  end type evtlist_type
+
+  type :: evtlistlist_type
+     type(evtlist_type)  :: evtlist(1:1)
+  end type evtlistlist_type
+
+end module testmodule 
+
+program main
+  use testmodule
+  type(evtlist_type), dimension(10) :: a
+end program main
+! { dg-final  { scan-tree-dump-times "__builtin_free" 8 "original" } }
Index: gcc/testsuite/gfortran.dg/no_arg_check_2.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/no_arg_check_2.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/no_arg_check_2.f90	(.../branches/gcc-7-branch)
@@ -139,7 +139,7 @@
 ! { dg-final { scan-tree-dump-times "sub_scalar .\\(struct t1 .\\) array_class_t1_alloc._data.data" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_scalar .\\(struct t1 .\\) \\(array_class_t1_ptr._data.dat" 1 "original" } }
 
-! { dg-final { scan-tree-dump-times "sub_array_assumed \\(D" 3 "original" } }
+! { dg-final { scan-tree-dump-times "sub_array_assumed \\(D" 4 "original" } }
 ! { dg-final { scan-tree-dump-times " = _gfortran_internal_pack \\(&parm" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(&array_int\\)" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(real\\(kind=4\\).0:. . restrict\\) array_real_alloc.data" 1 "original" } }
@@ -148,5 +148,5 @@
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) parm" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t2.0:. . restrict\\) array_t2_alloc.data\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. . restrict\\) array_class_t1_alloc._data.data\\);" 1 "original" } }
-! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) array_class_t1_ptr._data.data\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) array_class_t1_ptr._data.data\\);" 0 "original" } }
 
Index: gcc/testsuite/gfortran.dg/pointer_init_9.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pointer_init_9.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pointer_init_9.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! PR 71237 - this used to ICE.
+module data_mod
+  implicit none
+
+  type data_t
+    integer :: i
+  end type
+
+  type(data_t), pointer :: data
+  integer, pointer :: idata => data%i ! { dg-error "Pointer assignment target in initialization expression does not have the TARGET attribute" }
+
+end module
Index: gcc/testsuite/gfortran.dg/pr68318_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr68318_1.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr68318_1.f90	(.../branches/gcc-7-branch)
@@ -1,5 +1,5 @@
 ! { dg-do compile }
-! { dg-options "-O0"
+! { dg-options "-O0" }
 ! PR fortran/68318
 ! Original code submitted by Gerhard Steinmetz
 ! <gerhard dot steinmetz dot fortran at t-online dot de>
Index: gcc/testsuite/gfortran.dg/pr77583.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr77583.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr77583.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,10 @@
+! { dg-do compile }
+!
+! PR fortran/77583 - ICE in pp_quoted_string, at pretty-print.c:966
+! Contributed by Gerhard Steinmetz <gerhard.steinmetz.fortran@t-online.de>
+
+pure subroutine sub(s)
+contains
+   pure subroutine s  ! { dg-error "conflicts with DUMMY argument" }
+   end
+end
Index: gcc/testsuite/gfortran.dg/pr88249.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr88249.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr88249.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,7 @@
+! { dg-do compile }
+program p
+   backspace (err=1) ! { dg-error "UNIT number missing" }
+   endfile (err=1)   ! { dg-error "UNIT number missing" }
+   flush (err=1)     ! { dg-error "UNIT number missing" }
+   rewind (err=1)    ! { dg-error "UNIT number missing" }
+end
Index: gcc/testsuite/gfortran.dg/blockdata_11.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/blockdata_11.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/blockdata_11.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,33 @@
+! { dg-do run }
+! PR 84394 - this used to complain about private procedures in
+! BLOCK data.
+module mod1
+   implicit none
+   type :: type1
+      integer :: i1
+   end type type1
+end module
+
+module mod2
+   implicit none
+   contains
+      subroutine sub1
+         integer vals
+         common /block1/ vals(5)
+         if (any(vals /= [1, 2, 3, 4, 5])) stop 1
+      end subroutine
+end module
+
+block data blkdat
+  use mod1
+  integer vals
+  common /block1/ vals(5)
+  data vals/1, 2, 3, 4, 5/
+end block data blkdat
+
+program main
+  use mod2, only: sub1
+  implicit none
+  call sub1
+end program
+
Index: gcc/testsuite/gfortran.dg/altreturn_9_0.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/altreturn_9_0.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/altreturn_9_0.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,10 @@
+! { dg-do  run }
+! { dg-options -std=gnu }
+! { dg-additional-sources altreturn_9_1.f90 }
+! PR 89496 - wrong type for alternate return was generated
+
+program main
+  call sub(10, *10, 20)
+  stop 1
+10 continue
+end program main
Index: gcc/testsuite/gfortran.dg/submodule_30.f08
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/submodule_30.f08	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/submodule_30.f08	(.../branches/gcc-7-branch)
@@ -0,0 +1,42 @@
+! { dg-do run }
+!
+! Test the fix for PR82550 in which the reference to 'p' in 'foo'
+! was not being correctly handled.
+!
+! Contributed by Reinhold Bader  <Bader@lrz.de>
+!
+module m_subm_18_pos
+  implicit none
+  integer :: i = 0
+  interface
+    module subroutine foo(fun_ptr)
+      procedure(p), pointer, intent(out) :: fun_ptr
+    end subroutine
+  end interface
+contains
+  subroutine p()
+    i = 1
+  end subroutine p
+end module m_subm_18_pos
+submodule (m_subm_18_pos) subm_18_pos
+    implicit none
+contains
+    module subroutine foo(fun_ptr)
+      procedure(p), pointer, intent(out) :: fun_ptr
+      fun_ptr => p
+    end subroutine
+end submodule
+program p_18_pos
+  use m_subm_18_pos
+  implicit none
+  procedure(), pointer :: x
+  call foo(x)
+  call x()
+  if (i == 1) then
+     write(*,*) 'OK'
+  else
+     write(*,*) 'FAIL'
+     STOP 1
+  end if
+end program p_18_pos
+
Index: gcc/testsuite/gfortran.dg/binding_label_tests_31.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/binding_label_tests_31.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/binding_label_tests_31.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,19 @@
+! { dg-do compile }
+! PR fortran/66695 - this used to ICE.
+! Original test case by Vladimir Fuka.
+module mod
+  implicit none
+contains
+    integer function F()
+    end function
+end module
+    
+module mod_C
+  use mod
+  implicit none
+contains
+  subroutine s()  bind(C, name="f")
+    integer :: x
+      x = F()
+  end subroutine
+end module
Index: gcc/testsuite/gfortran.dg/pr88138.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr88138.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr88138.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,9 @@
+! { dg-do compile }
+program p
+   type t
+      character :: c = 'c'
+   end type
+   type(t), parameter :: x  = 1.e1  ! { dg-error "Incompatible initialization between a" }s
+   print *, 'a' // x%c
+end
+! { dg-prune-output "has no IMPLICIT type" }
Index: gcc/testsuite/gfortran.dg/select_type_45.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/select_type_45.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/select_type_45.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,22 @@
+! { dg-do compile }
+!
+! Tests the fix for PR80260
+!
+! Contributed by Damian Rouson  <damian@sourceryinstitute.org>
+!
+    type foo
+    end type foo
+    type, extends(foo) :: bar
+    end type
+contains
+    subroutine f(x)
+      class(foo) x(:,:)
+      select type(x)
+        class is (bar)
+          call g(x(1,:))   ! ICEd here.
+      end select
+    end subroutine
+    subroutine g(y)
+      class(bar) y(:)
+    end subroutine
+end
Index: gcc/testsuite/gfortran.dg/assumed_type_2.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/assumed_type_2.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/assumed_type_2.f90	(.../branches/gcc-7-branch)
@@ -157,7 +157,7 @@
 ! { dg-final { scan-tree-dump-times "sub_scalar .\\(struct t1 .\\) array_class_t1_alloc._data.data" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_scalar .\\(struct t1 .\\) \\(array_class_t1_ptr._data.dat" 1 "original" } }
 
-! { dg-final { scan-tree-dump-times "sub_array_assumed \\(D" 3 "original" } }
+! { dg-final { scan-tree-dump-times "sub_array_assumed \\(D" 4 "original" } }
 ! { dg-final { scan-tree-dump-times " = _gfortran_internal_pack \\(&parm" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(&array_int\\)" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(real\\(kind=4\\).0:. . restrict\\) array_real_alloc.data" 1 "original" } }
@@ -166,7 +166,7 @@
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) parm" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t2.0:. . restrict\\) array_t2_alloc.data\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. . restrict\\) array_class_t1_alloc._data.data\\);" 1 "original" } }
-! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) array_class_t1_ptr._data.data\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) array_class_t1_ptr._data.data\\);" 0 "original" } }
 
 ! { dg-final { scan-tree-dump-times "sub_array_shape \\(&array_real_alloc," 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_shape \\(&array_char_ptr," 1 "original" } }
Index: gcc/testsuite/gcc.c-torture/execute/20190820-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/20190820-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/20190820-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,111 @@
+/* PR rtl-optimization/91347 */
+/* Reported by John David Anglin <danglin@gcc.gnu.org> */
+
+typedef unsigned short __u16;
+typedef __signed__ int __s32;
+typedef unsigned int __u32;
+typedef __signed__ long long __s64;
+typedef unsigned long long __u64;
+typedef __u16 u16;
+typedef __s32 s32;
+typedef __u32 u32;
+typedef __u64 u64;
+typedef _Bool bool;
+typedef s32 int32_t;
+typedef u32 uint32_t;
+typedef u64 uint64_t;
+
+char hex_asc_upper[16];
+u16 decpair[100];
+
+static __attribute__((noinline, noclone)) void
+put_dec_full4 (char *buf, unsigned r)
+{
+ unsigned q;
+ q = (r * 0x147b) >> 19;
+ *((u16 *)buf) = decpair[r - 100*q];
+ buf += 2;
+ *((u16 *)buf) = decpair[q];
+}
+
+static __attribute__((noinline, noclone)) unsigned
+put_dec_helper4 (char *buf, unsigned x)
+{
+  uint32_t q = (x * (uint64_t)0x346DC5D7) >> 43;
+  put_dec_full4(buf, x - q * 10000);
+  return q;
+}
+
+static __attribute__((noinline, noclone)) char *
+put_dec (char *buf, unsigned long long n)
+{
+ uint32_t d3, d2, d1, q, h;
+ d1 = ((uint32_t)n >> 16);
+ h = (n >> 32);
+ d2 = (h ) & 0xffff;
+ d3 = (h >> 16);
+ q = 656 * d3 + 7296 * d2 + 5536 * d1 + ((uint32_t)n & 0xffff);
+ q = put_dec_helper4(buf, q);
+ q += 7671 * d3 + 9496 * d2 + 6 * d1;
+ q = put_dec_helper4(buf+4, q);
+ q += 4749 * d3 + 42 * d2;
+ q = put_dec_helper4(buf+8, q);
+ return buf;
+}
+
+struct printf_spec {
+ unsigned int type:8;
+ signed int field_width:24;
+ unsigned int flags:8;
+ unsigned int base:8;
+ signed int precision:16;
+} __attribute__((__packed__));
+
+static __attribute__((noinline, noclone)) char *
+number (char *buf, char *end, unsigned long long num, struct printf_spec spec)
+{
+
+ char tmp[3 * sizeof(num)] __attribute__((__aligned__(2)));
+ char sign;
+ char locase;
+ int need_pfx = ((spec.flags & 64) && spec.base != 10);
+ int i;
+ bool is_zero = num == 0LL;
+ int field_width = spec.field_width;
+ int precision = spec.precision;
+
+ i = 0;
+ if (num < spec.base)
+  tmp[i++] = hex_asc_upper[num] | locase;
+ else if (spec.base != 10) {
+  int mask = spec.base - 1;
+  int shift = 3;
+  if (spec.base == 16)
+   shift = 4;
+  else
+    __builtin_abort ();
+  do {
+   tmp[i++] = (hex_asc_upper[((unsigned char)num) & mask] | locase);
+   num >>= shift;
+  } while (num);
+ } else {
+  i = put_dec(tmp, num) - tmp;
+ }
+ return buf;
+}
+
+static __attribute__((noinline, noclone)) char *
+pointer_string (char *buf, char *end, const void *ptr, struct printf_spec spec)
+{
+ spec.base = 16;
+ spec.flags = 0;
+ return number(buf, end, 100, spec);
+}
+
+int
+main (void)
+{
+  struct printf_spec spec;
+  char *s = pointer_string (0, 0, 0, spec);
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr90949.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr90949.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr90949.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,42 @@
+void __attribute__ ((noipa, noinline)) my_puts (const char *str) { }
+
+void __attribute__ ((noipa, noinline)) my_free (void *p) { }
+
+
+struct Node
+{
+  struct Node *child;
+};
+
+struct Node space[2] = { };
+
+struct Node * __attribute__ ((noipa, noinline)) my_malloc (int bytes)
+{
+  return &space[0];
+}
+
+void
+walk (struct Node *module, int cleanup)
+{
+  if (module == 0)
+    {
+      return;
+    }
+  if (!cleanup)
+    {
+      my_puts ("No cleanup");
+    }
+  walk (module->child, cleanup);
+  if (cleanup)
+    {
+      my_free (module);
+    }
+}
+
+int
+main ()
+{
+  struct Node *node = my_malloc (sizeof (struct Node));
+  node->child = 0;
+  walk (node, 1);
+}
Index: gcc/testsuite/gcc.c-torture/execute/builtins/builtins.exp
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/builtins/builtins.exp	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/builtins/builtins.exp	(.../branches/gcc-7-branch)
@@ -37,7 +37,7 @@
 torture-init
 set-torture-options $C_TORTURE_OPTIONS {{}} $LTO_TORTURE_OPTIONS
 
-set additional_flags "-fno-tree-loop-distribute-patterns -fno-tracer"
+set additional_flags "-fno-tree-loop-distribute-patterns -fno-tracer -fno-ipa-ra"
 if [istarget "powerpc-*-darwin*"] {
    lappend additional_flags "-Wl,-multiply_defined,suppress"
 }
Index: gcc/testsuite/gcc.c-torture/execute/pr88739.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr88739.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr88739.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,59 @@
+/* PR tree-optimization/88739 */
+#if __SIZEOF_SHORT__ == 2 &&  __SIZEOF_INT__ == 4 && __CHAR_BIT__ == 8
+struct A
+{
+  unsigned int a, b, c;
+  unsigned int d : 30;
+  unsigned int e : 2;
+};
+
+union U
+{
+  struct A f;
+  unsigned int g[4];
+  unsigned short h[8];
+  unsigned char i[16];
+};
+volatile union U v = { .f.d = 0x4089 };
+
+__attribute__((noipa)) void
+bar (int x)
+{
+  static int i;
+  switch (i++)
+    {
+    case 0: if (x != v.f.d) __builtin_abort (); break;
+    case 1: if (x != v.f.e) __builtin_abort (); break;
+    case 2: if (x != v.g[3]) __builtin_abort (); break;
+    case 3: if (x != v.h[6]) __builtin_abort (); break;
+    case 4: if (x != v.h[7]) __builtin_abort (); break;
+    default: __builtin_abort (); break;
+    }
+}
+
+void
+foo (unsigned int x)
+{
+  union U u;
+  u.f.d = x >> 2;
+  u.f.e = 0;
+  bar (u.f.d);
+  bar (u.f.e);
+  bar (u.g[3]);
+  bar (u.h[6]);
+  bar (u.h[7]);
+}
+
+int
+main ()
+{
+  foo (0x10224);
+  return 0;
+}
+#else
+int
+main ()
+{
+  return 0;
+}
+#endif
Index: gcc/testsuite/gnat.dg/opt73.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt73.adb	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gnat.dg/opt73.adb	(.../branches/gcc-7-branch)
@@ -0,0 +1,34 @@
+-- { dg-do run }
+-- { dg-options "-O" }
+
+procedure Opt73 is
+
+   type Terminal_Set_Indexed_By_Non_Terminal is
+     array (Natural range <>, Natural  range <>) of Boolean with Pack;
+
+   type Terminal_Set_Per_Non_Terminal
+     (Last_Terminal     : Natural;
+      Last_Non_Terminal : Natural) is
+   record
+      Map : Terminal_Set_Indexed_By_Non_Terminal
+        (1 .. Last_Non_Terminal, 0 .. Last_Terminal);
+   end record;
+
+   Follow : Terminal_Set_Per_Non_Terminal (5, 4);
+   Expect : Terminal_Set_Per_Non_Terminal :=
+     (5, 4, (1 => (2 => True, others => False),
+             others => (others => False)));
+
+   procedure Get_Follow (Value : out Terminal_Set_Per_Non_Terminal) is
+   begin
+      Value.Map := (others => (others => False));
+      Value.Map (1, 2) := True;
+      Value.Map (2, 0) := Value.Map (2, 0) or Value.Map (1, 0);
+   end;
+
+begin
+   Get_Follow (Follow);
+   if Follow /= Expect then
+      raise Program_Error;
+   end if;
+end;
Index: gcc/testsuite/gnat.dg/opt75.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt75.adb	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gnat.dg/opt75.adb	(.../branches/gcc-7-branch)
@@ -0,0 +1,9 @@
+-- { dg-do run }
+-- { dg-options "-O3" }
+
+with Opt75_Pkg; use Opt75_Pkg;
+
+procedure Opt75 is
+begin
+  null;
+end;
Index: gcc/testsuite/gnat.dg/opt76.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt76.adb	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gnat.dg/opt76.adb	(.../branches/gcc-7-branch)
@@ -0,0 +1,36 @@
+-- { dg-do run }
+-- { dg-options "-O2 -gnatp -fno-omit-frame-pointer" }
+
+procedure Opt76 is
+
+   type Integer_Access is access Integer;
+   type Registry_Array is array (Natural range <>) of Integer_Access;
+
+   procedure Nested (Input, Parser : Integer; A, B : Boolean) is
+
+      Index : Registry_Array (1 .. 1024);
+      Not_B : constant Boolean := not B;
+
+      procedure Inner (Input : Integer) is
+      begin
+         if Input /= 1 then
+            raise Program_Error;
+         end if;
+
+         if Parser = 128 and then A and then Not_B then
+            Inner (Input);
+            Index (Index'First) := null;
+         end if;
+      end;
+
+   begin
+      Inner (Input);
+   end;
+
+   Input : Integer := 1 with Volatile;
+   Parser : Integer := 2 with Volatile;
+      
+begin
+   Nested (Input, Parser, False, True);
+   Nested (Input, Parser, True, False);
+end;
Index: gcc/testsuite/gnat.dg/opt79.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt79.adb	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gnat.dg/opt79.adb	(.../branches/gcc-7-branch)
@@ -0,0 +1,28 @@
+-- { dg-do compile }
+-- { dg-options "-O" }
+
+package body Opt79 is
+
+  function F (I : Integer) return Arr is
+    A : Arr;
+
+    procedure Nested is
+
+      procedure Inner is
+      begin
+        A (1) := 0;
+      end;
+
+    begin
+       Inner;
+    end;
+
+  begin
+    Nested;
+    for J in A'Range loop
+      A (J) := I;
+    end loop;
+    return A;
+  end;
+
+end Opt79;
Index: gcc/testsuite/gnat.dg/opt79.ads
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt79.ads	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gnat.dg/opt79.ads	(.../branches/gcc-7-branch)
@@ -0,0 +1,7 @@
+package Opt79 is
+
+  type Arr is array (1 .. 8) of Integer;
+
+  function F (I : Integer) return Arr;
+
+end Opt79;
Index: gcc/testsuite/gnat.dg/opt75_pkg.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt75_pkg.adb	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gnat.dg/opt75_pkg.adb	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+package body Opt75_Pkg is
+
+  overriding procedure Adjust (Object : in out T) is
+  begin
+    if Object.Ref /= Empty_Rec'Access then
+      System.Atomic_Counters.Increment (Object.Ref.Counter);
+    end if;
+  end;
+
+  A : constant Arr := (others => (others => Empty));
+
+end Opt75_Pkg;
Index: gcc/testsuite/gnat.dg/opt75_pkg.ads
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt75_pkg.ads	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gnat.dg/opt75_pkg.ads	(.../branches/gcc-7-branch)
@@ -0,0 +1,27 @@
+pragma Restrictions (No_Abort_Statements);
+pragma Restrictions (Max_Asynchronous_Select_Nesting => 0);
+
+with Ada.Finalization;
+with System.Atomic_Counters;
+
+package Opt75_Pkg is
+
+  type Rec is record
+    Counter : System.Atomic_Counters.Atomic_Counter;
+  end record;
+
+  type Rec_Ptr is access all Rec;
+
+  Empty_Rec : aliased Rec;
+
+  type T is new Ada.Finalization.Controlled with record
+    Ref : Rec_Ptr := Empty_Rec'Access;
+  end record;
+
+  overriding procedure Adjust (Object : in out T);
+
+  Empty : constant T := (Ada.Finalization.Controlled with Ref => Empty_Rec'Access);
+
+  type Arr is array (Integer range 1 .. 8, Integer range 1 .. 4) of T;
+
+end Opt75_Pkg;
Index: gcc/testsuite/gnat.dg/array34.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/array34.adb	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gnat.dg/array34.adb	(.../branches/gcc-7-branch)
@@ -0,0 +1,22 @@
+--  { dg-do run }
+
+procedure Array34 is
+
+  type Arr is array (1 .. 6) of Short_Short_Integer;
+  for Arr'Alignment use 4;
+
+  type Rec is record
+    A : Arr;
+    B: Short_Integer;
+  end record;
+  pragma Pack (Rec);
+
+  R : Rec;
+
+begin
+  R.B := 31415;
+  R.A := (others => 0);
+  if R.B /= 31415 then
+    raise Program_Error;
+  end if;
+end;
Index: gcc/testsuite/gcc.dg/asm-qual-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/asm-qual-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/asm-qual-1.c	(.../branches/gcc-7-branch)
@@ -1,4 +1,4 @@
-/* Test that qualifiers other than volatile are ignored on asm.  */
+/* Test that qualifiers other than volatile are disallowed on asm.  */
 /* Origin: Joseph Myers <joseph@codesourcery.com> */
 /* { dg-do compile } */
 /* { dg-options "-std=gnu99" } */
@@ -7,6 +7,8 @@
 f (void)
 {
   asm volatile ("");
-  asm const (""); /* { dg-warning "const qualifier ignored on asm" } */
-  asm restrict (""); /* { dg-warning "restrict qualifier ignored on asm" } */
+
+  asm const (""); /* { dg-warning {'const' is not an asm qualifier} } */
+
+  asm restrict (""); /* { dg-warning {'restrict' is not an asm qualifier} } */
 }
Index: gcc/testsuite/gcc.dg/gomp/pr88105.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/gomp/pr88105.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr88105.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,30 @@
+/* { dg-do compile } */
+/* { dg-options "-fopenmp -O -fexceptions -fnon-call-exceptions -fno-tree-fre" } */
+
+int
+s0 (void)
+{
+  int g6, oh = 0;
+  int *a6 = &g6;
+
+  (void) a6;
+
+#pragma omp parallel for
+  for (g6 = 0; g6 < 1; ++g6)
+    {
+      int zk;
+
+      for (zk = 0; zk < 1; ++zk)
+        {
+          oh += zk / (zk + 1);
+
+          for (;;)
+            {
+            }
+        }
+
+      a6 = &zk;
+    }
+
+  return oh;
+}
Index: gcc/testsuite/gcc.dg/pr89037.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr89037.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr89037.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,24 @@
+/* { dg-do run { target int128 } } */
+/* { dg-options "" } */
+
+struct s
+{
+  __int128 y : 66;
+};
+typedef struct s T;
+T a[] = { 1, 10000, 0x12345, 0xff000001, 1ULL << 63, (__int128) 1 << 64,
+	  ((__int128) 1 << 64) | 1 };
+
+int
+main (void)
+{
+  if (a[0].y != 1
+      || a[1].y != 10000
+      || a[2].y != 0x12345
+      || a[3].y != 0xff000001
+      || a[4].y != (1ULL << 63)
+      || a[5].y != ((__int128) 1 << 64)
+      || a[6].y != (((__int128) 1 << 64) | 1))
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/asm-qual-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/asm-qual-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/asm-qual-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,46 @@
+/* Test that qualifiers on asm are allowed in any order.  */
+/* { dg-do compile } */
+/* { dg-options "-std=gnu99" } */
+
+void
+f (void)
+{
+  asm volatile goto ("" :::: lab);
+  asm volatile inline ("" :::);
+  asm inline volatile ("" :::);
+  asm inline goto ("" :::: lab);
+  asm goto volatile ("" :::: lab);
+  asm goto inline ("" :::: lab);
+
+  asm volatile inline goto ("" :::: lab);
+  asm volatile goto inline ("" :::: lab);
+  asm inline volatile goto ("" :::: lab);
+  asm inline goto volatile ("" :::: lab);
+  asm goto volatile inline ("" :::: lab);
+  asm goto inline volatile ("" :::: lab);
+
+  /* Duplicates are not allowed.  */
+  asm goto volatile volatile ("" :::: lab);  /* { dg-error "" } */
+  asm volatile goto volatile ("" :::: lab);  /* { dg-error "" } */
+  asm volatile volatile goto ("" :::: lab);  /* { dg-error "" } */
+  asm goto goto volatile ("" :::: lab);  /* { dg-error "" } */
+  asm goto volatile goto ("" :::: lab);  /* { dg-error "" } */
+  asm volatile goto goto ("" :::: lab);  /* { dg-error "" } */
+
+  asm inline volatile volatile ("" :::);  /* { dg-error "" } */
+  asm volatile inline volatile ("" :::);  /* { dg-error "" } */
+  asm volatile volatile inline ("" :::);  /* { dg-error "" } */
+  asm inline inline volatile ("" :::);  /* { dg-error "" } */
+  asm inline volatile inline ("" :::);  /* { dg-error "" } */
+  asm volatile inline inline ("" :::);  /* { dg-error "" } */
+
+  asm goto inline inline ("" :::: lab);  /* { dg-error "" } */
+  asm inline goto inline ("" :::: lab);  /* { dg-error "" } */
+  asm inline inline goto ("" :::: lab);  /* { dg-error "" } */
+  asm goto goto inline ("" :::: lab);  /* { dg-error "" } */
+  asm goto inline goto ("" :::: lab);  /* { dg-error "" } */
+  asm inline goto goto ("" :::: lab);  /* { dg-error "" } */
+
+lab:
+  ;
+}
Index: gcc/testsuite/gcc.dg/asan/pr81923.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/asan/pr81923.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/asan/pr81923.c	(.../branches/gcc-7-branch)
@@ -1,8 +1,11 @@
 /* PR sanitizer/81923 */
 /* { dg-do link } */
 
-int foobar __asm (__USER_LABEL_PREFIX__ "barbaz") = 34;
+#define STR1(X) #X
+#define STR2(X) STR1(X)
 
+int foobar __asm (STR2(__USER_LABEL_PREFIX__) "barbaz") = 34;
+
 int
 main ()
 {
Index: gcc/testsuite/gcc.dg/graphite/pr84552.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/graphite/pr84552.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/graphite/pr84552.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -floop-nest-optimize -fno-tree-copy-prop -fno-tree-fre -fno-tree-loop-ivcanon" } */
+
+int cx;
+
+int
+e6 (int pj, int xe)
+{
+  for (cx = 0; cx < 2; ++cx)
+    while (xe < 1)
+      {
+	for (cx = 0; cx < 2; ++cx)
+	  pj *= 2;
+
+	if (cx != 0)
+	  goto o3;
+
+	++xe;
+      }
+
+o3:
+  return pj;
+}
Index: gcc/testsuite/gcc.dg/inline-40.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/inline-40.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/inline-40.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,49 @@
+/* Test inline functions declared in inner scopes.  Bugs 88720 and 88726.  */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+void
+inline_1 (void)
+{
+}
+
+void
+inline_2 (void)
+{
+}
+
+static void
+inline_static_1 (void)
+{
+}
+
+static void
+inline_static_2 (void)
+{
+}
+
+static void inline_static_3 (void);
+static void inline_static_4 (void);
+
+static void
+test (void)
+{
+  inline void inline_1 (void);
+  extern inline void inline_2 (void);
+  inline void inline_3 (void);
+  extern inline void inline_4 (void);
+  inline void inline_static_1 (void);
+  extern inline void inline_static_2 (void);
+  inline void inline_static_3 (void);
+  extern inline void inline_static_4 (void);
+}
+
+void
+inline_3 (void)
+{
+}
+
+void
+inline_4 (void)
+{
+}
Index: gcc/testsuite/gcc.dg/asm-qual-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/asm-qual-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/asm-qual-3.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,9 @@
+/* Test that asm-qualifiers are not allowed on toplevel asm.  */
+/* { dg-do compile } */
+/* { dg-options "-std=gnu99" } */
+
+asm const ("");    /* { dg-error {expected '\(' before 'const'} } */
+asm volatile (""); /* { dg-error {expected '\(' before 'volatile'} } */
+asm restrict (""); /* { dg-error {expected '\(' before 'restrict'} } */
+asm inline ("");   /* { dg-error {expected '\(' before 'inline'} } */
+asm goto ("");     /* { dg-error {expected '\(' before 'goto'} } */
Index: gcc/testsuite/gcc.dg/lto/pr85248_0.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/lto/pr85248_0.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/lto/pr85248_0.c	(.../branches/gcc-7-branch)
@@ -2,8 +2,13 @@
 /* { dg-lto-do run } */
 /* { dg-lto-options { { -flto -O2 } } } */
 
-extern void test_alias (int s, int e) __asm__ (__USER_LABEL_PREFIX__ "test");
-extern void test_noreturn (int s, int e) __asm__ (__USER_LABEL_PREFIX__ "test")
+#define STR1(X) #X
+#define STR2(X) STR1(X)
+
+extern void test_alias (int s, int e) 
+  __asm__ (STR2(__USER_LABEL_PREFIX__) "test");
+extern void test_noreturn (int s, int e)
+  __asm__ (STR2(__USER_LABEL_PREFIX__)  "test")
   __attribute__ ((__noreturn__));
 
 extern inline __attribute__ ((__always_inline__, __gnu_inline__)) void
Index: gcc/testsuite/gcc.dg/torture/neon-immediate-timode.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/neon-immediate-timode.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/neon-immediate-timode.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,10 @@
+union a {
+  char b;
+  long long c;
+};
+union a d;
+int g(int, union a, union a);
+void e() {
+  union a f[2] = {-1L};
+  g(0, d, f[0]);
+}
Index: gcc/testsuite/gcc.dg/torture/pr86554-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr86554-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr86554-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,35 @@
+/* { dg-do run } */
+
+struct foo
+{
+  unsigned x;
+};
+typedef struct foo foo;
+
+static inline int zot(foo *f)
+{
+  int ret;
+
+  if (f->x > 0x7FFFFFFF)
+    ret = (int)(f->x - 0x7FFFFFFF);
+  else
+    ret = (int)f->x - 0x7FFFFFFF;
+  return ret;
+}
+
+void __attribute__((noinline,noclone)) bar(foo *f)
+{
+  int ret = zot(f);
+  volatile int x = ret;
+  if (ret < 1)
+    __builtin_abort ();
+}
+
+int main()
+{
+  foo f;
+  f.x = 0x800003f8;
+
+  bar(&f);
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr68037-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr68037-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr68037-1.c	(.../branches/gcc-7-branch)
@@ -1,4 +1,5 @@
 /* { dg-do run { target i?86-*-* x86_64-*-* } } */
+/* { dg-skip-if "PR81210 sp not aligned to 16 bytes" { *-*-darwin* } } */
 /* { dg-options "-mgeneral-regs-only" } */
 
 extern void exit (int);
Index: gcc/testsuite/gcc.dg/torture/pr68037-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr68037-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr68037-3.c	(.../branches/gcc-7-branch)
@@ -1,4 +1,5 @@
 /* { dg-do run { target i?86-*-* x86_64-*-* } } */
+/* { dg-skip-if "PR81210 sp not aligned to 16 bytes" { *-*-darwin* } } */
 /* { dg-options "-mgeneral-regs-only" } */
 
 #include <stddef.h>
Index: gcc/testsuite/gcc.dg/torture/pr89008.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr89008.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr89008.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,27 @@
+/* { dg-do run } */
+/* { dg-require-effective-target int32plus } */
+
+unsigned long a, c;
+unsigned b;
+int d, e;
+long f()
+{
+  unsigned long g = 0;
+  for (d = 0; d < 5; d += 2)
+    for (e = 0; e < 5; e += 3)
+      {
+	c = 4 + b;
+	g = -b - b;
+	b = 5 * (b << 24);
+      }
+  a = g;
+  return 0;
+}
+
+int main()
+{
+  f();
+  if (a)
+    __builtin_abort();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr68264.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr68264.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr68264.c	(.../branches/gcc-7-branch)
@@ -1,4 +1,5 @@
 /* { dg-do run } */
+/* { dg-skip-if "PR68356 no math-errno on darwin" { "*-*-darwin*" } } */
 /* { dg-add-options ieee } */
 /* { dg-require-effective-target fenv_exceptions } */
 
Index: gcc/testsuite/gcc.dg/torture/pr86554-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr86554-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr86554-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,49 @@
+/* { dg-do run } */
+/* { dg-require-effective-target int32plus } */
+
+struct s { __INT64_TYPE__ e; };
+
+static void f (struct s *ps)
+{
+  volatile __INT64_TYPE__ m = 9223372036854775807;
+  const char *str = "11E";
+  int r;
+  __INT64_TYPE__ sum;
+
+  ps->e = 0;
+
+  for (;;)
+    {
+      if (*str++ != '1')
+	break;
+      ps->e ++;
+    }
+
+  r = 1;
+  sum = m;
+
+  if (sum >= 0 && ps->e >= 0)
+    {
+      __UINT64_TYPE__ uc;
+      uc = (__UINT64_TYPE__) sum + (__UINT64_TYPE__) ps->e;
+      if (uc > 9223372036854775807)
+	r = 2;
+      else
+	sum = 17;
+    }
+  else
+    sum = sum + ps->e;
+
+  if (sum != 9223372036854775807)
+    __builtin_abort ();
+  if (r != 2)
+    __builtin_abort ();
+  ps->e = sum;
+}
+
+int main (void)
+{
+  struct s s;
+  f (&s);
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr68037-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr68037-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr68037-2.c	(.../branches/gcc-7-branch)
@@ -1,4 +1,5 @@
 /* { dg-do run { target i?86-*-* x86_64-*-* } } */
+/* { dg-skip-if "PR81210 sp not aligned to 16 bytes" { *-*-darwin* } } */
 /* { dg-options "-mgeneral-regs-only" } */
 
 extern void exit (int);
Index: gcc/testsuite/gcc.dg/torture/pr89223.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr89223.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr89223.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,10 @@
+/* { dg-do compile { target int128 } } */
+
+int a[5];
+unsigned __int128 b;
+void c()
+{
+  b = 4;
+  for (;; b--)
+    a[b] = ({ a[b + b]; });
+}
Index: gcc/testsuite/gcc.dg/torture/pr89505.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr89505.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr89505.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,22 @@
+/* { dg-do run } */
+
+struct S { int i; void *p; int j; };
+int a;
+int __attribute__((noinline))
+foo (struct S * __restrict p, int q)
+{
+  int *x = &p->j;
+  if (q)
+    x = &a;
+  p->j = 1;
+  *x = 2;
+  return p->j;
+}
+
+int main()
+{
+  struct S s;
+  if (foo (&s, 0) != 2)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/memcmp-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/memcmp-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/memcmp-1.c	(.../branches/gcc-7-branch)
@@ -8,9 +8,14 @@
 #include <string.h>
 #include <stdint.h>
 
-int lib_memcmp(const void *a, const void *b, size_t n) asm("memcmp");
-int lib_strncmp(const char *a, const char *b, size_t n) asm("strncmp");
+#define STR1(X) #X
+#define STR2(X) STR1(X)
 
+int lib_memcmp(const void *a, const void *b, size_t n)
+ asm(STR2(__USER_LABEL_PREFIX__) "memcmp");
+int lib_strncmp(const char *a, const char *b, size_t n)
+ asm(STR2(__USER_LABEL_PREFIX__) "strncmp");
+
 #ifndef NRAND
 #define NRAND 10000
 #endif
Index: gcc/testsuite/gcc.dg/inline-41.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/inline-41.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/inline-41.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,49 @@
+/* Test inline functions declared in inner scopes.  Bugs 88720 and 88726.  */
+/* { dg-do compile } */
+/* { dg-options "-fgnu89-inline" } */
+
+void
+inline_1 (void)
+{
+}
+
+void
+inline_2 (void)
+{
+}
+
+static void
+inline_static_1 (void)
+{
+}
+
+static void
+inline_static_2 (void)
+{
+}
+
+static void inline_static_3 (void);
+static void inline_static_4 (void);
+
+static void
+test (void)
+{
+  inline void inline_1 (void);
+  extern inline void inline_2 (void);
+  inline void inline_3 (void);
+  extern inline void inline_4 (void);
+  inline void inline_static_1 (void);
+  extern inline void inline_static_2 (void);
+  inline void inline_static_3 (void);
+  extern inline void inline_static_4 (void);
+}
+
+void
+inline_3 (void)
+{
+}
+
+void
+inline_4 (void)
+{
+}
Index: gcc/testsuite/gcc.dg/tree-prof/section-attr-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/tree-prof/section-attr-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/section-attr-1.c	(.../branches/gcc-7-branch)
@@ -13,7 +13,11 @@
 
 void foo (int path);
 
+#ifdef __APPLE__
+__attribute__ ((section ("__TEXT,__text")))
+#else
 __attribute__((section(".text")))
+#endif
 int
 main (int argc, char *argv[])
 {
@@ -43,3 +47,4 @@
 }
 
 /* { dg-final-use { scan-assembler "\.section\[\t \]*\.text\.unlikely\[\\n\\r\]+\[\t \]*\.size\[\t \]*foo\.cold\.0" { target *-*-linux* *-*-gnu* } } } */
+/* { dg-final-use { scan-assembler "\.section\[\t \]*__TEXT,__text_cold\.\*\[\\n\\r\]+_foo\.cold\.0" { target *-*-darwin* } } } */
Index: gcc/testsuite/gcc.dg/tree-prof/section-attr-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/tree-prof/section-attr-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/section-attr-2.c	(.../branches/gcc-7-branch)
@@ -28,7 +28,11 @@
 void NOINLINE
 foo (int path)
 {
+#ifdef __APPLE__
+  static int i __attribute__ ((section ("__DATA,__data")));
+#else
   static int i __attribute__((section(".data")));
+#endif
   if (path)
     {
       for (i = 0; i < SIZE; i++)
@@ -42,3 +46,4 @@
 }
 
 /* { dg-final-use { scan-assembler "\.section\[\t \]*\.text\.unlikely\[\\n\\r\]+\[\t \]*\.size\[\t \]*foo\.cold\.0" { target *-*-linux* *-*-gnu* } } } */
+/* { dg-final-use { scan-assembler "\.section\[\t \]*__TEXT,__text_cold\.\*\[\\n\\r\]+_foo\.cold\.0:" { target *-*-darwin* } } } */
Index: gcc/testsuite/gcc.dg/tree-prof/section-attr-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/tree-prof/section-attr-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/section-attr-3.c	(.../branches/gcc-7-branch)
@@ -9,7 +9,11 @@
 #define NOINLINE __attribute__((noinline)) __attribute__ ((noclone))
 
 const char *sarr[SIZE];
+#ifdef __APPLE__
+const char *buf_hot __attribute__ ((section ("__DATA,__data")));
+#else
 const char *buf_hot __attribute__ ((section (".data")));
+#endif
 const char *buf_cold;
 
 void foo (int path);
@@ -43,3 +47,4 @@
 }
 
 /* { dg-final-use { scan-assembler "\.section\[\t \]*\.text\.unlikely\[\\n\\r\]+\[\t \]*\.size\[\t \]*foo\.cold\.0" { target *-*-linux* *-*-gnu* } } } */
+/* { dg-final-use { scan-assembler "\.section\[\t \]*__TEXT,__text_cold\.\*\[\\n\\r\]+_foo\.cold\.0:" { target *-*-darwin* } } } */
Index: gcc/testsuite/gcc.dg/ipa/ipcp-5.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/ipa/ipcp-5.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipcp-5.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,45 @@
+/* Test that estimated local cloning time benefit of extern inline functions is
+   zero.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -fdump-ipa-cp -fno-early-inlining"  } */
+/* { dg-add-options bind_pic_locally } */
+
+extern int get_int (void);
+extern void use_stuff (int);
+
+int arr[10];
+
+inline void
+f (int a)
+{
+  arr[0] += a + 5;
+  arr[1] += a + 50;
+  arr[2] += a - 3;
+  arr[3] += a;
+  arr[4] += a + 21;
+  arr[5] += a + 900;
+  arr[6] += a + 2;
+  arr[7] += a + 3456;
+  arr[8] += a + 3;
+  arr[9] += a + 32;
+  use_stuff (a);
+}
+
+
+int
+entry (void)
+{
+  int i;
+  for (i = 0; i < 100; i++)
+    f (7);
+  for (i = 0; i < 100; i++)
+    f (get_int ());
+  return 0;
+}
+
+
+/* { dg-final { scan-ipa-dump "loc_time: 0" "cp" } } */
+/* { dg-final { scan-ipa-dump-not "replacing param.*with const" "cp"  } } */
+
+
Index: gcc/testsuite/gcc.dg/ipa/pr88214.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/ipa/pr88214.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/ipa/pr88214.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void i();
+  short a;
+  void b(e) char * e;
+  {
+    i();
+    b(a);
+  }
Index: gcc/testsuite/ChangeLog
===================================================================
--- a/src/gcc/testsuite/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,1042 @@
+2019-08-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/20190820-1.c: New test.
+
+2019-08-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	Paul Thomas <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90786
+	PR fortran/90813
+	* gfortran.dg/proc_ptr_51.f90: New test.
+
+2019-07-22  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-07-22  Martin Liska  <mliska@suse.cz>
+
+	PR driver/91172
+	* gcc.dg/pr91172.c: New test.
+
+2019-07-16  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	Backport from mainline
+	2019-03-05  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	PR target/89222
+	* gcc.target/arm/pr89222.c: Add new test.
+
+2019-07-15  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-07-01  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* gcc.target/s390/vector/vec-shift-2.c: New test.
+
+2019-07-12  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	PR testsuite/78529
+	* gcc.c-torture/execute/builtins/builtins.exp: Add -fno-ipa-ra.
+
+2019-06-21  Jeff Law  <law@redhat.com>
+
+	Backport fom mainline
+	2019-06-21  Jeff Law  <law@redhat.com>
+
+        PR tree-optimization/90949
+	* gcc.c-torture/execute/pr90949.c: New test.
+
+2019-06-21  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90937
+	* gfortran.dg/external_procedure_4.f90: New test.
+
+2019-06-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/90870
+	* gfortran.dg/deferred_character_33.f90: Remove failing test.
+	* gfortran.dg/deferred_character_33a.f90: Likewise.
+
+2019-06-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	Tomáš Trnka  <trnka@scm.com>
+
+	Backport from trunk
+	PR fortran/90744
+	* gfortran.dg/deferred_character_33.f90: New test.
+	* gfortran.dg/deferred_character_33a.f90: New test.
+
+2019-06-04  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-05-02  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* g++.dg/ext/instantiate2.C: Remove special-casing for Darwin.
+
+2019-05-28  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-04-20  Sandra Loosemore  <sandra@codesourcery.com>
+
+	* g++.dg/ipa/pr89009.C: Add dg-require-effective-target fpic.
+
+2019-05-28  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-28  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR testsuite/89441
+	* g++.dg/ipa/pr89009.C: Update symbol visibility.
+
+2019-05-28  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-11  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/89009
+	* g++.dg/ipa/pr89009.C: New test.
+
+2019-05-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt79.ad[sb]: New test.
+
+2019-05-23  Uroš Bizjak  <ubizjak@gmail.com>
+
+	Backported from mainline
+	2019-05-21  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/90547
+	* gcc.target/i386/pr90547.c: New test.
+
+2019-05-20  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-05-07  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/89765
+	* gcc.target/powerpc/pr89765-mc.c: New test.
+	* gcc.target/powerpc/vsx-builtin-10c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-10d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-11c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-11d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-12c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-12d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-13c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-13d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-14c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-14d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-15c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-15d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-16c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-16d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-17c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-17d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-18c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-18d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-19c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-19d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-20c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-20d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-9c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-9d.c: New test.
+
+2019-05-13  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-05-06  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/89424
+	* gcc.target/powerpc/pr89424-0.c: New test.
+	* gcc.target/powerpc/vsx-builtin-13a.c: Define macro PR89424 to
+	enable testing of newly patched capability.
+	* gcc.target/powerpc/vsx-builtin-13b.c: Likewise.
+	* gcc.target/powerpc/vsx-builtin-20a.c: Likewise.
+	* gcc.target/powerpc/vsx-builtin-20b.c: Likewise.
+
+2019-05-07  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline:
+	2019-01-25  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR middle-end/89037
+	* gcc.dg/pr89037.c: New test.
+
+2019-05-05  Thomas Koenig <tkoenig@gcc.gnu.org>
+
+	PR fortran/90344
+	* gfortran.dg/pr90344.f90: New test
+
+2019-04-30  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	PR target/90075
+	* gcc.target/aarch64/pr90075.c: New test.
+
+2019-04-25  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	* gcc.target/powerpc/vsx-vector-6.p8.c: Fix failure caused by typo.
+
+2019-04-22  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-03-15  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/87532
+	* gcc.target/powerpc/pr87532-mc.c: New test.
+	* gcc.target/powerpc/pr87532.c: New test.
+	* gcc.target/powerpc/vec-extract-v16qiu-v2.h: New test.
+	* gcc.target/powerpc/vec-extract-v16qiu-v2a.c: New test.
+	* gcc.target/powerpc/vec-extract-v16qiu-v2b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-10a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-10b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-11a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-11b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-12a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-12b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-13a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-13b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-14a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-14b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-15a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-15b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-16a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-16b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-17a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-17b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-18a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-18b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-19a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-19b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-20a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-20b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-9a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-9b.c: New test.
+
+	2019-03-19  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/89736
+	* gcc.target/powerpc/pr87532-mc.c: Modify dejagnu directives to
+	restrict this test to vsx targets.
+
+2019-04-19  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	Backport from trunk
+	2018-02-07  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	* gcc.target/powerpc/vsx-vector-6-le.c: Update CPU target.
+	* gcc.target/powerpc/vsx-vector-6-le.p9.c: New.
+
+	Backport from trunk
+	2018-05-04  Carl Love  <cel@us.ibm.com>
+	* gcc.target/powerpc/vsx-vector-6.h (foo): Add test for vec_max,
+	vec_trunc.
+	* gcc.target/powerpc/vsx-vector-6-le.c (dg-final): Update xvcmpeqdp,
+	xvcmpgtdp, xvcmpgedp counts. Add xxsel counts.
+	* gcc.target/powerpc/vsx-vector-6-be.c (dg-final): Update xvcmpgtdp,
+	xvcmpgedp counts. Add xxsel counts.
+
+	Backport from trunk
+	2018-05-16  Carl Love  <cel@us.ibm.com>
+	* gcc.target/powerpc/vsx-vector-6-be.c: Remove file.
+	* gcc.target/powerpc/vsx-vector-6-be.p7.c: New test file.
+	* gcc.target/powerpc/vsx-vector-6-be.p8.c: New test file.
+	* gcc.target/powerpc/vsx-vector-6-le.c (dg-final): Update counts for
+	xvcmpeqdp., xvcmpgtdp., xvcmpgedp., xxlxor, xvrdpi.
+
+	Backport from trunk
+	2018-05-23  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* lib/target-supports.exp (check_effective_target_be): New.
+	(check_effective_target_le): New.
+
+	Backport from trunk
+	2018-06-01  Carl Love  <cel@us.ibm.com>
+
+	* gcc.target/powerpc/altivec-7-be.c: Delete file.
+	* gcc.target/powerpc/altivec-7-le.c: Delete file.
+	* gcc.target/powerpc/vsx-7-be.c: Remove file.
+
+	Backport from trunk
+	2018-06-01  Carl Love  <cel@us.ibm.com>
+
+	Commit 260294 on 2018-05-16 by Carl Love was supposed to add the
+	following files.
+
+	* gcc.target/powerpc/vsx-vector-6-be.p7.c: New test file.
+	* gcc.target/powerpc/vsx-vector-6-be.p8.c: New test file.
+
+	Backport from trunk
+	2018-06-08  Carl Love  <cel@us.ibm.com>
+
+	* gcc.target/powerpc/vsx-vector-6-be.p7.c: Rename this file to
+	vsx-vector-6.p7.c.
+	* gcc.target/powerpc/vsx-vector-6-le.p9.c: Rename this file to
+	vsx-vector-6.p9.c.
+	* gcc.target/powerpc/vsx-vector-6-be.p8.c: Move instruction counts
+	for BE system that are different then for an LE system from this file
+	into vsx-vector-6-le.c using be target qualifier.  Remove this file.
+	* gcc.target/powerpc/vsx-vector-6-le.c: Add le qualifiers as needed for
+	the various instruction counts.  Rename file to vsx-vector-6.p8.c.
+
+	Backport from trunk
+	2019-02-06  Bill Seurer  <seurer@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/vsx-vector-6.p7.c: Update instruction
+	counts and target.
+	* gcc.target/powerpc/vsx-vector-6.p8.c: Update instruction
+	counts and target.
+	* gcc.target/powerpc/vsx-vector-6.p9.c: Update instruction
+	counts and target.
+
+2019-04-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/87352
+	* gfortran.dg/finalize_28.f90: Adjust count of __builtin_free.
+	* gfortran.dg/finalize_34.f90: New test.
+
+2019-04-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/87352
+	* gfortran.dg/finalize_28.f90: Adjust count of __builtin_free.
+	* gfortran.dg/finalize_34.f90: New test.
+
+2019-04-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-03-08  Martin Liska  <mliska@suse.cz>
+
+	PR target/86952
+	* gcc.target/i386/pr86952.c: New test.
+	* gcc.target/i386/indirect-thunk-7.c: Use jump tables to match
+	scanned pattern.
+	* gcc.target/i386/indirect-thunk-inline-7.c: Likewise.
+
+2019-04-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89904
+	* gfortran.dg/pr85797.f90: Adjust testcase.
+
+2019-04-10  Matthew Malcomson  <matthew.malcomson@arm.com>
+
+	PR target/90024
+	* gcc.dg/torture/neon-immediate-timode.c: New test.
+
+2019-04-07  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/89945
+	* gcc.target/i386/pr89945.c: New test.
+
+2019-04-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt73.adb: New test.
+
+2019-04-02  Xiong Hu Luo <luoxhu@linux.ibm.com>
+
+	Backport from trunk r250477.
+
+	2017-07-24  Carl Love  <cel@us.ibm.com>
+
+	* gcc.target/powerpc/builtins-3-p9-runnable.c: Add new test file for
+	the new built-ins.
+
+	Backport from trunk r255555.
+
+	2017-12-11  Carl Love  <cel@us.ibm.com>
+	* gcc.target/powerpc/altivec-7.c: Renamed altivec-7.h.
+	* gcc.target/powerpc/altivec-7.h (main): Add testcases for vec_unpackl.
+	Add dg-final tests for the instructions generated.
+	* gcc.target/powerpc/altivec-7-be.c: New file to test on big endian.
+	* gcc.target/powerpc/altivec-7-le.c: New file to test on little endian.
+	* gcc.target/powerpc/altivec-13.c (foo): Add vec_sld, vec_srl,
+	 vec_sro testcases. Add dg-final tests for the instructions generated.
+	* gcc.target/powerpc/builtins-3-p8.c (test_vsi_packs_vui,
+	test_vsi_packs_vsi, test_vsi_packs_vssi, test_vsi_packs_vusi,
+	test_vsi_packsu-vssi, test_vsi_packsu-vusi, test_vsi_packsu-vsll,
+	test_vsi_packsu-vull, test_vsi_packsu-vsi, test_vsi_packsu-vui): Add
+	testcases. Add dg-final tests for new instructions.
+	* gcc.target/powerpc/p8vector-builtin-2.c (vbschar_eq, vbchar_eq,
+	vuchar_eq, vbint_eq, vsint_eq, viint_eq, vuint_eq, vbool_eq, vbint_ne,
+	vsint_ne, vuint_ne, vbool_ne, vsign_ne, vuns_ne, vbshort_ne): Add
+	tests.
+	Add dg-final instruction tests.
+	* gcc.target/powerpc/vsx-vector-6.c: Renamed vsx-vector-6.h.
+	* gcc.target/powerpc/vsx-vector-6.h (vec_andc,vec_nmsub, vec_nmadd,
+	vec_or, vec_nor, vec_andc, vec_or, vec_andc, vec_msums): Add tests.
+	Add dg-final tests for the generated instructions.
+	* gcc.target/powerpc/builtins-3.c (test_sll_vsc_vsc_vsuc,
+	test_sll_vuc_vuc, test_sll_vsi_vsi_vuc, test_sll_vui_vui_vuc,
+	test_sll_vbll_vull, test_sll_vbll_vbll_vus, test_sll_vp_vp_vuc,
+	test_sll_vssi_vssi_vuc, test_sll_vusi_vusi_vuc, test_slo_vsc_vsc_vsc,
+	test_slo_vuc_vuc_vsc, test_slo_vsi_vsi_vsc, test_slo_vsi_vsi_vuc,
+	test_slo_vui_vui_vsc, test_slo_vui_vui_vuc, test_slo_vsll_slo_vsll_vsc,
+	test_slo_vsll_slo_vsll_vuc, test_slo_vull_slo_vull_vsc,
+	test_slo_vull_slo_vull_vuc, test_slo_vp_vp_vsc, test_slo_vp_vp_vuc,
+	test_slo_vssi_vssi_vsc, test_slo_vssi_vssi_vuc, test_slo_vusi_vusi_vsc,
+	test_slo_vusi_vusi_vuc, test_slo_vusi_vusi_vuc, test_slo_vf_vf_vsc,
+	test_slo_vf_vf_vuc, test_cmpb_float): Add tests.
+
+	Backport from trunk r257253.
+
+	2018-01-31  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	* gcc.target/powerpc/altivec-13.c: Remove VSX-requiring built-ins.
+	* gcc.target/powerpc/vsx-13.c: New.
+
+	Backport from trunk r258137.
+
+	2018-03-02  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	* gcc.target/powerpc/altivec-7-be.c: Remove VSX content, allow
+	32-bit target.
+	* gcc.target/powerpc/altivec-7.h: Remove VSX content.
+	* gcc.target/powerpc/vsx-7-be.c: New test (VSX content).
+	* gcc.target/powerpc/vsx-7.h: New include (VSX content).
+	* gcc.target/powerpc/altivec-7-le.c: Add vsx-7.h include.
+
+2019-03-31  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/83515
+	PR fortran/85797
+	* gfortran.dg/pr85797.f90: New test.
+
+2019-02-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-02-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89253
+	* gfortran.dg/pr89253.f: New testcase.
+
+	2019-02-08  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89223
+	* gcc.dg/torture/pr89223.c: New testcase.
+
+	2019-01-28  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/88739
+	* gcc.c-torture/execute/pr88739.c: New test.
+
+2019-03-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-01-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/86554
+	* gcc.dg/torture/pr86554-1.c: New testcase.
+	* gcc.dg/torture/pr86554-2.c: Likewise.
+
+	2018-11-20  Richard Biener  <rguenther@suse.de>
+ 
+	PR tree-optimization/88105
+	* gcc.dg/gomp/pr88105.c: New testcase.
+
+	2018-03-08  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/84552
+	* gcc.dg/graphite/pr84552.c: New testcase.
+
+2019-03-25  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/71861
+	Backport from trunk
+	* gfortran.dg/interface_abstract_5.f90: New test case.
+
+2019-03-21  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR fortran/56408
+	* gcc.target/powerpc/ppc-fortran/ppc-fortran.exp
+	(dg-compile-aux-modules): Fix diagnostic.
+	* gfortran.dg/coarray/caf.exp (dg-compile-aux-modules): Likewise.
+	* gfortran.dg/dg.exp (dg-compile-aux-modules): Likewise.
+
+	PR fortran/56408
+	* gfortran.dg/coarray/caf.exp (dg-compile-aux-modules): Workaround
+	missing nexted dg-test call support in dejaGNU 1.4.4.
+
+	PR fortran/29383
+	* gfortran.dg/ieee/ieee.exp (DEFAULT_FFLAGS): Set the same as in
+	other '*.exp' files.
+
+2019-03-21  Matthias Klose  <doko@ubuntu.com>
+
+	Backport from mainline
+	2019-02-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89505
+	* gcc.dg/torture/pr89505.c: New testcase.
+
+2019-03-17  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/84394
+	Backport from trunk
+	* gfortran.dg/blockdata_11.f90: New test.
+
+2019-03-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2019-03-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/89523
+	* gcc.target/i386/pr89523-1a.c: New test.
+	* gcc.target/i386/pr89523-1b.c: Likewise.
+	* gcc.target/i386/pr89523-2.c: Likewise.
+	* gcc.target/i386/pr89523-3.c: Likewise.
+	* gcc.target/i386/pr89523-4.c: Likewise.
+	* gcc.target/i386/pr89523-5.c: Likewise.
+	* gcc.target/i386/pr89523-6.c: Likewise.
+	* gcc.target/i386/pr89523-7.c: Likewise.
+	* gcc.target/i386/pr89523-8.c: Likewise.
+	* gcc.target/i386/pr89523-9.c: Likewise.
+
+2019-03-16  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/66089
+	Backport from trunk
+	* gfortran.dg/dependency_53.f90: New test.
+	* gfortran.dg/assumed_type_2.f90: Adapted tree dumps.
+	* gfortran.dg/no_arg_check_2.f90: Likewise.
+
+2019-03-16 Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/66695
+	PR fortran/77746
+	PR fortran/79485
+	Backport from trunk
+	* gfortran.dg/binding_label_tests_30.f90: New test.
+	* gfortran.dg/binding_label_tests_31.f90: New test.
+	* gfortran.dg/binding_label_tests_32.f90: New test.
+	* gfortran.dg/binding_label_tests_33.f90: New test.
+
+2019-03-14  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-03-07  Martin Jambor  <mjambor@suse.cz>
+
+	PR lto/87525
+	* gcc.dg/ipa/ipcp-5.c: New test.
+
+2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-02-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84272
+	* g++.dg/opt/pr84272.C: New test.
+
+2019-03-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87673
+	Backport from trunk
+	* gfortran.dg/charlen_17.f90: New test.
+
+2019-03-13  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2019-03-08  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* gcc.target/arm/f16_f64_conv_no_dp.c: New test.
+
+	Backport from mainline
+	2019-03-11  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	* gcc.target/arm/f16_f64_conv_no_dp.c: Add arm_fp16_ok effective
+	target.
+
+2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71544
+	Backport from trunk
+	* gfortran.dg/c_ptr_tests_19.f90: New test.
+
+2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87734
+	Backport from trunk
+	* gfortran.dg/public_private_module_10.f90: New test.
+
+2019-04-10  Matthias Klose  <doko@ubuntu.com>
+
+	Backport from the gcc-8 branch
+	2019-03-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89585
+	* g++.dg/asm-qual-3.C: Adjust expected diagnostics.
+
+2019-03-07  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	Backport of r268834 from mainline to gcc-7-branch.
+	2019-01-23  Xiong Hu Luo  <luoxhu@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/crypto-builtin-1.c
+	(crypto1_be, crypto2_be, crypto3_be, crypto4_be, crypto5_be):
+	New testcases.
+
+2019-03-06  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/72714
+	Backport from trunk
+	* gfortran.dg/coarray_allocate_11.f90: New test.
+
+2019-03-03  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/77583
+	* gfortran.dg/pr77583.f90: New test.
+
+2019-03-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87689
+	Backport from trunk
+	* gfortran.dg/lto/20091028-1_0.f90: Add -Wno-lto-type-mismatch to
+	options.
+	* gfortran.dg/lto/20091028-2_0.f90: Likewise.
+	* gfortran.dg/lto/pr87689_0.f: New file.
+	* gfortran.dg/lto/pr87689_1.f: New file.
+	* gfortran.dg/altreturn_9_0.f90: New file.
+	* gfortran.dg/altreturn_9_1.f90: New file.
+
+2019-02-23  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/88117
+	* gfortran.dg/deferred_character_32.f90 : New test
+
+2019-02-23  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71066
+	Backport from trunk
+	* gfortran.dg/coarray_data_1.f90: New test.
+
+2019-02-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-14  Martin Liska  <mliska@suse.cz>
+
+	PR rtl-optimization/89242
+	* g++.dg/pr89242.C: New test.
+
+2019-02-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-11  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/89009
+	* g++.dg/ipa/pr89009.C: New test.
+
+2019-02-15  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/sparc/struct-ret-check-1.c: Add -fno-pie option.
+
+2019-02-11  Stefan Agner  <stefan@agner.ch>
+
+	Backport from mainline
+	2019-01-10  Stefan Agner  <stefan@agner.ch>
+
+	PR target/88648
+	* gcc.target/arm/pr88648-asm-syntax-unified.c: Add test to
+	check if -masm-syntax-unified gets applied properly.
+
+2019-02-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89077
+	* gfortran.dg/pr89077.f90: New test.
+
+2019-02-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71723
+	Backport from trunk
+	* gfortran.dg/pointer_init_2.f90: Adjust error messages.
+	* gfortran.dg/pointer_init_6.f90: Likewise.
+	* gfortran.dg/pointer_init_9.f90: New test.
+
+2019-02-09  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71860
+	Backport from trunk
+	* gfortran.dg/null_10.f90: New test.
+
+2019-02-06  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	2019-02-05  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+	* gcc.target/powerpc/vec-extract-slong-1.c: Require p8 execution
+	hardware.
+	* gcc.target/powerpc/vec-extract-schar-1.c: Likewise.
+	* gcc.target/powerpc/vec-extract-sint128-1.c: Likewise.
+	* gcc.target/powerpc/vec-extract-sshort-1.c: Likewise.
+	* gcc.target/powerpc/vec-extract-ulong-1.c: Likewise.
+	* gcc.target/powerpc/vec-extract-uchar-1.c: Likewise.
+	* gcc.target/powerpc/vec-extract-sint-1.c: Likewise.
+	* gcc.target/powerpc/vec-extract-uint128-1.c: Likewise.
+	* gcc.target/powerpc/vec-extract-ushort-1.c: Likewise.
+	* gcc.target/powerpc/vec-extract-uint-1.c: Likewise.
+
+	Backport from mainline.
+	2019-01-30  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+	* gcc.target/powerpc/vec-extract-schar-1.c: New test.
+	* gcc.target/powerpc/vec-extract-sint-1.c: New test.
+	* gcc.target/powerpc/vec-extract-sint128-1.c: New test.
+	* gcc.target/powerpc/vec-extract-slong-1.c: New test.
+	* gcc.target/powerpc/vec-extract-sshort-1.c: New test.
+	* gcc.target/powerpc/vec-extract-uchar-1.c: New test.
+	* gcc.target/powerpc/vec-extract-uint-1.c: New test.
+	* gcc.target/powerpc/vec-extract-uint128-1.c: New test.
+	* gcc.target/powerpc/vec-extract-ulong-1.c: New test.
+	* gcc.target/powerpc/vec-extract-ushort-1.c: New test.
+
+2019-02-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt76.adb: New test.
+
+2019-02-05  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/67679
+	Backport from trunk
+	* gfortran.dg/warn_undefined_1.f90: New test.
+	* gfortran.dg/coarray_lock_7.f90: Fix patterns in test.
+
+2019-02-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/88393
+	* gfortran.dg/alloc_comp_assign_16.f03 : New test.
+
+2019-02-02  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/88298
+	Backport from trunk
+	* gfortran.dg/warn_conversion_10.f90: New test.
+
+2019-02-02  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/57048
+	Backport from trunk
+	* gfortran.dg/c_funptr_1.f90: New file.
+	* gfortran.dg/c_funptr_1_mod.f90: New file.
+
+2019-01-30  Manfred Schwarb  <manfred99@gmx.ch>
+
+	* gfortran.dg/pr68318_1.f90: Fix a dg directive.
+
+2019-01-30  Kewen Lin  <linkw@gcc.gnu.org>
+
+	Backport from mainline
+	2019-01-20  Kewen Lin  <linkw@gcc.gnu.org>
+
+	* gcc.target/powerpc/altivec_vld_vst_addr.c: Remove, split into
+	altivec_vld_vst_addr-1.c and altivec_vld_vst_addr-2.c.
+	* gcc.target/powerpc/altivec_vld_vst_addr-1.c: New test.
+	* gcc.target/powerpc/altivec_vld_vst_addr-2.c: Ditto.
+
+	2019-01-17  Kewen Lin  <linkw@gcc.gnu.org>
+
+	* gcc.target/powerpc/altivec_vld_vst_addr.c: New test.
+
+2019-01-27  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR fortran/70696
+	* gfortran.dg/coarray/event_3.f0: Add save attribue to x.
+
+2019-01-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/56386
+	PR fortran/58906
+	PR fortran/77385
+	* gfortran.dg/associate_44.f90 : New test.
+
+	PR fortran/80260
+	* gfortran.dg/select_type_45.f90 : New test.
+
+	PR fortran/82077
+	* gfortran.dg/select_type_46.f90 : New test.
+
+2019-01-27  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt75.adb: New test.
+	* gnat.dg/opt75_pkg.ad[sb]: New helper.
+
+2019-01-27  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/88948
+	* gcc.target/i386/pr88948.c: New test.
+
+2019-01-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/array34.adb: New test.
+
+2019-01-26  Dominique d'Humieres  <dominiq@gcc.gnu.org>
+
+	PR fortran/85579
+	* gfortran.dg/pr51434.f90: Fix the TRANSFER argument.
+
+2019-01-26  Manfred Schwarb  <manfred99@gmx.ch>
+
+	* gfortran.dg/array_function_5.f90
+	* gfortran.dg/class_66.f90
+	* gfortran.dg/dec_structure_12.f90
+	* gfortran.dg/dec_structure_14.f90
+	* gfortran.dg/dec_structure_15.f90
+	* gfortran.dg/extends_11.f03
+	* gfortran.dg/pr58968.f
+	* gfortran.dg/pr78259.f90
+	* gfortran.dg/debug/pr35154-stabs.f
+
+2019-01-24  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/88998
+	* g++.dg/pr88998.c: New test.
+
+2019-01-24  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-01-23  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89008
+	* gcc.dg/torture/pr89008.c: New testcase.
+
+2019-01-22  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/88938
+	* gcc.target/i386/pr88938.c: New test.
+
+2019-01-16  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from mainline
+	2019-01-07  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/88720
+	PR c/88726
+	* gcc.dg/inline-40.c, gcc.dg/inline-41.c: New tests.
+
+2019-01-16  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from mainline
+	2018-12-10  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/88214
+	* gcc.dg/ipa/pr88214.c: New test.
+
+2019-01-15  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/81849
+	* gfortran.dg/pr81849.f90: New test.
+
+2019-01-13  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/88776
+	* gfortran.dg/namelist_96.f90: New test.
+
+2019-01-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/35031
+	* gfortran.dg/pr35031.f90: new test.
+
+2019-01-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/sparc/tls-ld-int8.c: New test.
+	* gcc.target/sparc/tls-ld-int16.c: Likewise.
+	* gcc.target/sparc/tls-ld-int32.c: Likewise.
+	* gcc.target/sparc/tls-ld-uint8.c: Likewise.
+	* gcc.target/sparc/tls-ld-uint16.c: Likewise.
+	* gcc.target/sparc/tls-ld-uint32.c: Likewise.
+
+2019-01-05  Dominique d'Humieres  <dominiq@gcc.gnu.org>
+
+	PR target/60563
+	* g++.dg/ext/sync-4.C: Add dg-xfail-run-if for darwin.
+
+2018-01-02  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR inline-asm/55681
+	* gcc.dg/asm-qual-1.c: Test that "const" and "restrict" are refused.
+	* gcc.dg/asm-qual-2.c: New test, test that asm-qualifiers are allowed
+	in any order, but that duplicates are not allowed.
+
+	Backport from trunk
+	2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* c-c++-common/torture/asm-inline.c: New testcase.
+	* gcc.dg/asm-qual-2.c: Test asm inline, too.
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* g++.dg/asm-qual-1.C: New testcase.
+	* g++.dg/asm-qual-2.C: New testcase.
+	* gcc.dg/asm-qual-1.c: Update.
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* g++.dg/asm-qual-3.C: New testcase.
+	* gcc.dg/asm-qual-3.c: New testcase.
+
+	And extra for the backport
+	2019-01-02  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* gcc.dg/asm-qual-1.c: Adjust.
+
+2018-12-30  Dominique d'Humieres  <dominiq@gcc.gnu.org>
+
+	PR tree-optimization/68356
+	PR target/81210
+	* gcc.dg/torture/pr68264.c: Skip on darwin.
+	* gcc.dg/torture/pr68037-1.c: Likewise.
+	* gcc.dg/torture/pr68037-2.c: Likewise.
+	* gcc.dg/torture/pr68037-3.c: Likewise.
+
+2018-12-29  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/82550
+	* gfortran.dg/submodule_30.f08 : New test.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR testsuite/67974
+	* gcc.target/x86_64/abi/avx/asm-support-darwin.s: New.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-08-16  Iain Sandoe <iain@sandoe.co.uk>
+
+	* g++.dg/torture/pr44295.C : Skip for Darwin.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-08-22  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.dg/lto/pr85248_0.c (test_alias):
+	Stringify __USER_LABEL_PREFIX__.
+	(test_noreturn): Likewise.
+
+	2018-08-16  Iain Sandoe <iain@sandoe.co.uk>
+
+	* gcc.dg/memcmp-1.c (lib_memcmp): Apply __USER_LABEL_PREFIX__.
+	(lib_strncmp): Likewise.
+
+	2018-08-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.dg/asan/pr81923.c: Stringify __USER_LABEL_PREFIX__.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-08-16  Iain Sandoe <iain@sandoe.co.uk>
+
+	PR testsuite/78544
+	* gcc.dg/tree-prof/section-attr-1.c: Add Darwin-specific section
+	attributes and matching.
+	* gcc.dg/tree-prof/section-attr-2.c: Likewise.
+	* gcc.dg/tree-prof/section-attr-3.c: Likewise.
+
+2018-12-23  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/77703
+	* gfortran.dg/ptr_func_assign_5.f08 : New test.
+
+2018-12-22  Steven G . Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85798
+	* gfortran.dg/pr85798.f90: New test.
+
+2018-12-22  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/85544
+	* gfortran.dg/power_7.f90: New test.
+
+2018-12-21  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88169
+	* gfortran.dg/pr88169_1.f90: new test.
+	* gfortran.dg/pr88169_2.f90: Ditto.
+	* gfortran.dg/pr88169_3.f90: Ditto.
+
+2018-12-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2018-12-10  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/88418
+	* gcc.target/i386/pr88418.c: New test.
+
+2018-12-17  Senthil Kumar Selvaraj  <senthilkumar.selvaraj@microchip.com>
+
+	Backport from trunk
+	2018-12-17  Senthil Kumar Selvaraj  <senthilkumar.selvaraj@microchip.com>
+
+	PR rtl-optimization/88253
+	* gcc.target/avr/pr88253.c: New test.
+
+2018-12-15  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88138
+	* gfortran.dg/pr88138.f90: new test.
+
+2018-12-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2018-12-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* gcc.target/s390/zvector/vec-double-1.c: New test.
+	* gcc.target/s390/zvector/vec-double-2.c: New test.
+
+2018-12-12  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backport from mainline
+	2018-12-07  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/87496
+	* gcc.target/powerpc/pr87496-1.c: New test.
+	* gcc.target/powerpc/pr87496-2.c: New test.
+	* gcc.target/powerpc/pr87496-3.c: New test.
+
+2018-12-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88155
+	* gfortran.dg/pr70870_1.f90: Update testcase to use -std=gnu.
+	* gfortran.dg/pr88155.f90: New test.
+
+2018-12-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88249
+	* gfortran.dg/pr88249.f90: New test.
+
+2018-12-10  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88269
+	* gfortran.dg/pr88269.f90: New test.
+
+2018-12-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88205
+	* gfortran.dg/pr88205.f90: New unit.
+
+2018-12-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88206
+	* gfortran.dg/pr88206.f90: New test.
+
+2018-12-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88228
+	* gfortran.dg/pr88228.f90: New test.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: gcc/testsuite/g++.dg/asm-qual-2.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/asm-qual-2.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/asm-qual-2.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,46 @@
+// Test that qualifiers on asm are allowed in any order.
+// { dg-do compile }
+// { dg-options "-std=c++98" }
+
+void
+f ()
+{
+  asm volatile goto ("" :::: lab);
+  asm volatile inline ("" :::);
+  asm inline volatile ("" :::);
+  asm inline goto ("" :::: lab);
+  asm goto volatile ("" :::: lab);
+  asm goto inline ("" :::: lab);
+
+  asm volatile inline goto ("" :::: lab);
+  asm volatile goto inline ("" :::: lab);
+  asm inline volatile goto ("" :::: lab);
+  asm inline goto volatile ("" :::: lab);
+  asm goto volatile inline ("" :::: lab);
+  asm goto inline volatile ("" :::: lab);
+
+  /* Duplicates are not allowed.  */
+  asm goto volatile volatile ("" :::: lab);  /* { dg-error "" } */
+  asm volatile goto volatile ("" :::: lab);  /* { dg-error "" } */
+  asm volatile volatile goto ("" :::: lab);  /* { dg-error "" } */
+  asm goto goto volatile ("" :::: lab);  /* { dg-error "" } */
+  asm goto volatile goto ("" :::: lab);  /* { dg-error "" } */
+  asm volatile goto goto ("" :::: lab);  /* { dg-error "" } */
+
+  asm inline volatile volatile ("" :::);  /* { dg-error "" } */
+  asm volatile inline volatile ("" :::);  /* { dg-error "" } */
+  asm volatile volatile inline ("" :::);  /* { dg-error "" } */
+  asm inline inline volatile ("" :::);  /* { dg-error "" } */
+  asm inline volatile inline ("" :::);  /* { dg-error "" } */
+  asm volatile inline inline ("" :::);  /* { dg-error "" } */
+
+  asm goto inline inline ("" :::: lab);  /* { dg-error "" } */
+  asm inline goto inline ("" :::: lab);  /* { dg-error "" } */
+  asm inline inline goto ("" :::: lab);  /* { dg-error "" } */
+  asm goto goto inline ("" :::: lab);  /* { dg-error "" } */
+  asm goto inline goto ("" :::: lab);  /* { dg-error "" } */
+  asm inline goto goto ("" :::: lab);  /* { dg-error "" } */
+
+lab:
+  ;
+}
Index: gcc/testsuite/g++.dg/opt/pr84272.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/opt/pr84272.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/opt/pr84272.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,23 @@
+// PR target/84272
+// { dg-do compile }
+// { dg-options "-O2" }
+// { dg-additional-options "-march=armv8-a -mtune=cortex-a57" { target aarch64-*-* } }
+
+struct A
+{
+  float b, c;
+  A ();
+  A (float, float, float);
+  float operator * (A)
+  {
+    float d = b * b + c * c;
+    return d;
+  }
+};
+
+void
+foo ()
+{
+  A g[1];
+  A h (0, 0, h * g[2]);
+}
Index: gcc/testsuite/g++.dg/asm-qual-3.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/asm-qual-3.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/asm-qual-3.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+// Test that asm-qualifiers are not allowed on toplevel asm.
+// { dg-do compile }
+// { dg-options "-std=gnu++98" }
+
+asm const ("");    // { dg-error {'const' is not an asm qualifier} }
+asm volatile ("");
+asm restrict (""); // { dg-error {expected '\(' before 'restrict'} }
+asm inline ("");   // { dg-error {asm qualifier outside of function body} }
+asm goto ("");     // { dg-error {asm qualifier outside of function body} }
+
+// There are many other things wrong with this code, so:
+// { dg-excess-errors "" }
Index: gcc/testsuite/g++.dg/torture/pr44295.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/torture/pr44295.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/torture/pr44295.C	(.../branches/gcc-7-branch)
@@ -1,4 +1,6 @@
 /* { dg-do compile } */
+/* { dg-skip-if "no pthread_barrier" { *-*-darwin* } } */
+
 extern "C" {
   typedef __SIZE_TYPE__ size_t;
   typedef struct   {
Index: gcc/testsuite/g++.dg/ipa/pr89009.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/pr89009.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/pr89009.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,14 @@
+/* PR ipa/89009 */
+/* { dg-do run } */
+/* { dg-require-effective-target fpic } */
+/* { dg-options "-fpic -O2 -fno-inline" } */
+/* { dg-require-visibility "" } */
+
+void foo1() { __builtin_printf ("foo\n"); }
+#pragma GCC visibility push(hidden)
+void foo2() { __builtin_printf ("foo\n"); }
+#pragma GCC visibility pop
+
+int main() { foo2(); return 0; }
+
+/* { dg-output "foo" } */
Index: gcc/testsuite/g++.dg/ext/instantiate2.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ext/instantiate2.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/ext/instantiate2.C	(.../branches/gcc-7-branch)
@@ -8,8 +8,7 @@
 template <class T> T A<T>::t = 0;
 static template struct A<int>;
 
-// { dg-final { scan-assembler "\n_?_ZN1AIiE1tE(:|\n|\t)" { target { ! *-*-darwin* } } } }
-// { dg-final { scan-assembler ".zerofill __DATA,__pu_bss2,__ZN1AIiE1tE" { target *-*-darwin* } } } 
+// { dg-final { scan-assembler "\n_?_ZN1AIiE1tE(:|\n|\t)" } }
 void test_int() { A<int>::t = 42; }
 
 // { dg-final { scan-assembler-not "\n_?_ZN1AIcE1tE(:|\n|\t)" } }
Index: gcc/testsuite/g++.dg/ext/sync-4.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ext/sync-4.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/ext/sync-4.C	(.../branches/gcc-7-branch)
@@ -1,4 +1,6 @@
 /* { dg-do run { target hppa*-*-hpux* *-*-linux* *-*-gnu* powerpc*-*-darwin* *-*-darwin[912]* } } */
+/* FIXME The following additional option should be removed after the fix for radr://19802258.
+/* { dg-xfail-run-if "PR60563 radr://19802258" { *-*-darwin* } } */
 /* { dg-require-effective-target sync_long_long_runtime } */
 /* { dg-options "-fexceptions -fnon-call-exceptions -O2" } */
 /* { dg-additional-options "-march=pentium" { target { { i?86-*-* x86_64-*-* } && ia32 } } } */
Index: gcc/testsuite/g++.dg/pr88998.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/pr88998.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/pr88998.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,31 @@
+// PR target/88998
+// { dg-do run { target { { x86_64-*-* i?86-*-* } && sse2_runtime } } }
+// { dg-options "-O2 -msse2 -mfpmath=387" }
+// { dg-require-effective-target c++11 }
+
+#include <cassert>
+#include <unordered_map>
+#include <x86intrin.h>
+
+double
+__attribute__((noinline))
+prepare (int a, int b)
+{
+  __m128i is = _mm_setr_epi32 (a, b, 0, 0);
+  __m128d ds = _mm_cvtepi32_pd (is);
+  return ds[0] + ds[1];
+}
+
+int
+main (int, char **)
+{
+  double d = prepare (1, 2);
+
+  std::unordered_map < int, int >m;
+  m.insert ({0, 0});
+  m.insert ({1, 1});
+  assert (m.load_factor () <= m.max_load_factor ());
+
+  assert (d == 3.0);
+  return 0;
+}
Index: gcc/testsuite/g++.dg/asm-qual-1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/asm-qual-1.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/asm-qual-1.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,13 @@
+// Test that qualifiers other than volatile are disallowed on asm.
+// { dg-do compile }
+// { dg-options "-std=gnu++98" }
+
+void
+f ()
+{
+  asm volatile ("");
+
+  asm const (""); // { dg-error {'const' is not an asm qualifier} }
+
+  asm __restrict (""); // { dg-error {'__restrict' is not an asm qualifier} }
+}
Index: gcc/testsuite/c-c++-common/torture/asm-inline.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/torture/asm-inline.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/c-c++-common/torture/asm-inline.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,53 @@
+/* { dg-do compile } */
+/* -O0 does no inlining, and -O3 does it too aggressively for this test:  */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O3" } { "" } }
+/* The normal asm is not inlined:  */
+/* { dg-final { scan-assembler-times "w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w" 2 } } */
+/* But the asm inline is inlined:  */
+/* { dg-final { scan-assembler-times "x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x" 8 } } */
+
+static void f(void)
+{
+  asm ("w\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\n"
+       "w\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw");
+}
+
+int f0(void) { f(); return 0; }
+int f1(void) { f(); return 1; }
+int f2(void) { f(); return 2; }
+int f3(void) { f(); return 3; }
+
+static void fg(void)
+{
+  asm goto("w\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\n"
+	   "w\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw" :::: q);
+  q: ;
+}
+
+int fg0(void) { fg(); return 0; }
+int fg1(void) { fg(); return 1; }
+int fg2(void) { fg(); return 2; }
+int fg3(void) { fg(); return 3; }
+
+static void g(void)
+{
+  asm inline("x\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\n"
+	     "x\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx");
+}
+
+int g0(void) { g(); return 0; }
+int g1(void) { g(); return 1; }
+int g2(void) { g(); return 2; }
+int g3(void) { g(); return 3; }
+
+static void gg(void)
+{
+  asm inline goto("x\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\n"
+		  "x\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx" :::: q);
+  q: ;
+}
+
+int gg0(void) { gg(); return 0; }
+int gg1(void) { gg(); return 1; }
+int gg2(void) { gg(); return 2; }
+int gg3(void) { gg(); return 3; }
Index: gcc/cp/ChangeLog
===================================================================
--- a/src/gcc/cp/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cp/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,58 @@
+2019-04-10  Matthias Klose  <doko@ubuntu.com>
+
+	Backport from the gcc-8 branch
+	2019-03-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89585
+	* parser.c (cp_parser_asm_definition): Parse asm qualifiers even
+	at toplevel, but diagnose them.
+
+2018-01-02  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR inline-asm/55681
+	* parser.c (cp_parser_asm_definition): Update grammar.  Allow any
+	combination of volatile and goto, in any order, without repetitions.
+
+	Backport from trunk
+	2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* cp-tree.h (finish_asm_stmt): Update declaration.
+	* parser.c (cp_parser_asm_definition): Detect the inline keyword
+	after asm.  Pass a flag for it to finish_asm_stmt.
+	* pt.c (tsubst_expr): Pass the ASM_INLINE_P flag to finish_asm_stmt.
+	* semantics.c (finish_asm_stmt): Add inline_p parameter.  Use it to
+	set ASM_INLINE_P.
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* parser.c (cp_parser_asm_definition): Rewrite the loop to work without
+	"done" boolean variable.
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* parser.c (cp_parser_asm_definition): Rewrite the loop to work without
+	"done" boolean variable.
+	* parser.c (cp_parser_asm_definition): Keep track of the location each
+	asm qualifier is first seen; use that to give nicer "duplicate asm
+	qualifier" messages.
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* parser.c (cp_parser_asm_definition) <RID_CONST, RID_RESTRICT>: Give
+	a more specific error message (instead of just falling through).
+
+	Backport from trunk
+	2018-12-10  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* parser.c (cp_parser_asm_definition): Do not allow any asm qualifiers
+	on top-level asm.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: gcc/cp/pt.c
===================================================================
--- a/src/gcc/cp/pt.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cp/pt.c	(.../branches/gcc-7-branch)
@@ -16159,7 +16159,7 @@
 	tree labels = tsubst_copy_asm_operands (ASM_LABELS (t), args,
 						complain, in_decl);
 	tmp = finish_asm_stmt (ASM_VOLATILE_P (t), string, outputs, inputs,
-			       clobbers, labels);
+			       clobbers, labels, ASM_INLINE_P (t));
 	tree asm_expr = tmp;
 	if (TREE_CODE (asm_expr) == CLEANUP_POINT_EXPR)
 	  asm_expr = TREE_OPERAND (asm_expr, 0);
Index: gcc/cp/semantics.c
===================================================================
--- a/src/gcc/cp/semantics.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cp/semantics.c	(.../branches/gcc-7-branch)
@@ -1429,11 +1429,11 @@
 /* Finish an asm-statement, whose components are a STRING, some
    OUTPUT_OPERANDS, some INPUT_OPERANDS, some CLOBBERS and some
    LABELS.  Also note whether the asm-statement should be
-   considered volatile.  */
+   considered volatile, and whether it is asm inline.  */
 
 tree
 finish_asm_stmt (int volatile_p, tree string, tree output_operands,
-		 tree input_operands, tree clobbers, tree labels)
+		 tree input_operands, tree clobbers, tree labels, bool inline_p)
 {
   tree r;
   tree t;
@@ -1587,6 +1587,7 @@
 		  output_operands, input_operands,
 		  clobbers, labels);
   ASM_VOLATILE_P (r) = volatile_p || noutputs == 0;
+  ASM_INLINE_P (r) = inline_p;
   r = maybe_cleanup_point_expr_void (r);
   return add_stmt (r);
 }
Index: gcc/cp/parser.c
===================================================================
--- a/src/gcc/cp/parser.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cp/parser.c	(.../branches/gcc-7-branch)
@@ -18789,6 +18789,15 @@
 
 /* Parse an asm-definition.
 
+  asm-qualifier:
+    volatile
+    inline
+    goto
+
+  asm-qualifier-list:
+    asm-qualifier
+    asm-qualifier-list asm-qualifier
+
    asm-definition:
      asm ( string-literal ) ;
 
@@ -18795,17 +18804,21 @@
    GNU Extension:
 
    asm-definition:
-     asm volatile [opt] ( string-literal ) ;
-     asm volatile [opt] ( string-literal : asm-operand-list [opt] ) ;
-     asm volatile [opt] ( string-literal : asm-operand-list [opt]
-			  : asm-operand-list [opt] ) ;
-     asm volatile [opt] ( string-literal : asm-operand-list [opt]
-			  : asm-operand-list [opt]
+     asm asm-qualifier-list [opt] ( string-literal ) ;
+     asm asm-qualifier-list [opt] ( string-literal : asm-operand-list [opt] ) ;
+     asm asm-qualifier-list [opt] ( string-literal : asm-operand-list [opt]
+				    : asm-operand-list [opt] ) ;
+     asm asm-qualifier-list [opt] ( string-literal : asm-operand-list [opt]
+				    : asm-operand-list [opt]
 			  : asm-clobber-list [opt] ) ;
-     asm volatile [opt] goto ( string-literal : : asm-operand-list [opt]
-			       : asm-clobber-list [opt]
-			       : asm-goto-list ) ;  */
+     asm asm-qualifier-list [opt] ( string-literal : : asm-operand-list [opt]
+				    : asm-clobber-list [opt]
+				    : asm-goto-list ) ;
 
+  The form with asm-goto-list is valid if and only if the asm-qualifier-list
+  contains goto, and is the only allowed form in that case.  No duplicates are
+  allowed in an asm-qualifier-list.  */
+
 static void
 cp_parser_asm_definition (cp_parser* parser)
 {
@@ -18815,11 +18828,9 @@
   tree clobbers = NULL_TREE;
   tree labels = NULL_TREE;
   tree asm_stmt;
-  bool volatile_p = false;
   bool extended_p = false;
   bool invalid_inputs_p = false;
   bool invalid_outputs_p = false;
-  bool goto_p = false;
   required_token missing = RT_NONE;
 
   /* Look for the `asm' keyword.  */
@@ -18832,24 +18843,78 @@
       cp_function_chain->invalid_constexpr = true;
     }
 
-  /* See if the next token is `volatile'.  */
-  if (cp_parser_allow_gnu_extensions_p (parser)
-      && cp_lexer_next_token_is_keyword (parser->lexer, RID_VOLATILE))
+  /* Handle the asm-qualifier-list.  */
+  location_t volatile_loc = UNKNOWN_LOCATION;
+  location_t inline_loc = UNKNOWN_LOCATION;
+  location_t goto_loc = UNKNOWN_LOCATION;
+  location_t first_loc = UNKNOWN_LOCATION;
+
+  if (cp_parser_allow_gnu_extensions_p (parser))
+    for (;;)
+      {
+	cp_token *token = cp_lexer_peek_token (parser->lexer);
+	location_t loc = token->location;
+	switch (cp_lexer_peek_token (parser->lexer)->keyword)
+	  {
+	  case RID_VOLATILE:
+	    if (volatile_loc)
+	      {
+		error_at (loc, "duplicate asm qualifier %qT", token->u.value);
+		inform (volatile_loc, "first seen here");
+	      }
+	    else
+	      volatile_loc = loc;
+	    cp_lexer_consume_token (parser->lexer);
+	    continue;
+
+	  case RID_INLINE:
+	    if (inline_loc)
+	      {
+		error_at (loc, "duplicate asm qualifier %qT", token->u.value);
+		inform (inline_loc, "first seen here");
+	      }
+	    else
+	      inline_loc = loc;
+	    if (!first_loc)
+	      first_loc = loc;
+	    cp_lexer_consume_token (parser->lexer);
+	    continue;
+
+	  case RID_GOTO:
+	    if (goto_loc)
+	      {
+		error_at (loc, "duplicate asm qualifier %qT", token->u.value);
+		inform (goto_loc, "first seen here");
+	      }
+	    else
+	      goto_loc = loc;
+	    if (!first_loc)
+	      first_loc = loc;
+	    cp_lexer_consume_token (parser->lexer);
+	    continue;
+
+	  case RID_CONST:
+	  case RID_RESTRICT:
+	    error_at (loc, "%qT is not an asm qualifier", token->u.value);
+	    cp_lexer_consume_token (parser->lexer);
+	    continue;
+
+	  default:
+	    break;
+	  }
+	break;
+      }
+
+  bool volatile_p = (volatile_loc != UNKNOWN_LOCATION);
+  bool inline_p = (inline_loc != UNKNOWN_LOCATION);
+  bool goto_p = (goto_loc != UNKNOWN_LOCATION);
+
+  if (!parser->in_function_body && (inline_p || goto_p))
     {
-      /* Remember that we saw the `volatile' keyword.  */
-      volatile_p = true;
-      /* Consume the token.  */
-      cp_lexer_consume_token (parser->lexer);
+      error_at (first_loc, "asm qualifier outside of function body");
+      inline_p = goto_p = false;
     }
-  if (cp_parser_allow_gnu_extensions_p (parser)
-      && parser->in_function_body
-      && cp_lexer_next_token_is_keyword (parser->lexer, RID_GOTO))
-    {
-      /* Remember that we saw the `goto' keyword.  */
-      goto_p = true;
-      /* Consume the token.  */
-      cp_lexer_consume_token (parser->lexer);
-    }
+
   /* Look for the opening `('.  */
   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))
     return;
@@ -18941,8 +19006,7 @@
 					     CPP_CLOSE_PAREN))
 	    clobbers = cp_parser_asm_clobber_list (parser);
 	}
-      else if (goto_p
-	       && cp_lexer_next_token_is (parser->lexer, CPP_SCOPE))
+      else if (goto_p && cp_lexer_next_token_is (parser->lexer, CPP_SCOPE))
 	/* The labels are coming next.  */
 	labels_p = true;
 
@@ -18976,7 +19040,7 @@
       if (parser->in_function_body)
 	{
 	  asm_stmt = finish_asm_stmt (volatile_p, string, outputs,
-				      inputs, clobbers, labels);
+				      inputs, clobbers, labels, inline_p);
 	  /* If the extended syntax was not used, mark the ASM_EXPR.  */
 	  if (!extended_p)
 	    {
Index: gcc/cp/cp-tree.h
===================================================================
--- a/src/gcc/cp/cp-tree.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cp/cp-tree.h	(.../branches/gcc-7-branch)
@@ -6455,7 +6455,7 @@
 
 extern void finish_compound_stmt		(tree);
 extern tree finish_asm_stmt			(int, tree, tree, tree, tree,
-						 tree);
+						 tree, bool);
 extern tree finish_label_stmt			(tree);
 extern void finish_label_decl			(tree);
 extern cp_expr finish_parenthesized_expr	(cp_expr);
Index: gcc/df-core.c
===================================================================
--- a/src/gcc/df-core.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/df-core.c	(.../branches/gcc-7-branch)
@@ -298,12 +298,12 @@
 
    Artificial defs and uses occur both at the beginning and ends of blocks.
 
-     For blocks that area at the destination of eh edges, the
+     For blocks that are at the destination of eh edges, the
      artificial uses and defs occur at the beginning.  The defs relate
      to the registers specified in EH_RETURN_DATA_REGNO and the uses
-     relate to the registers specified in ED_USES.  Logically these
+     relate to the registers specified in EH_USES.  Logically these
      defs and uses should really occur along the eh edge, but there is
-     no convenient way to do this.  Artificial edges that occur at the
+     no convenient way to do this.  Artificial defs that occur at the
      beginning of the block have the DF_REF_AT_TOP flag set.
 
      Artificial uses occur at the end of all blocks.  These arise from
Index: gcc/ipa-pure-const.c
===================================================================
--- a/src/gcc/ipa-pure-const.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ipa-pure-const.c	(.../branches/gcc-7-branch)
@@ -1233,7 +1233,7 @@
   bool remove_p = false;
   bool has_cdtor;
 
-  order_pos = ipa_reduced_postorder (order, true, false,
+  order_pos = ipa_reduced_postorder (order, true,
 				     ignore_edge_for_pure_const);
   if (dump_file)
     {
@@ -1566,7 +1566,7 @@
   int i;
   struct ipa_dfs_info * w_info;
 
-  order_pos = ipa_reduced_postorder (order, true, false,
+  order_pos = ipa_reduced_postorder (order, true,
 				     ignore_edge_for_nothrow);
   if (dump_file)
     {
Index: gcc/xcoffout.c
===================================================================
--- a/src/gcc/xcoffout.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/xcoffout.c	(.../branches/gcc-7-branch)
@@ -63,6 +63,7 @@
 
 char *xcoff_bss_section_name;
 char *xcoff_private_data_section_name;
+char *xcoff_private_rodata_section_name;
 char *xcoff_tls_data_section_name;
 char *xcoff_tbss_section_name;
 char *xcoff_read_only_section_name;
Index: gcc/tree-ssa-dom.c
===================================================================
--- a/src/gcc/tree-ssa-dom.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssa-dom.c	(.../branches/gcc-7-branch)
@@ -531,7 +531,8 @@
 	  if (bb == NULL)
 	    continue;
 	  while (single_succ_p (bb)
-		 && (single_succ_edge (bb)->flags & EDGE_EH) == 0)
+		 && (single_succ_edge (bb)->flags
+		     & (EDGE_EH|EDGE_DFS_BACK)) == 0)
 	    bb = single_succ (bb);
 	  if (bb == EXIT_BLOCK_PTR_FOR_FN (fun))
 	    continue;
Index: gcc/xcoffout.h
===================================================================
--- a/src/gcc/xcoffout.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/xcoffout.h	(.../branches/gcc-7-branch)
@@ -127,6 +127,7 @@
 
 extern char *xcoff_bss_section_name;
 extern char *xcoff_private_data_section_name;
+extern char *xcoff_private_rodata_section_name;
 extern char *xcoff_tls_data_section_name;
 extern char *xcoff_tbss_section_name;
 extern char *xcoff_read_only_section_name;
Index: gcc/ipa-utils.c
===================================================================
--- a/src/gcc/ipa-utils.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ipa-utils.c	(.../branches/gcc-7-branch)
@@ -63,7 +63,6 @@
   int order_pos;
   splay_tree nodes_marked_new;
   bool reduce;
-  bool allow_overwritable;
   int count;
 };
 
@@ -105,7 +104,7 @@
 
       if (w->aux
 	  && (avail > AVAIL_INTERPOSABLE
-	      || (env->allow_overwritable && avail == AVAIL_INTERPOSABLE)))
+	      || avail == AVAIL_INTERPOSABLE))
 	{
 	  w_info = (struct ipa_dfs_info *) w->aux;
 	  if (w_info->new_node)
@@ -162,7 +161,7 @@
 
 int
 ipa_reduced_postorder (struct cgraph_node **order,
-		       bool reduce, bool allow_overwritable,
+		       bool reduce,
 		       bool (*ignore_edge) (struct cgraph_edge *))
 {
   struct cgraph_node *node;
@@ -175,7 +174,6 @@
   env.nodes_marked_new = splay_tree_new (splay_tree_compare_ints, 0, 0);
   env.count = 1;
   env.reduce = reduce;
-  env.allow_overwritable = allow_overwritable;
 
   FOR_EACH_DEFINED_FUNCTION (node)
     {
@@ -182,8 +180,7 @@
       enum availability avail = node->get_availability ();
 
       if (avail > AVAIL_INTERPOSABLE
-	  || (allow_overwritable
-	      && (avail == AVAIL_INTERPOSABLE)))
+	  || avail == AVAIL_INTERPOSABLE)
 	{
 	  /* Reuse the info if it is already there.  */
 	  struct ipa_dfs_info *info = (struct ipa_dfs_info *) node->aux;
Index: gcc/ipa-utils.h
===================================================================
--- a/src/gcc/ipa-utils.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ipa-utils.h	(.../branches/gcc-7-branch)
@@ -36,7 +36,7 @@
 
 /* In ipa-utils.c  */
 void ipa_print_order (FILE*, const char *, struct cgraph_node**, int);
-int ipa_reduced_postorder (struct cgraph_node **, bool, bool,
+int ipa_reduced_postorder (struct cgraph_node **, bool,
 			  bool (*ignore_edge) (struct cgraph_edge *));
 void ipa_free_postorder_info (void);
 vec<cgraph_node *> ipa_get_nodes_in_cycle (struct cgraph_node *);
Index: gcc/lto-wrapper.c
===================================================================
--- a/src/gcc/lto-wrapper.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/lto-wrapper.c	(.../branches/gcc-7-branch)
@@ -1403,7 +1403,9 @@
 	  struct pex_obj *pex;
 	  char jobs[32];
 
-	  fprintf (mstream, "all:");
+	  fprintf (mstream,
+		   ".PHONY: all\n"
+		   "all:");
 	  for (i = 0; i < nr; ++i)
 	    fprintf (mstream, " \\\n\t%s", output_names[i]);
 	  fprintf (mstream, "\n");
Index: gcc/ipa-inline.c
===================================================================
--- a/src/gcc/ipa-inline.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ipa-inline.c	(.../branches/gcc-7-branch)
@@ -1745,7 +1745,7 @@
      metrics.  */
 
   max_count = 0;
-  ipa_reduced_postorder (order, true, true, NULL);
+  ipa_reduced_postorder (order, true, NULL);
   free (order);
 
   FOR_EACH_DEFINED_FUNCTION (node)
Index: gcc/opts.c
===================================================================
--- a/src/gcc/opts.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/opts.c	(.../branches/gcc-7-branch)
@@ -654,9 +654,18 @@
   /* For -O1 only do loop invariant motion for very small loops.  */
   maybe_set_param_value
     (PARAM_LOOP_INVARIANT_MAX_BBS_IN_LOOP,
-     opt2 ? default_param_value (PARAM_LOOP_INVARIANT_MAX_BBS_IN_LOOP) : 1000,
+     opt2 ? default_param_value (PARAM_LOOP_INVARIANT_MAX_BBS_IN_LOOP)
+     : default_param_value (PARAM_LOOP_INVARIANT_MAX_BBS_IN_LOOP) / 10,
      opts->x_param_values, opts_set->x_param_values);
 
+  /* For -O1 reduce the maximum number of active local stores for RTL DSE
+     since this can consume huge amounts of memory (PR89115).  */
+  maybe_set_param_value
+    (PARAM_MAX_DSE_ACTIVE_LOCAL_STORES,
+     opt2 ? default_param_value (PARAM_MAX_DSE_ACTIVE_LOCAL_STORES)
+     : default_param_value (PARAM_MAX_DSE_ACTIVE_LOCAL_STORES) / 10,
+     opts->x_param_values, opts_set->x_param_values);
+
   /* At -Ofast, allow store motion to introduce potential race conditions.  */
   maybe_set_param_value
     (PARAM_ALLOW_STORE_DATA_RACES,
Index: gcc/ada/exp_ch6.adb
===================================================================
--- a/src/gcc/ada/exp_ch6.adb	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ada/exp_ch6.adb	(.../branches/gcc-7-branch)
@@ -3937,6 +3937,23 @@
               Unchecked_Convert_To
                 (RTE (RE_Address), Relocate_Node (First_Actual (Call_Node))));
             return;
+
+         --  A call to a null procedure is replaced by a null statement, but we
+         --  are not allowed to ignore possible side effects of the call, so we
+         --  make sure that actuals are evaluated.
+         --  We also suppress this optimization for GNATCoverage.
+
+         elsif Is_Null_Procedure (Subp)
+           and then not Opt.Suppress_Control_Flow_Optimizations
+         then
+            Actual := First_Actual (Call_Node);
+            while Present (Actual) loop
+               Remove_Side_Effects (Actual);
+               Next_Actual (Actual);
+            end loop;
+
+            Rewrite (Call_Node, Make_Null_Statement (Loc));
+            return;
          end if;
 
          --  Handle inlining. No action needed if the subprogram is not inlined
Index: gcc/ada/ChangeLog
===================================================================
--- a/src/gcc/ada/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ada/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,101 @@
+2019-06-29  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (mark_visited_r): Set TYPE_SIZES_GIMPLIFIED on
+	the main variant of a type, if any.
+
+2019-06-29  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (set_nonaliased_component_on_array_type): Add
+	missing guard for the presence of TYPE_CANONICAL.
+	(set_reverse_storage_order_on_array_type): Likewise.
+
+2019-05-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (walk_nesting_tree): New static function.
+	(finalize_nrv): Use it to walk the entire nesting tree.
+
+2019-05-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* gcc-interface/Makefile.in (install-gcc-specs): Use foreach.
+	Honor DESTDIR.
+
+2019-02-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/81956
+	Backport from mainline
+	2017-09-06  Ed Schonberg  <schonberg@adacore.com>
+
+	* exp_ch6.adb (Expand_Call_Helper): Do not optimize calls to
+	null procedures when GNAT coverage is used, so that their (empty)
+	bodies are properly covered.
+
+	2017-09-06  Ed Schonberg  <schonberg@adacore.com>
+
+	* exp_ch6.adb (Expand_Call_Helper): Replace call to null
+	procedure by a single null statement, after evaluating the
+	actuals that require it.
+
+2019-02-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/89349
+	Backport from mainline
+	2018-05-25  Arnaud Charlet  <charlet@adacore.com>
+
+	* osint.ads (Unknown_Attributes): No longer pretend this is a constant.
+	(No_File_Info_Cache): Initialize separately.
+	* osint.adb (No_File_Info_Cache): Update initializer.
+
+2019-02-08  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (Loop_Statement_to_gnu): Replace tests on
+	individual flag_unswitch_loops and flag_tree_loop_vectorize switches
+	with test on global optimize switch.
+	(Raise_Error_to_gnu): Likewise.
+
+2019-02-07  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* s-linux-sparc.ads (ETIMEDOUT): Set to correct value.
+
+2019-02-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2017-09-05  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (annotate_value): Tidy up.
+	<INTEGER_CST>: Set TCODE instead of recursing.
+	<COMPONENT_REF>: Set TCODE instead of calling Create_Node manually.
+	<MULT_EXPR, PLUS_EXPR>: Fold conversions into inner operations.
+	<BIT_AND_EXPR>: Adjust.
+	<CALL_EXPR>: Do not fall through.
+
+2019-01-27  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (array_type_has_nonaliased_component): Return
+	the same value for every dimension of a multidimensional array type.
+
+2019-01-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (gnat_to_gnu) <N_Assignment_Statement>: Use
+	DECL_SIZE_UNIT instead of TYPE_SIZE_UNIT for the size to be assigned
+	by a call to memset if the LHS is a DECL.
+
+2019-01-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (struct loop_info_d): Remove artificial field.
+	(Loop_Statement_to_gnu): Do not set it.
+
+2019-01-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (annotate_value) <INTEGER_CST>: Use test on
+	the sign bit instead of on the sign of the value.
+	<PLUS_EXPR>: Turn addition of negative constant into subtraction.
+	<BIT_AND_EXPR>: Simplify.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* adaint.c [__APPLE__] (__gnat_lwp_self): Ensure that the system
+	interface used is available on the target.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: gcc/ada/s-linux-sparc.ads
===================================================================
--- a/src/gcc/ada/s-linux-sparc.ads	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ada/s-linux-sparc.ads	(.../branches/gcc-7-branch)
@@ -70,7 +70,7 @@
    EINVAL    : constant := 22;
    ENOMEM    : constant := 12;
    EPERM     : constant := 1;
-   ETIMEDOUT : constant := 110;
+   ETIMEDOUT : constant := 60;
 
    -------------
    -- Signals --
Index: gcc/ada/adaint.c
===================================================================
--- a/src/gcc/ada/adaint.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ada/adaint.c	(.../branches/gcc-7-branch)
@@ -3174,9 +3174,13 @@
 #endif
 
 #if defined (__APPLE__)
-#include <mach/thread_info.h>
-#include <mach/mach_init.h>
-#include <mach/thread_act.h>
+# if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1060
+#  include <mach/thread_info.h>
+#  include <mach/mach_init.h>
+#  include <mach/thread_act.h>
+# else
+#  include <pthread.h>
+# endif
 
 /* System-wide thread identifier.  Note it could be truncated on 32 bit
    hosts.
@@ -3184,6 +3188,7 @@
 void *
 __gnat_lwp_self (void)
 {
+#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1060
   thread_identifier_info_data_t data;
   mach_msg_type_number_t count = THREAD_IDENTIFIER_INFO_COUNT;
   kern_return_t kret;
@@ -3194,6 +3199,9 @@
     return (void *)(uintptr_t)data.thread_id;
   else
     return 0;
+#else
+  return (void *)pthread_mach_thread_np (pthread_self ());
+#endif
 }
 #endif
 
Index: gcc/ada/gcc-interface/Makefile.in
===================================================================
--- a/src/gcc/ada/gcc-interface/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ada/gcc-interface/Makefile.in	(.../branches/gcc-7-branch)
@@ -2660,9 +2660,8 @@
 install-gcc-specs:
 #	Install all the requested GCC spec files.
 
-	for f in $(GCC_SPEC_FILES); do \
-	    $(INSTALL_DATA_DATE) $(srcdir)/ada/$$f $(libsubdir)/; \
-	done
+	$(foreach f,$(GCC_SPEC_FILES), \
+	    $(INSTALL_DATA_DATE) $(srcdir)/ada/$(f) $(DESTDIR)$(libsubdir)/;)
 
 install-gnatlib: ../stamp-gnatlib-$(RTSDIR) install-gcc-specs
 	$(RMDIR) $(DESTDIR)$(ADA_RTL_OBJ_DIR)
Index: gcc/ada/gcc-interface/decl.c
===================================================================
--- a/src/gcc/ada/gcc-interface/decl.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ada/gcc-interface/decl.c	(.../branches/gcc-7-branch)
@@ -6307,7 +6307,8 @@
 set_nonaliased_component_on_array_type (tree type)
 {
   TYPE_NONALIASED_COMPONENT (type) = 1;
-  TYPE_NONALIASED_COMPONENT (TYPE_CANONICAL (type)) = 1;
+  if (TYPE_CANONICAL (type))
+    TYPE_NONALIASED_COMPONENT (TYPE_CANONICAL (type)) = 1;
 }
 
 /* Set TYPE_REVERSE_STORAGE_ORDER on an array type built by means of
@@ -6317,7 +6318,8 @@
 set_reverse_storage_order_on_array_type (tree type)
 {
   TYPE_REVERSE_STORAGE_ORDER (type) = 1;
-  TYPE_REVERSE_STORAGE_ORDER (TYPE_CANONICAL (type)) = 1;
+  if (TYPE_CANONICAL (type))
+    TYPE_REVERSE_STORAGE_ORDER (TYPE_CANONICAL (type)) = 1;
 }
 
 /* Return true if DISCR1 and DISCR2 represent the same discriminant.  */
@@ -6341,12 +6343,6 @@
 static bool
 array_type_has_nonaliased_component (tree gnu_type, Entity_Id gnat_type)
 {
-  /* If the array type is not the innermost dimension of the GNAT type,
-     then it has a non-aliased component.  */
-  if (TREE_CODE (TREE_TYPE (gnu_type)) == ARRAY_TYPE
-      && TYPE_MULTI_ARRAY_P (TREE_TYPE (gnu_type)))
-    return true;
-
   /* If the array type has an aliased component in the front-end sense,
      then it also has an aliased component in the back-end sense.  */
   if (Has_Aliased_Components (gnat_type))
@@ -6357,15 +6353,17 @@
   if (Is_Derived_Type (gnat_type))
     {
       tree gnu_parent_type = gnat_to_gnu_type (Etype (gnat_type));
-      int index;
       if (TREE_CODE (gnu_parent_type) == UNCONSTRAINED_ARRAY_TYPE)
 	gnu_parent_type
 	  = TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_parent_type))));
-      for (index = Number_Dimensions (gnat_type) - 1; index > 0; index--)
-	gnu_parent_type = TREE_TYPE (gnu_parent_type);
       return TYPE_NONALIASED_COMPONENT (gnu_parent_type);
     }
 
+  /* For a multi-dimensional array type, find the component type.  */
+  while (TREE_CODE (TREE_TYPE (gnu_type)) == ARRAY_TYPE
+	 && TYPE_MULTI_ARRAY_P (TREE_TYPE (gnu_type)))
+    gnu_type = TREE_TYPE (gnu_type);
+
   /* Otherwise, rely exclusively on properties of the element type.  */
   return type_for_nonaliased_component_p (TREE_TYPE (gnu_type));
 }
@@ -8052,9 +8050,8 @@
 annotate_value (tree gnu_size)
 {
   TCode tcode;
-  Node_Ref_Or_Val ops[3], ret, pre_op1 = No_Uint;
+  Node_Ref_Or_Val ops[3] = { No_Uint, No_Uint, No_Uint };
   struct tree_int_map in;
-  int i;
 
   /* See if we've already saved the value for this node.  */
   if (EXPR_P (gnu_size))
@@ -8071,49 +8068,56 @@
     in.base.from = NULL_TREE;
 
   /* If we do not return inside this switch, TCODE will be set to the
-     code to use for a Create_Node operand and LEN (set above) will be
-     the number of recursive calls for us to make.  */
-
+     code to be used in a call to Create_Node.  */
   switch (TREE_CODE (gnu_size))
     {
     case INTEGER_CST:
       /* For negative values, build NEGATE_EXPR of the opposite.  Such values
-	 can appear for discriminants in expressions for variants.  */
-      if (tree_int_cst_sgn (gnu_size) < 0)
+	 can appear for discriminants in expressions for variants.  Note that
+	 sizetype being unsigned, we don't directly use tree_int_cst_sgn.  */
+      if (tree_int_cst_sign_bit (gnu_size))
 	{
 	  tree t = wide_int_to_tree (sizetype, wi::neg (gnu_size));
-	  return annotate_value (build1 (NEGATE_EXPR, sizetype, t));
+	  tcode = Negate_Expr;
+	  ops[0] = UI_From_gnu (t);
 	}
+      else
+	return TREE_OVERFLOW (gnu_size) ? No_Uint : UI_From_gnu (gnu_size);
+      break;
 
-      return TREE_OVERFLOW (gnu_size) ? No_Uint : UI_From_gnu (gnu_size);
-
     case COMPONENT_REF:
       /* The only case we handle here is a simple discriminant reference.  */
       if (DECL_DISCRIMINANT_NUMBER (TREE_OPERAND (gnu_size, 1)))
 	{
-	  tree n = DECL_DISCRIMINANT_NUMBER (TREE_OPERAND (gnu_size, 1));
+	  tree ref = gnu_size;
+	  gnu_size = TREE_OPERAND (ref, 1);
 
 	  /* Climb up the chain of successive extensions, if any.  */
-	  while (TREE_CODE (TREE_OPERAND (gnu_size, 0)) == COMPONENT_REF
-		 && DECL_NAME (TREE_OPERAND (TREE_OPERAND (gnu_size, 0), 1))
+	  while (TREE_CODE (TREE_OPERAND (ref, 0)) == COMPONENT_REF
+		 && DECL_NAME (TREE_OPERAND (TREE_OPERAND (ref, 0), 1))
 		    == parent_name_id)
-	    gnu_size = TREE_OPERAND (gnu_size, 0);
+	    ref = TREE_OPERAND (ref, 0);
 
-	  if (TREE_CODE (TREE_OPERAND (gnu_size, 0)) == PLACEHOLDER_EXPR)
-	    return
-	      Create_Node (Discrim_Val, annotate_value (n), No_Uint, No_Uint);
+	  if (TREE_CODE (TREE_OPERAND (ref, 0)) == PLACEHOLDER_EXPR)
+	    {
+	      /* Fall through to common processing as a FIELD_DECL.  */
+	      tcode = Discrim_Val;
+	      ops[0] = UI_From_gnu (DECL_DISCRIMINANT_NUMBER (gnu_size));
+	    }
+	  else
+	    return No_Uint;
 	}
+      else
+	return No_Uint;
+      break;
 
-      return No_Uint;
-
-    CASE_CONVERT:   case NON_LVALUE_EXPR:
+    CASE_CONVERT:
+    case NON_LVALUE_EXPR:
       return annotate_value (TREE_OPERAND (gnu_size, 0));
 
       /* Now just list the operations we handle.  */
     case COND_EXPR:		tcode = Cond_Expr; break;
-    case PLUS_EXPR:		tcode = Plus_Expr; break;
     case MINUS_EXPR:		tcode = Minus_Expr; break;
-    case MULT_EXPR:		tcode = Mult_Expr; break;
     case TRUNC_DIV_EXPR:	tcode = Trunc_Div_Expr; break;
     case CEIL_DIV_EXPR:		tcode = Ceil_Div_Expr; break;
     case FLOOR_DIV_EXPR:	tcode = Floor_Div_Expr; break;
@@ -8138,20 +8142,56 @@
     case EQ_EXPR:		tcode = Eq_Expr; break;
     case NE_EXPR:		tcode = Ne_Expr; break;
 
+    case PLUS_EXPR:
+      /* Turn addition of negative constant into subtraction.  */
+      if (TREE_CODE (TREE_OPERAND (gnu_size, 1)) == INTEGER_CST
+	  && tree_int_cst_sign_bit (TREE_OPERAND (gnu_size, 1)))
+	{
+	  tcode = Minus_Expr;
+	  ops[0] = annotate_value (TREE_OPERAND (gnu_size, 0));
+	  wide_int op1 = wi::neg (TREE_OPERAND (gnu_size, 1));
+	  ops[1] = annotate_value (wide_int_to_tree (sizetype, op1));
+	  break;
+	}
+
+      /* ... fall through ... */
+
+    case MULT_EXPR:
+      tcode = (TREE_CODE (gnu_size) == MULT_EXPR ? Mult_Expr : Plus_Expr);
+      /* Fold conversions from bytes to bits into inner operations.  */
+      if (TREE_CODE (TREE_OPERAND (gnu_size, 1)) == INTEGER_CST
+	  && CONVERT_EXPR_P (TREE_OPERAND (gnu_size, 0)))
+	{
+	  tree inner_op = TREE_OPERAND (TREE_OPERAND (gnu_size, 0), 0);
+	  if (TREE_CODE (inner_op) == TREE_CODE (gnu_size)
+	      && TREE_CODE (TREE_OPERAND (inner_op, 1)) == INTEGER_CST)
+	    {
+	      ops[0] = annotate_value (TREE_OPERAND (inner_op, 0));
+	      tree inner_op_op1 = TREE_OPERAND (inner_op, 1);
+	      tree gnu_size_op1 = TREE_OPERAND (gnu_size, 1);
+	      wide_int op1;
+	      if (TREE_CODE (gnu_size) == MULT_EXPR)
+		op1 = wi::mul (inner_op_op1, gnu_size_op1);
+	      else
+		{
+		  op1 = wi::add (inner_op_op1, gnu_size_op1);
+		  if (wi::zext (op1, TYPE_PRECISION (sizetype)) == 0)
+		    return ops[0];
+		}
+	      ops[1] = annotate_value (wide_int_to_tree (sizetype, op1));
+	    }
+	}
+      break;
+
     case BIT_AND_EXPR:
       tcode = Bit_And_Expr;
       /* For negative values in sizetype, build NEGATE_EXPR of the opposite.
-	 Such values appear in expressions with aligning patterns.  Note that,
-	 since sizetype is unsigned, we have to jump through some hoops.   */
+	 Such values can appear in expressions with aligning patterns.  */
       if (TREE_CODE (TREE_OPERAND (gnu_size, 1)) == INTEGER_CST)
 	{
-	  tree op1 = TREE_OPERAND (gnu_size, 1);
-	  wide_int signed_op1 = wi::sext (op1, TYPE_PRECISION (sizetype));
-	  if (wi::neg_p (signed_op1))
-	    {
-	      op1 = wide_int_to_tree (sizetype, wi::neg (signed_op1));
-	      pre_op1 = annotate_value (build1 (NEGATE_EXPR, sizetype, op1));
-	    }
+	  wide_int op1 = wi::sext (TREE_OPERAND (gnu_size, 1),
+				   TYPE_PRECISION (sizetype));
+	  ops[1] = annotate_value (wide_int_to_tree (sizetype, op1));
 	}
       break;
 
@@ -8162,14 +8202,11 @@
       if (List_Representation_Info == 3 || type_annotate_only)
 	{
 	  tree t = maybe_inline_call_in_expr (gnu_size);
-	  if (t)
-	    return annotate_value (t);
+	  return t ? annotate_value (t) : No_Uint;
 	}
       else
 	return Uint_Minus_1;
 
-      /* Fall through... */
-
     default:
       return No_Uint;
     }
@@ -8176,20 +8213,15 @@
 
   /* Now get each of the operands that's relevant for this code.  If any
      cannot be expressed as a repinfo node, say we can't.  */
-  for (i = 0; i < 3; i++)
-    ops[i] = No_Uint;
-
-  for (i = 0; i < TREE_CODE_LENGTH (TREE_CODE (gnu_size)); i++)
-    {
-      if (i == 1 && pre_op1 != No_Uint)
-	ops[i] = pre_op1;
-      else
+  for (int i = 0; i < TREE_CODE_LENGTH (TREE_CODE (gnu_size)); i++)
+    if (ops[i] == No_Uint)
+      {
 	ops[i] = annotate_value (TREE_OPERAND (gnu_size, i));
-      if (ops[i] == No_Uint)
-	return No_Uint;
-    }
+	if (ops[i] == No_Uint)
+	  return No_Uint;
+      }
 
-  ret = Create_Node (tcode, ops[0], ops[1], ops[2]);
+  Node_Ref_Or_Val ret = Create_Node (tcode, ops[0], ops[1], ops[2]);
 
   /* Save the result in the cache.  */
   if (in.base.from)
@@ -8202,7 +8234,7 @@
       h = annotate_value_cache->find_slot (&in, INSERT);
       gcc_assert (!*h);
       *h = ggc_alloc<tree_int_map> ();
-      (*h)->base.from = gnu_size;
+      (*h)->base.from = in.base.from;
       (*h)->to = ret;
     }
 
Index: gcc/ada/gcc-interface/trans.c
===================================================================
--- a/src/gcc/ada/gcc-interface/trans.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ada/gcc-interface/trans.c	(.../branches/gcc-7-branch)
@@ -197,7 +197,6 @@
   tree low_bound;
   tree high_bound;
   vec<range_check_info, va_gc> *checks;
-  bool artificial;
 };
 
 typedef struct loop_info_d *loop_info;
@@ -2841,7 +2840,6 @@
 
   /* Save the statement for later reuse.  */
   gnu_loop_info->stmt = gnu_loop_stmt;
-  gnu_loop_info->artificial = !Comes_From_Source (gnat_node);
 
   /* Set the condition under which the loop must keep going.
      For the case "LOOP .... END LOOP;" the condition is always true.  */
@@ -3104,7 +3102,7 @@
 	 unswitching is enabled, do not require the loop bounds to be also
 	 invariant, as their evaluation will still be ahead of the loop.  */
       if (vec_safe_length (gnu_loop_info->checks) > 0
-	 && (make_invariant (&gnu_low, &gnu_high) || flag_unswitch_loops))
+	 && (make_invariant (&gnu_low, &gnu_high) || optimize >= 3))
 	{
 	  struct range_check_info_d *rci;
 	  unsigned int i, n_remaining_checks = 0;
@@ -3156,14 +3154,15 @@
 
 	  /* Note that loop unswitching can only be applied a small number of
 	     times to a given loop (PARAM_MAX_UNSWITCH_LEVEL default to 3).  */
-	  if (0 < n_remaining_checks && n_remaining_checks <= 3
-	      && optimize > 1 && !optimize_size)
+	  if (IN_RANGE (n_remaining_checks, 1, 3)
+	      && optimize >= 2
+	      && !optimize_size)
 	    FOR_EACH_VEC_ELT (*gnu_loop_info->checks, i, rci)
 	      if (rci->invariant_cond != boolean_false_node)
 		{
 		  TREE_OPERAND (rci->inserted_cond, 0) = rci->invariant_cond;
 
-		  if (flag_unswitch_loops)
+		  if (optimize >= 3)
 		    add_stmt_with_node_force (rci->inserted_cond, gnat_node);
 		}
 	}
@@ -3170,8 +3169,7 @@
 
       /* Second, if loop vectorization is enabled and the iterations of the
 	 loop can easily be proved as independent, mark the loop.  */
-      if (optimize
-	  && flag_tree_loop_vectorize
+      if (optimize >= 3
 	  && independent_iterations_p (LOOP_STMT_BODY (gnu_loop_stmt)))
 	LOOP_STMT_IVDEP (gnu_loop_stmt) = 1;
 
@@ -3521,6 +3519,20 @@
   return NULL_TREE;
 }
 
+/* Apply FUNC to all the sub-trees of nested functions in NODE.  FUNC is called
+   with the DATA and the address of each sub-tree.  If FUNC returns a non-NULL
+   value, the traversal is stopped.  */
+
+static void
+walk_nesting_tree (struct cgraph_node *node, walk_tree_fn func, void *data)
+{
+  for (node = node->nested; node; node = node->next_nested)
+    {
+      walk_tree_without_duplicates (&DECL_SAVED_TREE (node->decl), func, data);
+      walk_nesting_tree (node, func, data);
+    }
+}
+
 /* Finalize the Named Return Value optimization for FNDECL.  The NRV bitmap
    contains the candidates for Named Return Value and OTHER is a list of
    the other return values.  GNAT_RET is a representative return node.  */
@@ -3528,7 +3540,6 @@
 static void
 finalize_nrv (tree fndecl, bitmap nrv, vec<tree, va_gc> *other, Node_Id gnat_ret)
 {
-  struct cgraph_node *node;
   struct nrv_data data;
   walk_tree_fn func;
   unsigned int i;
@@ -3549,10 +3560,7 @@
     return;
 
   /* Prune also the candidates that are referenced by nested functions.  */
-  node = cgraph_node::get_create (fndecl);
-  for (node = node->nested; node; node = node->next_nested)
-    walk_tree_without_duplicates (&DECL_SAVED_TREE (node->decl), prune_nrv_r,
-				  &data);
+  walk_nesting_tree (cgraph_node::get_create (fndecl), prune_nrv_r, &data);
   if (bitmap_empty_p (nrv))
     return;
 
@@ -5639,7 +5647,7 @@
 		= build1 (SAVE_EXPR, boolean_type_node, boolean_true_node);
 	      vec_safe_push (loop->checks, rci);
 	      gnu_cond = build_noreturn_cond (gnat_to_gnu (gnat_cond));
-	      if (flag_unswitch_loops)
+	      if (optimize >= 3)
 		gnu_cond = build_binary_op (TRUTH_ANDIF_EXPR,
 					    boolean_type_node,
 					    rci->inserted_cond,
@@ -6906,14 +6914,22 @@
 	  /* Or else, use memset when the conditions are met.  */
 	  else if (use_memset_p)
 	    {
-	      tree value = fold_convert (integer_type_node, gnu_rhs);
-	      tree to = gnu_lhs;
-	      tree type = TREE_TYPE (to);
-	      tree size
-	        = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_SIZE_UNIT (type), to);
-	      tree to_ptr = build_fold_addr_expr (to);
+	      tree value
+		= real_zerop (gnu_rhs)
+		  ? integer_zero_node
+		  : fold_convert (integer_type_node, gnu_rhs);
+	      tree dest = build_fold_addr_expr (gnu_lhs);
 	      tree t = builtin_decl_explicit (BUILT_IN_MEMSET);
-	      if (TREE_CODE (value) == INTEGER_CST)
+	      /* Be extra careful not to write too much data.  */
+	      tree size;
+	      if (TREE_CODE (gnu_lhs) == COMPONENT_REF)
+		size = DECL_SIZE_UNIT (TREE_OPERAND (gnu_lhs, 1));
+	      else if (DECL_P (gnu_lhs))
+		size = DECL_SIZE_UNIT (gnu_lhs);
+	      else
+		size = TYPE_SIZE_UNIT (TREE_TYPE (gnu_lhs));
+	      size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (size, gnu_lhs);
+	      if (TREE_CODE (value) == INTEGER_CST && !integer_zerop (value))
 		{
 		  tree mask
 		    = build_int_cst (integer_type_node,
@@ -6920,7 +6936,7 @@
 				     ((HOST_WIDE_INT) 1 << BITS_PER_UNIT) - 1);
 		  value = int_const_binop (BIT_AND_EXPR, value, mask);
 		}
-	      gnu_result = build_call_expr (t, 3, to_ptr, value, size);
+	      gnu_result = build_call_expr (t, 3, dest, value, size);
 	    }
 
 	  /* Otherwise build a regular assignment.  */
@@ -8084,8 +8100,9 @@
   else if (!TYPE_IS_DUMMY_P (t))
     TREE_VISITED (t) = 1;
 
+  /* The test in gimplify_type_sizes is on the main variant.  */
   if (TYPE_P (t))
-    TYPE_SIZES_GIMPLIFIED (t) = 1;
+    TYPE_SIZES_GIMPLIFIED (TYPE_MAIN_VARIANT (t)) = 1;
 
   return NULL_TREE;
 }
Index: gcc/ada/osint.adb
===================================================================
--- a/src/gcc/ada/osint.adb	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ada/osint.adb	(.../branches/gcc-7-branch)
@@ -250,8 +250,7 @@
       Attr : aliased File_Attributes;
    end record;
 
-   No_File_Info_Cache : constant File_Info_Cache :=
-                          (No_File, Unknown_Attributes);
+   No_File_Info_Cache : constant File_Info_Cache := (No_File, (others => 0));
 
    package File_Name_Hash_Table is new GNAT.HTable.Simple_HTable (
      Header_Num => File_Hash_Num,
Index: gcc/ada/osint.ads
===================================================================
--- a/src/gcc/ada/osint.ads	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ada/osint.ads	(.../branches/gcc-7-branch)
@@ -273,10 +273,26 @@
    --  from the disk and then cached in the File_Attributes parameter (possibly
    --  along with other values).
 
-   type File_Attributes is private;
-   Unknown_Attributes : constant File_Attributes;
+   File_Attributes_Size : constant Natural := 32;
+   --  This should be big enough to fit a "struct file_attributes" on any
+   --  system. It doesn't cause any malfunction if it is too big (which avoids
+   --  the need for either mapping the struct exactly or importing the sizeof
+   --  from C, which would result in dynamic code). However, it does waste
+   --  space (e.g. when a component of this type appears in a record, if it is
+   --  unnecessarily large). Note: for runtime units, use System.OS_Constants.
+   --  SIZEOF_struct_file_attributes instead, which has the exact value.
+
+   type File_Attributes is
+     array (1 .. File_Attributes_Size)
+       of System.Storage_Elements.Storage_Element;
+   for File_Attributes'Alignment use Standard'Maximum_Alignment;
+
+   Unknown_Attributes : File_Attributes;
    --  A cache for various attributes for a file (length, accessibility,...)
-   --  This must be initialized to Unknown_Attributes prior to the first call.
+   --  Will be initialized properly at elaboration (for efficiency later on,
+   --  avoid function calls every time we want to reset the attributes) prior
+   --  to the first usage. We cannot make it constant since the compiler may
+   --  put it in a read-only section.
 
    function Is_Directory
      (Name : C_File_Name;
@@ -769,22 +785,4 @@
    --  detected, the file being written is deleted, and a fatal error is
    --  signalled.
 
-   File_Attributes_Size : constant Natural := 32;
-   --  This should be big enough to fit a "struct file_attributes" on any
-   --  system. It doesn't cause any malfunction if it is too big (which avoids
-   --  the need for either mapping the struct exactly or importing the sizeof
-   --  from C, which would result in dynamic code). However, it does waste
-   --  space (e.g. when a component of this type appears in a record, if it is
-   --  unnecessarily large). Note: for runtime units, use System.OS_Constants.
-   --  SIZEOF_struct_file_attributes instead, which has the exact value.
-
-   type File_Attributes is
-     array (1 .. File_Attributes_Size)
-       of System.Storage_Elements.Storage_Element;
-   for File_Attributes'Alignment use Standard'Maximum_Alignment;
-
-   Unknown_Attributes : constant File_Attributes := (others => 0);
-   --  Will be initialized properly at elaboration (for efficiency later on,
-   --  avoid function calls every time we want to reset the attributes).
-
 end Osint;
Index: gcc/dse.c
===================================================================
--- a/src/gcc/dse.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/dse.c	(.../branches/gcc-7-branch)
@@ -2389,10 +2389,13 @@
 		clear_rhs_from_active_local_stores ();
 	    }
 	}
-      else if (SIBLING_CALL_P (insn) && reload_completed)
+      else if (SIBLING_CALL_P (insn)
+	       && (reload_completed || HARD_FRAME_POINTER_IS_ARG_POINTER))
 	/* Arguments for a sibling call that are pushed to memory are passed
 	   using the incoming argument pointer of the current function.  After
-	   reload that might be (and likely is) frame pointer based.  */
+	   reload that might be (and likely is) frame pointer based.  And, if
+	   it is a frame pointer on the target, even before reload we need to
+	   kill frame pointer based stores.  */
 	add_wild_read (bb_info);
       else
 	/* Every other call, including pure functions, may read any memory
Index: gcc/gimple-ssa-strength-reduction.c
===================================================================
--- a/src/gcc/gimple-ssa-strength-reduction.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/gimple-ssa-strength-reduction.c	(.../branches/gcc-7-branch)
@@ -1220,7 +1220,7 @@
       c->next_interp = c2->cand_num;
       c2->first_interp = c->cand_num;
     }
-  else
+  else if (TREE_CODE (rhs2) == INTEGER_CST && !integer_zerop (rhs2))
     {
       /* Record an interpretation for the multiply-immediate.  */
       c = create_mul_imm_cand (gs, rhs1, rhs2, speed);
Index: gcc/fortran/interface.c
===================================================================
--- a/src/gcc/fortran/interface.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/interface.c	(.../branches/gcc-7-branch)
@@ -691,6 +691,15 @@
   if (ts1->type == BT_VOID || ts2->type == BT_VOID)
     return true;
 
+  /* Special case for our C interop types.  There should be a better
+     way of doing this...  */
+
+  if (((ts1->type == BT_INTEGER && ts2->type == BT_DERIVED)
+       || (ts1->type == BT_DERIVED && ts2->type == BT_INTEGER))
+      && ts1->u.derived && ts2->u.derived
+      && ts1->u.derived == ts2->u.derived)
+    return true;
+
   /* The _data component is not always present, therefore check for its
      presence before assuming, that its derived->attr is available.
      When the _data component is not present, then nevertheless the
Index: gcc/fortran/intrinsic.c
===================================================================
--- a/src/gcc/fortran/intrinsic.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/intrinsic.c	(.../branches/gcc-7-branch)
@@ -4919,6 +4919,8 @@
   if (ts->type == BT_UNKNOWN)
     goto bad;
 
+  expr->do_not_warn = ! wflag;
+
   /* NULL and zero size arrays get their type here.  */
   if (expr->expr_type == EXPR_NULL
       || (expr->expr_type == EXPR_ARRAY && expr->value.constructor == NULL))
Index: gcc/fortran/trans-expr.c
===================================================================
--- a/src/gcc/fortran/trans-expr.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/trans-expr.c	(.../branches/gcc-7-branch)
@@ -391,7 +391,7 @@
       e->ref = NULL;
     }
 
-  base_expr = gfc_expr_to_initialize (e);
+  base_expr = gfc_copy_expr (e);
 
   /* Restore the original tail expression.  */
   if (class_ref)
@@ -2987,6 +2987,83 @@
     if (gfc_conv_cst_int_power (se, lse.expr, rse.expr))
       return;
 
+  if (INTEGER_CST_P (lse.expr)
+      && TREE_CODE (TREE_TYPE (rse.expr)) == INTEGER_TYPE)
+    {
+      wide_int wlhs = lse.expr;
+      HOST_WIDE_INT v;
+      v = wlhs.to_shwi ();
+      if (v == 1)
+	{
+	  /* 1**something is always 1.  */
+	  se->expr = build_int_cst (TREE_TYPE (lse.expr), 1);
+	  return;
+	}
+      else if (v == 2 || v == 4 || v == 8 || v == 16)
+	{
+	  /* 2**n = 1<<n, 4**n = 1<<(n+n), 8**n = 1 <<(3*n), 16**n =
+	   1<<(4*n), but we have to make sure to return zero if the
+	   number of bits is too large. */
+	  tree lshift;
+	  tree type;
+	  tree shift;
+	  tree ge;
+	  tree cond;
+	  tree num_bits;
+	  tree cond2;
+
+	  type = TREE_TYPE (lse.expr);
+
+	  if (v == 2)
+	    shift = rse.expr;
+	  else if (v == 4)
+	    shift = fold_build2_loc (input_location, PLUS_EXPR,
+				     TREE_TYPE (rse.expr),
+				       rse.expr, rse.expr);
+	  else if (v == 8)
+	    shift = fold_build2_loc (input_location, MULT_EXPR,
+				     TREE_TYPE (rse.expr),
+				     build_int_cst (TREE_TYPE (rse.expr), 3),
+				     rse.expr);
+	  else if (v == 16)
+	    shift = fold_build2_loc (input_location, MULT_EXPR,
+				     TREE_TYPE (rse.expr),
+				     build_int_cst (TREE_TYPE (rse.expr), 4),
+				     rse.expr);
+	  else
+	    gcc_unreachable ();
+
+	  lshift = fold_build2_loc (input_location, LSHIFT_EXPR, type,
+				    build_int_cst (type, 1), shift);
+	  ge = fold_build2_loc (input_location, GE_EXPR, logical_type_node,
+				rse.expr, build_int_cst (type, 0));
+	  cond = fold_build3_loc (input_location, COND_EXPR, type, ge, lshift,
+				 build_int_cst (type, 0));
+	  num_bits = build_int_cst (TREE_TYPE (rse.expr), TYPE_PRECISION (type));
+	  cond2 = fold_build2_loc (input_location, GE_EXPR, logical_type_node,
+				   rse.expr, num_bits);
+	  se->expr = fold_build3_loc (input_location, COND_EXPR, type, cond2,
+				      build_int_cst (type, 0), cond);
+	  return;
+	}
+      else if (v == -1)
+	{
+	  /* (-1)**n is 1 - ((n & 1) << 1) */
+	  tree type;
+	  tree tmp;
+
+	  type = TREE_TYPE (lse.expr);
+	  tmp = fold_build2_loc (input_location, BIT_AND_EXPR, type,
+				 rse.expr, build_int_cst (type, 1));
+	  tmp = fold_build2_loc (input_location, LSHIFT_EXPR, type,
+				 tmp, build_int_cst (type, 1));
+	  tmp = fold_build2_loc (input_location, MINUS_EXPR, type,
+				 build_int_cst (type, 1), tmp);
+	  se->expr = tmp;
+	  return;
+	}
+    }
+
   gfc_int4_type_node = gfc_get_int_type (4);
 
   /* In case of integer operands with kinds 1 or 2, we call the integer kind 4
@@ -3722,7 +3799,8 @@
 
 
 static void
-conv_function_val (gfc_se * se, gfc_symbol * sym, gfc_expr * expr)
+conv_function_val (gfc_se * se, gfc_symbol * sym, gfc_expr * expr,
+		   gfc_actual_arglist *actual_args)
 {
   tree tmp;
 
@@ -3740,7 +3818,7 @@
   else
     {
       if (!sym->backend_decl)
-	sym->backend_decl = gfc_get_extern_function_decl (sym);
+	sym->backend_decl = gfc_get_extern_function_decl (sym, actual_args);
 
       TREE_USED (sym->backend_decl) = 1;
 
@@ -5635,6 +5713,16 @@
 	      break;
 	    }
 
+	  if (e->ts.type == BT_DERIVED && fsym && fsym->ts.type == BT_CLASS)
+	    {
+	      /* The derived type is passed to gfc_deallocate_alloc_comp.
+		 Therefore, class actuals can be handled correctly but derived
+		 types passed to class formals need the _data component.  */
+	      tmp = gfc_class_data_get (tmp);
+	      if (!CLASS_DATA (fsym)->attr.dimension)
+		tmp = build_fold_indirect_ref_loc (input_location, tmp);
+	    }
+
 	  if (e->expr_type == EXPR_OP
 		&& e->value.op.op == INTRINSIC_PARENTHESES
 		&& e->value.op.op1->expr_type == EXPR_VARIABLE)
@@ -5646,16 +5734,6 @@
 	      gfc_add_expr_to_block (&se->post, local_tmp);
 	    }
 
-	  if (e->ts.type == BT_DERIVED && fsym && fsym->ts.type == BT_CLASS)
-	    {
-	      /* The derived type is passed to gfc_deallocate_alloc_comp.
-		 Therefore, class actuals can handled correctly but derived
-		 types passed to class formals need the _data component.  */
-	      tmp = gfc_class_data_get (tmp);
-	      if (!CLASS_DATA (fsym)->attr.dimension)
-		tmp = build_fold_indirect_ref_loc (input_location, tmp);
-	    }
-
 	  tmp = gfc_deallocate_alloc_comp (e->ts.u.derived, tmp, parm_rank);
 
 	  gfc_prepend_expr_to_block (&post, tmp);
@@ -6161,7 +6239,7 @@
 
   /* Generate the actual call.  */
   if (base_object == NULL_TREE)
-    conv_function_val (se, sym, expr);
+    conv_function_val (se, sym, expr, args);
   else
     conv_base_obj_fcn_val (se, base_object, expr);
 
@@ -8255,24 +8333,7 @@
     }
 }
 
-/* Indentify class valued proc_pointer assignments.  */
 
-static bool
-pointer_assignment_is_proc_pointer (gfc_expr * expr1, gfc_expr * expr2)
-{
-  gfc_ref * ref;
-
-  ref = expr1->ref;
-  while (ref && ref->next)
-     ref = ref->next;
-
-  return ref && ref->type == REF_COMPONENT
-      && ref->u.c.component->attr.proc_pointer
-      && expr2->expr_type == EXPR_VARIABLE
-      && expr2->symtree->n.sym->attr.flavor == FL_PROCEDURE;
-}
-
-
 /* Do everything that is needed for a CLASS function expr2.  */
 
 static tree
@@ -8325,7 +8386,7 @@
   tree tmp;
   tree decl;
   tree expr1_vptr = NULL_TREE;
-  bool scalar, non_proc_pointer_assign;
+  bool scalar, non_proc_ptr_assign;
   gfc_ss *ss;
 
   gfc_start_block (&block);
@@ -8333,7 +8394,9 @@
   gfc_init_se (&lse, NULL);
 
   /* Usually testing whether this is not a proc pointer assignment.  */
-  non_proc_pointer_assign = !pointer_assignment_is_proc_pointer (expr1, expr2);
+  non_proc_ptr_assign = !(gfc_expr_attr (expr1).proc_pointer
+			&& expr2->expr_type == EXPR_VARIABLE
+			&& expr2->symtree->n.sym->attr.flavor == FL_PROCEDURE);
 
   /* Check whether the expression is a scalar or not; we cannot use
      expr1->rank as it can be nonzero for proc pointers.  */
@@ -8343,7 +8406,7 @@
     gfc_free_ss_chain (ss);
 
   if (expr1->ts.type == BT_DERIVED && expr2->ts.type == BT_CLASS
-      && expr2->expr_type != EXPR_FUNCTION && non_proc_pointer_assign)
+      && expr2->expr_type != EXPR_FUNCTION && non_proc_ptr_assign)
     {
       gfc_add_data_component (expr2);
       /* The following is required as gfc_add_data_component doesn't
@@ -8363,7 +8426,7 @@
       else
 	gfc_conv_expr (&rse, expr2);
 
-      if (non_proc_pointer_assign && expr1->ts.type == BT_CLASS)
+      if (non_proc_ptr_assign && expr1->ts.type == BT_CLASS)
 	{
 	  trans_class_vptr_len_assignment (&block, expr1, expr2, &rse, NULL,
 					   NULL);
Index: gcc/fortran/trans-array.c
===================================================================
--- a/src/gcc/fortran/trans-array.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/trans-array.c	(.../branches/gcc-7-branch)
@@ -2498,6 +2498,9 @@
   if (ss_info->type != GFC_SS_REFERENCE)
     return false;
 
+  if (ss_info->data.scalar.needs_temporary)
+    return false;
+
   /* If the actual argument can be absent (in other words, it can
      be a NULL reference), don't try to evaluate it; pass instead
      the reference directly.  */
@@ -5482,6 +5485,7 @@
   tree var_overflow = NULL_TREE;
   tree cond;
   tree set_descriptor;
+  tree not_prev_allocated = NULL_TREE;
   stmtblock_t set_descriptor_block;
   stmtblock_t elseblock;
   gfc_expr **lower;
@@ -5619,8 +5623,6 @@
 	}
     }
 
-  gfc_start_block (&elseblock);
-
   /* Allocate memory to store the data.  */
   if (POINTER_TYPE_P (TREE_TYPE (se->expr)))
     se->expr = build_fold_indirect_ref_loc (input_location, se->expr);
@@ -5636,6 +5638,19 @@
     pointer = gfc_conv_descriptor_data_get (se->expr);
   STRIP_NOPS (pointer);
 
+  if (allocatable)
+    {
+      not_prev_allocated = gfc_create_var (logical_type_node,
+					   "not_prev_allocated");
+      tmp = fold_build2_loc (input_location, EQ_EXPR,
+			     logical_type_node, pointer,
+			     build_int_cst (TREE_TYPE (pointer), 0));
+
+      gfc_add_modify (&se->pre, not_prev_allocated, tmp);
+    }
+
+  gfc_start_block (&elseblock);
+
   /* The allocatable variant takes the old pointer as first argument.  */
   if (allocatable)
     gfc_allocate_allocatable (&elseblock, pointer, size, token,
@@ -5672,6 +5687,11 @@
       cond = fold_build2_loc (input_location, EQ_EXPR,
 			  logical_type_node, status,
 			  build_int_cst (TREE_TYPE (status), 0));
+
+      if (not_prev_allocated != NULL_TREE)
+	cond = fold_build2_loc (input_location, TRUTH_OR_EXPR,
+				logical_type_node, cond, not_prev_allocated);
+
       gfc_add_expr_to_block (&se->pre,
 		 fold_build3_loc (input_location, COND_EXPR, void_type_node,
 				  cond,
@@ -9755,6 +9775,8 @@
 {
   gfc_ref *ref;
 
+  gfc_fix_class_refs (expr);
+
   for (ref = expr->ref; ref; ref = ref->next)
     if (ref->type == REF_ARRAY && ref->u.ar.type != AR_ELEMENT)
       break;
Index: gcc/fortran/symbol.c
===================================================================
--- a/src/gcc/fortran/symbol.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/symbol.c	(.../branches/gcc-7-branch)
@@ -477,7 +477,7 @@
   /* The copying of procedure dummy arguments for module procedures in
      a submodule occur whilst the current state is COMP_CONTAINS. It
      is necessary, therefore, to let this through.  */
-  if (attr->dummy
+  if (name && attr->dummy
       && (attr->function || attr->subroutine)
       && gfc_current_state () == COMP_CONTAINS
       && !(gfc_new_block && gfc_new_block->abr_modproc_decl))
@@ -509,6 +509,7 @@
 
   conf (external, intrinsic);
   conf (entry, intrinsic);
+  conf (abstract, intrinsic);
 
   if ((attr->if_source == IFSRC_DECL && !attr->procedure) || attr->contained)
     conf (external, subroutine);
@@ -1595,7 +1596,15 @@
     return false;
 
   attr->subroutine = 1;
-  return check_conflict (attr, name, where);
+
+  /* If we are looking at a BLOCK DATA statement and we encounter a
+     name with a leading underscore (which must be
+     compiler-generated), do not check. See PR 84394.  */
+
+  if (name && *name != '_' && gfc_current_state () != COMP_BLOCK_DATA)
+    return check_conflict (attr, name, where);
+  else
+    return true;
 }
 
 
@@ -1711,7 +1720,8 @@
   if (where == NULL)
     where = &gfc_current_locus;
 
-  if (attr->proc != PROC_UNKNOWN && !attr->module_procedure)
+  if (attr->proc != PROC_UNKNOWN && !attr->module_procedure
+      && attr->access == ACCESS_UNKNOWN)
     {
       if (attr->proc == PROC_ST_FUNCTION && t == PROC_INTERNAL
 	  && !gfc_notification_std (GFC_STD_F2008))
@@ -4173,7 +4183,7 @@
 /* Get a global symbol, creating it if it doesn't exist.  */
 
 gfc_gsymbol *
-gfc_get_gsymbol (const char *name)
+gfc_get_gsymbol (const char *name, bool bind_c)
 {
   gfc_gsymbol *s;
 
@@ -4184,6 +4194,7 @@
   s = XCNEW (gfc_gsymbol);
   s->type = GSYM_UNKNOWN;
   s->name = gfc_get_string ("%s", name);
+  s->bind_c = bind_c;
 
   gfc_insert_bbt (&gfc_gsym_root, s, gsym_compare);
 
Index: gcc/fortran/class.c
===================================================================
--- a/src/gcc/fortran/class.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/class.c	(.../branches/gcc-7-branch)
@@ -899,6 +899,9 @@
   if (!comp_is_finalizable (comp))
     return;
 
+  if (comp->finalized)
+    return;
+
   e = gfc_copy_expr (expr);
   if (!e->ref)
     e->ref = ref = gfc_get_ref ();
@@ -1026,6 +1029,7 @@
 			    sub_ns);
       gfc_free_expr (e);
     }
+  comp->finalized = true;
 }
 
 
Index: gcc/fortran/decl.c
===================================================================
--- a/src/gcc/fortran/decl.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/decl.c	(.../branches/gcc-7-branch)
@@ -552,6 +552,7 @@
 gfc_match_data (void)
 {
   gfc_data *new_data;
+  gfc_expr *e;
   match m;
 
   /* Before parsing the rest of a DATA statement, check F2008:c1206.  */
@@ -588,6 +589,30 @@
 	  goto cleanup;
 	}
 
+      /* Check for an entity with an allocatable component, which is not
+	 allowed.  */
+      e = new_data->var->expr;
+      if (e)
+	{
+	  bool invalid;
+
+	  invalid = false;
+	  for (gfc_ref *ref = e->ref; ref; ref = ref->next)
+	    if ((ref->type == REF_COMPONENT
+		 && ref->u.c.component->attr.allocatable)
+		|| (ref->type == REF_ARRAY
+		    && e->symtree->n.sym->attr.pointer != 1
+		    && ref->u.ar.as && ref->u.ar.as->type == AS_DEFERRED))
+	      invalid = true;
+
+	  if (invalid)
+	    {
+	      gfc_error ("Allocatable component or deferred-shaped array "
+			 "near %C in DATA statement");
+	      goto cleanup;
+	    }
+	}
+
       m = top_val_list (new_data);
       if (m != MATCH_YES)
 	goto cleanup;
@@ -1771,7 +1796,7 @@
 		    }
 		  else if (init->ts.u.cl && init->ts.u.cl->length)
 		    sym->ts.u.cl->length =
-				gfc_copy_expr (sym->value->ts.u.cl->length);
+				gfc_copy_expr (init->ts.u.cl->length);
 		}
 	    }
 	  /* Update initializer character length according symbol.  */
@@ -2544,6 +2569,22 @@
       goto cleanup;
     }
 
+  /* Before adding a possible initilizer, do a simple check for compatibility
+     of lhs and rhs types.  Assigning a REAL value to a derive type is not a
+     good thing.  */
+  if (current_ts.type == BT_DERIVED && initializer
+      && (gfc_numeric_ts (&initializer->ts)
+	  || initializer->ts.type == BT_LOGICAL
+	  || initializer->ts.type == BT_CHARACTER))
+    {
+      gfc_error ("Incompatible initialization between a derive type "
+		 "entity and an entity with %qs type at %C",
+		  gfc_typename (&initializer->ts));
+      m = MATCH_ERROR;
+      goto cleanup;
+    }
+
+
   /* Add the initializer.  Note that it is fine if initializer is
      NULL here, because we sometimes also need to check if a
      declaration *must* have an initialization expression.  */
@@ -6239,7 +6280,7 @@
      name is a global identifier.  */
   if (!binding_label || gfc_notification_std (GFC_STD_F2008))
     {
-      s = gfc_get_gsymbol (name);
+      s = gfc_get_gsymbol (name, false);
 
       if (s->defined || (s->type != GSYM_UNKNOWN && s->type != type))
 	{
@@ -6261,7 +6302,7 @@
       && (!gfc_notification_std (GFC_STD_F2008)
 	  || strcmp (name, binding_label) != 0))
     {
-      s = gfc_get_gsymbol (binding_label);
+      s = gfc_get_gsymbol (binding_label, true);
 
       if (s->defined || (s->type != GSYM_UNKNOWN && s->type != type))
 	{
@@ -6438,9 +6479,11 @@
 	      gfc_error ("Missing required parentheses before BIND(C) at %C");
 	      return MATCH_ERROR;
 	    }
-	    if (!gfc_add_is_bind_c (&(entry->attr), entry->name,
-				    &(entry->declared_at), 1))
-	      return MATCH_ERROR;
+
+	  if (!gfc_add_is_bind_c (&(entry->attr), entry->name,
+				  &(entry->declared_at), 1))
+	    return MATCH_ERROR;
+	
 	}
 
       if (!gfc_current_ns->parent
@@ -6524,6 +6567,14 @@
       return MATCH_ERROR;
     }
 
+  /* F2018:C1546 An elemental procedure shall not have the BIND attribute.  */
+  if (proc->attr.elemental && entry->attr.is_bind_c)
+    {
+      gfc_error ("ENTRY statement at %L with BIND(C) prohibited in an "
+		 "elemental procedure", &entry->declared_at);
+      return MATCH_ERROR;
+    }
+
   entry->attr.recursive = proc->attr.recursive;
   entry->attr.elemental = proc->attr.elemental;
   entry->attr.pure = proc->attr.pure;
Index: gcc/fortran/gfortran.h
===================================================================
--- a/src/gcc/fortran/gfortran.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/gfortran.h	(.../branches/gcc-7-branch)
@@ -1058,6 +1058,7 @@
   struct gfc_typebound_proc *tb;
   /* When allocatable/pointer and in a coarray the associated token.  */
   tree caf_token;
+  bool finalized;
 }
 gfc_component;
 
@@ -1854,6 +1855,7 @@
   enum gfc_symbol_type type;
 
   int defined, used;
+  bool bind_c;
   locus where;
   gfc_namespace *ns;
 }
@@ -2106,6 +2108,9 @@
   /* Will require finalization after use.  */
   unsigned int must_finalize : 1;
 
+  /* Set this if no warning should be given somewhere in a lower level.  */
+
+  unsigned int do_not_warn : 1;
   /* If an expression comes from a Hollerith constant or compile-time
      evaluation of a transfer statement, it may have a prescribed target-
      memory representation, and these cannot always be backformed from
@@ -2988,7 +2993,7 @@
 void gfc_free_dt_list (void);
 
 
-gfc_gsymbol *gfc_get_gsymbol (const char *);
+gfc_gsymbol *gfc_get_gsymbol (const char *, bool bind_c);
 gfc_gsymbol *gfc_find_gsymbol (gfc_gsymbol *, const char *);
 
 gfc_typebound_proc* gfc_get_typebound_proc (gfc_typebound_proc*);
@@ -3124,7 +3129,7 @@
 
 bool gfc_check_conformance (gfc_expr *, gfc_expr *, const char *, ...) ATTRIBUTE_PRINTF_3;
 bool gfc_check_assign (gfc_expr *, gfc_expr *, int, bool c = true);
-bool gfc_check_pointer_assign (gfc_expr *, gfc_expr *);
+bool gfc_check_pointer_assign (gfc_expr *, gfc_expr *, bool is_init_expr = false);
 bool gfc_check_assign_symbol (gfc_symbol *, gfc_component *, gfc_expr *);
 
 gfc_expr *gfc_build_default_init_expr (gfc_typespec *, locus *);
@@ -3269,7 +3274,7 @@
 void gfc_free_close (gfc_close *);
 bool gfc_resolve_close (gfc_close *);
 void gfc_free_filepos (gfc_filepos *);
-bool gfc_resolve_filepos (gfc_filepos *);
+bool gfc_resolve_filepos (gfc_filepos *, locus *);
 void gfc_free_inquire (gfc_inquire *);
 bool gfc_resolve_inquire (gfc_inquire *);
 void gfc_free_dt (gfc_dt *);
Index: gcc/fortran/ChangeLog
===================================================================
--- a/src/gcc/fortran/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,354 @@
+2019-08-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	Paul Thomas <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90786
+	PR fortran/90813
+	* trans-expr.c (pointer_assignment_is_proc_pointer) Remove as
+	it is very simple and only called from one place.
+	(gfc_trans_pointer_assignment): Rename non_proc_pointer_assign
+	as non_proc_ptr_assign. Assign to it directly, rather than call
+	to above, deleted function and use gfc_expr_attr instead of
+	only checking the reference chain.
+	* trans-decl.c (sym_identifier): New function.
+	(mangled_identifier): New function, doing most of the work
+	of gfc_sym_mangled_identifier.
+	(gfc_sym_mangled_identifier): Use mangled_identifier.  Add mangled
+	identifier to global symbol table.
+	(get_proc_pointer_decl): Use backend decl from global identifier
+	if present.
+
+2019-06-21  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90937
+	* trans-types.c (get_formal_from_actual_arglist): Get symbol from
+	current namespace so it will be freed later.  If symbol is of type
+	character, get an empty character length.
+
+2019-06-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	Tomáš Trnka  <trnka@scm.com>
+
+	Backport from trunk
+	PR fortran/90744
+	* trans-types.c (get_formal_from_actual_arglist): Unset typespec
+	flags which make no sense for procedures without explicit
+	interface.
+
+2019-05-05  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/90344
+	* frontend-passes.c (create_var): Bring into sync with gcc 8.
+
+2019-04-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87352
+	Backport from trunk
+	* gfortran.h (gfc_component): Add finalized field.
+	* class.c (finalize_component): If the component is already
+	finalized, return early.  Set component->finalized on exit.
+
+2019-04-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89904
+	* check.c (gfc_check_transfer): Reject procedures as actual
+	arguments for SOURCE and MOLD of TRANSFER intrinsic.
+
+2019-03-31  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/83515
+	PR fortran/85797
+	* trans-types.c (gfc_typenode_for_spec): Handle conversion for
+	procedure pointers.
+	* target-memory.c (gfc_element_size): Handle size determination
+	for procedure pointers.
+
+2019-03-25  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/71861
+	Backport from trunk
+	* symbol.c (check_conflict): ABSTRACT attribute conflicts with
+	INTRINSIC attribute.
+
+2019-03-23  Thomas Koenig  <tkoeng@gcc.gnu.org>
+
+	PR fortran/68009
+	Backport from trunk
+	* iresolve.c: Include trans.h.
+	(gfc_resolve_fe_runtine_error): Set backend_decl on
+	resolved_sym.
+
+2019-03-17  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/84394
+	Backport from trunk
+	* symbol.c (gfc_add_subroutine): If we are encountering a
+	subrtoutine within a BLOCK DATA and the name starts with an
+	underscore, do not check.
+
+2019-03-16  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/66089
+	Backport from trunk
+	* trans-array.c (gfc_scalar_elemental_arg_saved_as_reference):
+	Return false if a scalar tempoary is needed.
+	(gfc_walk_variable_expr): Fix up class refs.
+
+2019-03-16  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/66695
+	PR fortran/77746
+	PR fortran/79485
+	Backport from trunk
+	* gfortran.h (gfc_symbol): Add bind_c component.
+	(gfc_get_gsymbol): Add argument bind_c.
+	* decl.c (add_global_entry): Add bind_c argument to
+	gfc_get_symbol.
+	* parse.c (parse_block_data): Likewise.
+	(parse_module): Likewise.
+	(add_global_procedure): Likewise.
+	(add_global_program): Likewise.
+	* resolve.c (resolve_common_blocks): Likewise.
+	(resolve_global_procedure): Likewise.
+	(gfc_verify_binding_labels): Likewise.
+	* symbol.c (gfc_get_gsymbol): Add argument bind_c. Set bind_c
+	in gsym.
+	* trans-decl.c (gfc_get_module_backend_decl): Add bind_c argument
+	to gfc_get_symbol.
+	(gfc_get_extern_function_decl): If the sym has a binding label
+	and it cannot be found in the global symbol tabel, it is the wrong
+	one and vice versa.
+
+2019-03-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87673
+	Backport from trunk
+	* match.c (gfc_match_type_spec): Remove call to
+	gfc_resolve_expr for character length.
+
+2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71544
+	Backport from trunk
+	* trans-types.c (gfc_typenode_for_spec) Set ts->is_c_interop of
+	C_PTR and C_FUNPTR.
+	(create_fn_spec): Mark argument as escaping if ts->is_c_interop is set.
+
+2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/87734
+	Backort from trunk
+	* symbol.c (gfc_add_procedure): Only throw an error if the
+	procedure has not been declared either PUBLIC or PRIVATE.
+	* resolve.c (is_illegal_recursion): Remove an assert().
+
+2019-03-06  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/72714
+	Backport from trunk
+	* resolve.c (resolve_allocate_expr): Add some tests for coarrays.
+
+2019-03-03  Harald Anlauf  <anlauf@gmx.de>
+	    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/77583
+	* symbol.c (check_conflict): Check for valid procedure name
+	passed to error reporting routine.
+
+2019-03-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87689
+	Backport from trunk
+	* trans-decl.c (gfc_get_extern_function_decl): Add argument
+	actual_args and pass it through to gfc_get_function_type.
+	* trans-expr.c (conv_function_val): Add argument actual_args
+	and pass it on to gfc_get_extern_function_decl.
+	(conv_procedure_call): Pass actual arguments to conv_function_val.
+	* trans-types.c (get_formal_from_actual_arglist): New function.
+	(gfc_get_function_type): Add argument actual_args.  Generate
+	formal args from actual args if necessary.
+	* trans-types.h (gfc_get_function_type): Add optional argument.
+	* trans.h (gfc_get_extern_function_decl): Add optional argument.
+
+2019-02-23  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/88117
+	* resolve.c (deferred_op_assign): Return if the lhs expression
+	has the pointer attribute.
+
+2019-02-23  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71066
+	Backport from trunk
+	* trans-decl.c (generate_coarray_sym_init):  For an array
+	constructor in a DATA statement of a coarray variable, set the
+	rank to 1 to avoid confusion later on.  If the constructor
+	contains only one value, use that for initiailizig.
+
+2019-02-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89077
+	* decl.c (add_init_expr_to_sym): Copy length of string initializer
+	to declared symbol.
+
+2019-02-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71723
+	Backport from trunk
+	* expr.c (gfc_check_assign): Add argument is_init_expr.  If we are
+	looking at an init expression, issue error if the target is not a
+	TARGET and we are not looking at a procedure pointer.
+	* gfortran.h (gfc_check_assign): Add optional argument
+	is_init_expr.
+
+2019-02-05  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/67679
+	Backport from trunk
+	* trans-array.c (gfc_array_allocate):  For setting the bounds on
+	the new array, add a condition for a not previously allocated
+	variable.
+
+2019-02-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/88393
+	* trans-expr.c (gfc_conv_procedure_call): For derived entities,
+	passed in parentheses to class formals, invert the order of
+	copying allocatable components to taking the _data of the
+	class expression.
+
+2019-02-02  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/88298
+	Backport from trunk
+	* arith.c (gfc_int2int): Do not warn if src->do_not_warn is set.
+	* gfortran.h (gfc_expr): Add flag do_not_warn.
+	* intrinsic.c (gfc_convert_type_warn): Set expr->do_not_warn if
+	no warning is desired.
+
+2019-02-02  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/57048
+	Backport from trunk
+	* interface.c (gfc_compare_types): If a derived type and an
+	integer both have a derived type, and they are identical,
+	this is a C binding type and compares equal.
+
+2019-01-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/56386
+	PR fortran/58906
+	PR fortran/77385
+	PR fortran/80260
+	PR fortran/82077
+	* resolve.c (resolve_variable): Fix up expressions with array
+	associate names, where the parser did not detect that this is
+	array and there was no array part_ref in the expression.
+	* trans-expr.c (gfc_find_and_cut_at_last_class_ref): base_expr
+	should be a copy of e and not the initialization expr.
+
+2019-01-15  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/81849
+	* resolve.c (resolve_symbol): Host associated varaibles can appear
+	in the specification statement of a RESULT array.
+
+2019-01-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/35031
+	* decl.c (gfc_match_entry): Check for F2018:C1546.  Fix nearby
+	mis-indentation.
+
+2018-12-29  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/82550
+	* trans_decl.c (gfc_get_symbol_decl): Procedure symbols that
+	have the 'used_in_submodule' attribute should be processed by
+	'gfc_get_extern_function_decl'.
+
+2018-12-23  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/77703
+	* resolve.c (get_temp_from_expr): Use the string length of
+	constant character expressions.
+
+2018-12-22  Steven G . Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85798
+	* decl.c (gfc_match_data): If a component of a derived type entity
+	appears in data statement, check that does not have the allocatable
+	attribute.
+
+2018-12-22  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/85544
+	* frontend-passes.c (optimize_power): Remove.
+	(optimize_op): Remove call to optimize_power.
+	* trans-expr.c (gfc_conv_power_op): Handle cases of 1**integer,
+	(2|4|8|16) ** integer and (-1) ** integer.
+
+2018-12-21  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88169
+	* module.c (mio_namelist): Remove an error condition/message that
+	is contrary to the Fortran standard.
+
+2018-12-15  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88138
+	* decl.c (variable_decl): Check that a derived isn't being assigned
+	an incompatible entity in an initialization.
+
+2018-12-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88155
+	* primary.c (gfc_match_structure_constructor):  Set the locus of
+	an expression to avoid a NULL pointer dereference.
+
+2018-12-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88249
+	* gfortran.h: Update prototype for gfc_resolve_filepos().
+	* io.c (gfc_resolve_filepos): Check for UNIT number if ERR= is present.
+	Use passed in locus for error message.
+	* resolve.c (gfc_resolve_code): Pass locus in gfc_resolve_filepos()
+	call.
+
+2018-12-10  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88269
+	* io.c (io_constraint): Update macro. If locus line buffer is NULL,
+	use gfc_current_locus in error messages.
+	(check_io_constraints): Catch missing IO UNIT in write and read
+	statements.  io_constraint macro is incompatible here.
+
+2018-12-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88205
+	* io.c (gfc_match_open): Move NEWUNIT checks to after STATUS checks.
+
+2018-12-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88206
+	* match.c (gfc_match_type_spec): REAL can be an intrinsic function.
+
+2018-12-09  Fritz Reese  <fritzoreese@gmail.com>
+
+	PR fortran/88228
+	* resolve.c (resolve_operator):  Do not call resolve_function.
+	Break like other cases.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: gcc/fortran/expr.c
===================================================================
--- a/src/gcc/fortran/expr.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/expr.c	(.../branches/gcc-7-branch)
@@ -3342,7 +3342,7 @@
    NULLIFY statement.  */
 
 bool
-gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)
+gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue, bool is_init_expr)
 {
   symbol_attribute attr, lhs_attr;
   gfc_ref *ref;
@@ -3773,12 +3773,36 @@
       return false;
     }
 
-  if (!attr.target && !attr.pointer)
+  if (is_init_expr)
     {
-      gfc_error ("Pointer assignment target is neither TARGET "
-		 "nor POINTER at %L", &rvalue->where);
-      return false;
+      gfc_symbol *sym;
+      bool target;
+
+      gcc_assert (rvalue->symtree);
+      sym = rvalue->symtree->n.sym;
+
+      if (sym->ts.type == BT_CLASS && sym->attr.class_ok)
+	target = CLASS_DATA (sym)->attr.target;
+      else
+	target = sym->attr.target;
+
+      if (!target && !proc_pointer)
+	{
+	  gfc_error ("Pointer assignment target in initialization expression "
+		     "does not have the TARGET attribute at %L",
+		     &rvalue->where);
+	  return false;
+	}
     }
+  else
+    {
+      if (!attr.target && !attr.pointer)
+	{
+	  gfc_error ("Pointer assignment target is neither TARGET "
+		     "nor POINTER at %L", &rvalue->where);
+	  return false;
+	}
+    }
 
   if (is_pure && gfc_impure_variable (rvalue->symtree->n.sym))
     {
@@ -3903,7 +3927,7 @@
     }
 
   if (pointer || proc_pointer)
-    r = gfc_check_pointer_assign (&lvalue, rvalue);
+    r = gfc_check_pointer_assign (&lvalue, rvalue, true);
   else
     {
       /* If a conversion function, e.g., __convert_i8_i4, was inserted
Index: gcc/fortran/module.c
===================================================================
--- a/src/gcc/fortran/module.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/module.c	(.../branches/gcc-7-branch)
@@ -3632,7 +3632,6 @@
 mio_namelist (gfc_symbol *sym)
 {
   gfc_namelist *n, *m;
-  const char *check_name;
 
   mio_lparen ();
 
@@ -3643,17 +3642,6 @@
     }
   else
     {
-      /* This departure from the standard is flagged as an error.
-	 It does, in fact, work correctly. TODO: Allow it
-	 conditionally?  */
-      if (sym->attr.flavor == FL_NAMELIST)
-	{
-	  check_name = find_use_name (sym->name, false);
-	  if (check_name && strcmp (check_name, sym->name) != 0)
-	    gfc_error ("Namelist %s cannot be renamed by USE "
-		       "association to %s", sym->name, check_name);
-	}
-
       m = NULL;
       while (peek_atom () != ATOM_RPAREN)
 	{
Index: gcc/fortran/trans-types.c
===================================================================
--- a/src/gcc/fortran/trans-types.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/trans-types.c	(.../branches/gcc-7-branch)
@@ -1139,7 +1139,8 @@
         {
           spec->type = BT_INTEGER;
           spec->kind = gfc_index_integer_kind;
-          spec->f90_type = BT_VOID;
+	  spec->f90_type = BT_VOID;
+	  spec->is_c_interop = 1;  /* Mark as escaping later.  */
         }
       break;
     case BT_VOID:
@@ -1156,6 +1157,9 @@
 	    basetype = pfunc_type_node;
 	}
        break;
+    case BT_PROCEDURE:
+      basetype = pfunc_type_node;
+      break;
     default:
       gcc_unreachable ();
     }
@@ -2884,7 +2888,8 @@
 		    || f->sym->ts.u.derived->attr.pointer_comp))
 	    || (f->sym->ts.type == BT_CLASS
 		&& (CLASS_DATA (f->sym)->ts.u.derived->attr.proc_pointer_comp
-		    || CLASS_DATA (f->sym)->ts.u.derived->attr.pointer_comp)))
+		    || CLASS_DATA (f->sym)->ts.u.derived->attr.pointer_comp))
+	    || (f->sym->ts.type == BT_INTEGER && f->sym->ts.is_c_interop))
 	  spec[spec_len++] = '.';
 	else if (f->sym->attr.intent == INTENT_IN)
 	  spec[spec_len++] = 'r';
@@ -2897,9 +2902,64 @@
   return build_type_attribute_variant (fntype, tmp);
 }
 
+/* Helper function - if we do not find an interface for a procedure,
+   construct it from the actual arglist.  Luckily, this can only
+   happen for call by reference, so the information we actually need
+   to provide (and which would be impossible to guess from the call
+   itself) is not actually needed.  */
 
+static void
+get_formal_from_actual_arglist (gfc_symbol *sym, gfc_actual_arglist *actual_args)
+{
+  gfc_actual_arglist *a;
+  gfc_formal_arglist **f;
+  gfc_symbol *s;
+  char name[GFC_MAX_SYMBOL_LEN + 1];
+  static int var_num;
+
+  f = &sym->formal;
+  for (a = actual_args; a != NULL; a = a->next)
+    {
+      (*f) = gfc_get_formal_arglist ();
+      if (a->expr)
+	{
+	  snprintf (name, GFC_MAX_SYMBOL_LEN, "_formal_%d", var_num ++);
+	  gfc_get_symbol (name, gfc_current_ns, &s);
+	  if (a->expr->ts.type == BT_PROCEDURE)
+	    {
+	      s->attr.flavor = FL_PROCEDURE;
+	    }
+	  else
+	    {
+	      s->ts = a->expr->ts;
+
+	      if (s->ts.type == BT_CHARACTER)
+		s->ts.u.cl = gfc_get_charlen ();
+
+ 	      s->ts.deferred = 0;
+ 	      s->ts.is_iso_c = 0;
+ 	      s->ts.is_c_interop = 0;
+	      s->attr.flavor = FL_VARIABLE;
+	      if (a->expr->rank > 0)
+		{
+		  s->attr.dimension = 1;
+		  s->as = gfc_get_array_spec ();
+		  s->as->type = AS_ASSUMED_SIZE;
+		}
+	    }
+	  s->attr.dummy = 1;
+	  s->attr.intent = INTENT_UNKNOWN;
+	  (*f)->sym = s;
+	}
+      else  /* If a->expr is NULL, this is an alternate rerturn.  */
+	(*f)->sym = NULL;
+
+      f = &((*f)->next);
+    }
+}
+
 tree
-gfc_get_function_type (gfc_symbol * sym)
+gfc_get_function_type (gfc_symbol * sym, gfc_actual_arglist *actual_args)
 {
   tree type;
   vec<tree, va_gc> *typelist = NULL;
@@ -2957,6 +3017,10 @@
 	    vec_safe_push (typelist, build_pointer_type(gfc_charlen_type_node));
 	}
     }
+  if (sym->backend_decl == error_mark_node && actual_args != NULL
+      && sym->formal == NULL && (sym->attr.proc == PROC_EXTERNAL
+				 || sym->attr.proc == PROC_UNKNOWN))
+    get_formal_from_actual_arglist (sym, actual_args);
 
   /* Build the argument types for the function.  */
   for (f = gfc_sym_get_dummy_args (sym); f; f = f->next)
Index: gcc/fortran/trans.h
===================================================================
--- a/src/gcc/fortran/trans.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/trans.h	(.../branches/gcc-7-branch)
@@ -578,7 +578,8 @@
 tree gfc_get_label_decl (gfc_st_label *);
 
 /* Return the decl for an external function.  */
-tree gfc_get_extern_function_decl (gfc_symbol *);
+tree gfc_get_extern_function_decl (gfc_symbol *,
+				   gfc_actual_arglist *args = NULL);
 
 /* Return the decl for a function.  */
 tree gfc_get_function_decl (gfc_symbol *);
Index: gcc/fortran/trans-types.h
===================================================================
--- a/src/gcc/fortran/trans-types.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/trans-types.h	(.../branches/gcc-7-branch)
@@ -87,7 +87,7 @@
 tree gfc_typenode_for_spec (gfc_typespec *, int c = 0);
 int gfc_copy_dt_decls_ifequal (gfc_symbol *, gfc_symbol *, bool);
 
-tree gfc_get_function_type (gfc_symbol *);
+tree gfc_get_function_type (gfc_symbol *, gfc_actual_arglist *args = NULL);
 
 tree gfc_type_for_size (unsigned, int);
 tree gfc_type_for_mode (machine_mode, int);
Index: gcc/fortran/io.c
===================================================================
--- a/src/gcc/fortran/io.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/io.c	(.../branches/gcc-7-branch)
@@ -2090,33 +2090,6 @@
 
   warn = (open->err || open->iostat) ? true : false;
 
-  /* Checks on NEWUNIT specifier.  */
-  if (open->newunit)
-    {
-      if (open->unit)
-	{
-	  gfc_error ("UNIT specifier not allowed with NEWUNIT at %C");
-	  goto cleanup;
-	}
-
-      if (!open->file && open->status)
-        {
-	  if (open->status->expr_type == EXPR_CONSTANT
-	     && gfc_wide_strncasecmp (open->status->value.character.string,
-				       "scratch", 7) != 0)
-	   {
-	     gfc_error ("NEWUNIT specifier must have FILE= "
-			"or STATUS='scratch' at %C");
-	     goto cleanup;
-	   }
-	}
-    }
-  else if (!open->unit)
-    {
-      gfc_error ("OPEN statement at %C must have UNIT or NEWUNIT specified");
-      goto cleanup;
-    }
-
   /* Checks on the ACCESS specifier.  */
   if (open->access && open->access->expr_type == EXPR_CONSTANT)
     {
@@ -2441,6 +2414,33 @@
 	}
     }
 
+  /* Checks on NEWUNIT specifier.  */
+  if (open->newunit)
+    {
+      if (open->unit)
+	{
+	  gfc_error ("UNIT specifier not allowed with NEWUNIT at %C");
+	  goto cleanup;
+	}
+
+      if (!open->file && open->status)
+        {
+	  if (open->status->expr_type == EXPR_CONSTANT
+	     && gfc_wide_strncasecmp (open->status->value.character.string,
+				       "scratch", 7) != 0)
+	   {
+	     gfc_error ("NEWUNIT specifier must have FILE= "
+			"or STATUS='scratch' at %C");
+	     goto cleanup;
+	   }
+	}
+    }
+  else if (!open->unit)
+    {
+      gfc_error ("OPEN statement at %C must have UNIT or NEWUNIT specified");
+      goto cleanup;
+    }
+
   /* Things that are not allowed for unformatted I/O.  */
   if (open->form && open->form->expr_type == EXPR_CONSTANT
       && (open->delim || open->decimal || open->encoding || open->round
@@ -2774,22 +2774,21 @@
 
 
 bool
-gfc_resolve_filepos (gfc_filepos *fp)
+gfc_resolve_filepos (gfc_filepos *fp, locus *where)
 {
   RESOLVE_TAG (&tag_unit, fp->unit);
   RESOLVE_TAG (&tag_iostat, fp->iostat);
   RESOLVE_TAG (&tag_iomsg, fp->iomsg);
-  if (!gfc_reference_st_label (fp->err, ST_LABEL_TARGET))
-    return false;
 
-  if (!fp->unit && (fp->iostat || fp->iomsg))
+  if (!fp->unit && (fp->iostat || fp->iomsg || fp->err))
     {
-      locus where;
-      where = fp->iostat ? fp->iostat->where : fp->iomsg->where;
-      gfc_error ("UNIT number missing in statement at %L", &where);
+      gfc_error ("UNIT number missing in statement at %L", where);
       return false;
     }
 
+  if (!gfc_reference_st_label (fp->err, ST_LABEL_TARGET))
+    return false;
+
   if (fp->unit->expr_type == EXPR_CONSTANT
       && fp->unit->ts.type == BT_INTEGER
       && mpz_sgn (fp->unit->value.integer) < 0)
@@ -3617,10 +3616,13 @@
 check_io_constraints (io_kind k, gfc_dt *dt, gfc_code *io_code,
 		      locus *spec_end)
 {
-#define io_constraint(condition,msg,arg)\
+#define io_constraint(condition, msg, arg)\
 if (condition) \
   {\
-    gfc_error(msg,arg);\
+    if ((arg)->lb != NULL)\
+      gfc_error ((msg), (arg));\
+    else\
+      gfc_error ((msg), &gfc_current_locus);\
     m = MATCH_ERROR;\
   }
 
@@ -3680,11 +3682,14 @@
   if (expr && expr->ts.type != BT_CHARACTER)
     {
 
-      io_constraint (gfc_pure (NULL) && (k == M_READ || k == M_WRITE),
-		     "IO UNIT in %s statement at %C must be "
+      if (gfc_pure (NULL) && (k == M_READ || k == M_WRITE))
+	{
+	  gfc_error ("IO UNIT in %s statement at %C must be "
 		     "an internal file in a PURE procedure",
 		     io_kind_name (k));
-
+	  return MATCH_ERROR;
+	}
+	  
       if (k == M_READ || k == M_WRITE)
 	gfc_unset_implicit_pure (NULL);
     }
Index: gcc/fortran/frontend-passes.c
===================================================================
--- a/src/gcc/fortran/frontend-passes.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/frontend-passes.c	(.../branches/gcc-7-branch)
@@ -701,6 +701,11 @@
   if (e->expr_type == EXPR_CONSTANT || is_fe_temp (e))
     return gfc_copy_expr (e);
 
+  /* Creation of an array of unknown size requires realloc on assignment.
+     If that is not possible, just return NULL.  */
+  if (flag_realloc_lhs == 0 && e->rank > 0 && e->shape == NULL)
+    return NULL;
+
   ns = insert_block ();
 
   if (vname)
@@ -748,7 +753,7 @@
     }
 
   deferred = 0;
-  if (e->ts.type == BT_CHARACTER && e->rank == 0)
+  if (e->ts.type == BT_CHARACTER)
     {
       gfc_expr *length;
 
@@ -759,6 +764,8 @@
       else
 	{
 	  symbol->attr.allocatable = 1;
+	  symbol->ts.u.cl->length = NULL;
+	  symbol->ts.deferred = 1;
 	  deferred = 1;
 	}
     }
@@ -771,7 +778,7 @@
 
   result = gfc_get_expr ();
   result->expr_type = EXPR_VARIABLE;
-  result->ts = e->ts;
+  result->ts = symbol->ts;
   result->ts.deferred = deferred;
   result->rank = e->rank;
   result->shape = gfc_copy_shape (e->shape, e->rank);
@@ -1422,84 +1429,6 @@
   return true;
 }
 
-/* Change (-1)**k into 1-ishift(iand(k,1),1) and
- 2**k into ishift(1,k) */
-
-static bool
-optimize_power (gfc_expr *e)
-{
-  gfc_expr *op1, *op2;
-  gfc_expr *iand, *ishft;
-
-  if (e->ts.type != BT_INTEGER)
-    return false;
-
-  op1 = e->value.op.op1;
-
-  if (op1 == NULL || op1->expr_type != EXPR_CONSTANT)
-    return false;
-
-  if (mpz_cmp_si (op1->value.integer, -1L) == 0)
-    {
-      gfc_free_expr (op1);
-
-      op2 = e->value.op.op2;
-
-      if (op2 == NULL)
-	return false;
-
-      iand = gfc_build_intrinsic_call (current_ns, GFC_ISYM_IAND,
-				       "_internal_iand", e->where, 2, op2,
-				       gfc_get_int_expr (e->ts.kind,
-							 &e->where, 1));
-
-      ishft = gfc_build_intrinsic_call (current_ns, GFC_ISYM_ISHFT,
-					"_internal_ishft", e->where, 2, iand,
-					gfc_get_int_expr (e->ts.kind,
-							  &e->where, 1));
-
-      e->value.op.op = INTRINSIC_MINUS;
-      e->value.op.op1 = gfc_get_int_expr (e->ts.kind, &e->where, 1);
-      e->value.op.op2 = ishft;
-      return true;
-    }
-  else if (mpz_cmp_si (op1->value.integer, 2L) == 0)
-    {
-      gfc_free_expr (op1);
-
-      op2 = e->value.op.op2;
-      if (op2 == NULL)
-	return false;
-
-      ishft = gfc_build_intrinsic_call (current_ns, GFC_ISYM_ISHFT,
-					"_internal_ishft", e->where, 2,
-					gfc_get_int_expr (e->ts.kind,
-							  &e->where, 1),
-					op2);
-      *e = *ishft;
-      return true;
-    }
-
-  else if (mpz_cmp_si (op1->value.integer, 1L) == 0)
-    {
-      op2 = e->value.op.op2;
-      if (op2 == NULL)
-	return false;
-
-      gfc_free_expr (op1);
-      gfc_free_expr (op2);
-
-      e->expr_type = EXPR_CONSTANT;
-      e->value.op.op1 = NULL;
-      e->value.op.op2 = NULL;
-      mpz_init_set_si (e->value.integer, 1);
-      /* Typespec and location are still OK.  */
-      return true;
-    }
-
-  return false;
-}
-
 /* Recursive optimization of operators.  */
 
 static bool
@@ -1560,9 +1489,6 @@
     case INTRINSIC_DIVIDE:
       return combine_array_constructor (e) || changed;
 
-    case INTRINSIC_POWER:
-      return optimize_power (e);
-
     default:
       break;
     }
Index: gcc/fortran/resolve.c
===================================================================
--- a/src/gcc/fortran/resolve.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/resolve.c	(.../branches/gcc-7-branch)
@@ -1045,7 +1045,7 @@
 	}
       if (!gsym)
 	{
-	  gsym = gfc_get_gsymbol (common_root->n.common->name);
+	  gsym = gfc_get_gsymbol (common_root->n.common->name, false);
 	  gsym->type = GSYM_COMMON;
 	  gsym->where = common_root->n.common->where;
 	  gsym->defined = 1;
@@ -1067,7 +1067,7 @@
 	}
       if (!gsym)
 	{
-	  gsym = gfc_get_gsymbol (common_root->n.common->binding_label);
+	  gsym = gfc_get_gsymbol (common_root->n.common->binding_label, true);
 	  gsym->type = GSYM_COMMON;
 	  gsym->where = common_root->n.common->where;
 	  gsym->defined = 1;
@@ -1576,8 +1576,6 @@
       || gfc_fl_struct (sym->attr.flavor))
     return false;
 
-  gcc_assert (sym->attr.flavor == FL_PROCEDURE);
-
   /* If we've got an ENTRY, find real procedure.  */
   if (sym->attr.entry && sym->ns->entries)
     proc_sym = sym->ns->entries->sym;
@@ -2379,7 +2377,8 @@
 
   type = sub ? GSYM_SUBROUTINE : GSYM_FUNCTION;
 
-  gsym = gfc_get_gsymbol (sym->binding_label ? sym->binding_label : sym->name);
+  gsym = gfc_get_gsymbol (sym->binding_label ? sym->binding_label : sym->name,
+			  sym->binding_label != NULL);
 
   if ((gsym->type != GSYM_UNKNOWN && gsym->type != type))
     gfc_global_used (gsym, where);
@@ -3737,7 +3736,7 @@
 	  if (op2->ts.type != e->ts.type || op2->ts.kind != e->ts.kind)
 	    gfc_convert_type (op2, &e->ts, 1);
 	  e = logical_to_bitwise (e);
-	  return resolve_function (e);
+	  break;
 	}
 
       sprintf (msg, _("Operands of logical operator %%<%s%%> at %%L are %s/%s"),
@@ -3753,7 +3752,7 @@
 	  e->ts.type = BT_INTEGER;
 	  e->ts.kind = op1->ts.kind;
 	  e = logical_to_bitwise (e);
-	  return resolve_function (e);
+	  break;
 	}
 
       if (op1->ts.type == BT_LOGICAL)
@@ -5161,6 +5160,23 @@
 	gfc_fix_class_refs (e);
       if (!sym->attr.dimension && e->ref && e->ref->type == REF_ARRAY)
 	return false;
+       else if (sym->attr.dimension && (!e->ref || e->ref->type != REF_ARRAY))
+	  {
+	    /* This can happen because the parser did not detect that the
+	       associate name is an array and the expression had no array
+	       part_ref.  */
+	    gfc_ref *ref = gfc_get_ref ();
+	    ref->type = REF_ARRAY;
+	    ref->u.ar = *gfc_get_array_ref();
+	    ref->u.ar.type = AR_FULL;
+	    if (sym->as)
+	      {
+		ref->u.ar.as = sym->as;
+		ref->u.ar.dimen = sym->as->rank;
+	      }
+	    ref->next = e->ref;
+	    e->ref = ref;
+	  }
     }
 
   if (sym->ts.type == BT_DERIVED && sym->ts.u.derived->attr.generic)
@@ -7414,13 +7430,54 @@
 
   if (codimension)
     for (i = ar->dimen; i < ar->dimen + ar->codimen; i++)
-      if (ar->dimen_type[i] == DIMEN_THIS_IMAGE)
-	{
-	  gfc_error ("Coarray specification required in ALLOCATE statement "
-		     "at %L", &e->where);
-	  goto failure;
-	}
+      {
+	switch (ar->dimen_type[i])
+	  {
+	  case DIMEN_THIS_IMAGE:
+	    gfc_error ("Coarray specification required in ALLOCATE statement "
+		       "at %L", &e->where);
+	    goto failure;
 
+	  case  DIMEN_RANGE:
+	    if (ar->start[i] == 0 || ar->end[i] == 0)
+	      {
+		/* If ar->stride[i] is NULL, we issued a previous error.  */
+		if (ar->stride[i] == NULL)
+		  gfc_error ("Bad array specification in ALLOCATE statement "
+			     "at %L", &e->where);
+		goto failure;
+	      }
+	    else if (gfc_dep_compare_expr (ar->start[i], ar->end[i]) == 1)
+	      {
+		gfc_error ("Upper cobound is less than lower cobound at %L",
+			   &ar->start[i]->where);
+		goto failure;
+	      }
+	    break;
+
+	  case DIMEN_ELEMENT:
+	    if (ar->start[i]->expr_type == EXPR_CONSTANT)
+	      {
+		gcc_assert (ar->start[i]->ts.type == BT_INTEGER);
+		if (mpz_cmp_si (ar->start[i]->value.integer, 1) < 0)
+		  {
+		    gfc_error ("Upper cobound is less than lower cobound "
+			       " of 1 at %L", &ar->start[i]->where);
+		    goto failure;
+		  }
+	      }
+	    break;
+
+	  case DIMEN_STAR:
+	    break;
+
+	  default:
+	    gfc_error ("Bad array specification in ALLOCATE statement at %L",
+		       &e->where);
+	    goto failure;
+
+	  }
+      }
   for (i = 0; i < ar->dimen; i++)
     {
       if (ar->type == AR_ELEMENT || ar->type == AR_FULL)
@@ -10264,6 +10321,11 @@
   gfc_get_sym_tree (name, ns, &tmp, false);
   gfc_add_type (tmp->n.sym, &e->ts, NULL);
 
+  if (e->expr_type == EXPR_CONSTANT && e->ts.type == BT_CHARACTER)
+    tmp->n.sym->ts.u.cl->length = gfc_get_int_expr (gfc_charlen_int_kind,
+						    NULL,
+						    e->value.character.length);
+
   as = NULL;
   ref = NULL;
   aref = NULL;
@@ -10754,6 +10816,9 @@
   if (!gfc_check_dependency ((*code)->expr1, (*code)->expr2, 1))
     return false;
 
+  if (gfc_expr_attr ((*code)->expr1).pointer)
+    return false;
+
   tmp_expr = get_temp_from_expr ((*code)->expr1, ns);
   tmp_expr->where = (*code)->loc;
 
@@ -11163,7 +11228,7 @@
 	case EXEC_ENDFILE:
 	case EXEC_REWIND:
 	case EXEC_FLUSH:
-	  if (!gfc_resolve_filepos (code->ext.filepos))
+	  if (!gfc_resolve_filepos (code->ext.filepos, &code->loc))
 	    break;
 
 	  resolve_branch (code->ext.filepos->err, code);
@@ -11385,7 +11450,7 @@
 	  && (gsym->type == GSYM_FUNCTION || gsym->type == GSYM_SUBROUTINE)))
     {
       if (!gsym)
-	gsym = gfc_get_gsymbol (sym->binding_label);
+	gsym = gfc_get_gsymbol (sym->binding_label, true);
       gsym->where = sym->declared_at;
       gsym->sym_name = sym->name;
       gsym->binding_label = sym->binding_label;
@@ -14854,7 +14919,7 @@
   /* Set the formal_arg_flag so that check_conflict will not throw
      an error for host associated variables in the specification
      expression for an array_valued function.  */
-  if (sym->attr.function && sym->as)
+  if ((sym->attr.function || sym->attr.result) && sym->as)
     formal_arg_flag = true;
 
   saved_specification_expr = specification_expr;
Index: gcc/fortran/iresolve.c
===================================================================
--- a/src/gcc/fortran/iresolve.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/iresolve.c	(.../branches/gcc-7-branch)
@@ -35,6 +35,7 @@
 #include "intrinsic.h"
 #include "constructor.h"
 #include "arith.h"
+#include "trans.h"
 
 /* Given printf-like arguments, return a stable version of the result string. 
 
@@ -2286,6 +2287,10 @@
     a->name = "%VAL";
 
   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);
+  /* We set the backend_decl here because runtime_error is a
+     variadic function and we would use the wrong calling
+     convention otherwise.  */
+  c->resolved_sym->backend_decl = gfor_fndecl_runtime_error;
 }
 
 void
Index: gcc/fortran/trans-decl.c
===================================================================
--- a/src/gcc/fortran/trans-decl.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/trans-decl.c	(.../branches/gcc-7-branch)
@@ -334,39 +334,45 @@
     }
 }
 
+/* Return the name of an identifier.  */
 
+static const char *
+sym_identifier (gfc_symbol *sym)
+{
+  if (sym->attr.is_main_program && strcmp (sym->name, "main") == 0)
+    return "MAIN__";
+  else
+    return sym->name;
+}
+
 /* Convert a gfc_symbol to an identifier of the same name.  */
 
 static tree
 gfc_sym_identifier (gfc_symbol * sym)
 {
-  if (sym->attr.is_main_program && strcmp (sym->name, "main") == 0)
-    return (get_identifier ("MAIN__"));
-  else
-    return (get_identifier (sym->name));
+  return get_identifier (sym_identifier (sym));
 }
 
+/* Construct mangled name from symbol name.   */
 
-/* Construct mangled name from symbol name.  */
-
-static tree
-gfc_sym_mangled_identifier (gfc_symbol * sym)
+static const char *
+mangled_identifier (gfc_symbol *sym)
 {
-  char name[GFC_MAX_MANGLED_SYMBOL_LEN + 1];
-
+  static char name[GFC_MAX_MANGLED_SYMBOL_LEN + 1];
   /* Prevent the mangling of identifiers that have an assigned
      binding label (mainly those that are bind(c)).  */
+
   if (sym->attr.is_bind_c == 1 && sym->binding_label)
-    return get_identifier (sym->binding_label);
+    return sym->binding_label;
 
   if (!sym->fn_result_spec)
     {
       if (sym->module == NULL)
-	return gfc_sym_identifier (sym);
+	return sym_identifier (sym);
       else
 	{
 	  snprintf (name, sizeof name, "__%s_MOD_%s", sym->module, sym->name);
-	  return get_identifier (name);
+	  return name;
 	}
     }
   else
@@ -381,18 +387,41 @@
 		    sym->ns->proc_name->module,
 		    sym->ns->proc_name->name,
 		    sym->name);
-	  return get_identifier (name);
+	  return name;
 	}
       else
 	{
 	  snprintf (name, sizeof name, "__%s_PROC_%s",
 		    sym->ns->proc_name->name, sym->name);
-	  return get_identifier (name);
+	  return name;
 	}
     }
 }
 
+/* Get mangled identifier, adding the symbol to the global table if
+   it is not yet already there.  */
 
+static tree
+gfc_sym_mangled_identifier (gfc_symbol * sym)
+{
+  tree result;
+  gfc_gsymbol *gsym;
+  const char *name;
+
+  name = mangled_identifier (sym);
+  result = get_identifier (name);
+
+  gsym = gfc_find_gsymbol (gfc_gsym_root, name);
+  if (gsym == NULL)
+    {
+      gsym = gfc_get_gsymbol (name, false);
+      gsym->ns = sym->ns;
+      gsym->sym_name = sym->name;
+    }
+
+  return result;
+}
+
 /* Construct mangled function name from symbol name.  */
 
 static tree
@@ -831,7 +860,7 @@
 	{
 	  if (!gsym)
 	    {
-	      gsym = gfc_get_gsymbol (sym->module);
+	      gsym = gfc_get_gsymbol (sym->module, false);
 	      gsym->type = GSYM_MODULE;
 	      gsym->ns = gfc_get_namespace (NULL, 0);
 	    }
@@ -1655,7 +1684,9 @@
     {
       /* Catch functions. Only used for actual parameters,
 	 procedure pointers and procptr initialization targets.  */
-      if (sym->attr.use_assoc || sym->attr.intrinsic
+      if (sym->attr.use_assoc
+	  || sym->attr.used_in_submodule
+	  || sym->attr.intrinsic
 	  || sym->attr.if_source != IFSRC_DECL)
 	{
 	  decl = gfc_get_extern_function_decl (sym);
@@ -1862,6 +1893,22 @@
   tree decl;
   tree attributes;
 
+  if (sym->module || sym->fn_result_spec)
+    {
+      const char *name;
+      gfc_gsymbol *gsym;
+
+      name = mangled_identifier (sym);
+      gsym = gfc_find_gsymbol (gfc_gsym_root, name);
+      if (gsym != NULL)
+	{
+	  gfc_symbol *s;
+	  gfc_find_symbol (sym->name, gsym->ns, 0, &s);
+	  if (s && s->backend_decl)
+	    return s->backend_decl;
+	}
+    }
+
   decl = sym->backend_decl;
   if (decl)
     return decl;
@@ -1934,7 +1981,7 @@
 /* Get a basic decl for an external function.  */
 
 tree
-gfc_get_extern_function_decl (gfc_symbol * sym)
+gfc_get_extern_function_decl (gfc_symbol * sym, gfc_actual_arglist *actual_args)
 {
   tree type;
   tree fndecl;
@@ -1959,10 +2006,23 @@
     return get_proc_pointer_decl (sym);
 
   /* See if this is an external procedure from the same file.  If so,
-     return the backend_decl.  */
-  gsym =  gfc_find_gsymbol (gfc_gsym_root, sym->binding_label
-					   ? sym->binding_label : sym->name);
+     return the backend_decl.  If we are looking at a BIND(C)
+     procedure and the symbol is not BIND(C), or vice versa, we
+     haven't found the right procedure.  */
 
+  if (sym->binding_label)
+    {
+      gsym = gfc_find_gsymbol (gfc_gsym_root, sym->binding_label);
+      if (gsym && !gsym->bind_c)
+	gsym = NULL;
+    }
+  else
+    {
+      gsym = gfc_find_gsymbol (gfc_gsym_root, sym->name);
+      if (gsym && gsym->bind_c)
+	gsym = NULL;
+    }
+
   if (gsym && !gsym->defined)
     gsym = NULL;
 
@@ -2107,7 +2167,7 @@
       mangled_name = gfc_sym_mangled_function_id (sym);
     }
 
-  type = gfc_get_function_type (sym);
+  type = gfc_get_function_type (sym, actual_args);
   fndecl = build_decl (input_location,
 		       FUNCTION_DECL, name, type);
 
@@ -5220,6 +5280,33 @@
   /* Handle "static" initializer.  */
   if (sym->value)
     {
+      if (sym->value->expr_type == EXPR_ARRAY)
+	{
+	  gfc_constructor *c, *cnext;
+
+	  /* Test if the array has more than one element.  */
+	  c = gfc_constructor_first (sym->value->value.constructor);
+	  gcc_assert (c);  /* Empty constructor should not happen here.  */
+	  cnext = gfc_constructor_next (c);
+
+	  if (cnext)
+	    {
+	      /* An EXPR_ARRAY with a rank > 1 here has to come from a
+		 DATA statement.  Set its rank here as not to confuse
+		 the following steps.   */
+	      sym->value->rank = 1;
+	    }
+	  else
+	    {
+	      /* There is only a single value in the constructor, use
+		 it directly for the assignment.  */
+	      gfc_expr *new_expr;
+	      new_expr = gfc_copy_expr (c->expr);
+	      gfc_free_expr (sym->value);
+	      sym->value = new_expr;
+	    }
+	}
+
       sym->attr.pointer = 1;
       tmp = gfc_trans_assignment (gfc_lval_expr_from_sym (sym), sym->value,
 				  true, false);
Index: gcc/fortran/target-memory.c
===================================================================
--- a/src/gcc/fortran/target-memory.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/target-memory.c	(.../branches/gcc-7-branch)
@@ -111,6 +111,7 @@
     case BT_CLASS:
     case BT_VOID:
     case BT_ASSUMED:
+    case BT_PROCEDURE:
       {
 	/* Determine type size without clobbering the typespec for ISO C
 	   binding types.  */
Index: gcc/fortran/match.c
===================================================================
--- a/src/gcc/fortran/match.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/match.c	(.../branches/gcc-7-branch)
@@ -2050,8 +2050,6 @@
       ts->type = BT_CHARACTER;
 
       m = gfc_match_char_spec (ts);
-      if (ts->u.cl && ts->u.cl->length)
-	gfc_resolve_expr (ts->u.cl->length);
 
       if (m == MATCH_NO)
 	m = MATCH_YES;
@@ -2153,6 +2151,9 @@
 	      return MATCH_NO;
 	    }
 
+	  if (e->expr_type != EXPR_CONSTANT)
+	    goto ohno;
+
 	  gfc_next_char (); /* Burn the ')'. */
 	  ts->kind = (int) mpz_get_si (e->value.integer);
 	  if (gfc_validate_kind (ts->type, ts->kind , true) == -1)
@@ -2167,6 +2168,8 @@
 	}
     }
 
+ohno:
+
   /* If a type is not matched, simply return MATCH_NO.  */
   gfc_current_locus = old_locus;
   return MATCH_NO;
Index: gcc/fortran/arith.c
===================================================================
--- a/src/gcc/fortran/arith.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/arith.c	(.../branches/gcc-7-branch)
@@ -2050,7 +2050,7 @@
       gfc_convert_mpz_to_signed (result->value.integer,
 				 gfc_integer_kinds[k].bit_size);
 
-      if (warn_conversion && kind < src->ts.kind)
+      if (warn_conversion && !src->do_not_warn && kind < src->ts.kind)
 	gfc_warning_now (OPT_Wconversion, "Conversion from %qs to %qs at %L",
 			 gfc_typename (&src->ts), gfc_typename (&result->ts),
 			 &src->where);
Index: gcc/fortran/parse.c
===================================================================
--- a/src/gcc/fortran/parse.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/parse.c	(.../branches/gcc-7-branch)
@@ -5780,7 +5780,7 @@
     }
   else
     {
-      s = gfc_get_gsymbol (gfc_new_block->name);
+      s = gfc_get_gsymbol (gfc_new_block->name, false);
       if (s->defined
 	  || (s->type != GSYM_UNKNOWN && s->type != GSYM_BLOCK_DATA))
        gfc_global_used (s, &gfc_new_block->declared_at);
@@ -5862,7 +5862,7 @@
   gfc_gsymbol *s;
   bool error;
 
-  s = gfc_get_gsymbol (gfc_new_block->name);
+  s = gfc_get_gsymbol (gfc_new_block->name, false);
   if (s->defined || (s->type != GSYM_UNKNOWN && s->type != GSYM_MODULE))
     gfc_global_used (s, &gfc_new_block->declared_at);
   else
@@ -5926,7 +5926,7 @@
      name is a global identifier.  */
   if (!gfc_new_block->binding_label || gfc_notification_std (GFC_STD_F2008))
     {
-      s = gfc_get_gsymbol (gfc_new_block->name);
+      s = gfc_get_gsymbol (gfc_new_block->name, false);
 
       if (s->defined
 	  || (s->type != GSYM_UNKNOWN
@@ -5951,7 +5951,7 @@
       && (!gfc_notification_std (GFC_STD_F2008)
           || strcmp (gfc_new_block->name, gfc_new_block->binding_label) != 0))
     {
-      s = gfc_get_gsymbol (gfc_new_block->binding_label);
+      s = gfc_get_gsymbol (gfc_new_block->binding_label, true);
 
       if (s->defined
 	  || (s->type != GSYM_UNKNOWN
@@ -5983,7 +5983,7 @@
 
   if (gfc_new_block == NULL)
     return;
-  s = gfc_get_gsymbol (gfc_new_block->name);
+  s = gfc_get_gsymbol (gfc_new_block->name, false);
 
   if (s->defined || (s->type != GSYM_UNKNOWN && s->type != GSYM_PROGRAM))
     gfc_global_used (s, &gfc_new_block->declared_at);
Index: gcc/fortran/check.c
===================================================================
--- a/src/gcc/fortran/check.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/check.c	(.../branches/gcc-7-branch)
@@ -5295,6 +5295,26 @@
   size_t source_size;
   size_t result_size;
 
+  /* SOURCE shall be a scalar or array of any type.  */
+  if (source->ts.type == BT_PROCEDURE
+      && source->symtree->n.sym->attr.subroutine == 1)
+    {
+      gfc_error ("%<SOURCE%> argument of %<TRANSFER%> intrinsic at %L "
+                 "must not be a %s", &source->where,
+		 gfc_basic_typename (source->ts.type));
+      return false;
+    }
+
+  /* MOLD shall be a scalar or array of any type.  */
+  if (mold->ts.type == BT_PROCEDURE
+      && mold->symtree->n.sym->attr.subroutine == 1)
+    {
+      gfc_error ("%<MOLD%> argument of %<TRANSFER%> intrinsic at %L "
+                 "must not be a %s", &mold->where,
+		 gfc_basic_typename (mold->ts.type));
+      return false;
+    }
+
   if (mold->ts.type == BT_HOLLERITH)
     {
       gfc_error ("%<MOLD%> argument of %<TRANSFER%> intrinsic at %L must not be"
@@ -5302,6 +5322,8 @@
       return false;
     }
 
+  /* SIZE (optional) shall be an integer scalar.  The corresponding actual
+     argument shall not be an optional dummy argument.  */
   if (size != NULL)
     {
       if (!type_check (size, 2, BT_INTEGER))
Index: gcc/fortran/primary.c
===================================================================
--- a/src/gcc/fortran/primary.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/primary.c	(.../branches/gcc-7-branch)
@@ -2980,6 +2980,7 @@
   e = gfc_get_expr ();
   e->symtree = symtree;
   e->expr_type = EXPR_FUNCTION;
+  e->where = gfc_current_locus;
 
   gcc_assert (gfc_fl_struct (sym->attr.flavor)
 	      && symtree->n.sym->attr.flavor == FL_PROCEDURE);
Index: gcc/gimple-pretty-print.c
===================================================================
--- a/src/gcc/gimple-pretty-print.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/gimple-pretty-print.c	(.../branches/gcc-7-branch)
@@ -1989,6 +1989,8 @@
       pp_string (buffer, "__asm__");
       if (gimple_asm_volatile_p (gs))
 	pp_string (buffer, " __volatile__");
+      if (gimple_asm_inline_p (gs))
+	pp_string (buffer, " __inline__");
       if (gimple_asm_nlabels (gs))
 	pp_string (buffer, " goto");
       pp_string (buffer, "(\"");
Index: gcc/function.c
===================================================================
--- a/src/gcc/function.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/function.c	(.../branches/gcc-7-branch)
@@ -6604,7 +6604,7 @@
       output_matched[match] = true;
 
       start_sequence ();
-      emit_move_insn (output, input);
+      emit_move_insn (output, copy_rtx (input));
       insns = get_insns ();
       end_sequence ();
       emit_insn_before (insns, insn);
Index: gcc/gcse.c
===================================================================
--- a/src/gcc/gcse.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/gcse.c	(.../branches/gcc-7-branch)
@@ -1963,14 +1963,11 @@
   return rval;
 }
 
-/* Generate RTL to copy an EXPR to its `reaching_reg' and return it.  */
+/* Generate RTL to copy an EXP to REG and return it.  */
 
-static rtx_insn *
-process_insert_insn (struct gcse_expr *expr)
+rtx_insn *
+prepare_copy_insn (rtx reg, rtx exp)
 {
-  rtx reg = expr->reaching_reg;
-  /* Copy the expression to make sure we don't have any sharing issues.  */
-  rtx exp = copy_rtx (expr->expr);
   rtx_insn *pat;
 
   start_sequence ();
@@ -1996,6 +1993,18 @@
   return pat;
 }
 
+/* Generate RTL to copy an EXPR to its `reaching_reg' and return it.  */
+
+static rtx_insn *
+process_insert_insn (struct gcse_expr *expr)
+{
+  rtx reg = expr->reaching_reg;
+  /* Copy the expression to make sure we don't have any sharing issues.  */
+  rtx exp = copy_rtx (expr->expr);
+
+  return prepare_copy_insn (reg, exp);
+}
+
 /* Add EXPR to the end of basic block BB.
 
    This is used by both the PRE and code hoisting.  */
Index: gcc/tree-data-ref.c
===================================================================
--- a/src/gcc/tree-data-ref.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-data-ref.c	(.../branches/gcc-7-branch)
@@ -2118,6 +2118,8 @@
   switch (TREE_CODE (chrec))
     {
     case POLYNOMIAL_CHREC:
+      if (!cst_and_fits_in_hwi (CHREC_RIGHT (chrec)))
+	return chrec_dont_know;
       A[index][0] = mult * int_cst_value (CHREC_RIGHT (chrec));
       return initialize_matrix_A (A, CHREC_LEFT (chrec), index + 1, mult);
 
@@ -2499,7 +2501,7 @@
 				 tree *last_conflicts)
 {
   unsigned nb_vars_a, nb_vars_b, dim;
-  HOST_WIDE_INT init_a, init_b, gamma, gcd_alpha_beta;
+  HOST_WIDE_INT gamma, gcd_alpha_beta;
   lambda_matrix A, U, S;
   struct obstack scratch_obstack;
 
@@ -2536,9 +2538,20 @@
   A = lambda_matrix_new (dim, 1, &scratch_obstack);
   S = lambda_matrix_new (dim, 1, &scratch_obstack);
 
-  init_a = int_cst_value (initialize_matrix_A (A, chrec_a, 0, 1));
-  init_b = int_cst_value (initialize_matrix_A (A, chrec_b, nb_vars_a, -1));
-  gamma = init_b - init_a;
+  tree init_a = initialize_matrix_A (A, chrec_a, 0, 1);
+  tree init_b = initialize_matrix_A (A, chrec_b, nb_vars_a, -1);
+  if (init_a == chrec_dont_know
+      || init_b == chrec_dont_know)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "affine-affine test failed: "
+		 "representation issue.\n");
+      *overlaps_a = conflict_fn_not_known ();
+      *overlaps_b = conflict_fn_not_known ();
+      *last_conflicts = chrec_dont_know;
+      goto end_analyze_subs_aa;
+    }
+  gamma = int_cst_value (init_b) - int_cst_value (init_a);
 
   /* Don't do all the hard work of solving the Diophantine equation
      when we already know the solution: for example,
Index: gcc/gimplify.c
===================================================================
--- a/src/gcc/gimplify.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/gimplify.c	(.../branches/gcc-7-branch)
@@ -6206,6 +6206,7 @@
 
       gimple_asm_set_volatile (stmt, ASM_VOLATILE_P (expr) || noutputs == 0);
       gimple_asm_set_input (stmt, ASM_INPUT_P (expr));
+      gimple_asm_set_inline (stmt, ASM_INLINE_P (expr));
 
       gimplify_seq_add_stmt (pre_p, stmt);
     }
Index: gcc/tree-ssa-loop-split.c
===================================================================
--- a/src/gcc/tree-ssa-loop-split.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssa-loop-split.c	(.../branches/gcc-7-branch)
@@ -649,7 +649,8 @@
 					false, true)
 	  && niter.cmp != ERROR_MARK
 	  /* We can't yet handle loops controlled by a != predicate.  */
-	  && niter.cmp != NE_EXPR)
+	  && niter.cmp != NE_EXPR
+	  && can_duplicate_loop_p (loop))
 	{
 	  if (split_loop (loop, &niter))
 	    {
Index: gcc/store-motion.c
===================================================================
--- a/src/gcc/store-motion.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/store-motion.c	(.../branches/gcc-7-branch)
@@ -907,8 +907,7 @@
   rtx_insn *insn;
   rtx mem, note, set;
 
-  mem = smexpr->pattern;
-  insn = gen_move_insn (reg, SET_SRC (single_set (del)));
+  insn = prepare_copy_insn (reg, SET_SRC (single_set (del)));
 
   unsigned int i;
   rtx_insn *temp;
@@ -941,6 +940,7 @@
   /* Now we must handle REG_EQUAL notes whose contents is equal to the mem;
      they are no longer accurate provided that they are reached by this
      definition, so drop them.  */
+  mem = smexpr->pattern;
   for (; insn != NEXT_INSN (BB_END (bb)); insn = NEXT_INSN (insn))
     if (NONDEBUG_INSN_P (insn))
       {
Index: gcc/ipa-prop.c
===================================================================
--- a/src/gcc/ipa-prop.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ipa-prop.c	(.../branches/gcc-7-branch)
@@ -1577,7 +1577,8 @@
       if (TREE_CODE (arg) == SSA_NAME)
 	{
 	  tree type_size;
-          if (!tree_fits_uhwi_p (TYPE_SIZE (TREE_TYPE (arg_type))))
+          if (!tree_fits_uhwi_p (TYPE_SIZE (TREE_TYPE (arg_type)))
+	      || !POINTER_TYPE_P (TREE_TYPE (arg)))
             return;
 	  check_ref = true;
 	  arg_base = arg;
Index: gcc/tree-ssa-copy.c
===================================================================
--- a/src/gcc/tree-ssa-copy.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssa-copy.c	(.../branches/gcc-7-branch)
@@ -532,13 +532,12 @@
 	      duplicate_ssa_name_ptr_info (copy_of[i].value,
 					   SSA_NAME_PTR_INFO (var));
 	      /* Points-to information is cfg insensitive,
-		 but alignment info might be cfg sensitive, if it
-		 e.g. is derived from VRP derived non-zero bits.
-		 So, do not copy alignment info if the two SSA_NAMEs
-		 aren't defined in the same basic block.  */
+		 but [E]VRP might record context sensitive alignment
+		 info, non-nullness, etc.  So reset context sensitive
+		 info if the two SSA_NAMEs aren't defined in the same
+		 basic block.  */
 	      if (var_bb != copy_of_bb)
-		mark_ptr_info_alignment_unknown
-				(SSA_NAME_PTR_INFO (copy_of[i].value));
+		reset_flow_sensitive_info (copy_of[i].value);
 	    }
 	  else if (!POINTER_TYPE_P (TREE_TYPE (var))
 		   && SSA_NAME_RANGE_INFO (var)
Index: gcc/varasm.c
===================================================================
--- a/src/gcc/varasm.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/varasm.c	(.../branches/gcc-7-branch)
@@ -5175,7 +5175,7 @@
     {
       int this_time;
       int shift;
-      HOST_WIDE_INT value;
+      unsigned HOST_WIDE_INT value;
       HOST_WIDE_INT next_byte = next_offset / BITS_PER_UNIT;
       HOST_WIDE_INT next_bit = next_offset % BITS_PER_UNIT;
 
@@ -5207,15 +5207,13 @@
 	      this_time = end - shift + 1;
 	    }
 
-	  /* Now get the bits from the appropriate constant word.  */
-	  value = TREE_INT_CST_ELT (local->val, shift / HOST_BITS_PER_WIDE_INT);
-	  shift = shift & (HOST_BITS_PER_WIDE_INT - 1);
+	  /* Now get the bits we want to insert.  */
+	  value = wi::extract_uhwi (wi::to_widest (local->val),
+				    shift, this_time);
 
 	  /* Get the result.  This works only when:
 	     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */
-	  local->byte |= (((value >> shift)
-			   & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))
-			  << (BITS_PER_UNIT - this_time - next_bit));
+	  local->byte |= value << (BITS_PER_UNIT - this_time - next_bit);
 	}
       else
 	{
@@ -5232,15 +5230,13 @@
 	    this_time
 	      = HOST_BITS_PER_WIDE_INT - (shift & (HOST_BITS_PER_WIDE_INT - 1));
 
-	  /* Now get the bits from the appropriate constant word.  */
-	  value = TREE_INT_CST_ELT (local->val, shift / HOST_BITS_PER_WIDE_INT);
-	  shift = shift & (HOST_BITS_PER_WIDE_INT - 1);
+	  /* Now get the bits we want to insert.  */
+	  value = wi::extract_uhwi (wi::to_widest (local->val),
+				    shift, this_time);
 
 	  /* Get the result.  This works only when:
 	     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */
-	  local->byte |= (((value >> shift)
-			   & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))
-			  << next_bit);
+	  local->byte |= value << next_bit;
 	}
 
       next_offset += this_time;
Index: gcc/rtl.h
===================================================================
--- a/src/gcc/rtl.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/rtl.h	(.../branches/gcc-7-branch)
@@ -3666,6 +3666,9 @@
 /* In gcse.c */
 extern bool can_copy_p (machine_mode);
 extern bool can_assign_to_reg_without_clobbers_p (rtx, machine_mode);
+extern rtx_insn *prepare_copy_insn (rtx, rtx);
+
+/* In cprop.c */
 extern rtx fis_get_condition (rtx_insn *);
 
 /* In ira.c */
Index: gcc/tree-inline.c
===================================================================
--- a/src/gcc/tree-inline.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-inline.c	(.../branches/gcc-7-branch)
@@ -4173,6 +4173,9 @@
 	   with very long asm statements.  */
 	if (count > 1000)
 	  count = 1000;
+	/* If this asm is asm inline, count anything as minimum size.  */
+	if (gimple_asm_inline_p (as_a <gasm *> (stmt)))
+	  count = MIN (1, count);
 	return count;
       }
 
Index: gcc/combine.c
===================================================================
--- a/src/gcc/combine.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/combine.c	(.../branches/gcc-7-branch)
@@ -5807,8 +5807,9 @@
 	    && GET_MODE_PRECISION (mode) < GET_MODE_PRECISION (op0_mode)
 	    && subreg_lowpart_offset (mode, op0_mode) == SUBREG_BYTE (x)
 	    && HWI_COMPUTABLE_MODE_P (op0_mode)
-	    && (nonzero_bits (SUBREG_REG (x), op0_mode)
-		& GET_MODE_MASK (mode)) == 0)
+	    && ((nonzero_bits (SUBREG_REG (x), op0_mode)
+		 & GET_MODE_MASK (mode)) == 0)
+	    && !side_effects_p (SUBREG_REG (x)))
 	  return CONST0_RTX (mode);
       }
 
Index: gcc/resource.c
===================================================================
--- a/src/gcc/resource.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/resource.c	(.../branches/gcc-7-branch)
@@ -966,9 +966,13 @@
     {
       regset regs_live = DF_LR_IN (BASIC_BLOCK_FOR_FN (cfun, b));
       rtx_insn *start_insn, *stop_insn;
+      df_ref def;
 
       /* Compute hard regs live at start of block.  */
       REG_SET_TO_HARD_REG_SET (current_live_regs, regs_live);
+      FOR_EACH_ARTIFICIAL_DEF (def, b)
+	if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)
+	  SET_HARD_REG_BIT (current_live_regs, DF_REF_REGNO (def));
 
       /* Get starting and ending insn, handling the case where each might
 	 be a SEQUENCE.  */
Index: gcc/opts-global.c
===================================================================
--- a/src/gcc/opts-global.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/opts-global.c	(.../branches/gcc-7-branch)
@@ -100,10 +100,14 @@
 	   text, bad_lang);
   else if (lang_mask == CL_DRIVER)
     gcc_unreachable ();
-  else
+  else if (ok_langs[0] != '\0')
     /* Eventually this should become a hard error IMO.  */
     warning (0, "command line option %qs is valid for %s but not for %s",
 	     text, ok_langs, bad_lang);
+  else
+    /* Happens for -Werror=warning_name.  */
+    warning (0, "%<-Werror=%> argument %qs is not valid for %s",
+	     text, bad_lang);
 
   free (ok_langs);
   free (bad_lang);
Index: gcc/tree-ssa-structalias.c
===================================================================
--- a/src/gcc/tree-ssa-structalias.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssa-structalias.c	(.../branches/gcc-7-branch)
@@ -7456,7 +7456,10 @@
 	    }
 	  if (used)
 	    {
-	      bitmap_set_bit (rvars, restrict_var->id);
+	      /* Add all subvars to the set of restrict pointed-to set. */
+	      for (unsigned sv = restrict_var->head; sv != 0;
+		   sv = get_varinfo (sv)->next)
+		bitmap_set_bit (rvars, sv);
 	      varinfo_t escaped = get_varinfo (find (escaped_id));
 	      if (bitmap_bit_p (escaped->solution, restrict_var->id))
 		escaped_p = true;
Index: gcc/gimple.h
===================================================================
--- a/src/gcc/gimple.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/gimple.h	(.../branches/gcc-7-branch)
@@ -136,6 +136,7 @@
 enum gf_mask {
     GF_ASM_INPUT		= 1 << 0,
     GF_ASM_VOLATILE		= 1 << 1,
+    GF_ASM_INLINE		= 1 << 2,
     GF_CALL_FROM_THUNK		= 1 << 0,
     GF_CALL_RETURN_SLOT_OPT	= 1 << 1,
     GF_CALL_TAILCALL		= 1 << 2,
@@ -3909,7 +3910,7 @@
 }
 
 
-/* Return true ASM_STMT ASM_STMT is an asm statement marked volatile.  */
+/* Return true if ASM_STMT is marked volatile.  */
 
 static inline bool
 gimple_asm_volatile_p (const gasm *asm_stmt)
@@ -3918,7 +3919,7 @@
 }
 
 
-/* If VOLATLE_P is true, mark asm statement ASM_STMT as volatile.  */
+/* If VOLATILE_P is true, mark asm statement ASM_STMT as volatile.  */
 
 static inline void
 gimple_asm_set_volatile (gasm *asm_stmt, bool volatile_p)
@@ -3930,6 +3931,27 @@
 }
 
 
+/* Return true if ASM_STMT is marked inline.  */
+
+static inline bool
+gimple_asm_inline_p (const gasm *asm_stmt)
+{
+  return (asm_stmt->subcode & GF_ASM_INLINE) != 0;
+}
+
+
+/* If INLINE_P is true, mark asm statement ASM_STMT as inline.  */
+
+static inline void
+gimple_asm_set_inline (gasm *asm_stmt, bool inline_p)
+{
+  if (inline_p)
+    asm_stmt->subcode |= GF_ASM_INLINE;
+  else
+    asm_stmt->subcode &= ~GF_ASM_INLINE;
+}
+
+
 /* If INPUT_P is true, mark asm ASM_STMT as an ASM_INPUT.  */
 
 static inline void
Index: gcc/tree-core.h
===================================================================
--- a/src/gcc/tree-core.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-core.h	(.../branches/gcc-7-branch)
@@ -1138,6 +1138,9 @@
        OMP_CLAUSE_LINEAR_VARIABLE_STRIDE in
 	   OMP_CLAUSE_LINEAR
 
+       ASM_INLINE_P in
+	   ASM_EXPR
+
    side_effects_flag:
 
        TREE_SIDE_EFFECTS in
Index: gcc/tree-ssa-reassoc.c
===================================================================
--- a/src/gcc/tree-ssa-reassoc.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssa-reassoc.c	(.../branches/gcc-7-branch)
@@ -1012,7 +1012,7 @@
 		    fprintf (dump_file, "Found * 0, removing all other ops\n");
 
 		  reassociate_stats.ops_eliminated += ops->length () - 1;
-		  ops->truncate (1);
+		  ops->truncate (0);
 		  ops->quick_push (oelast);
 		  return;
 		}
Index: gcc/config/alpha/alpha.c
===================================================================
--- a/src/gcc/config/alpha/alpha.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/alpha/alpha.c	(.../branches/gcc-7-branch)
@@ -6357,9 +6357,41 @@
   offset = get_initialized_tmp_var (t, pre_p, NULL);
 
   indirect = pass_by_reference (NULL, TYPE_MODE (type), type, false);
+
   if (indirect)
-    type = build_pointer_type_for_mode (type, ptr_mode, true);
+    {
+      if (TREE_CODE (type) == COMPLEX_TYPE
+	  && targetm.calls.split_complex_arg (type))
+	{
+	  tree real_part, imag_part, real_temp;
 
+	  tree ptr_type = build_pointer_type_for_mode (TREE_TYPE (type),
+						       ptr_mode, true);
+
+	  real_part = alpha_gimplify_va_arg_1 (ptr_type, base,
+					       offset, pre_p);
+	  real_part = build_va_arg_indirect_ref (real_part);
+
+	  /* Copy the value into a new temporary, lest the formal temporary
+	     be reused out from under us.  */
+	  real_temp = get_initialized_tmp_var (real_part, pre_p, NULL);
+
+	  imag_part = alpha_gimplify_va_arg_1 (ptr_type, base,
+					       offset, pre_p);
+	  imag_part = build_va_arg_indirect_ref (imag_part);
+
+	  r = build2 (COMPLEX_EXPR, type, real_temp, imag_part);
+
+	  /* Stuff the offset temporary back into its field.  */
+	  gimplify_assign (unshare_expr (offset_field),
+			   fold_convert (TREE_TYPE (offset_field), offset),
+			   pre_p);
+	  return r;
+	}
+      else
+	type = build_pointer_type_for_mode (type, ptr_mode, true);
+    }
+
   /* Find the value.  Note that this will be a stable indirection, or
      a composite of stable indirections in the case of complex.  */
   r = alpha_gimplify_va_arg_1 (type, base, offset, pre_p);
Index: gcc/config/s390/s390.md
===================================================================
--- a/src/gcc/config/s390/s390.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/s390/s390.md	(.../branches/gcc-7-branch)
@@ -1332,10 +1332,11 @@
 ; (TF|DF|SF|TD|DD|SD) instructions
 
 
-; load and test instructions turn SNaN into QNaN what is not
+; FIXME: load and test instructions turn SNaN into QNaN what is not
 ; acceptable if the target will be used afterwards.  On the other hand
 ; they are quite convenient for implementing comparisons with 0.0. So
-; try to enable them via splitter if the value isn't needed anymore.
+; try to enable them via splitter/peephole if the value isn't needed anymore.
+; See testcases: load-and-test-fp-1.c and load-and-test-fp-2.c
 
 ; ltxbr, ltdbr, ltebr, ltxtr, ltdtr
 (define_insn "*cmp<mode>_ccs_0"
@@ -1348,22 +1349,6 @@
    [(set_attr "op_type" "RRE")
     (set_attr "type"  "fsimp<mode>")])
 
-(define_split
-  [(set (match_operand 0 "cc_reg_operand")
-	(compare (match_operand:FP 1 "register_operand")
-		 (match_operand:FP 2 "const0_operand")))]
-  "TARGET_HARD_FLOAT && REG_P (operands[1]) && dead_or_set_p (insn, operands[1])"
-  [(parallel
-    [(set (match_dup 0) (match_dup 3))
-     (clobber (match_dup 1))])]
- {
-   /* s390_match_ccmode requires the compare to have the same CC mode
-      as the CC destination register.  */
-   operands[3] = gen_rtx_COMPARE (GET_MODE (operands[0]),
-				  operands[1], operands[2]);
- })
-
-
 ; VX: TFmode in FPR pairs: use cxbr instead of wfcxb
 ; cxtr, cdtr, cxbr, cdbr, cebr, cdb, ceb, wfcsb, wfcdb
 (define_insn "*cmp<mode>_ccs"
Index: gcc/config/s390/vector.md
===================================================================
--- a/src/gcc/config/s390/vector.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/s390/vector.md	(.../branches/gcc-7-branch)
@@ -933,7 +933,7 @@
 	(VEC_SHIFTS:VI (match_operand:VI 1 "register_operand"   "v")
 		       (match_operand:SI 2 "nonmemory_operand" "an")))]
   "TARGET_VX"
-  "<vec_shifts_mnem><bhfgq>\t%v0,%v1,%Y2"
+  "<vec_shifts_mnem><bhfgq>\t%v0,%v1,<addr_style_op_ops>"
   [(set_attr "op_type" "VRS")])
 
 ; Shift each element by corresponding vector element
Index: gcc/config/s390/s390-builtins.def
===================================================================
--- a/src/gcc/config/s390/s390-builtins.def	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/s390/s390-builtins.def	(.../branches/gcc-7-branch)
@@ -2804,8 +2804,8 @@
 B_DEF      (s390_vfsqdb,                sqrtv2df2,          0,                  B_VX,               0,                  BT_FN_V2DF_V2DF)
 
 OB_DEF     (s390_vec_double,            s390_vec_double_s64,s390_vec_double_u64,B_VX,               BT_FN_OV4SI_OV4SI)
-OB_DEF_VAR (s390_vec_double_s64,        s390_vcdgb,         0,                  0,                  BT_OV_V2DF_V2DI)
-OB_DEF_VAR (s390_vec_double_u64,        s390_vcdlgb,        0,                  0,                  BT_OV_V2DF_UV2DI)
+OB_DEF_VAR (s390_vec_double_s64,        s390_vec_double_s64,0,                  0,                  BT_OV_V2DF_V2DI)
+OB_DEF_VAR (s390_vec_double_u64,        s390_vec_double_u64,0,                  0,                  BT_OV_V2DF_UV2DI)
 
 B_DEF      (s390_vec_double_s64,        vec_double_s64,     0,                  B_INT | B_VX,       0,                  BT_FN_V2DF_V2DI)  /* vcdgb */
 B_DEF      (s390_vec_double_u64,        vec_double_u64,     0,                  B_INT | B_VX,       0,                  BT_FN_V2DF_UV2DI) /* vcdlgb */
Index: gcc/config/s390/vx-builtins.md
===================================================================
--- a/src/gcc/config/s390/vx-builtins.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/s390/vx-builtins.md	(.../branches/gcc-7-branch)
@@ -1607,7 +1607,7 @@
 (define_expand "vec_ctd_s64"
   [(set (match_operand:V2DF               0 "register_operand" "")
 	(unspec:V2DF [(match_operand:V2DI 1 "register_operand" "")
-		      (const_int 4) ; inexact suppressed
+		      (const_int VEC_NOINEXACT)
 		      (const_int VEC_RND_CURRENT)]
 		     UNSPEC_VEC_VCDGB))
    (use (match_operand:QI 2 "const_int_operand" ""))
@@ -1638,7 +1638,7 @@
 (define_expand "vec_ctd_u64"
   [(set (match_operand:V2DF               0 "register_operand" "")
 	(unspec:V2DF [(match_operand:V2DI 1 "register_operand" "")
-		      (const_int 4) ; inexact suppressed
+		      (const_int VEC_NOINEXACT)
 		      (const_int VEC_RND_CURRENT)]
 		     UNSPEC_VEC_VCDLGB))
    (use (match_operand:QI 2 "const_int_operand" ""))
@@ -1672,7 +1672,7 @@
 				 (match_dup 3)))
    (set (match_operand:V2DI 0 "register_operand" "")
 	(unspec:V2DI [(match_dup 4)
-		      (const_int 4) ; inexact suppressed
+		      (const_int VEC_NOINEXACT)
 		      (const_int VEC_RND_CURRENT)]
 		     UNSPEC_VEC_VCGDB))]
   "TARGET_VX"
@@ -1705,7 +1705,7 @@
 				 (match_dup 3)))
    (set (match_operand:V2DI 0 "register_operand" "")
 	(unspec:V2DI [(match_dup 4)
-		      (const_int 4) ; inexact suppressed
+		      (const_int VEC_NOINEXACT)
 		      (const_int VEC_RND_CURRENT)]
 		     UNSPEC_VEC_VCLGDB))]
   "TARGET_VX"
@@ -2026,7 +2026,7 @@
 (define_expand "vec_double_s64"
   [(set (match_operand:V2DF               0 "register_operand")
 	(unspec:V2DF [(match_operand:V2DI 1 "register_operand")
-		      (const_int 0)  ; inexact suppression disabled
+		      (const_int VEC_INEXACT)
 		      (const_int VEC_RND_CURRENT)]
 		     UNSPEC_VEC_VCDGB))]
   "TARGET_VX")
@@ -2034,7 +2034,7 @@
 (define_expand "vec_double_u64"
   [(set (match_operand:V2DF               0 "register_operand")
 	(unspec:V2DF [(match_operand:V2DI 1 "register_operand")
-		      (const_int 0)  ; inexact suppression disabled
+		      (const_int VEC_INEXACT)
 		      (const_int VEC_RND_CURRENT)]
 		     UNSPEC_VEC_VCDLGB))]
   "TARGET_VX")
Index: gcc/config/sparc/sparc.md
===================================================================
--- a/src/gcc/config/sparc/sparc.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/sparc/sparc.md	(.../branches/gcc-7-branch)
@@ -7961,158 +7961,112 @@
 
 ;; TLS support instructions.
 
-(define_insn "tgd_hi22"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-        (high:SI (unspec:SI [(match_operand 1 "tgd_symbolic_operand" "")]
-			    UNSPEC_TLSGD)))]
+(define_insn "tgd_hi22<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+        (high:P (unspec:P [(match_operand 1 "tgd_symbolic_operand" "")]
+			  UNSPEC_TLSGD)))]
   "TARGET_TLS"
   "sethi\\t%%tgd_hi22(%a1), %0")
 
-(define_insn "tgd_lo10"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
-		   (unspec:SI [(match_operand 2 "tgd_symbolic_operand" "")]
-			      UNSPEC_TLSGD)))]
+(define_insn "tgd_lo10<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(lo_sum:P (match_operand:P 1 "register_operand" "r")
+		  (unspec:P [(match_operand 2 "tgd_symbolic_operand" "")]
+			    UNSPEC_TLSGD)))]
   "TARGET_TLS"
   "add\\t%1, %%tgd_lo10(%a2), %0")
 
-(define_insn "tgd_add32"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(plus:SI (match_operand:SI 1 "register_operand" "r")
-		 (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-			     (match_operand 3 "tgd_symbolic_operand" "")]
-			    UNSPEC_TLSGD)))]
-  "TARGET_TLS && TARGET_ARCH32"
+(define_insn "tgd_add<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(plus:P (match_operand:P 1 "register_operand" "r")
+		(unspec:P [(match_operand:P 2 "register_operand" "r")
+			   (match_operand 3 "tgd_symbolic_operand" "")]
+			  UNSPEC_TLSGD)))]
+  "TARGET_TLS"
   "add\\t%1, %2, %0, %%tgd_add(%a3)")
 
-(define_insn "tgd_add64"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(plus:DI (match_operand:DI 1 "register_operand" "r")
-		 (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-			     (match_operand 3 "tgd_symbolic_operand" "")]
-			    UNSPEC_TLSGD)))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "add\\t%1, %2, %0, %%tgd_add(%a3)")
-
-(define_insn "tgd_call32"
+(define_insn "tgd_call<P:mode>"
   [(set (match_operand 0 "register_operand" "=r")
-	(call (mem:SI (unspec:SI [(match_operand:SI 1 "symbolic_operand" "s")
-				  (match_operand 2 "tgd_symbolic_operand" "")]
-				 UNSPEC_TLSGD))
+	(call (mem:P (unspec:P [(match_operand:P 1 "symbolic_operand" "s")
+				(match_operand 2 "tgd_symbolic_operand" "")]
+			       UNSPEC_TLSGD))
 	      (match_operand 3 "" "")))
-   (clobber (reg:SI O7_REG))]
-  "TARGET_TLS && TARGET_ARCH32"
+   (clobber (reg:P O7_REG))]
+  "TARGET_TLS"
   "call\t%a1, %%tgd_call(%a2)%#"
   [(set_attr "type" "call")])
 
-(define_insn "tgd_call64"
-  [(set (match_operand 0 "register_operand" "=r")
-	(call (mem:DI (unspec:DI [(match_operand:DI 1 "symbolic_operand" "s")
-				  (match_operand 2 "tgd_symbolic_operand" "")]
-				 UNSPEC_TLSGD))
-	      (match_operand 3 "" "")))
-   (clobber (reg:DI O7_REG))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "call\t%a1, %%tgd_call(%a2)%#"
-  [(set_attr "type" "call")])
-
-(define_insn "tldm_hi22"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-        (high:SI (unspec:SI [(const_int 0)] UNSPEC_TLSLDM)))]
+(define_insn "tldm_hi22<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+        (high:P (unspec:P [(const_int 0)] UNSPEC_TLSLDM)))]
   "TARGET_TLS"
   "sethi\\t%%tldm_hi22(%&), %0")
 
-(define_insn "tldm_lo10"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
-		    (unspec:SI [(const_int 0)] UNSPEC_TLSLDM)))]
+(define_insn "tldm_lo10<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(lo_sum:P (match_operand:P 1 "register_operand" "r")
+		  (unspec:P [(const_int 0)] UNSPEC_TLSLDM)))]
   "TARGET_TLS"
   "add\\t%1, %%tldm_lo10(%&), %0")
 
-(define_insn "tldm_add32"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(plus:SI (match_operand:SI 1 "register_operand" "r")
-		 (unspec:SI [(match_operand:SI 2 "register_operand" "r")]
-			    UNSPEC_TLSLDM)))]
-  "TARGET_TLS && TARGET_ARCH32"
+(define_insn "tldm_add<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(plus:P (match_operand:P 1 "register_operand" "r")
+		(unspec:P [(match_operand:P 2 "register_operand" "r")]
+			  UNSPEC_TLSLDM)))]
+  "TARGET_TLS"
   "add\\t%1, %2, %0, %%tldm_add(%&)")
 
-(define_insn "tldm_add64"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(plus:DI (match_operand:DI 1 "register_operand" "r")
-		 (unspec:DI [(match_operand:SI 2 "register_operand" "r")]
-			    UNSPEC_TLSLDM)))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "add\\t%1, %2, %0, %%tldm_add(%&)")
-
-(define_insn "tldm_call32"
+(define_insn "tldm_call<P:mode>"
   [(set (match_operand 0 "register_operand" "=r")
-	(call (mem:SI (unspec:SI [(match_operand:SI 1 "symbolic_operand" "s")]
-				 UNSPEC_TLSLDM))
+	(call (mem:P (unspec:P [(match_operand:P 1 "symbolic_operand" "s")]
+			       UNSPEC_TLSLDM))
 	      (match_operand 2 "" "")))
-   (clobber (reg:SI O7_REG))]
-  "TARGET_TLS && TARGET_ARCH32"
+   (clobber (reg:P O7_REG))]
+  "TARGET_TLS"
   "call\t%a1, %%tldm_call(%&)%#"
   [(set_attr "type" "call")])
 
-(define_insn "tldm_call64"
-  [(set (match_operand 0 "register_operand" "=r")
-	(call (mem:DI (unspec:DI [(match_operand:DI 1 "symbolic_operand" "s")]
-				 UNSPEC_TLSLDM))
-	      (match_operand 2 "" "")))
-   (clobber (reg:DI O7_REG))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "call\t%a1, %%tldm_call(%&)%#"
-  [(set_attr "type" "call")])
-
-(define_insn "tldo_hix22"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-        (high:SI (unspec:SI [(match_operand 1 "tld_symbolic_operand" "")]
-			    UNSPEC_TLSLDO)))]
+(define_insn "tldo_hix22<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+        (high:P (unspec:P [(match_operand 1 "tld_symbolic_operand" "")]
+			  UNSPEC_TLSLDO)))]
   "TARGET_TLS"
   "sethi\\t%%tldo_hix22(%a1), %0")
 
-(define_insn "tldo_lox10"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
-		   (unspec:SI [(match_operand 2 "tld_symbolic_operand" "")]
-			      UNSPEC_TLSLDO)))]
+(define_insn "tldo_lox10<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(lo_sum:P (match_operand:P 1 "register_operand" "r")
+		  (unspec:P [(match_operand 2 "tld_symbolic_operand" "")]
+			    UNSPEC_TLSLDO)))]
   "TARGET_TLS"
   "xor\\t%1, %%tldo_lox10(%a2), %0")
 
-(define_insn "tldo_add32"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(plus:SI (match_operand:SI 1 "register_operand" "r")
-		 (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-			     (match_operand 3 "tld_symbolic_operand" "")]
-			    UNSPEC_TLSLDO)))]
-  "TARGET_TLS && TARGET_ARCH32"
+(define_insn "tldo_add<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(plus:P (match_operand:P 1 "register_operand" "r")
+		(unspec:P [(match_operand:P 2 "register_operand" "r")
+			   (match_operand 3 "tld_symbolic_operand" "")]
+			  UNSPEC_TLSLDO)))]
+  "TARGET_TLS"
   "add\\t%1, %2, %0, %%tldo_add(%a3)")
 
-(define_insn "tldo_add64"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(plus:DI (match_operand:DI 1 "register_operand" "r")
-		 (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-			     (match_operand 3 "tld_symbolic_operand" "")]
-			    UNSPEC_TLSLDO)))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "add\\t%1, %2, %0, %%tldo_add(%a3)")
-
-(define_insn "tie_hi22"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-        (high:SI (unspec:SI [(match_operand 1 "tie_symbolic_operand" "")]
-			    UNSPEC_TLSIE)))]
+(define_insn "tie_hi22<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+        (high:P (unspec:P [(match_operand 1 "tie_symbolic_operand" "")]
+			  UNSPEC_TLSIE)))]
   "TARGET_TLS"
   "sethi\\t%%tie_hi22(%a1), %0")
 
-(define_insn "tie_lo10"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
-		   (unspec:SI [(match_operand 2 "tie_symbolic_operand" "")]
-			      UNSPEC_TLSIE)))]
+(define_insn "tie_lo10<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(lo_sum:P (match_operand:P 1 "register_operand" "r")
+		  (unspec:P [(match_operand 2 "tie_symbolic_operand" "")]
+			    UNSPEC_TLSIE)))]
   "TARGET_TLS"
   "add\\t%1, %%tie_lo10(%a2), %0")
 
+; Note the %%tie_ld operator
 (define_insn "tie_ld32"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(unspec:SI [(match_operand:SI 1 "register_operand" "r")
@@ -8124,10 +8078,11 @@
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")])
 
+; Note the %%tie_ldx operator
 (define_insn "tie_ld64"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(unspec:DI [(match_operand:DI 1 "register_operand" "r")
-		    (match_operand:SI 2 "register_operand" "r")
+		    (match_operand:DI 2 "register_operand" "r")
 		    (match_operand 3 "tie_symbolic_operand" "")]
 		   UNSPEC_TLSIE))]
   "TARGET_TLS && TARGET_ARCH64"
@@ -8135,159 +8090,97 @@
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")])
 
-(define_insn "tie_add32"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(plus:SI (match_operand:SI 1 "register_operand" "r")
-		 (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-			     (match_operand 3 "tie_symbolic_operand" "")]
-			    UNSPEC_TLSIE)))]
-  "TARGET_SUN_TLS && TARGET_ARCH32"
+(define_insn "tie_add<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(plus:P (match_operand:P 1 "register_operand" "r")
+		(unspec:P [(match_operand:P 2 "register_operand" "r")
+			   (match_operand 3 "tie_symbolic_operand" "")]
+			  UNSPEC_TLSIE)))]
+  "TARGET_SUN_TLS"
   "add\\t%1, %2, %0, %%tie_add(%a3)")
 
-(define_insn "tie_add64"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(plus:DI (match_operand:DI 1 "register_operand" "r")
-		 (unspec:DI [(match_operand:DI 2 "register_operand" "r")
-			     (match_operand 3 "tie_symbolic_operand" "")]
-			    UNSPEC_TLSIE)))]
-  "TARGET_SUN_TLS && TARGET_ARCH64"
-  "add\\t%1, %2, %0, %%tie_add(%a3)")
-
-(define_insn "tle_hix22_sp32"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-        (high:SI (unspec:SI [(match_operand 1 "tle_symbolic_operand" "")]
-			    UNSPEC_TLSLE)))]
-  "TARGET_TLS && TARGET_ARCH32"
+(define_insn "tle_hix22<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+        (high:P (unspec:P [(match_operand 1 "tle_symbolic_operand" "")]
+			  UNSPEC_TLSLE)))]
+  "TARGET_TLS"
   "sethi\\t%%tle_hix22(%a1), %0")
 
-(define_insn "tle_lox10_sp32"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
-		   (unspec:SI [(match_operand 2 "tle_symbolic_operand" "")]
-			      UNSPEC_TLSLE)))]
-  "TARGET_TLS && TARGET_ARCH32"
-  "xor\\t%1, %%tle_lox10(%a2), %0")
-
-(define_insn "tle_hix22_sp64"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-        (high:DI (unspec:DI [(match_operand 1 "tle_symbolic_operand" "")]
+(define_insn "tle_lox10<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(lo_sum:P (match_operand:P 1 "register_operand" "r")
+		  (unspec:P [(match_operand 2 "tle_symbolic_operand" "")]
 			    UNSPEC_TLSLE)))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "sethi\\t%%tle_hix22(%a1), %0")
-
-(define_insn "tle_lox10_sp64"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(lo_sum:DI (match_operand:DI 1 "register_operand" "r")
-		   (unspec:DI [(match_operand 2 "tle_symbolic_operand" "")]
-			      UNSPEC_TLSLE)))]
-  "TARGET_TLS && TARGET_ARCH64"
+  "TARGET_TLS"
   "xor\\t%1, %%tle_lox10(%a2), %0")
 
-;; Now patterns combining tldo_add{32,64} with some integer loads or stores
-(define_insn "*tldo_ldub_sp32"
+;; Now patterns combining tldo_add with some integer loads or stores
+(define_insn "*tldo_ldub<P:mode>"
   [(set (match_operand:QI 0 "register_operand" "=r")
-	(mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:SI 1 "register_operand" "r"))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	(mem:QI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				   (match_operand 3 "tld_symbolic_operand" "")]
+				  UNSPEC_TLSLDO)
+			(match_operand:P 1 "register_operand" "r"))))]
+  "TARGET_TLS"
   "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_ldub1_sp32"
+(define_insn "*tldo_ldub1<P:mode>"
   [(set (match_operand:HI 0 "register_operand" "=r")
 	(zero_extend:HI
-	  (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:SI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	  (mem:QI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			  (match_operand:P 1 "register_operand" "r")))))]
+  "TARGET_TLS"
   "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_ldub2_sp32"
+(define_insn "*tldo_ldub2<P:mode>"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(zero_extend:SI
-	  (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:SI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	  (mem:QI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			  (match_operand:P 1 "register_operand" "r")))))]
+  "TARGET_TLS"
   "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_ldsb1_sp32"
+(define_insn "*tldo_ldsb1<P:mode>"
   [(set (match_operand:HI 0 "register_operand" "=r")
 	(sign_extend:HI
-	  (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:SI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	  (mem:QI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			  (match_operand:P 1 "register_operand" "r")))))]
+  "TARGET_TLS"
   "ldsb\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "sload")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_ldsb2_sp32"
+(define_insn "*tldo_ldsb2<P:mode>"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(sign_extend:SI
-	  (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:SI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	  (mem:QI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			  (match_operand:P 1 "register_operand" "r")))))]
+  "TARGET_TLS"
   "ldsb\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "sload")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_ldub_sp64"
-  [(set (match_operand:QI 0 "register_operand" "=r")
-	(mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:DI 1 "register_operand" "r"))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "load")
-   (set_attr "subtype" "regular")
-   (set_attr "us3load_type" "3cycle")])
-
-(define_insn "*tldo_ldub1_sp64"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(zero_extend:HI
-	  (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:DI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "load")
-   (set_attr "subtype" "regular")
-   (set_attr "us3load_type" "3cycle")])
-
-(define_insn "*tldo_ldub2_sp64"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(zero_extend:SI
-	  (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:DI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "load")
-   (set_attr "subtype" "regular")
-   (set_attr "us3load_type" "3cycle")])
-
 (define_insn "*tldo_ldub3_sp64"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(zero_extend:DI
-	  (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+	  (mem:QI (plus:DI (unspec:DI [(match_operand:DI 2 "register_operand" "r")
 				       (match_operand 3 "tld_symbolic_operand" "")]
 				      UNSPEC_TLSLDO)
 			   (match_operand:DI 1 "register_operand" "r")))))]
@@ -8297,34 +8190,10 @@
    (set_attr "subtype" "regular")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_ldsb1_sp64"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(sign_extend:HI
-	  (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:DI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "ldsb\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "sload")
-   (set_attr "us3load_type" "3cycle")])
-
-(define_insn "*tldo_ldsb2_sp64"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(sign_extend:SI
-	  (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:DI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "ldsb\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "sload")
-   (set_attr "us3load_type" "3cycle")])
-
 (define_insn "*tldo_ldsb3_sp64"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(sign_extend:DI
-	  (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+	  (mem:QI (plus:DI (unspec:DI [(match_operand:DI 2 "register_operand" "r")
 				       (match_operand 3 "tld_symbolic_operand" "")]
 				      UNSPEC_TLSLDO)
 			   (match_operand:DI 1 "register_operand" "r")))))]
@@ -8333,72 +8202,47 @@
   [(set_attr "type" "sload")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_lduh_sp32"
+(define_insn "*tldo_lduh<P:mode>"
   [(set (match_operand:HI 0 "register_operand" "=r")
-	(mem:HI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:SI 1 "register_operand" "r"))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	(mem:HI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				   (match_operand 3 "tld_symbolic_operand" "")]
+				  UNSPEC_TLSLDO)
+			(match_operand:P 1 "register_operand" "r"))))]
+  "TARGET_TLS"
   "lduh\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_lduh1_sp32"
+(define_insn "*tldo_lduh1<P:mode>"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(zero_extend:SI
-	  (mem:HI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:SI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	  (mem:HI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			  (match_operand:P 1 "register_operand" "r")))))]
+  "TARGET_TLS"
   "lduh\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_ldsh1_sp32"
+(define_insn "*tldo_ldsh1<P:mode>"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(sign_extend:SI
-	  (mem:HI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:SI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	  (mem:HI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			  (match_operand:P 1 "register_operand" "r")))))]
+  "TARGET_TLS"
   "ldsh\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "sload")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_lduh_sp64"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:DI 1 "register_operand" "r"))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "lduh\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "load")
-   (set_attr "subtype" "regular")
-   (set_attr "us3load_type" "3cycle")])
-
-(define_insn "*tldo_lduh1_sp64"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(zero_extend:SI
-	  (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:DI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "lduh\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "load")
-   (set_attr "subtype" "regular")
-   (set_attr "us3load_type" "3cycle")])
-
 (define_insn "*tldo_lduh2_sp64"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(zero_extend:DI
-	  (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+	  (mem:HI (plus:DI (unspec:DI [(match_operand:DI 2 "register_operand" "r")
 				       (match_operand 3 "tld_symbolic_operand" "")]
 				      UNSPEC_TLSLDO)
 			   (match_operand:DI 1 "register_operand" "r")))))]
@@ -8408,22 +8252,10 @@
    (set_attr "subtype" "regular")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_ldsh1_sp64"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(sign_extend:SI
-	  (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:DI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "ldsh\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "sload")
-   (set_attr "us3load_type" "3cycle")])
-
 (define_insn "*tldo_ldsh2_sp64"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(sign_extend:DI
-	  (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+	  (mem:HI (plus:DI (unspec:DI [(match_operand:DI 2 "register_operand" "r")
 				       (match_operand 3 "tld_symbolic_operand" "")]
 				      UNSPEC_TLSLDO)
 			   (match_operand:DI 1 "register_operand" "r")))))]
@@ -8432,32 +8264,21 @@
   [(set_attr "type" "sload")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_lduw_sp32"
+(define_insn "*tldo_lduw<P:mode>"
   [(set (match_operand:SI 0 "register_operand" "=r")
-	(mem:SI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:SI 1 "register_operand" "r"))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	(mem:SI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				   (match_operand 3 "tld_symbolic_operand" "")]
+				  UNSPEC_TLSLDO)
+			(match_operand:P 1 "register_operand" "r"))))]
+  "TARGET_TLS"
   "ld\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")])
 
-(define_insn "*tldo_lduw_sp64"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(mem:SI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:DI 1 "register_operand" "r"))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "lduw\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "load")
-   (set_attr "subtype" "regular")])
-
 (define_insn "*tldo_lduw1_sp64"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(zero_extend:DI
-	  (mem:SI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+	  (mem:SI (plus:DI (unspec:DI [(match_operand:DI 2 "register_operand" "r")
 				       (match_operand 3 "tld_symbolic_operand" "")]
 				      UNSPEC_TLSLDO)
 			   (match_operand:DI 1 "register_operand" "r")))))]
@@ -8469,8 +8290,8 @@
 (define_insn "*tldo_ldsw1_sp64"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(sign_extend:DI
-	  (mem:SI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-					(match_operand 3 "tld_symbolic_operand" "")]
+	  (mem:SI (plus:DI (unspec:DI [(match_operand:DI 2 "register_operand" "r")
+				       (match_operand 3 "tld_symbolic_operand" "")]
 				      UNSPEC_TLSLDO)
 			   (match_operand:DI 1 "register_operand" "r")))))]
   "TARGET_TLS && TARGET_ARCH64"
@@ -8480,7 +8301,7 @@
 
 (define_insn "*tldo_ldx_sp64"
   [(set (match_operand:DI 0 "register_operand" "=r")
-	(mem:DI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+	(mem:DI (plus:DI (unspec:DI [(match_operand:DI 2 "register_operand" "r")
 				     (match_operand 3 "tld_symbolic_operand" "")]
 				    UNSPEC_TLSLDO)
 			 (match_operand:DI 1 "register_operand" "r"))))]
@@ -8489,68 +8310,38 @@
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")])
 
-(define_insn "*tldo_stb_sp32"
-  [(set (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:SI 1 "register_operand" "r")))
+(define_insn "*tldo_stb<P:mode>"
+  [(set (mem:QI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				   (match_operand 3 "tld_symbolic_operand" "")]
+				  UNSPEC_TLSLDO)
+			(match_operand:P 1 "register_operand" "r")))
 	(match_operand:QI 0 "register_operand" "r"))]
-  "TARGET_TLS && TARGET_ARCH32"
+  "TARGET_TLS"
   "stb\t%0, [%1 + %2], %%tldo_add(%3)"
   [(set_attr "type" "store")])
 
-(define_insn "*tldo_stb_sp64"
-  [(set (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:DI 1 "register_operand" "r")))
-	(match_operand:QI 0 "register_operand" "r"))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "stb\t%0, [%1 + %2], %%tldo_add(%3)"
-  [(set_attr "type" "store")])
-
-(define_insn "*tldo_sth_sp32"
-  [(set (mem:HI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:SI 1 "register_operand" "r")))
+(define_insn "*tldo_sth<P:mode>"
+  [(set (mem:HI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				   (match_operand 3 "tld_symbolic_operand" "")]
+				   UNSPEC_TLSLDO)
+			(match_operand:P 1 "register_operand" "r")))
 	(match_operand:HI 0 "register_operand" "r"))]
-  "TARGET_TLS && TARGET_ARCH32"
+  "TARGET_TLS"
   "sth\t%0, [%1 + %2], %%tldo_add(%3)"
   [(set_attr "type" "store")])
 
-(define_insn "*tldo_sth_sp64"
-  [(set (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:DI 1 "register_operand" "r")))
-	(match_operand:HI 0 "register_operand" "r"))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "sth\t%0, [%1 + %2], %%tldo_add(%3)"
-  [(set_attr "type" "store")])
-
-(define_insn "*tldo_stw_sp32"
-  [(set (mem:SI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:SI 1 "register_operand" "r")))
+(define_insn "*tldo_stw<P:mode>"
+  [(set (mem:SI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				   (match_operand 3 "tld_symbolic_operand" "")]
+				  UNSPEC_TLSLDO)
+			(match_operand:P 1 "register_operand" "r")))
 	(match_operand:SI 0 "register_operand" "r"))]
-  "TARGET_TLS && TARGET_ARCH32"
+  "TARGET_TLS"
   "st\t%0, [%1 + %2], %%tldo_add(%3)"
   [(set_attr "type" "store")])
 
-(define_insn "*tldo_stw_sp64"
-  [(set (mem:SI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:DI 1 "register_operand" "r")))
-	(match_operand:SI 0 "register_operand" "r"))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "stw\t%0, [%1 + %2], %%tldo_add(%3)"
-  [(set_attr "type" "store")])
-
 (define_insn "*tldo_stx_sp64"
-  [(set (mem:DI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+  [(set (mem:DI (plus:DI (unspec:DI [(match_operand:DI 2 "register_operand" "r")
 				     (match_operand 3 "tld_symbolic_operand" "")]
 				    UNSPEC_TLSLDO)
 			 (match_operand:DI 1 "register_operand" "r")))
Index: gcc/config/sparc/sparc.c
===================================================================
--- a/src/gcc/config/sparc/sparc.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/sparc/sparc.c	(.../branches/gcc-7-branch)
@@ -4531,30 +4531,38 @@
   gcc_assert (can_create_pseudo_p ());
 
   if (GET_CODE (addr) == SYMBOL_REF)
+    /* Although the various sethi/or sequences generate SImode values, many of
+       them can be transformed by the linker when relaxing and, if relaxing to
+       local-exec, will become a sethi/xor pair, which is signed and therefore
+       a full DImode value in 64-bit mode.  Thus we must use Pmode, lest these
+       values be spilled onto the stack in 64-bit mode.  */
     switch (SYMBOL_REF_TLS_MODEL (addr))
       {
       case TLS_MODEL_GLOBAL_DYNAMIC:
 	start_sequence ();
-	temp1 = gen_reg_rtx (SImode);
-	temp2 = gen_reg_rtx (SImode);
+	temp1 = gen_reg_rtx (Pmode);
+	temp2 = gen_reg_rtx (Pmode);
 	ret = gen_reg_rtx (Pmode);
 	o0 = gen_rtx_REG (Pmode, 8);
 	got = sparc_tls_got ();
-	emit_insn (gen_tgd_hi22 (temp1, addr));
-	emit_insn (gen_tgd_lo10 (temp2, temp1, addr));
 	if (TARGET_ARCH32)
 	  {
-	    emit_insn (gen_tgd_add32 (o0, got, temp2, addr));
-	    insn = emit_call_insn (gen_tgd_call32 (o0, sparc_tls_get_addr (),
+	    emit_insn (gen_tgd_hi22si (temp1, addr));
+	    emit_insn (gen_tgd_lo10si (temp2, temp1, addr));
+	    emit_insn (gen_tgd_addsi (o0, got, temp2, addr));
+	    insn = emit_call_insn (gen_tgd_callsi (o0, sparc_tls_get_addr (),
 						   addr, const1_rtx));
 	  }
 	else
 	  {
-	    emit_insn (gen_tgd_add64 (o0, got, temp2, addr));
-	    insn = emit_call_insn (gen_tgd_call64 (o0, sparc_tls_get_addr (),
+	    emit_insn (gen_tgd_hi22di (temp1, addr));
+	    emit_insn (gen_tgd_lo10di (temp2, temp1, addr));
+	    emit_insn (gen_tgd_adddi (o0, got, temp2, addr));
+	    insn = emit_call_insn (gen_tgd_calldi (o0, sparc_tls_get_addr (),
 						   addr, const1_rtx));
 	  }
 	use_reg (&CALL_INSN_FUNCTION_USAGE (insn), o0);
+	RTL_CONST_CALL_P (insn) = 1;
 	insn = get_insns ();
 	end_sequence ();
 	emit_libcall_block (insn, ret, o0, addr);
@@ -4562,61 +4570,78 @@
 
       case TLS_MODEL_LOCAL_DYNAMIC:
 	start_sequence ();
-	temp1 = gen_reg_rtx (SImode);
-	temp2 = gen_reg_rtx (SImode);
+	temp1 = gen_reg_rtx (Pmode);
+	temp2 = gen_reg_rtx (Pmode);
 	temp3 = gen_reg_rtx (Pmode);
 	ret = gen_reg_rtx (Pmode);
 	o0 = gen_rtx_REG (Pmode, 8);
 	got = sparc_tls_got ();
-	emit_insn (gen_tldm_hi22 (temp1));
-	emit_insn (gen_tldm_lo10 (temp2, temp1));
 	if (TARGET_ARCH32)
 	  {
-	    emit_insn (gen_tldm_add32 (o0, got, temp2));
-	    insn = emit_call_insn (gen_tldm_call32 (o0, sparc_tls_get_addr (),
+	    emit_insn (gen_tldm_hi22si (temp1));
+	    emit_insn (gen_tldm_lo10si (temp2, temp1));
+	    emit_insn (gen_tldm_addsi (o0, got, temp2));
+	    insn = emit_call_insn (gen_tldm_callsi (o0, sparc_tls_get_addr (),
 						    const1_rtx));
 	  }
 	else
 	  {
-	    emit_insn (gen_tldm_add64 (o0, got, temp2));
-	    insn = emit_call_insn (gen_tldm_call64 (o0, sparc_tls_get_addr (),
+	    emit_insn (gen_tldm_hi22di (temp1));
+	    emit_insn (gen_tldm_lo10di (temp2, temp1));
+	    emit_insn (gen_tldm_adddi (o0, got, temp2));
+	    insn = emit_call_insn (gen_tldm_calldi (o0, sparc_tls_get_addr (),
 						    const1_rtx));
 	  }
 	use_reg (&CALL_INSN_FUNCTION_USAGE (insn), o0);
+	RTL_CONST_CALL_P (insn) = 1;
 	insn = get_insns ();
 	end_sequence ();
+	/* Attach a unique REG_EQUAL, to allow the RTL optimizers to
+	  share the LD_BASE result with other LD model accesses.  */
 	emit_libcall_block (insn, temp3, o0,
 			    gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),
 					    UNSPEC_TLSLD_BASE));
-	temp1 = gen_reg_rtx (SImode);
-	temp2 = gen_reg_rtx (SImode);
-	emit_insn (gen_tldo_hix22 (temp1, addr));
-	emit_insn (gen_tldo_lox10 (temp2, temp1, addr));
+	temp1 = gen_reg_rtx (Pmode);
+	temp2 = gen_reg_rtx (Pmode);
 	if (TARGET_ARCH32)
-	  emit_insn (gen_tldo_add32 (ret, temp3, temp2, addr));
+	  {
+	    emit_insn (gen_tldo_hix22si (temp1, addr));
+	    emit_insn (gen_tldo_lox10si (temp2, temp1, addr));
+	    emit_insn (gen_tldo_addsi (ret, temp3, temp2, addr));
+	  }
 	else
-	  emit_insn (gen_tldo_add64 (ret, temp3, temp2, addr));
+	  {
+	    emit_insn (gen_tldo_hix22di (temp1, addr));
+	    emit_insn (gen_tldo_lox10di (temp2, temp1, addr));
+	    emit_insn (gen_tldo_adddi (ret, temp3, temp2, addr));
+	  }
 	break;
 
       case TLS_MODEL_INITIAL_EXEC:
-	temp1 = gen_reg_rtx (SImode);
-	temp2 = gen_reg_rtx (SImode);
+	temp1 = gen_reg_rtx (Pmode);
+	temp2 = gen_reg_rtx (Pmode);
 	temp3 = gen_reg_rtx (Pmode);
 	got = sparc_tls_got ();
-	emit_insn (gen_tie_hi22 (temp1, addr));
-	emit_insn (gen_tie_lo10 (temp2, temp1, addr));
 	if (TARGET_ARCH32)
-	  emit_insn (gen_tie_ld32 (temp3, got, temp2, addr));
+	  {
+	    emit_insn (gen_tie_hi22si (temp1, addr));
+	    emit_insn (gen_tie_lo10si (temp2, temp1, addr));
+	    emit_insn (gen_tie_ld32 (temp3, got, temp2, addr));
+	  }
 	else
-	  emit_insn (gen_tie_ld64 (temp3, got, temp2, addr));
+	  {
+	    emit_insn (gen_tie_hi22di (temp1, addr));
+	    emit_insn (gen_tie_lo10di (temp2, temp1, addr));
+	    emit_insn (gen_tie_ld64 (temp3, got, temp2, addr));
+	  }
         if (TARGET_SUN_TLS)
 	  {
 	    ret = gen_reg_rtx (Pmode);
 	    if (TARGET_ARCH32)
-	      emit_insn (gen_tie_add32 (ret, gen_rtx_REG (Pmode, 7),
+	      emit_insn (gen_tie_addsi (ret, gen_rtx_REG (Pmode, 7),
 					temp3, addr));
 	    else
-	      emit_insn (gen_tie_add64 (ret, gen_rtx_REG (Pmode, 7),
+	      emit_insn (gen_tie_adddi (ret, gen_rtx_REG (Pmode, 7),
 					temp3, addr));
 	  }
 	else
@@ -4628,13 +4653,13 @@
 	temp2 = gen_reg_rtx (Pmode);
 	if (TARGET_ARCH32)
 	  {
-	    emit_insn (gen_tle_hix22_sp32 (temp1, addr));
-	    emit_insn (gen_tle_lox10_sp32 (temp2, temp1, addr));
+	    emit_insn (gen_tle_hix22si (temp1, addr));
+	    emit_insn (gen_tle_lox10si (temp2, temp1, addr));
 	  }
 	else
 	  {
-	    emit_insn (gen_tle_hix22_sp64 (temp1, addr));
-	    emit_insn (gen_tle_lox10_sp64 (temp2, temp1, addr));
+	    emit_insn (gen_tle_hix22di (temp1, addr));
+	    emit_insn (gen_tle_lox10di (temp2, temp1, addr));
 	  }
 	ret = gen_rtx_PLUS (Pmode, gen_rtx_REG (Pmode, 7), temp2);
 	break;
Index: gcc/config/i386/i386.md
===================================================================
--- a/src/gcc/config/i386/i386.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/i386/i386.md	(.../branches/gcc-7-branch)
@@ -8268,7 +8268,24 @@
   [(parallel [(set (match_dup 0)
 		   (zero_extend:DI (and:SI (match_dup 1) (match_dup 2))))
 	      (clobber (reg:CC FLAGS_REG))])]
-  "operands[2] = gen_lowpart (SImode, operands[2]);")
+{
+  if (GET_CODE (operands[2]) == SYMBOL_REF
+      || GET_CODE (operands[2]) == LABEL_REF)
+    {
+      operands[2] = shallow_copy_rtx (operands[2]);
+      PUT_MODE (operands[2], SImode);
+    }
+  else if (GET_CODE (operands[2]) == CONST)
+    {
+      /* (const:DI (plus:DI (symbol_ref:DI ("...")) (const_int N))) */
+      operands[2] = copy_rtx (operands[2]);
+      PUT_MODE (operands[2], SImode);
+      PUT_MODE (XEXP (operands[2], 0), SImode);
+      PUT_MODE (XEXP (XEXP (operands[2], 0), 0), SImode);
+    }    
+  else
+    operands[2] = gen_lowpart (SImode, operands[2]);
+})
 
 ;; See comment for addsi_1_zext why we do use nonimmediate_operand
 (define_insn "*andsi_1_zext"
Index: gcc/config/i386/cpuid.h
===================================================================
--- a/src/gcc/config/i386/cpuid.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/i386/cpuid.h	(.../branches/gcc-7-branch)
@@ -167,10 +167,27 @@
 #define signature_VORTEX_ecx	0x436f5320
 #define signature_VORTEX_edx	0x36387865
 
+#ifndef __x86_64__
+/* At least one cpu (Winchip 2) does not set %ebx and %ecx
+   for cpuid leaf 1. Forcibly zero the two registers before
+   calling cpuid as a precaution.  */
 #define __cpuid(level, a, b, c, d)			\
+  do {							\
+    if (__builtin_constant_p (level) && (level) != 1)	\
+      __asm__ ("cpuid\n\t"				\
+	      : "=a" (a), "=b" (b), "=c" (c), "=d" (d)	\
+	      : "0" (level));				\
+    else						\
+      __asm__ ("cpuid\n\t"				\
+	      : "=a" (a), "=b" (b), "=c" (c), "=d" (d)	\
+	      : "0" (level), "1" (0), "2" (0));		\
+  } while (0)
+#else
+#define __cpuid(level, a, b, c, d)			\
   __asm__ ("cpuid\n\t"					\
 	   : "=a" (a), "=b" (b), "=c" (c), "=d" (d)	\
 	   : "0" (level))
+#endif
 
 #define __cpuid_count(level, count, a, b, c, d)		\
   __asm__ ("cpuid\n\t"					\
Index: gcc/config/i386/darwin64.h
===================================================================
--- a/src/gcc/config/i386/darwin64.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/i386/darwin64.h	(.../branches/gcc-7-branch)
@@ -21,6 +21,32 @@
 #undef  DARWIN_ARCH_SPEC
 #define DARWIN_ARCH_SPEC "%{m32:i386;:x86_64}"
 
+/* WORKAROUND pr80556:
+   For x86_64 Darwin10 and later, the unwinder is in libunwind (redirected
+   from libSystem).  This doesn't use the keymgr (see keymgr.c) and therefore
+   the calls that libgcc makes to obtain the KEYMGR_GCC3_DW2_OBJ_LIST are not
+   updated to include new images, and might not even be valid for a single
+   image.
+   Therefore, for 64b exes at least, we must use the libunwind implementation,
+   even when static-libgcc is specified.  We put libSystem first so that
+   unwinder symbols are satisfied from there. */
+#undef REAL_LIBGCC_SPEC
+#define REAL_LIBGCC_SPEC						   \
+   "%{static-libgcc|static: 						   \
+      %{!m32:%:version-compare(>= 10.6 mmacosx-version-min= -lSystem)}	   \
+        -lgcc_eh -lgcc;							   \
+      shared-libgcc|fexceptions|fgnu-runtime:				   \
+       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_s.10.4)	   \
+       %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
+       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)	   \
+       %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)	   \
+       -lgcc ;								   \
+      :%:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_s.10.4) \
+       %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
+       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)	   \
+       %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)	   \
+       -lgcc }"
+
 #undef  DARWIN_SUBARCH_SPEC
 #define DARWIN_SUBARCH_SPEC DARWIN_ARCH_SPEC
 
Index: gcc/config/i386/sse.md
===================================================================
--- a/src/gcc/config/i386/sse.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/i386/sse.md	(.../branches/gcc-7-branch)
@@ -1777,7 +1777,7 @@
   [(set (match_operand:VF1_128_256 0 "register_operand")
 	(unspec:VF1_128_256
 	  [(match_operand:VF1_128_256 1 "vector_operand")] UNSPEC_RSQRT))]
-  "TARGET_SSE_MATH"
+  "TARGET_SSE && TARGET_SSE_MATH"
 {
   ix86_emit_swsqrtsf (operands[0], operands[1], <MODE>mode, true);
   DONE;
@@ -4601,37 +4601,49 @@
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
 (define_insn "sse2_cvtpi2pd"
-  [(set (match_operand:V2DF 0 "register_operand" "=x,x")
-	(float:V2DF (match_operand:V2SI 1 "nonimmediate_operand" "y,m")))]
+  [(set (match_operand:V2DF 0 "register_operand" "=v,x")
+	(float:V2DF (match_operand:V2SI 1 "nonimmediate_operand" "vBm,?!y")))]
   "TARGET_SSE2"
-  "cvtpi2pd\t{%1, %0|%0, %1}"
+  "@
+   %vcvtdq2pd\t{%1, %0|%0, %1}
+   cvtpi2pd\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssecvt")
-   (set_attr "unit" "mmx,*")
-   (set_attr "prefix_data16" "1,*")
+   (set_attr "unit" "*,mmx")
+   (set_attr "prefix_data16" "*,1")
+   (set_attr "prefix" "maybe_vex,*")
    (set_attr "mode" "V2DF")])
 
 (define_insn "sse2_cvtpd2pi"
-  [(set (match_operand:V2SI 0 "register_operand" "=y")
-	(unspec:V2SI [(match_operand:V2DF 1 "nonimmediate_operand" "xm")]
+  [(set (match_operand:V2SI 0 "register_operand" "=v,?!y")
+	(unspec:V2SI [(match_operand:V2DF 1 "nonimmediate_operand" "vBm,xm")]
 		     UNSPEC_FIX_NOTRUNC))]
   "TARGET_SSE2"
-  "cvtpd2pi\t{%1, %0|%0, %1}"
+  "@
+   * return TARGET_AVX ? \"vcvtpd2dq{x}\t{%1, %0|%0, %1}\" : \"cvtpd2dq\t{%1, %0|%0, %1}\";
+   cvtpd2pi\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssecvt")
-   (set_attr "unit" "mmx")
+   (set_attr "unit" "*,mmx")
+   (set_attr "amdfam10_decode" "double")
+   (set_attr "athlon_decode" "vector")
    (set_attr "bdver1_decode" "double")
-   (set_attr "btver2_decode" "direct")
-   (set_attr "prefix_data16" "1")
-   (set_attr "mode" "DI")])
+   (set_attr "prefix_data16" "*,1")
+   (set_attr "prefix" "maybe_vex,*")
+   (set_attr "mode" "TI")])
 
 (define_insn "sse2_cvttpd2pi"
-  [(set (match_operand:V2SI 0 "register_operand" "=y")
-	(fix:V2SI (match_operand:V2DF 1 "nonimmediate_operand" "xm")))]
+  [(set (match_operand:V2SI 0 "register_operand" "=v,?!y")
+	(fix:V2SI (match_operand:V2DF 1 "nonimmediate_operand" "vBm,xm")))]
   "TARGET_SSE2"
-  "cvttpd2pi\t{%1, %0|%0, %1}"
+  "@
+   * return TARGET_AVX ? \"vcvttpd2dq{x}\t{%1, %0|%0, %1}\" : \"cvttpd2dq\t{%1, %0|%0, %1}\";
+   cvttpd2pi\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssecvt")
-   (set_attr "unit" "mmx")
+   (set_attr "unit" "*,mmx")
+   (set_attr "amdfam10_decode" "double")
+   (set_attr "athlon_decode" "vector")
    (set_attr "bdver1_decode" "double")
-   (set_attr "prefix_data16" "1")
+   (set_attr "prefix_data16" "*,1")
+   (set_attr "prefix" "maybe_vex,*")
    (set_attr "mode" "TI")])
 
 (define_insn "sse2_cvtsi2sd"
@@ -16015,9 +16027,9 @@
   switch (INTVAL (operands[4]))
     {
     case 3:
-      return "vgatherpf0<ssemodesuffix>ps\t{%5%{%0%}|%5%{%0%}}";
+      return "%M2vgatherpf0<ssemodesuffix>ps\t{%5%{%0%}|%5%{%0%}}";
     case 2:
-      return "vgatherpf1<ssemodesuffix>ps\t{%5%{%0%}|%5%{%0%}}";
+      return "%M2vgatherpf1<ssemodesuffix>ps\t{%5%{%0%}|%5%{%0%}}";
     default:
       gcc_unreachable ();
     }
@@ -16060,9 +16072,9 @@
   switch (INTVAL (operands[4]))
     {
     case 3:
-      return "vgatherpf0<ssemodesuffix>pd\t{%5%{%0%}|%5%{%0%}}";
+      return "%M2vgatherpf0<ssemodesuffix>pd\t{%5%{%0%}|%5%{%0%}}";
     case 2:
-      return "vgatherpf1<ssemodesuffix>pd\t{%5%{%0%}|%5%{%0%}}";
+      return "%M2vgatherpf1<ssemodesuffix>pd\t{%5%{%0%}|%5%{%0%}}";
     default:
       gcc_unreachable ();
     }
@@ -16106,10 +16118,10 @@
     {
     case 3:
     case 7:
-      return "vscatterpf0<ssemodesuffix>ps\t{%5%{%0%}|%5%{%0%}}";
+      return "%M2vscatterpf0<ssemodesuffix>ps\t{%5%{%0%}|%5%{%0%}}";
     case 2:
     case 6:
-      return "vscatterpf1<ssemodesuffix>ps\t{%5%{%0%}|%5%{%0%}}";
+      return "%M2vscatterpf1<ssemodesuffix>ps\t{%5%{%0%}|%5%{%0%}}";
     default:
       gcc_unreachable ();
     }
@@ -16153,10 +16165,10 @@
     {
     case 3:
     case 7:
-      return "vscatterpf0<ssemodesuffix>pd\t{%5%{%0%}|%5%{%0%}}";
+      return "%M2vscatterpf0<ssemodesuffix>pd\t{%5%{%0%}|%5%{%0%}}";
     case 2:
     case 6:
-      return "vscatterpf1<ssemodesuffix>pd\t{%5%{%0%}|%5%{%0%}}";
+      return "%M2vscatterpf1<ssemodesuffix>pd\t{%5%{%0%}|%5%{%0%}}";
     default:
       gcc_unreachable ();
     }
@@ -19020,7 +19032,7 @@
 	  UNSPEC_GATHER))
    (clobber (match_scratch:VEC_GATHER_MODE 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherd<ssemodesuffix>\t{%1, %7, %0|%0, %7, %1}"
+  "%M3v<sseintprefix>gatherd<ssemodesuffix>\t{%1, %7, %0|%0, %7, %1}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19040,7 +19052,7 @@
 	  UNSPEC_GATHER))
    (clobber (match_scratch:VEC_GATHER_MODE 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherd<ssemodesuffix>\t{%1, %6, %0|%0, %6, %1}"
+  "%M2v<sseintprefix>gatherd<ssemodesuffix>\t{%1, %6, %0|%0, %6, %1}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19081,7 +19093,7 @@
 	  UNSPEC_GATHER))
    (clobber (match_scratch:VEC_GATHER_MODE 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %7, %2|%2, %7, %5}"
+  "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %7, %2|%2, %7, %5}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19103,8 +19115,8 @@
   "TARGET_AVX2"
 {
   if (<MODE>mode != <VEC_GATHER_SRCDI>mode)
-    return "v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %x0|%x0, %6, %4}";
-  return "v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %0|%0, %6, %4}";
+    return "%M2v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %x0|%x0, %6, %4}";
+  return "%M2v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %0|%0, %6, %4}";
 }
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
@@ -19128,7 +19140,7 @@
 		     (const_int 2) (const_int 3)])))
    (clobber (match_scratch:VI4F_256 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %7, %0|%0, %7, %5}"
+  "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %7, %0|%0, %7, %5}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19151,7 +19163,7 @@
 		     (const_int 2) (const_int 3)])))
    (clobber (match_scratch:VI4F_256 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %0|%0, %6, %4}"
+  "%M2v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %0|%0, %6, %4}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19195,7 +19207,7 @@
 	  UNSPEC_GATHER))
    (clobber (match_scratch:<avx512fmaskmode> 2 "=&Yk"))]
   "TARGET_AVX512F"
-  "v<sseintprefix>gatherd<ssemodesuffix>\t{%6, %0%{%2%}|%0%{%2%}, %<xtg_mode>6}"
+  "%M4v<sseintprefix>gatherd<ssemodesuffix>\t{%6, %0%{%2%}|%0%{%2%}, %<xtg_mode>6}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19214,7 +19226,7 @@
 	  UNSPEC_GATHER))
    (clobber (match_scratch:<avx512fmaskmode> 1 "=&Yk"))]
   "TARGET_AVX512F"
-  "v<sseintprefix>gatherd<ssemodesuffix>\t{%5, %0%{%1%}|%0%{%1%}, %<xtg_mode>5}"
+  "%M3v<sseintprefix>gatherd<ssemodesuffix>\t{%5, %0%{%1%}|%0%{%1%}, %<xtg_mode>5}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19254,7 +19266,7 @@
    (clobber (match_scratch:QI 2 "=&Yk"))]
   "TARGET_AVX512F"
 {
-  return "v<sseintprefix>gatherq<ssemodesuffix>\t{%6, %1%{%2%}|%1%{%2%}, %<gatherq_mode>6}";
+  return "%M4v<sseintprefix>gatherq<ssemodesuffix>\t{%6, %1%{%2%}|%1%{%2%}, %<gatherq_mode>6}";
 }
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
@@ -19278,11 +19290,11 @@
   if (<MODE>mode != <VEC_GATHER_SRCDI>mode)
     {
       if (<MODE_SIZE> != 64)
-	return "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %x0%{%1%}|%x0%{%1%}, %<gatherq_mode>5}";
+	return "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %x0%{%1%}|%x0%{%1%}, %<gatherq_mode>5}";
       else
-	return "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %t0%{%1%}|%t0%{%1%}, %t5}";
+	return "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %t0%{%1%}|%t0%{%1%}, %t5}";
     }
-  return "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %0%{%1%}|%0%{%1%}, %<gatherq_mode>5}";
+  return "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %0%{%1%}|%0%{%1%}, %<gatherq_mode>5}";
 }
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
@@ -19319,7 +19331,7 @@
 	  UNSPEC_SCATTER))
    (clobber (match_scratch:<avx512fmaskmode> 1 "=&Yk"))]
   "TARGET_AVX512F"
-  "v<sseintprefix>scatterd<ssemodesuffix>\t{%3, %5%{%1%}|%5%{%1%}, %3}"
+  "%M0v<sseintprefix>scatterd<ssemodesuffix>\t{%3, %5%{%1%}|%5%{%1%}, %3}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19357,8 +19369,8 @@
   "TARGET_AVX512F"
 {
   if (GET_MODE_SIZE (GET_MODE_INNER (<MODE>mode)) == 8)
-    return "v<sseintprefix>scatterq<ssemodesuffix>\t{%3, %5%{%1%}|%5%{%1%}, %3}";
-  return "v<sseintprefix>scatterq<ssemodesuffix>\t{%3, %5%{%1%}|%t5%{%1%}, %3}";
+    return "%M0v<sseintprefix>scatterq<ssemodesuffix>\t{%3, %5%{%1%}|%5%{%1%}, %3}";
+  return "%M0v<sseintprefix>scatterq<ssemodesuffix>\t{%3, %5%{%1%}|%t5%{%1%}, %3}";
 }
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
Index: gcc/config/i386/darwin.h
===================================================================
--- a/src/gcc/config/i386/darwin.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/i386/darwin.h	(.../branches/gcc-7-branch)
@@ -39,6 +39,32 @@
 #endif
 #endif
 
+/* WORKAROUND pr80556:
+   For x86_64 Darwin10 and later, the unwinder is in libunwind (redirected
+   from libSystem).  This doesn't use the keymgr (see keymgr.c) and therefore
+   the calls that libgcc makes to obtain the KEYMGR_GCC3_DW2_OBJ_LIST are not
+   updated to include new images, and might not even be valid for a single
+   image.
+   Therefore, for 64b exes at least, we must use the libunwind implementation,
+   even when static-libgcc is specified.  We put libSystem first so that
+   unwinder symbols are satisfied from there. */
+#undef REAL_LIBGCC_SPEC
+#define REAL_LIBGCC_SPEC						   \
+   "%{static-libgcc|static: 						   \
+      %{m64:%:version-compare(>= 10.6 mmacosx-version-min= -lSystem)}	   \
+        -lgcc_eh -lgcc;							   \
+      shared-libgcc|fexceptions|fgnu-runtime:				   \
+       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_s.10.4)	   \
+       %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
+       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)	   \
+       %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)	   \
+       -lgcc ;								   \
+      :%:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_s.10.4) \
+       %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
+       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)	   \
+       %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)	   \
+       -lgcc }"
+
 /* Size of the Obj-C jump buffer.  */
 #define OBJC_JBLEN ((TARGET_64BIT) ? ((9 * 2) + 3 + 16) : (18))
 
@@ -85,9 +111,6 @@
 /* On Darwin, the stack is 128-bit aligned at the point of every call.
    Failure to ensure this will lead to a crash in the system libraries
    or dynamic loader.  */
-#undef STACK_BOUNDARY
-#define STACK_BOUNDARY \
-  ((profile_flag || TARGET_64BIT_MS_ABI) ? 128 : BITS_PER_WORD)
 
 #undef MAIN_STACK_BOUNDARY
 #define MAIN_STACK_BOUNDARY 128
Index: gcc/config/i386/i386.c
===================================================================
--- a/src/gcc/config/i386/i386.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/i386/i386.c	(.../branches/gcc-7-branch)
@@ -6282,6 +6282,12 @@
     target_option_default_node = target_option_current_node
       = build_target_option_node (opts);
 
+  /* PR86952: jump table usage with retpolines is slow.
+     The PR provides some numbers about the slowness.  */
+  if (ix86_indirect_branch != indirect_branch_keep
+      && !opts_set->x_flag_jump_tables)
+    opts->x_flag_jump_tables = 0;
+
   return true;
 }
 
@@ -12788,10 +12794,16 @@
   /* 64-bit MS ABI seem to require stack alignment to be always 16,
      except for function prologues, leaf functions and when the defult
      incoming stack boundary is overriden at command line or via
-     force_align_arg_pointer attribute.  */
-  if ((TARGET_64BIT_MS_ABI && crtl->preferred_stack_boundary < 128)
+     force_align_arg_pointer attribute.
+
+     Darwin's ABI specifies 128b alignment for both 32 and  64 bit variants
+     at call sites, including profile function calls.
+ */
+  if (((TARGET_64BIT_MS_ABI || TARGET_MACHO)
+        && crtl->preferred_stack_boundary < 128)
       && (!crtl->is_leaf || cfun->calls_alloca != 0
 	  || ix86_current_function_calls_tls_descriptor
+	  || (TARGET_MACHO && crtl->profile)
 	  || ix86_incoming_stack_boundary < 128))
     {
       crtl->preferred_stack_boundary = 128;
@@ -14493,8 +14505,9 @@
 	}
       m->fs.sp_offset += allocate;
 
-      /* Use stack_pointer_rtx for relative addressing so that code
-	 works for realigned stack, too.  */
+      /* Use stack_pointer_rtx for relative addressing so that code works for
+	 realigned stack.  But this means that we need a blockage to prevent
+	 stores based on the frame pointer from being scheduled before.  */
       if (r10_live && eax_live)
         {
 	  t = gen_rtx_PLUS (Pmode, stack_pointer_rtx, eax);
@@ -14503,6 +14516,7 @@
 	  t = plus_constant (Pmode, t, UNITS_PER_WORD);
 	  emit_move_insn (gen_rtx_REG (word_mode, AX_REG),
 			  gen_frame_mem (word_mode, t));
+	  emit_insn (gen_memory_blockage ());
 	}
       else if (eax_live || r10_live)
 	{
@@ -14510,6 +14524,7 @@
 	  emit_move_insn (gen_rtx_REG (word_mode,
 				       (eax_live ? AX_REG : R10_REG)),
 			  gen_frame_mem (word_mode, t));
+	  emit_insn (gen_memory_blockage ());
 	}
     }
   gcc_assert (m->fs.sp_offset == frame.stack_pointer_offset);
@@ -18164,6 +18179,7 @@
    ~ -- print "i" if TARGET_AVX2, "f" otherwise.
    @ -- print a segment register of thread base pointer load
    ^ -- print addr32 prefix if TARGET_64BIT and Pmode != word_mode
+   M -- print addr32 prefix for TARGET_X32 with VSIB address.
    ! -- print MPX prefix for jxx/call/ret instructions if required.
  */
 
@@ -18723,6 +18739,26 @@
 	  putc (TARGET_AVX2 ? 'i' : 'f', file);
 	  return;
 
+	case 'M':
+	  if (TARGET_X32)
+	    {
+	      /* NB: 32-bit indices in VSIB address are sign-extended
+		 to 64 bits. In x32, if 32-bit address 0xf7fa3010 is
+		 sign-extended to 0xfffffffff7fa3010 which is invalid
+		 address.  Add addr32 prefix if there is no base
+		 register nor symbol.  */
+	      bool ok;
+	      struct ix86_address parts;
+	      ok = ix86_decompose_address (x, &parts);
+	      gcc_assert (ok && parts.index == NULL_RTX);
+	      if (parts.base == NULL_RTX
+		  && (parts.disp == NULL_RTX
+		      || !symbolic_operand (parts.disp,
+					    GET_MODE (parts.disp))))
+		fputs ("addr32 ", file);
+	    }
+	  return;
+
 	case '^':
 	  if (TARGET_64BIT && Pmode != word_mode)
 	    fputs ("addr32 ", file);
@@ -24118,7 +24154,7 @@
   return true;
 }
 
-/* Expand an sse vector comparison.  Return the register with the result.  */
+/* Expand an SSE comparison.  Return the register with the result.  */
 
 static rtx
 ix86_expand_sse_cmp (rtx dest, enum rtx_code code, rtx cmp_op0, rtx cmp_op1,
@@ -24144,9 +24180,12 @@
   else
     cmp_mode = cmp_ops_mode;
 
+  cmp_op0 = force_reg (cmp_ops_mode, cmp_op0);
 
-  cmp_op0 = force_reg (cmp_ops_mode, cmp_op0);
-  if (!nonimmediate_operand (cmp_op1, cmp_ops_mode))
+  int (*op1_predicate)(rtx, machine_mode)
+    = VECTOR_MODE_P (cmp_ops_mode) ? vector_operand : nonimmediate_operand;
+
+  if (!op1_predicate (cmp_op1, cmp_ops_mode))
     cmp_op1 = force_reg (cmp_ops_mode, cmp_op1);
 
   if (optimize
@@ -24266,7 +24305,7 @@
       rtx (*gen) (rtx, rtx, rtx, rtx) = NULL;
       rtx d = dest;
 
-      if (!nonimmediate_operand (op_true, mode))
+      if (!vector_operand (op_true, mode))
 	op_true = force_reg (mode, op_true);
 
       op_false = force_reg (mode, op_false);
@@ -38388,6 +38427,16 @@
           unsigned char lsb_index = INTVAL (op1) & 0xFF;
           op1 = GEN_INT (length);
           op2 = GEN_INT (lsb_index);
+
+	  mode1 = insn_data[icode].operand[1].mode;
+	  if (!insn_data[icode].operand[1].predicate (op0, mode1))
+	    op0 = copy_to_mode_reg (mode1, op0);
+
+	  mode0 = insn_data[icode].operand[0].mode;
+	  if (target == 0
+	      || !register_operand (target, mode0))
+	    target = gen_reg_rtx (mode0);
+
           pat = GEN_FCN (icode) (target, op0, op1, op2);
           if (pat)
             emit_insn (pat);
@@ -40478,7 +40527,7 @@
 static bool
 use_rsqrt_p ()
 {
-  return (TARGET_SSE_MATH
+  return (TARGET_SSE && TARGET_SSE_MATH
 	  && flag_finite_math_only
 	  && !flag_trapping_math
 	  && flag_unsafe_math_optimizations);
@@ -51933,7 +51982,7 @@
      there is no adddf3 pattern (since x87 floating point only has
      XFmode operations) so the default hook implementation gets this
      wrong.  */
-  return TARGET_80387 || TARGET_SSE_MATH;
+  return TARGET_80387 || (TARGET_SSE && TARGET_SSE_MATH);
 }
 
 /* Implement TARGET_ATOMIC_ASSIGN_EXPAND_FENV.  */
@@ -51941,7 +51990,7 @@
 static void
 ix86_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
 {
-  if (!TARGET_80387 && !TARGET_SSE_MATH)
+  if (!TARGET_80387 && !(TARGET_SSE && TARGET_SSE_MATH))
     return;
   tree exceptions_var = create_tmp_var_raw (integer_type_node);
   if (TARGET_80387)
@@ -51976,7 +52025,7 @@
       tree update_fldenv = build_call_expr (fldenv, 1, fenv_addr);
       *update = build2 (COMPOUND_EXPR, void_type_node, *update, update_fldenv);
     }
-  if (TARGET_SSE_MATH)
+  if (TARGET_SSE && TARGET_SSE_MATH)
     {
       tree mxcsr_orig_var = create_tmp_var_raw (unsigned_type_node);
       tree mxcsr_mod_var = create_tmp_var_raw (unsigned_type_node);
@@ -52335,7 +52384,7 @@
 	  return FLT_EVAL_METHOD_PROMOTE_TO_FLOAT;
 	else if (!TARGET_MIX_SSE_I387)
 	  {
-	    if (!TARGET_SSE_MATH)
+	    if (!(TARGET_SSE && TARGET_SSE_MATH))
 	      return FLT_EVAL_METHOD_PROMOTE_TO_LONG_DOUBLE;
 	    else if (TARGET_SSE2)
 	      return FLT_EVAL_METHOD_PROMOTE_TO_FLOAT;
Index: gcc/config/aarch64/cortex-a57-fma-steering.c
===================================================================
--- a/src/gcc/config/aarch64/cortex-a57-fma-steering.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/aarch64/cortex-a57-fma-steering.c	(.../branches/gcc-7-branch)
@@ -404,7 +404,7 @@
 
   /* Update root nodes' pointer to forest.  */
   for (other_root_iter = other_roots->begin ();
-       other_root_iter != other_roots->end (); other_root_iter++)
+       other_root_iter != other_roots->end (); ++other_root_iter)
     (*other_root_iter)->set_forest (this);
 
   /* Remove other_forest from the list of forests and move its tree roots in
@@ -845,14 +845,13 @@
 			void (*process_node) (fma_forest *, fma_node *),
 			bool free)
 {
-  vec<fma_node *> to_process;
+  auto_vec<fma_node *> to_process;
+  auto_vec<fma_node *> to_free;
   std::list<fma_forest *>::iterator forest_iter;
 
-  to_process.create (0);
-
   /* For each forest.  */
   for (forest_iter = this->m_fma_forests.begin ();
-       forest_iter != this->m_fma_forests.end (); forest_iter++)
+       forest_iter != this->m_fma_forests.end (); ++forest_iter)
     {
       std::list<fma_root_node *>::iterator root_iter;
 
@@ -861,7 +860,7 @@
 
       /* For each tree root in this forest.  */
       for (root_iter = (*forest_iter)->get_roots ()->begin ();
-	   root_iter != (*forest_iter)->get_roots ()->end (); root_iter++)
+	   root_iter != (*forest_iter)->get_roots ()->end (); ++root_iter)
 	{
 	  if (process_root)
 	    process_root (*forest_iter, *root_iter);
@@ -879,17 +878,23 @@
 	  if (process_node)
 	    process_node (*forest_iter, node);
 
-	  /* Absence of children might indicate an alternate root of a *chain*.
-	     It's ok to skip it here as the chain will be renamed when
-	     processing the canonical root for that chain.  */
-	  if (node->get_children ()->empty ())
-	    continue;
-
 	  for (child_iter = node->get_children ()->begin ();
-	       child_iter != node->get_children ()->end (); child_iter++)
+	       child_iter != node->get_children ()->end (); ++child_iter)
 	    to_process.safe_push (*child_iter);
+
+	  /* Defer freeing so that the process_node callback can access the
+	     parent and children of the node being processed.  */
 	  if (free)
+	    to_free.safe_push (node);
+	}
+
+      if (free)
+	{
+	  delete *forest_iter;
+
+	  while (!to_free.is_empty ())
 	    {
+	      fma_node *node = to_free.pop ();
 	      if (node->root_p ())
 		delete static_cast<fma_root_node *> (node);
 	      else
@@ -896,11 +901,7 @@
 		delete node;
 	    }
 	}
-      if (free)
-	delete *forest_iter;
     }
-
-  to_process.release ();
 }
 
 /* Build the dependency trees of FMUL and FMADD/FMSUB instructions.  */
Index: gcc/config/aarch64/iterators.md
===================================================================
--- a/src/gcc/config/aarch64/iterators.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/aarch64/iterators.md	(.../branches/gcc-7-branch)
@@ -438,7 +438,8 @@
 (define_mode_attr sizen [(QI "8") (HI "16") (SI "32") (DI "64")])
 
 ;; Give the ordinal of the MSB in the mode
-(define_mode_attr sizem1 [(QI "#7") (HI "#15") (SI "#31") (DI "#63")])
+(define_mode_attr sizem1 [(QI "#7") (HI "#15") (SI "#31") (DI "#63")
+			  (HF "#15") (SF "#31") (DF "#63")])
 
 ;; Attribute to describe constants acceptable in logical operations
 (define_mode_attr lconst [(SI "K") (DI "L")])
@@ -507,7 +508,7 @@
 			  (V8HF "16b") (V2SF  "8b")
 			  (V4SF "16b") (V2DF  "16b")
 			  (DI   "8b")  (DF    "8b")
-			  (SI   "8b")])
+			  (SI   "8b")  (SF    "8b")])
 
 ;; Define element mode for each vector mode.
 (define_mode_attr VEL [(V8QI "QI") (V16QI "QI")
@@ -648,6 +649,9 @@
 ;; Double vector types for ALLX.
 (define_mode_attr Vallxd [(QI "8b") (HI "4h") (SI "2s")])
 
+;; Mode with floating-point values replaced by like-sized integers.
+(define_mode_attr V_INT_EQUIV [(DF "DI") (SF "SI")])
+
 ;; Mode of result of comparison operations.
 (define_mode_attr V_cmp_result [(V8QI "V8QI") (V16QI "V16QI")
 				(V4HI "V4HI") (V8HI  "V8HI")
Index: gcc/config/aarch64/aarch64.md
===================================================================
--- a/src/gcc/config/aarch64/aarch64.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/aarch64/aarch64.md	(.../branches/gcc-7-branch)
@@ -140,6 +140,7 @@
     UNSPEC_RSQRTS
     UNSPEC_NZCV
     UNSPEC_XPACLRI
+    UNSPEC_COPYSIGN
 ])
 
 (define_c_enum "unspecv" [
@@ -5003,45 +5004,45 @@
 ;;   LDR d2, #(1 << 63)
 ;;   BSL v2.8b, [y], [x]
 ;;
-;; or another, equivalent, sequence using one of BSL/BIT/BIF.
-;; aarch64_simd_bsldf will select the best suited of these instructions
-;; to generate based on register allocation, and knows how to partially
-;; constant fold based on the values of X and Y, so expand through that.
+;; or another, equivalent, sequence using one of BSL/BIT/BIF.  Because
+;; we expect these operations to nearly always operate on
+;; floating-point values, we do not want the operation to be
+;; simplified into a bit-field insert operation that operates on the
+;; integer side, since typically that would involve three inter-bank
+;; register copies.  As we do not expect copysign to be followed by
+;; other logical operations on the result, it seems preferable to keep
+;; this as an unspec operation, rather than exposing the underlying
+;; logic to the compiler.
 
-(define_expand "copysigndf3"
-  [(match_operand:DF 0 "register_operand")
-   (match_operand:DF 1 "register_operand")
-   (match_operand:DF 2 "register_operand")]
+(define_expand "copysign<GPF:mode>3"
+  [(match_operand:GPF 0 "register_operand")
+   (match_operand:GPF 1 "register_operand")
+   (match_operand:GPF 2 "register_operand")]
   "TARGET_FLOAT && TARGET_SIMD"
 {
-  rtx mask = gen_reg_rtx (DImode);
-  emit_move_insn (mask, GEN_INT (HOST_WIDE_INT_1U << 63));
-  emit_insn (gen_aarch64_simd_bsldf (operands[0], mask,
-				     operands[2], operands[1]));
+  rtx bitmask = gen_reg_rtx (<V_INT_EQUIV>mode);
+  emit_move_insn (bitmask, GEN_INT (HOST_WIDE_INT_M1U
+				<< (GET_MODE_BITSIZE (<MODE>mode) - 1)));
+  emit_insn (gen_copysign<mode>3_insn (operands[0], operands[1], operands[2],
+				       bitmask));
   DONE;
 }
 )
 
-;; As above, but we must first get to a 64-bit value if we wish to use
-;; aarch64_simd_bslv2sf.
-
-(define_expand "copysignsf3"
-  [(match_operand:SF 0 "register_operand")
-   (match_operand:SF 1 "register_operand")
-   (match_operand:SF 2 "register_operand")]
+(define_insn "copysign<GPF:mode>3_insn"
+  [(set (match_operand:GPF 0 "register_operand" "=w,w,w,r")
+	(unspec:GPF [(match_operand:GPF 1 "register_operand" "w,0,w,r")
+		     (match_operand:GPF 2 "register_operand" "w,w,0,0")
+		     (match_operand:<V_INT_EQUIV> 3 "register_operand"
+		     "0,w,w,X")]
+	 UNSPEC_COPYSIGN))]
   "TARGET_FLOAT && TARGET_SIMD"
-{
-  rtx mask = gen_reg_rtx (DImode);
-
-  /* Juggle modes to get us in to a vector mode for BSL.  */
-  rtx op1 = lowpart_subreg (V2SFmode, operands[1], SFmode);
-  rtx op2 = lowpart_subreg (V2SFmode, operands[2], SFmode);
-  rtx tmp = gen_reg_rtx (V2SFmode);
-  emit_move_insn (mask, GEN_INT (HOST_WIDE_INT_1U << 31));
-  emit_insn (gen_aarch64_simd_bslv2sf (tmp, mask, op2, op1));
-  emit_move_insn (operands[0], lowpart_subreg (SFmode, tmp, V2SFmode));
-  DONE;
-}
+  "@
+   bsl\\t%0.<Vbtype>, %2.<Vbtype>, %1.<Vbtype>
+   bit\\t%0.<Vbtype>, %2.<Vbtype>, %3.<Vbtype>
+   bif\\t%0.<Vbtype>, %1.<Vbtype>, %3.<Vbtype>
+   bfxil\\t%<w1>0, %<w1>1, #0, <sizem1>"
+  [(set_attr "type" "neon_bsl<q>,neon_bsl<q>,neon_bsl<q>,bfm")]
 )
 
 ;; -------------------------------------------------------------------
Index: gcc/config/aarch64/aarch64-c.c
===================================================================
--- a/src/gcc/config/aarch64/aarch64-c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/aarch64/aarch64-c.c	(.../branches/gcc-7-branch)
@@ -134,6 +134,8 @@
   aarch64_def_or_undef (TARGET_CRYPTO, "__ARM_FEATURE_CRYPTO", pfile);
   aarch64_def_or_undef (TARGET_SIMD_RDMA, "__ARM_FEATURE_QRDMX", pfile);
 
+  aarch64_def_or_undef (TARGET_LSE, "__ARM_FEATURE_ATOMICS", pfile);
+
   /* Not for ACLE, but required to keep "float.h" correct if we switch
      target between implementations that do or do not support ARMv8.2-A
      16-bit floating-point extensions.  */
Index: gcc/config/rs6000/darwin7.h
===================================================================
--- a/src/gcc/config/rs6000/darwin7.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/darwin7.h	(.../branches/gcc-7-branch)
@@ -28,5 +28,10 @@
   %:version-compare(!< 10.3 mmacosx-version-min= -lmx)\
   -lSystem}"
 
+/* This generation of tools (specifically the archive tool) did not
+   export weak symbols from the TOC. */
+#undef TARGET_WEAK_NOT_IN_ARCHIVE_TOC
+#define TARGET_WEAK_NOT_IN_ARCHIVE_TOC 1
+
 #undef DEF_MIN_OSX_VERSION
 #define DEF_MIN_OSX_VERSION "10.3.9"
Index: gcc/config/rs6000/rs6000-builtin.def
===================================================================
--- a/src/gcc/config/rs6000/rs6000-builtin.def	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/rs6000-builtin.def	(.../branches/gcc-7-branch)
@@ -1000,6 +1000,7 @@
 BU_ALTIVEC_3 (VSLDOI_16QI,    "vsldoi_16qi",    CONST, 	altivec_vsldoi_v16qi)
 BU_ALTIVEC_3 (VSLDOI_8HI,     "vsldoi_8hi",     CONST, 	altivec_vsldoi_v8hi)
 BU_ALTIVEC_3 (VSLDOI_4SI,     "vsldoi_4si",     CONST, 	altivec_vsldoi_v4si)
+BU_ALTIVEC_3 (VSLDOI_2DI,     "vsldoi_2di",     CONST, 	altivec_vsldoi_v2di)
 BU_ALTIVEC_3 (VSLDOI_4SF,     "vsldoi_4sf",     CONST, 	altivec_vsldoi_v4sf)
 BU_ALTIVEC_3 (VSLDOI_2DF,     "vsldoi_2df",     CONST, 	altivec_vsldoi_v2df)
 
@@ -1988,6 +1989,9 @@
 
 BU_P9V_OVERLOAD_1 (REVB,	"revb")
 
+BU_P9V_OVERLOAD_1 (VEXTRACT_FP_FROM_SHORTH, "vextract_fp_from_shorth")
+BU_P9V_OVERLOAD_1 (VEXTRACT_FP_FROM_SHORTL, "vextract_fp_from_shortl")
+
 /* ISA 3.0 vector scalar overloaded 2 argument functions.  */
 BU_P9V_OVERLOAD_2 (VSIEDP,	"scalar_insert_exp")
 
@@ -2005,6 +2009,8 @@
 BU_P9V_VSX_1 (VEESP, "extract_exp_sp", CONST, xvxexpsp)
 BU_P9V_VSX_1 (VESDP, "extract_sig_dp", CONST, xvxsigdp)
 BU_P9V_VSX_1 (VESSP, "extract_sig_sp", CONST, xvxsigsp)
+BU_P9V_VSX_1 (VEXTRACT_FP_FROM_SHORTH, "vextract_fp_from_shorth", CONST, vextract_fp_from_shorth)
+BU_P9V_VSX_1 (VEXTRACT_FP_FROM_SHORTL, "vextract_fp_from_shortl", CONST, vextract_fp_from_shortl)
 
 /* 2 argument vsx vector functions added in ISA 3.0 (power9).  */
 BU_P9V_VSX_2 (VIEDP, "insert_exp_dp", CONST, xviexpdp)
@@ -2233,13 +2239,22 @@
 BU_FLOAT128_2 (COPYSIGNQ,	"copysignq",   CONST, copysignkf3)
 
 /* 1 argument crypto functions.  */
-BU_CRYPTO_1 (VSBOX,		"vsbox",	  CONST, crypto_vsbox)
+BU_CRYPTO_1 (VSBOX,		"vsbox",	  CONST, crypto_vsbox_v2di)
+BU_CRYPTO_1 (VSBOX_BE,		"vsbox_be",	  CONST, crypto_vsbox_v16qi)
 
 /* 2 argument crypto functions.  */
-BU_CRYPTO_2 (VCIPHER,		"vcipher",	  CONST, crypto_vcipher)
-BU_CRYPTO_2 (VCIPHERLAST,	"vcipherlast",	  CONST, crypto_vcipherlast)
-BU_CRYPTO_2 (VNCIPHER,		"vncipher",	  CONST, crypto_vncipher)
-BU_CRYPTO_2 (VNCIPHERLAST,	"vncipherlast",	  CONST, crypto_vncipherlast)
+BU_CRYPTO_2 (VCIPHER,		"vcipher",	  CONST, crypto_vcipher_v2di)
+BU_CRYPTO_2 (VCIPHER_BE,	"vcipher_be",	  CONST, crypto_vcipher_v16qi)
+BU_CRYPTO_2 (VCIPHERLAST,	"vcipherlast",
+	     CONST, crypto_vcipherlast_v2di)
+BU_CRYPTO_2 (VCIPHERLAST_BE,	"vcipherlast_be",
+	     CONST, crypto_vcipherlast_v16qi)
+BU_CRYPTO_2 (VNCIPHER,		"vncipher",	  CONST, crypto_vncipher_v2di)
+BU_CRYPTO_2 (VNCIPHER_BE,	"vncipher_be",	  CONST, crypto_vncipher_v16qi)
+BU_CRYPTO_2 (VNCIPHERLAST,	"vncipherlast",
+	     CONST, crypto_vncipherlast_v2di)
+BU_CRYPTO_2 (VNCIPHERLAST_BE,	"vncipherlast_be",
+	     CONST, crypto_vncipherlast_v16qi)
 BU_CRYPTO_2A (VPMSUMB,		"vpmsumb",	  CONST, crypto_vpmsumb)
 BU_CRYPTO_2A (VPMSUMH,		"vpmsumh",	  CONST, crypto_vpmsumh)
 BU_CRYPTO_2A (VPMSUMW,		"vpmsumw",	  CONST, crypto_vpmsumw)
Index: gcc/config/rs6000/rs6000-c.c
===================================================================
--- a/src/gcc/config/rs6000/rs6000-c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/rs6000-c.c	(.../branches/gcc-7-branch)
@@ -910,6 +910,8 @@
     RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V4SI, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_UNPACKH, ALTIVEC_BUILTIN_VUPKHPX,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_pixel_V8HI, 0, 0 },
+  { ALTIVEC_BUILTIN_VEC_UNPACKH, ALTIVEC_BUILTIN_VUPKHPX,
+    RS6000_BTI_V2DF, RS6000_BTI_V4SF, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_VUPKHSH, ALTIVEC_BUILTIN_VUPKHSH,
     RS6000_BTI_V4SI, RS6000_BTI_V8HI, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_VUPKHSH, ALTIVEC_BUILTIN_VUPKHSH,
@@ -940,6 +942,8 @@
     RS6000_BTI_V2DI, RS6000_BTI_V4SI, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_UNPACKL, P8V_BUILTIN_VUPKLSW,
     RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V4SI, 0, 0 },
+  { ALTIVEC_BUILTIN_VEC_UNPACKL, ALTIVEC_BUILTIN_VUPKLPX,
+    RS6000_BTI_V2DF, RS6000_BTI_V4SF, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_VUPKLPX, ALTIVEC_BUILTIN_VUPKLPX,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V8HI, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_VUPKLPX, ALTIVEC_BUILTIN_VUPKLPX,
@@ -1185,6 +1189,8 @@
   { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+    RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
     RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, 0 },
   { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
     RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_V4SI, 0 },
@@ -1518,12 +1524,19 @@
     RS6000_BTI_V2DF, RS6000_BTI_unsigned_V2DI, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DF,
     RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_V2DF, 0 },
+  { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DF,
+    RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_double, 0 },
   { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DI,
+    RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_long_long, 0 },
+  { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DI,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI,
     ~RS6000_BTI_unsigned_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_long_long, 0 },
+  { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DI,
     RS6000_BTI_bool_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V4SF,
     RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF, 0 },
@@ -2535,6 +2548,18 @@
     RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_unsigned_V8HI, 0 },
   { ALTIVEC_BUILTIN_VEC_SLL, ALTIVEC_BUILTIN_VSL,
     RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
+
+  { ALTIVEC_BUILTIN_VEC_SLL, ALTIVEC_BUILTIN_VSL,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SLL, ALTIVEC_BUILTIN_VSL,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SLL, ALTIVEC_BUILTIN_VSL,
+    RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SLL, ALTIVEC_BUILTIN_VSL,
+    RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SLL, ALTIVEC_BUILTIN_VSL,
+    RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V8HI, 0 },
+
   { ALTIVEC_BUILTIN_VEC_SLO, ALTIVEC_BUILTIN_VSLO,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V16QI, 0 },
   { ALTIVEC_BUILTIN_VEC_SLO, ALTIVEC_BUILTIN_VSLO,
@@ -2735,6 +2760,10 @@
     RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_unsigned_V8HI, 0 },
   { ALTIVEC_BUILTIN_VEC_SRL, ALTIVEC_BUILTIN_VSR,
     RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SRL, ALTIVEC_BUILTIN_VSR,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SRL, ALTIVEC_BUILTIN_VSR,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V16QI, 0 },
   { ALTIVEC_BUILTIN_VEC_SRO, ALTIVEC_BUILTIN_VSRO,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V16QI, 0 },
   { ALTIVEC_BUILTIN_VEC_SRO, ALTIVEC_BUILTIN_VSRO,
@@ -2767,6 +2796,15 @@
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_V16QI, 0 },
   { ALTIVEC_BUILTIN_VEC_SRO, ALTIVEC_BUILTIN_VSRO,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SRO, ALTIVEC_BUILTIN_VSRO,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SRO, ALTIVEC_BUILTIN_VSRO,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SRO, ALTIVEC_BUILTIN_VSRO,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SRO, ALTIVEC_BUILTIN_VSRO,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V16QI, 0 },
+
   { ALTIVEC_BUILTIN_VEC_SUB, ALTIVEC_BUILTIN_VSUBUBM,
     RS6000_BTI_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_V16QI, 0 },
   { ALTIVEC_BUILTIN_VEC_SUB, ALTIVEC_BUILTIN_VSUBUBM,
@@ -3438,16 +3476,36 @@
     RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_NOT_OPAQUE },
   { ALTIVEC_BUILTIN_VEC_SLD, ALTIVEC_BUILTIN_VSLDOI_2DF,
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_NOT_OPAQUE },
+  { ALTIVEC_BUILTIN_VEC_SLD, ALTIVEC_BUILTIN_VSLDOI_2DI,
+    RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_NOT_OPAQUE },
+  { ALTIVEC_BUILTIN_VEC_SLD, ALTIVEC_BUILTIN_VSLDOI_2DI,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_NOT_OPAQUE },
+  { ALTIVEC_BUILTIN_VEC_SLD, ALTIVEC_BUILTIN_VSLDOI_2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_NOT_OPAQUE },
+
   { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DF,
     RS6000_BTI_void, RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_V2DF },
+  { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DF,
+    RS6000_BTI_void, RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_double },
   { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DI,
     RS6000_BTI_void, RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_V2DI },
   { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DI,
+    RS6000_BTI_void, RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_long_long },
+  { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DI,
     RS6000_BTI_void, RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI,
     ~RS6000_BTI_unsigned_V2DI },
   { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DI,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_long_long },
+  { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DI,
     RS6000_BTI_void, RS6000_BTI_bool_V2DI, RS6000_BTI_INTSI,
     ~RS6000_BTI_bool_V2DI },
+  { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DI,
+    RS6000_BTI_void, RS6000_BTI_bool_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_long_long },
+  { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DI,
+    RS6000_BTI_void, RS6000_BTI_bool_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_long_long },
   { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V4SF,
     RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF },
   { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V4SF,
@@ -5050,6 +5108,11 @@
   { P9V_BUILTIN_VEC_EXTRACT4B, P9V_BUILTIN_EXTRACT4B,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, 0 },
 
+  { P9V_BUILTIN_VEC_VEXTRACT_FP_FROM_SHORTH, P9V_BUILTIN_VEXTRACT_FP_FROM_SHORTH,
+    RS6000_BTI_V4SF, RS6000_BTI_unsigned_V8HI, 0, 0 },
+  { P9V_BUILTIN_VEC_VEXTRACT_FP_FROM_SHORTL, P9V_BUILTIN_VEXTRACT_FP_FROM_SHORTL,
+    RS6000_BTI_V4SF, RS6000_BTI_unsigned_V8HI, 0, 0 },
+
   { P9V_BUILTIN_VEC_VEXTULX, P9V_BUILTIN_VEXTUBLX,
     RS6000_BTI_INTQI, RS6000_BTI_UINTSI,
     RS6000_BTI_V16QI, 0 },
@@ -5958,11 +6021,15 @@
 	  tree call = NULL_TREE;
 	  int nunits = GET_MODE_NUNITS (mode);
 
-	  /* If the second argument is an integer constant, if the value is in
-	     the expected range, generate the built-in code if we can.  We need
-	     64-bit and direct move to extract the small integer vectors.  */
-	  if (TREE_CODE (arg2) == INTEGER_CST && wi::ltu_p (arg2, nunits))
+	  /* If the second argument is an integer constant, generate
+	     the built-in code if we can.  We need 64-bit and direct
+	     move to extract the small integer vectors.  */
+	  if (TREE_CODE (arg2) == INTEGER_CST)
 	    {
+	      wide_int selector
+		= wi::to_wide (arg2, TYPE_PRECISION (TREE_TYPE (arg2)));
+	      selector = wi::umod_trunc (selector, nunits);
+	      arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);
 	      switch (mode)
 		{
 		default:
@@ -6037,7 +6104,13 @@
 	    }
 
 	  if (call)
-	    return build_call_expr (call, 2, arg1, arg2);
+	    {
+	      tree result = build_call_expr (call, 2, arg1, arg2);
+	      /* Coerce the result to vector element type.  May be no-op.  */
+	      arg1_inner_type = TREE_TYPE (arg1_type);
+	      result = fold_convert (arg1_inner_type, result);
+	      return result;
+	    }
 	}
 
       /* Build *(((arg1_inner_type*)&(vector type){arg1})+arg2). */
@@ -6131,11 +6204,14 @@
       /* If we can use the VSX xxpermdi instruction, use that for insert.  */
       mode = TYPE_MODE (arg1_type);
       if ((mode == V2DFmode || mode == V2DImode) && VECTOR_UNIT_VSX_P (mode)
-	  && TREE_CODE (arg2) == INTEGER_CST
-	  && wi::ltu_p (arg2, 2))
+	  && TREE_CODE (arg2) == INTEGER_CST)
 	{
+	  wide_int selector
+	    = wi::to_wide (arg2, TYPE_PRECISION (TREE_TYPE (arg2)));
+	  selector = wi::umod_trunc (selector, 2);
 	  tree call = NULL_TREE;
 
+	  arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);
 	  if (mode == V2DFmode)
 	    call = rs6000_builtin_decls[VSX_BUILTIN_VEC_SET_V2DF];
 	  else if (mode == V2DImode)
@@ -6147,11 +6223,12 @@
 	    return build_call_expr (call, 3, arg1, arg0, arg2);
 	}
       else if (mode == V1TImode && VECTOR_UNIT_VSX_P (mode)
-	       && TREE_CODE (arg2) == INTEGER_CST
-	       && wi::eq_p (arg2, 0))
+	       && TREE_CODE (arg2) == INTEGER_CST)
 	{
 	  tree call = rs6000_builtin_decls[VSX_BUILTIN_VEC_SET_V1TI];
+	  wide_int selector = wi::zero(32);
 
+	  arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);
 	  /* Note, __builtin_vec_insert_<xxx> has vector and scalar types
 	     reversed.  */
 	  return build_call_expr (call, 3, arg1, arg0, arg2);
@@ -6159,10 +6236,13 @@
 
       /* Build *(((arg1_inner_type*)&(vector type){arg1})+arg2) = arg0. */
       arg1_inner_type = TREE_TYPE (arg1_type);
-      arg2 = build_binary_op (loc, BIT_AND_EXPR, arg2,
-			      build_int_cst (TREE_TYPE (arg2),
-					     TYPE_VECTOR_SUBPARTS (arg1_type)
-					     - 1), 0);
+      if (TYPE_VECTOR_SUBPARTS (arg1_type) == 1)
+	arg2 = build_int_cst (TREE_TYPE (arg2), 0);
+      else
+	arg2 = build_binary_op (loc, BIT_AND_EXPR, arg2,
+				build_int_cst (TREE_TYPE (arg2),
+					       TYPE_VECTOR_SUBPARTS (arg1_type)
+					       - 1), 0);
       decl = build_decl (loc, VAR_DECL, NULL_TREE, arg1_type);
       DECL_EXTERNAL (decl) = 0;
       TREE_PUBLIC (decl) = 0;
Index: gcc/config/rs6000/rs6000.c
===================================================================
--- a/src/gcc/config/rs6000/rs6000.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/rs6000.c	(.../branches/gcc-7-branch)
@@ -4829,6 +4829,13 @@
       else
 	rs6000_long_double_type_size = RS6000_DEFAULT_LONG_DOUBLE_SIZE;
     }
+  else if (global_options_set.x_rs6000_ieeequad)
+    {
+      if (global_options.x_rs6000_ieeequad)
+	error ("%qs requires %qs", "-mabi=ieeelongdouble", "-mlong-double-128");
+      else
+	error ("%qs requires %qs", "-mabi=ibmlongdouble", "-mlong-double-128");
+    }
 
   /* Set -mabi=ieeelongdouble on some old targets.  Note, AIX and Darwin
      explicitly redefine TARGET_IEEEQUAD to 0, so those systems will not
@@ -4838,6 +4845,11 @@
     rs6000_ieeequad = 1;
 #endif
 
+  if (global_options_set.x_rs6000_ieeequad
+      && global_options.x_rs6000_ieeequad
+      && (!TARGET_POPCNTD || !TARGET_VSX))
+    error ("%qs requires full ISA 2.06 support", "-mabi=ieeelongdouble");
+
   /* Enable the default support for IEEE 128-bit floating point on Linux VSX
      sytems, but don't enable the __float128 keyword.  */
   if (TARGET_VSX && TARGET_LONG_DOUBLE_128
@@ -7643,7 +7655,6 @@
 	default:
 	  break;
 	case V1TImode:
-	  gcc_assert (INTVAL (elt) == 0 && inner_mode == TImode);
 	  emit_move_insn (target, gen_lowpart (TImode, vec));
 	  break;
 	case V2DFmode:
@@ -7694,6 +7705,10 @@
 
       switch (mode)
 	{
+	case V1TImode:
+	  emit_move_insn (target, gen_lowpart (TImode, vec));
+	  return;
+
 	case V2DFmode:
 	  emit_insn (gen_vsx_extract_v2df_var (target, vec, elt));
 	  return;
@@ -7723,18 +7738,32 @@
 	}
     }
 
-  gcc_assert (CONST_INT_P (elt));
-
   /* Allocate mode-sized buffer.  */
   mem = assign_stack_temp (mode, GET_MODE_SIZE (mode));
 
   emit_move_insn (mem, vec);
+  if (CONST_INT_P (elt))
+    {
+      int modulo_elt = INTVAL (elt) % GET_MODE_NUNITS (mode);
 
-  /* Add offset to field within buffer matching vector element.  */
-  mem = adjust_address_nv (mem, inner_mode,
-			   INTVAL (elt) * GET_MODE_SIZE (inner_mode));
+      /* Add offset to field within buffer matching vector element.  */
+      mem = adjust_address_nv (mem, inner_mode,
+			       modulo_elt * GET_MODE_SIZE (inner_mode));
+      emit_move_insn (target, adjust_address_nv (mem, inner_mode, 0));
+    }
+  else
+    {
+      unsigned int ele_size = GET_MODE_SIZE (inner_mode);
+      rtx num_ele_m1 = GEN_INT (GET_MODE_NUNITS (mode) - 1);
+      rtx new_addr = gen_reg_rtx (Pmode);
 
-  emit_move_insn (target, adjust_address_nv (mem, inner_mode, 0));
+      elt = gen_rtx_AND (Pmode, elt, num_ele_m1);
+      if (ele_size > 1)
+	elt = gen_rtx_MULT (Pmode, elt, GEN_INT (ele_size));
+      new_addr = gen_rtx_PLUS (Pmode, XEXP (mem, 0), elt);
+      new_addr = change_address (mem, inner_mode, new_addr);
+      emit_move_insn (target, new_addr);
+    }
 }
 
 /* Helper function to return the register number of a RTX.  */
@@ -7915,7 +7944,7 @@
 			      rtx tmp_altivec)
 {
   machine_mode mode = GET_MODE (src);
-  machine_mode scalar_mode = GET_MODE (dest);
+  machine_mode scalar_mode = GET_MODE_INNER (GET_MODE (src));
   unsigned scalar_size = GET_MODE_SIZE (scalar_mode);
   int byte_shift = exact_log2 (scalar_size);
 
@@ -7926,6 +7955,10 @@
      systems.  */
   if (MEM_P (src))
     {
+      int num_elements = GET_MODE_NUNITS (mode);
+      rtx num_ele_m1 = GEN_INT (num_elements - 1);
+
+      emit_insn (gen_anddi3 (element, element, num_ele_m1));
       gcc_assert (REG_P (tmp_gpr));
       emit_move_insn (dest, rs6000_adjust_vec_address (dest, src, element,
 						       tmp_gpr, scalar_mode));
@@ -7934,7 +7967,9 @@
 
   else if (REG_P (src) || SUBREG_P (src))
     {
-      int bit_shift = byte_shift + 3;
+      int num_elements = GET_MODE_NUNITS (mode);
+      int bits_in_element = GET_MODE_BITSIZE (GET_MODE_INNER (mode));
+      int bit_shift = 7 - exact_log2 (num_elements);
       rtx element2;
       int dest_regno = regno_or_subregno (dest);
       int src_regno = regno_or_subregno (src);
@@ -8010,7 +8045,7 @@
 	{
 	  if (!VECTOR_ELT_ORDER_BIG)
 	    {
-	      rtx num_ele_m1 = GEN_INT (GET_MODE_NUNITS (mode) - 1);
+	      rtx num_ele_m1 = GEN_INT (num_elements - 1);
 
 	      emit_insn (gen_anddi3 (tmp_gpr, element, num_ele_m1));
 	      emit_insn (gen_subdi3 (tmp_gpr, num_ele_m1, tmp_gpr));
@@ -8068,8 +8103,8 @@
 	    emit_insn (gen_vsx_vslo_v2di (tmp_altivec_di, src_v2di,
 					  tmp_altivec));
 	    emit_move_insn (tmp_gpr_di, tmp_altivec_di);
-	    emit_insn (gen_ashrdi3 (tmp_gpr_di, tmp_gpr_di,
-				    GEN_INT (64 - (8 * scalar_size))));
+	    emit_insn (gen_lshrdi3 (tmp_gpr_di, tmp_gpr_di,
+				    GEN_INT (64 - bits_in_element)));
 	    return;
 	  }
 
@@ -13109,7 +13144,9 @@
       if (elt_mode == TDmode && (cum->fregno % 2) == 1)
 	cum->fregno++;
 
-      if (USE_FP_FOR_ARG_P (cum, elt_mode))
+      if (USE_FP_FOR_ARG_P (cum, elt_mode)
+	  && !(TARGET_AIX && !TARGET_ELF
+	       && type != NULL && AGGREGATE_TYPE_P (type)))
 	{
 	  rtx rvec[GP_ARG_NUM_REG + AGGR_ARG_NUM_REG + 1];
 	  rtx r, off;
@@ -13245,7 +13282,9 @@
 
   align_words = rs6000_parm_start (mode, type, cum->words);
 
-  if (USE_FP_FOR_ARG_P (cum, elt_mode))
+  if (USE_FP_FOR_ARG_P (cum, elt_mode)
+      && !(TARGET_AIX && !TARGET_ELF
+	   && type != NULL && AGGREGATE_TYPE_P (type)))
     {
       unsigned long n_fpreg = (GET_MODE_SIZE (elt_mode) + 7) >> 3;
 
@@ -16146,9 +16185,17 @@
   op0 = expand_normal (arg0);
   op1 = expand_normal (arg1);
 
-  /* Call get_element_number to validate arg1 if it is a constant.  */
   if (TREE_CODE (arg1) == INTEGER_CST)
-    (void) get_element_number (TREE_TYPE (arg0), arg1);
+    {
+      unsigned HOST_WIDE_INT elt;
+      unsigned HOST_WIDE_INT size = TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0));
+      unsigned int truncated_selector;
+      /* Even if !tree_fits_uhwi_p (arg1)), TREE_INT_CST_LOW (arg0)
+	 returns low-order bits of INTEGER_CST for modulo indexing.  */
+      elt = TREE_INT_CST_LOW (arg1);
+      truncated_selector = elt % size;
+      op1 = GEN_INT (truncated_selector);
+    }
 
   tmode = TYPE_MODE (TREE_TYPE (TREE_TYPE (arg0)));
   mode0 = TYPE_MODE (TREE_TYPE (arg0));
@@ -18806,6 +18853,7 @@
     {
       /* unsigned 1 argument functions.  */
     case CRYPTO_BUILTIN_VSBOX:
+    case CRYPTO_BUILTIN_VSBOX_BE:
     case P8V_BUILTIN_VGBBD:
     case MISC_BUILTIN_CDTBCD:
     case MISC_BUILTIN_CBCDTD:
@@ -18819,9 +18867,13 @@
     case ALTIVEC_BUILTIN_VMULOUB:
     case ALTIVEC_BUILTIN_VMULOUH:
     case CRYPTO_BUILTIN_VCIPHER:
+    case CRYPTO_BUILTIN_VCIPHER_BE:
     case CRYPTO_BUILTIN_VCIPHERLAST:
+    case CRYPTO_BUILTIN_VCIPHERLAST_BE:
     case CRYPTO_BUILTIN_VNCIPHER:
+    case CRYPTO_BUILTIN_VNCIPHER_BE:
     case CRYPTO_BUILTIN_VNCIPHERLAST:
+    case CRYPTO_BUILTIN_VNCIPHERLAST_BE:
     case CRYPTO_BUILTIN_VPMSUMB:
     case CRYPTO_BUILTIN_VPMSUMH:
     case CRYPTO_BUILTIN_VPMSUMW:
@@ -26714,27 +26766,35 @@
 static bool
 rs6000_reg_live_or_pic_offset_p (int reg)
 {
-  /* We need to mark the PIC offset register live for the same conditions
-     as it is set up, or otherwise it won't be saved before we clobber it.  */
-
   if (reg == RS6000_PIC_OFFSET_TABLE_REGNUM && !TARGET_SINGLE_PIC_BASE)
     {
+      /* When calling eh_return, we must return true for all the cases
+	 where conditional_register_usage marks the PIC offset reg
+	 call used or fixed.  */
+      if (crtl->calls_eh_return
+	  && ((DEFAULT_ABI == ABI_V4 && flag_pic)
+	      || (DEFAULT_ABI == ABI_DARWIN && flag_pic)
+	      || (TARGET_TOC && TARGET_MINIMAL_TOC)))
+	return true;
+
+      /* We need to mark the PIC offset register live for the same
+	 conditions as it is set up in rs6000_emit_prologue, or
+	 otherwise it won't be saved before we clobber it.  */
       if (TARGET_TOC && TARGET_MINIMAL_TOC
-	  && (crtl->calls_eh_return
-	      || df_regs_ever_live_p (reg)
-	      || !constant_pool_empty_p ()))
+	  && !constant_pool_empty_p ())
 	return true;
 
-      if ((DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_DARWIN)
-	  && flag_pic)
+      if (DEFAULT_ABI == ABI_V4
+	  && (flag_pic == 1 || (flag_pic && TARGET_SECURE_PLT))
+	  && df_regs_ever_live_p (RS6000_PIC_OFFSET_TABLE_REGNUM))
 	return true;
+
+      if (DEFAULT_ABI == ABI_DARWIN
+	  && flag_pic && crtl->uses_pic_offset_table)
+	return true;
     }
 
-  /* If the function calls eh_return, claim used all the registers that would
-     be checked for liveness otherwise.  */
-
-  return ((crtl->calls_eh_return || df_regs_ever_live_p (reg))
-	  && !call_used_regs[reg]);
+  return !call_used_regs[reg] && df_regs_ever_live_p (reg);
 }
 
 /* Return the first fixed-point register that is required to be
@@ -36409,6 +36469,10 @@
 			   rs6000_xcoff_output_readwrite_section_asm_op,
 			   &xcoff_private_data_section_name);
 
+  read_only_private_data_section
+    = get_unnamed_section (0, rs6000_xcoff_output_readonly_section_asm_op,
+			   &xcoff_private_rodata_section_name);
+
   tls_data_section
     = get_unnamed_section (SECTION_TLS,
 			   rs6000_xcoff_output_tls_section_asm_op,
@@ -36419,10 +36483,6 @@
 			   rs6000_xcoff_output_tls_section_asm_op,
 			   &xcoff_private_data_section_name);
 
-  read_only_private_data_section
-    = get_unnamed_section (0, rs6000_xcoff_output_readonly_section_asm_op,
-			   &xcoff_private_data_section_name);
-
   toc_section
     = get_unnamed_section (0, rs6000_xcoff_output_toc_section_asm_op, NULL);
 
@@ -36603,6 +36663,8 @@
 			   main_input_filename, ".bss_");
   rs6000_gen_section_name (&xcoff_private_data_section_name,
 			   main_input_filename, ".rw_");
+  rs6000_gen_section_name (&xcoff_private_rodata_section_name,
+			   main_input_filename, ".rop_");
   rs6000_gen_section_name (&xcoff_read_only_section_name,
 			   main_input_filename, ".ro_");
   rs6000_gen_section_name (&xcoff_tls_data_section_name,
@@ -43013,6 +43075,14 @@
   /* Pre-pass to recombine lvx and stvx patterns so we don't lose info.  */
   recombine_lvx_stvx_patterns (fun);
 
+  /* Rebuild ud- and du-chains.  */                                            
+  df_remove_problem (df_chain);
+  df_process_deferred_rescans ();
+  df_set_flags (DF_RD_PRUNE_DEAD_DEFS);
+  df_chain_add_problem (DF_DU_CHAIN | DF_UD_CHAIN);
+  df_analyze ();
+  df_set_flags (DF_DEFER_INSN_RESCAN);
+
   /* Allocate structure to represent webs of insns.  */
   insn_entry = XCNEWVEC (swap_web_entry, get_max_uid ());
 
Index: gcc/config/rs6000/vsx.md
===================================================================
--- a/src/gcc/config/rs6000/vsx.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/vsx.md	(.../branches/gcc-7-branch)
@@ -339,6 +339,7 @@
    UNSPEC_VSX_CVDPSXWS
    UNSPEC_VSX_CVDPUXWS
    UNSPEC_VSX_CVSPDP
+   UNSPEC_VSX_CVHPSP
    UNSPEC_VSX_CVSPDPN
    UNSPEC_VSX_CVDPSPN
    UNSPEC_VSX_CVSXWDP
@@ -353,6 +354,8 @@
    UNSPEC_VSX_ROUND_I
    UNSPEC_VSX_ROUND_IC
    UNSPEC_VSX_SLDWI
+   UNSPEC_VSX_XXPERM
+
    UNSPEC_VSX_XXSPLTW
    UNSPEC_VSX_XXSPLTD
    UNSPEC_VSX_DIVSD
@@ -370,6 +373,8 @@
    UNSPEC_VSX_SIEXPDP
    UNSPEC_VSX_SCMPEXPDP
    UNSPEC_VSX_STSTDC
+   UNSPEC_VSX_VEXTRACT_FP_FROM_SHORTH
+   UNSPEC_VSX_VEXTRACT_FP_FROM_SHORTL
    UNSPEC_VSX_VXEXP
    UNSPEC_VSX_VXSIG
    UNSPEC_VSX_VIEXP
@@ -1779,6 +1784,15 @@
   "xscvspdp %x0,%x1"
   [(set_attr "type" "fp")])
 
+;; Generate xvcvhpsp instruction
+(define_insn "vsx_xvcvhpsp"
+  [(set (match_operand:V4SF 0 "vsx_register_operand" "=wa")
+	(unspec:V4SF [(match_operand: V16QI 1 "vsx_register_operand" "wa")]
+		     UNSPEC_VSX_CVHPSP))]
+  "TARGET_P9_VECTOR"
+  "xvcvhpsp %x0,%x1"
+  [(set_attr "type" "vecfloat")])
+
 ;; xscvdpsp used for splat'ing a scalar to V4SF, knowing that the internal SF
 ;; format of scalars is actually DF.
 (define_insn "vsx_xscvdpsp_scalar"
@@ -2438,7 +2452,7 @@
 	 (match_operand:VSX_D 1 "memory_operand" "m,m")
 	 (parallel [(match_operand:QI 2 "const_0_to_1_operand" "n,n")])))
    (clobber (match_scratch:P 3 "=&b,&b"))]
-  "VECTOR_MEM_VSX_P (<VSX_D:MODE>mode)"
+  "TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<VSX_D:MODE>mode)"
   "#"
   "&& reload_completed"
   [(set (match_dup 0) (match_dup 4))]
@@ -2947,9 +2961,9 @@
   DONE;
 })
 
-(define_insn_and_split "*vsx_extract_<VSX_EXTRACT_I:mode>_<SDI:mode>_var"
-  [(set (match_operand:SDI 0 "gpc_reg_operand" "=r,r,r")
-	(zero_extend:SDI
+(define_insn_and_split "*vsx_extract_<mode>_<VS_scalar>mode_var"
+  [(set (match_operand:<VS_scalar> 0 "gpc_reg_operand" "=r,r,r")
+	(zero_extend:<VS_scalar>
 	 (unspec:<VSX_EXTRACT_I:VS_scalar>
 	  [(match_operand:VSX_EXTRACT_I 1 "input_operand" "wK,v,m")
 	   (match_operand:DI 2 "gpc_reg_operand" "r,r,r")]
@@ -2961,7 +2975,7 @@
   "&& reload_completed"
   [(const_int 0)]
 {
-  machine_mode smode = <VSX_EXTRACT_I:MODE>mode;
+  machine_mode smode = <VS_scalar>mode;
   rs6000_split_vec_extract_var (gen_rtx_REG (smode, REGNO (operands[0])),
 				operands[1], operands[2],
 				operands[3], operands[4]);
@@ -3585,7 +3599,7 @@
 	  (match_dup 1))
 	 (parallel [(const_int 1)])))
    (clobber (match_scratch:DF 2 "=0,0,&wd,&wa"))]
-  "VECTOR_UNIT_VSX_P (V2DFmode)"
+  "BYTES_BIG_ENDIAN && VECTOR_UNIT_VSX_P (V2DFmode)"
   "#"
   ""
   [(const_int 0)]
@@ -3613,7 +3627,7 @@
    (clobber (match_scratch:V4SF 2 "=&wf,&wa"))
    (clobber (match_scratch:V4SF 3 "=&wf,&wa"))
    (clobber (match_scratch:V4SF 4 "=0,0"))]
-  "VECTOR_UNIT_VSX_P (V4SFmode)"
+  "BYTES_BIG_ENDIAN && VECTOR_UNIT_VSX_P (V4SFmode)"
   "#"
   ""
   [(const_int 0)]
@@ -4180,7 +4194,65 @@
 }
   [(set_attr "type" "vecperm")])
 
-
+;; Generate vector extract four float 32 values from left four elements
+;; of eight element vector of float 16 values.
+(define_expand "vextract_fp_from_shorth"
+  [(set (match_operand:V4SF 0 "register_operand" "=wa")
+	(unspec:V4SF [(match_operand:V8HI 1 "register_operand" "wa")]
+   UNSPEC_VSX_VEXTRACT_FP_FROM_SHORTH))]
+  "TARGET_P9_VECTOR"
+{
+  int vals[16] = {15, 14, 0, 0, 13, 12, 0, 0, 11, 10, 0, 0, 9, 8, 0, 0};
+  int i;
+
+  rtx rvals[16];
+  rtx mask = gen_reg_rtx (V16QImode);
+  rtx tmp = gen_reg_rtx (V16QImode);
+  rtvec v;
+
+  for (i = 0; i < 16; i++)
+    rvals[i] = GEN_INT (vals[i]);
+
+  /* xvcvhpsp - vector convert F16 to vector F32 requires the four F16
+     inputs in half words 1,3,5,7 (IBM numbering).  Use xxperm to move
+     src half words 0,1,2,3 for the conversion instruction.  */
+  v = gen_rtvec_v (16, rvals);
+  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));
+  emit_insn (gen_altivec_vperm_v8hiv16qi (tmp, operands[1],
+					  operands[1], mask));
+  emit_insn (gen_vsx_xvcvhpsp (operands[0], tmp));
+  DONE;
+})
+
+;; Generate vector extract four float 32 values from right four elements
+;; of eight element vector of float 16 values.
+(define_expand "vextract_fp_from_shortl"
+  [(set (match_operand:V4SF 0 "register_operand" "=wa")
+	(unspec:V4SF [(match_operand:V8HI 1 "register_operand" "wa")]
+	UNSPEC_VSX_VEXTRACT_FP_FROM_SHORTL))]
+  "TARGET_P9_VECTOR"
+{
+  int vals[16] = {7, 6, 0, 0, 5, 4, 0, 0, 3, 2, 0, 0, 1, 0, 0, 0};
+  int i;
+  rtx rvals[16];
+  rtx mask = gen_reg_rtx (V16QImode);
+  rtx tmp = gen_reg_rtx (V16QImode);
+  rtvec v;
+
+  for (i = 0; i < 16; i++)
+    rvals[i] = GEN_INT (vals[i]);
+
+  /* xvcvhpsp - vector convert F16 to vector F32 requires the four F16
+     inputs in half words 1,3,5,7 (IBM numbering).  Use xxperm to move
+     src half words 4,5,6,7 for the conversion instruction.  */
+  v = gen_rtvec_v (16, rvals);
+  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));
+  emit_insn (gen_altivec_vperm_v8hiv16qi (tmp, operands[1],
+					  operands[1], mask));
+  emit_insn (gen_vsx_xvcvhpsp (operands[0], tmp));
+  DONE;
+})
+
 ;; Support for ISA 3.0 vector byte reverse
 
 ;; Swap all bytes with in a vector
Index: gcc/config/rs6000/crypto.md
===================================================================
--- a/src/gcc/config/rs6000/crypto.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/crypto.md	(.../branches/gcc-7-branch)
@@ -48,6 +48,9 @@
 ;; Iterator for VSHASIGMAD/VSHASIGMAW
 (define_mode_iterator CR_hash [V4SI V2DI])
 
+;; Iterator for VSBOX/VCIPHER/VNCIPHER/VCIPHERLAST/VNCIPHERLAST
+(define_mode_iterator CR_vqdi [V16QI V2DI])
+
 ;; Iterator for the other crypto functions
 (define_int_iterator CR_code   [UNSPEC_VCIPHER
 				UNSPEC_VNCIPHER
@@ -60,10 +63,10 @@
 			  (UNSPEC_VNCIPHERLAST "vncipherlast")])
 
 ;; 2 operand crypto instructions
-(define_insn "crypto_<CR_insn>"
-  [(set (match_operand:V2DI 0 "register_operand" "=v")
-	(unspec:V2DI [(match_operand:V2DI 1 "register_operand" "v")
-		      (match_operand:V2DI 2 "register_operand" "v")]
+(define_insn "crypto_<CR_insn>_<mode>"
+  [(set (match_operand:CR_vqdi 0 "register_operand" "=v")
+	(unspec:CR_vqdi [(match_operand:CR_vqdi 1 "register_operand" "v")
+		      (match_operand:CR_vqdi 2 "register_operand" "v")]
 		     CR_code))]
   "TARGET_CRYPTO"
   "<CR_insn> %0,%1,%2"
@@ -90,9 +93,9 @@
   [(set_attr "type" "vecperm")])
 
 ;; 1 operand crypto instruction
-(define_insn "crypto_vsbox"
-  [(set (match_operand:V2DI 0 "register_operand" "=v")
-	(unspec:V2DI [(match_operand:V2DI 1 "register_operand" "v")]
+(define_insn "crypto_vsbox_<mode>"
+  [(set (match_operand:CR_vqdi 0 "register_operand" "=v")
+	(unspec:CR_vqdi [(match_operand:CR_vqdi 1 "register_operand" "v")]
 		     UNSPEC_VSBOX))]
   "TARGET_CRYPTO"
   "vsbox %0,%1"
Index: gcc/config/rs6000/rs6000.md
===================================================================
--- a/src/gcc/config/rs6000/rs6000.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/rs6000.md	(.../branches/gcc-7-branch)
@@ -8564,16 +8564,16 @@
 
 (define_insn "*movdi_internal32"
   [(set (match_operand:DI 0 "rs6000_nonimmediate_operand"
-         "=Y,        r,         r,         ^m,        ^d,         ^d,
-          r,         ^wY,       $Z,        ^wb,       $wv,        ^wi,
+         "=Y,        r,         r,         m,         ^d,         ^d,
+          r,         wY,        Z,         ^wb,       $wv,        ^wi,
           *wo,       *wo,       *wv,       *wi,       *wi,        *wv,
           *wv")
 
 	(match_operand:DI 1 "input_operand"
-          "r,        Y,         r,         d,         m,          d,
-           IJKnGHF,  wb,        wv,        wY,        Z,          wi,
-           Oj,       wM,        OjwM,      Oj,        wM,         wS,
-           wB"))]
+         "r,         Y,         r,         ^d,        m,          ^d,
+          IJKnGHF,   ^wb,       $wv,       wY,        Z,          ^wi,
+          Oj,        wM,        OjwM,      Oj,        wM,         wS,
+          wB"))]
 
   "! TARGET_POWERPC64
    && (gpc_reg_operand (operands[0], DImode)
@@ -8641,17 +8641,17 @@
 (define_insn "*movdi_internal64"
   [(set (match_operand:DI 0 "nonimmediate_operand"
                "=YZ,       r,         r,         r,         r,          r,
-                ^m,        ^d,        ^d,        ^wY,       $Z,         $wb,
+                m,         ^d,        ^d,        wY,        Z,          $wb,
                 $wv,       ^wi,       *wo,       *wo,       *wv,        *wi,
                 *wi,       *wv,       *wv,       r,         *h,         *h,
                 ?*r,       ?*wg,      ?*r,       ?*wj")
 
 	(match_operand:DI 1 "input_operand"
-                "r,        YZ,        r,         I,         L,          nF,
-                 d,        m,         d,         wb,        wv,         wY,
-                 Z,        wi,        Oj,        wM,        OjwM,       Oj,
-                 wM,       wS,        wB,        *h,        r,          0,
-                 wg,       r,         wj,        r"))]
+               "r,         YZ,        r,         I,         L,          nF,
+                ^d,        m,         ^d,        ^wb,       $wv,        wY,
+                Z,         ^wi,       Oj,        wM,        OjwM,       Oj,
+                wM,        wS,        wB,        *h,        r,          0,
+                wg,        r,         wj,        r"))]
 
   "TARGET_POWERPC64
    && (gpc_reg_operand (operands[0], DImode)
Index: gcc/config/rs6000/altivec.h
===================================================================
--- a/src/gcc/config/rs6000/altivec.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/altivec.h	(.../branches/gcc-7-branch)
@@ -388,6 +388,11 @@
 #define vec_vsubuqm __builtin_vec_vsubuqm
 #define vec_vupkhsw __builtin_vec_vupkhsw
 #define vec_vupklsw __builtin_vec_vupklsw
+#define vec_sbox_be __builtin_crypto_vsbox_be
+#define vec_cipher_be __builtin_crypto_vcipher_be
+#define vec_cipherlast_be __builtin_crypto_vcipherlast_be
+#define vec_ncipher_be __builtin_crypto_vncipher_be
+#define vec_ncipherlast_be __builtin_crypto_vncipherlast_be
 #endif
 
 #ifdef __POWER9_VECTOR__
@@ -421,6 +426,11 @@
 #define vec_insert_exp __builtin_vec_insert_exp
 #define vec_test_data_class __builtin_vec_test_data_class
 
+#define vec_extract_fp_from_shorth __builtin_vec_vextract_fp_from_shorth
+#define vec_extract_fp_from_shortl __builtin_vec_vextract_fp_from_shortl
+#define vec_extract_fp32_from_shorth __builtin_vec_vextract_fp_from_shorth
+#define vec_extract_fp32_from_shortl __builtin_vec_vextract_fp_from_shortl
+
 #define scalar_extract_exp __builtin_vec_scalar_extract_exp
 #define scalar_extract_sig __builtin_vec_scalar_extract_sig
 #define scalar_insert_exp __builtin_vec_scalar_insert_exp
Index: gcc/config/darwin.h
===================================================================
--- a/src/gcc/config/darwin.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/darwin.h	(.../branches/gcc-7-branch)
@@ -434,21 +434,30 @@
 
 #define DWARF2_DEBUGGING_INFO 1
 
-#define DEBUG_FRAME_SECTION	"__DWARF,__debug_frame,regular,debug"
-#define DEBUG_INFO_SECTION	"__DWARF,__debug_info,regular,debug"
-#define DEBUG_ABBREV_SECTION	"__DWARF,__debug_abbrev,regular,debug"
-#define DEBUG_ARANGES_SECTION	"__DWARF,__debug_aranges,regular,debug"
-#define DEBUG_MACINFO_SECTION	"__DWARF,__debug_macinfo,regular,debug"
-#define DEBUG_LINE_SECTION	"__DWARF,__debug_line,regular,debug"
-#define DEBUG_LOC_SECTION	"__DWARF,__debug_loc,regular,debug"
-#define DEBUG_PUBNAMES_SECTION	"__DWARF,__debug_pubnames,regular,debug"
-#define DEBUG_PUBTYPES_SECTION	"__DWARF,__debug_pubtypes,regular,debug"
-#define DEBUG_STR_SECTION	"__DWARF,__debug_str,regular,debug"
-#define DEBUG_RANGES_SECTION	"__DWARF,__debug_ranges,regular,debug"
-#define DEBUG_MACRO_SECTION    "__DWARF,__debug_macro,regular,debug"
+#define DEBUG_FRAME_SECTION	  "__DWARF,__debug_frame,regular,debug"
+#define DEBUG_INFO_SECTION	  "__DWARF,__debug_info,regular,debug"
+#define DEBUG_ABBREV_SECTION	  "__DWARF,__debug_abbrev,regular,debug"
+#define DEBUG_ARANGES_SECTION	  "__DWARF,__debug_aranges,regular,debug"
+#define DEBUG_MACINFO_SECTION	  "__DWARF,__debug_macinfo,regular,debug"
+#define DEBUG_LINE_SECTION	  "__DWARF,__debug_line,regular,debug"
+#define DEBUG_LOC_SECTION	  "__DWARF,__debug_loc,regular,debug"
+#define DEBUG_LOCLISTS_SECTION    "__DWARF,__debug_loclists,regular,debug"
 
+#define DEBUG_STR_SECTION	  "__DWARF,__debug_str,regular,debug"
+#define DEBUG_STR_OFFSETS_SECTION "__DWARF,__debug_str_offs,regular,debug"
+#define DEBUG_RANGES_SECTION	  "__DWARF,__debug_ranges,regular,debug"
+#define DEBUG_RNGLISTS_SECTION    "__DWARF,__debug_rnglists,regular,debug"
+#define DEBUG_MACRO_SECTION       "__DWARF,__debug_macro,regular,debug"
+
 #define TARGET_WANT_DEBUG_PUB_SECTIONS true
+#define DEBUG_PUBNAMES_SECTION   ((debug_generate_pub_sections == 2) \
+                               ? "__DWARF,__debug_gnu_pubn,regular,debug" \
+                               : "__DWARF,__debug_pubnames,regular,debug")
 
+#define DEBUG_PUBTYPES_SECTION   ((debug_generate_pub_sections == 2) \
+                               ? "__DWARF,__debug_gnu_pubt,regular,debug" \
+                               : "__DWARF,__debug_pubtypes,regular,debug")
+
 /* When generating stabs debugging, use N_BINCL entries.  */
 
 #define DBX_USE_BINCL
@@ -495,11 +504,6 @@
    links to, so there's no need for weak-ness for that.  */
 #define GTHREAD_USE_WEAK 0
 
-/* The Darwin linker doesn't want coalesced symbols to appear in
-   a static archive's table of contents. */
-#undef TARGET_WEAK_NOT_IN_ARCHIVE_TOC
-#define TARGET_WEAK_NOT_IN_ARCHIVE_TOC 1
-
 /* On Darwin, we don't (at the time of writing) have linkonce sections
    with names, so it's safe to make the class data not comdat.  */
 #define TARGET_CXX_CLASS_DATA_ALWAYS_COMDAT hook_bool_void_false
Index: gcc/config/arm/arm.c
===================================================================
--- a/src/gcc/config/arm/arm.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/arm/arm.c	(.../branches/gcc-7-branch)
@@ -3001,7 +3001,8 @@
 
   /* Thumb2 inline assembly code should always use unified syntax.
      This will apply to ARM and Thumb1 eventually.  */
-  opts->x_inline_asm_unified = TARGET_THUMB2_P (opts->x_target_flags);
+  if (TARGET_THUMB2_P (opts->x_target_flags))
+    opts->x_inline_asm_unified = true;
 
 #ifdef SUBTARGET_OVERRIDE_INTERNAL_OPTIONS
   SUBTARGET_OVERRIDE_INTERNAL_OPTIONS;
@@ -8711,11 +8712,16 @@
 arm_cannot_force_const_mem (machine_mode mode ATTRIBUTE_UNUSED, rtx x)
 {
   rtx base, offset;
+  split_const (x, &base, &offset);
 
-  if (ARM_OFFSETS_MUST_BE_WITHIN_SECTIONS_P)
+  if (SYMBOL_REF_P (base))
     {
-      split_const (x, &base, &offset);
-      if (GET_CODE (base) == SYMBOL_REF
+      /* Function symbols cannot have an offset due to the Thumb bit.  */
+      if ((SYMBOL_REF_FLAGS (base) & SYMBOL_FLAG_FUNCTION)
+	  && INTVAL (offset) != 0)
+	return true;
+
+      if (ARM_OFFSETS_MUST_BE_WITHIN_SECTIONS_P
 	  && !offset_within_block_p (base, INTVAL (offset)))
 	return true;
     }
@@ -11695,8 +11701,7 @@
   else
     {
       n_elts = 1;
-      if (mode == VOIDmode)
-	mode = DImode;
+      gcc_assert (mode != VOIDmode);
     }
 
   innersize = GET_MODE_UNIT_SIZE (mode);
Index: gcc/config/arm/arm.h
===================================================================
--- a/src/gcc/config/arm/arm.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/arm/arm.h	(.../branches/gcc-7-branch)
@@ -186,7 +186,7 @@
 /* FPU supports converting between HFmode and DFmode in a single hardware
    step.  */
 #define TARGET_FP16_TO_DOUBLE						\
-  (TARGET_HARD_FLOAT && (TARGET_FP16 && TARGET_VFP5))
+  (TARGET_HARD_FLOAT && TARGET_FP16 && TARGET_VFP5 && TARGET_VFP_DOUBLE)
 
 /* FPU supports fused-multiply-add operations.  */
 #define TARGET_FMA (bitmap_bit_p (arm_active_target.isa, isa_bit_VFPv4))
Index: gcc/config/arm/neon.md
===================================================================
--- a/src/gcc/config/arm/neon.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/arm/neon.md	(.../branches/gcc-7-branch)
@@ -25,14 +25,14 @@
 
 (define_insn "*neon_mov<mode>"
   [(set (match_operand:VDX 0 "nonimmediate_operand"
-	  "=w,Un,w, w,  ?r,?w,?r,?r, ?Us")
+	  "=w,Un,w, w, w,  ?r,?w,?r,?r, ?Us")
 	(match_operand:VDX 1 "general_operand"
-	  " w,w, Dn,Uni, w, r, r, Usi,r"))]
+	  " w,w, Dm,Dn,Uni, w, r, r, Usi,r"))]
   "TARGET_NEON
    && (register_operand (operands[0], <MODE>mode)
        || register_operand (operands[1], <MODE>mode))"
 {
-  if (which_alternative == 2)
+  if (which_alternative == 2 || which_alternative == 3)
     {
       int width, is_valid;
       static char templ[40];
@@ -53,31 +53,32 @@
   switch (which_alternative)
     {
     case 0: return "vmov\t%P0, %P1  @ <mode>";
-    case 1: case 3: return output_move_neon (operands);
-    case 2: gcc_unreachable ();
-    case 4: return "vmov\t%Q0, %R0, %P1  @ <mode>";
-    case 5: return "vmov\t%P0, %Q1, %R1  @ <mode>";
+    case 1: case 4: return output_move_neon (operands);
+    case 2: case 3: gcc_unreachable ();
+    case 5: return "vmov\t%Q0, %R0, %P1  @ <mode>";
+    case 6: return "vmov\t%P0, %Q1, %R1  @ <mode>";
     default: return output_move_double (operands, true, NULL);
     }
 }
  [(set_attr "type" "neon_move<q>,neon_store1_1reg,neon_move<q>,\
-                    neon_load1_1reg, neon_to_gp<q>,neon_from_gp<q>,mov_reg,\
-                    neon_load1_2reg, neon_store1_2reg")
-  (set_attr "length" "4,4,4,4,4,4,8,8,8")
-  (set_attr "arm_pool_range"     "*,*,*,1020,*,*,*,1020,*")
-  (set_attr "thumb2_pool_range"     "*,*,*,1018,*,*,*,1018,*")
-  (set_attr "neg_pool_range" "*,*,*,1004,*,*,*,1004,*")])
+                    neon_move<q>,neon_load1_1reg, neon_to_gp<q>,\
+		    neon_from_gp<q>,mov_reg,neon_load1_2reg,\
+		    neon_store1_2reg")
+  (set_attr "length" "4,4,4,4,4,4,4,8,8,8")
+  (set_attr "arm_pool_range"     "*,*,*,*,1020,*,*,*,1020,*")
+  (set_attr "thumb2_pool_range"     "*,*,*,*,1018,*,*,*,1018,*")
+  (set_attr "neg_pool_range" "*,*,*,*,1004,*,*,*,1004,*")])
 
 (define_insn "*neon_mov<mode>"
   [(set (match_operand:VQXMOV 0 "nonimmediate_operand"
-  	  "=w,Un,w, w,  ?r,?w,?r,?r,  ?Us")
+	  "=w,Un,w, w, w,  ?r,?w,?r,?r,  ?Us")
 	(match_operand:VQXMOV 1 "general_operand"
-	  " w,w, Dn,Uni, w, r, r, Usi, r"))]
+	  " w,w, Dm,DN,Uni, w, r, r, Usi, r"))]
   "TARGET_NEON
    && (register_operand (operands[0], <MODE>mode)
        || register_operand (operands[1], <MODE>mode))"
 {
-  if (which_alternative == 2)
+  if (which_alternative == 2 || which_alternative == 3)
     {
       int width, is_valid;
       static char templ[40];
@@ -98,20 +99,20 @@
   switch (which_alternative)
     {
     case 0: return "vmov\t%q0, %q1  @ <mode>";
-    case 1: case 3: return output_move_neon (operands);
-    case 2: gcc_unreachable ();
-    case 4: return "vmov\t%Q0, %R0, %e1  @ <mode>\;vmov\t%J0, %K0, %f1";
-    case 5: return "vmov\t%e0, %Q1, %R1  @ <mode>\;vmov\t%f0, %J1, %K1";
+    case 1: case 4: return output_move_neon (operands);
+    case 2: case 3: gcc_unreachable ();
+    case 5: return "vmov\t%Q0, %R0, %e1  @ <mode>\;vmov\t%J0, %K0, %f1";
+    case 6: return "vmov\t%e0, %Q1, %R1  @ <mode>\;vmov\t%f0, %J1, %K1";
     default: return output_move_quad (operands);
     }
 }
   [(set_attr "type" "neon_move_q,neon_store2_2reg_q,neon_move_q,\
-                     neon_load2_2reg_q,neon_to_gp_q,neon_from_gp_q,\
-                     mov_reg,neon_load1_4reg,neon_store1_4reg")
-   (set_attr "length" "4,8,4,8,8,8,16,8,16")
-   (set_attr "arm_pool_range" "*,*,*,1020,*,*,*,1020,*")
-   (set_attr "thumb2_pool_range" "*,*,*,1018,*,*,*,1018,*")
-   (set_attr "neg_pool_range" "*,*,*,996,*,*,*,996,*")])
+                     neon_move_q,neon_load2_2reg_q,neon_to_gp_q,\
+                     neon_from_gp_q,mov_reg,neon_load1_4reg,neon_store1_4reg")
+   (set_attr "length" "4,8,4,4,8,8,8,16,8,16")
+   (set_attr "arm_pool_range" "*,*,*,*,1020,*,*,*,1020,*")
+   (set_attr "thumb2_pool_range" "*,*,*,*,1018,*,*,*,1018,*")
+   (set_attr "neg_pool_range" "*,*,*,*,996,*,*,*,996,*")])
 
 (define_expand "movti"
   [(set (match_operand:TI 0 "nonimmediate_operand" "")
@@ -1007,7 +1008,7 @@
 (define_insn "vashl<mode>3"
   [(set (match_operand:VDQIW 0 "s_register_operand" "=w,w")
 	(ashift:VDQIW (match_operand:VDQIW 1 "s_register_operand" "w,w")
-		      (match_operand:VDQIW 2 "imm_lshift_or_reg_neon" "w,Dn")))]
+		      (match_operand:VDQIW 2 "imm_lshift_or_reg_neon" "w,Dm")))]
   "TARGET_NEON"
   {
     switch (which_alternative)
@@ -1026,7 +1027,7 @@
 (define_insn "vashr<mode>3_imm"
   [(set (match_operand:VDQIW 0 "s_register_operand" "=w")
 	(ashiftrt:VDQIW (match_operand:VDQIW 1 "s_register_operand" "w")
-			(match_operand:VDQIW 2 "imm_for_neon_rshift_operand" "Dn")))]
+			(match_operand:VDQIW 2 "imm_for_neon_rshift_operand" "Dm")))]
   "TARGET_NEON"
   {
     return neon_output_shift_immediate ("vshr", 's', &operands[2],
@@ -1039,7 +1040,7 @@
 (define_insn "vlshr<mode>3_imm"
   [(set (match_operand:VDQIW 0 "s_register_operand" "=w")
 	(lshiftrt:VDQIW (match_operand:VDQIW 1 "s_register_operand" "w")
-			(match_operand:VDQIW 2 "imm_for_neon_rshift_operand" "Dn")))]
+			(match_operand:VDQIW 2 "imm_for_neon_rshift_operand" "Dm")))]
   "TARGET_NEON"
   {
     return neon_output_shift_immediate ("vshr", 'u', &operands[2],
Index: gcc/config/arm/constraints.md
===================================================================
--- a/src/gcc/config/arm/constraints.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/arm/constraints.md	(.../branches/gcc-7-branch)
@@ -31,7 +31,8 @@
 ;; 'H' was previously used for FPA.
 
 ;; The following multi-letter normal constraints have been used:
-;; in ARM/Thumb-2 state: Da, Db, Dc, Dd, Dn, Dl, DL, Do, Dv, Dy, Di, Dt, Dp, Dz
+;; in ARM/Thumb-2 state: Da, Db, Dc, Dd, Dn, DN, Dm, Dl, DL, Do, Dv, Dy, Di,
+;;			 Dt, Dp, Dz
 ;; in Thumb-1 state: Pa, Pb, Pc, Pd, Pe
 ;; in Thumb-2 state: Pj, PJ, Ps, Pt, Pu, Pv, Pw, Px, Py
 ;; in all states: Pf
@@ -294,14 +295,28 @@
  (and (match_code "const_double,const_int")
       (match_test "TARGET_32BIT && arm_const_double_by_immediates (op)")))
 
-(define_constraint "Dn"
+(define_constraint "Dm"
  "@internal
-  In ARM/Thumb-2 state a const_vector or const_int which can be loaded with a
-  Neon vmov immediate instruction."
- (and (match_code "const_vector,const_int")
+  In ARM/Thumb-2 state a const_vector which can be loaded with a Neon vmov
+  immediate instruction."
+ (and (match_code "const_vector")
       (match_test "TARGET_32BIT
 		   && imm_for_neon_mov_operand (op, GET_MODE (op))")))
 
+(define_constraint "Dn"
+ "@internal
+  In ARM/Thumb-2 state a DImode const_int which can be loaded with a Neon vmov
+  immediate instruction."
+ (and (match_code "const_int")
+      (match_test "TARGET_32BIT && imm_for_neon_mov_operand (op, DImode)")))
+
+(define_constraint "DN"
+ "@internal
+  In ARM/Thumb-2 state a TImode const_int which can be loaded with a Neon vmov
+  immediate instruction."
+ (and (match_code "const_int")
+      (match_test "TARGET_32BIT && imm_for_neon_mov_operand (op, TImode)")))
+
 (define_constraint "Dl"
  "@internal
   In ARM/Thumb-2 state a const_vector which can be used with a Neon vorr or
Index: gcc/config/arm/t-rtems
===================================================================
--- a/src/gcc/config/arm/t-rtems	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/arm/t-rtems	(.../branches/gcc-7-branch)
@@ -1,7 +1,7 @@
 # Custom RTEMS multilibs for ARM
 
-MULTILIB_OPTIONS  = mbig-endian mthumb march=armv6-m/march=armv7-a/march=armv7-r/march=armv7-m/mcpu=cortex-m7 mfpu=neon/mfpu=vfp/mfpu=vfpv3-d16/mfpu=fpv4-sp-d16/mfpu=fpv5-d16 mfloat-abi=hard
-MULTILIB_DIRNAMES = eb thumb armv6-m armv7-a armv7-r armv7-m cortex-m7 neon vfp vfpv3-d16 fpv4-sp-d16 fpv5-d16 hard
+MULTILIB_OPTIONS  = mbig-endian mthumb march=armv6-m/march=armv7-a/march=armv7-r/mcpu=cortex-m3/mcpu=cortex-m4/mcpu=cortex-m7 mfpu=neon/mfpu=vfp/mfpu=vfpv3-d16/mfpu=fpv4-sp-d16/mfpu=fpv5-d16 mfloat-abi=hard
+MULTILIB_DIRNAMES = eb thumb armv6-m armv7-a armv7-r cortex-m3 cortex-m4 cortex-m7 neon vfp vfpv3-d16 fpv4-sp-d16 fpv5-d16 hard
 
 # Enumeration of multilibs
 
@@ -16,7 +16,8 @@
 MULTILIB_REQUIRED += mthumb/march=armv7-a
 MULTILIB_REQUIRED += mthumb/march=armv7-r/mfpu=vfpv3-d16/mfloat-abi=hard
 MULTILIB_REQUIRED += mthumb/march=armv7-r
-MULTILIB_REQUIRED += mthumb/march=armv7-m/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_REQUIRED += mthumb/mcpu=cortex-m3
+MULTILIB_REQUIRED += mthumb/mcpu=cortex-m4
+MULTILIB_REQUIRED += mthumb/mcpu=cortex-m4/mfpu=fpv4-sp-d16/mfloat-abi=hard
 MULTILIB_REQUIRED += mthumb/mcpu=cortex-m7/mfpu=fpv5-d16/mfloat-abi=hard
-MULTILIB_REQUIRED += mthumb/march=armv7-m
 MULTILIB_REQUIRED += mthumb
Index: gcc/config/arm/arm.md
===================================================================
--- a/src/gcc/config/arm/arm.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/arm/arm.md	(.../branches/gcc-7-branch)
@@ -5999,52 +5999,29 @@
         }
     }
 
-  if (ARM_OFFSETS_MUST_BE_WITHIN_SECTIONS_P)
+  split_const (operands[1], &base, &offset);
+  if (INTVAL (offset) != 0
+      && targetm.cannot_force_const_mem (SImode, operands[1]))
     {
-      split_const (operands[1], &base, &offset);
-      if (GET_CODE (base) == SYMBOL_REF
-	  && !offset_within_block_p (base, INTVAL (offset)))
-	{
-	  tmp = can_create_pseudo_p () ? gen_reg_rtx (SImode) : operands[0];
-	  emit_move_insn (tmp, base);
-	  emit_insn (gen_addsi3 (operands[0], tmp, offset));
-	  DONE;
-	}
+      tmp = can_create_pseudo_p () ? gen_reg_rtx (SImode) : operands[0];
+      emit_move_insn (tmp, base);
+      emit_insn (gen_addsi3 (operands[0], tmp, offset));
+      DONE;
     }
 
+  tmp = can_create_pseudo_p () ? NULL_RTX : operands[0];
+
   /* Recognize the case where operand[1] is a reference to thread-local
-     data and load its address to a register.  */
+     data and load its address to a register.  Offsets have been split off
+     already.  */
   if (arm_tls_referenced_p (operands[1]))
-    {
-      rtx tmp = operands[1];
-      rtx addend = NULL;
-
-      if (GET_CODE (tmp) == CONST && GET_CODE (XEXP (tmp, 0)) == PLUS)
-        {
-          addend = XEXP (XEXP (tmp, 0), 1);
-          tmp = XEXP (XEXP (tmp, 0), 0);
-        }
-
-      gcc_assert (GET_CODE (tmp) == SYMBOL_REF);
-      gcc_assert (SYMBOL_REF_TLS_MODEL (tmp) != 0);
-
-      tmp = legitimize_tls_address (tmp,
-				    !can_create_pseudo_p () ? operands[0] : 0);
-      if (addend)
-        {
-          tmp = gen_rtx_PLUS (SImode, tmp, addend);
-          tmp = force_operand (tmp, operands[0]);
-        }
-      operands[1] = tmp;
-    }
+    operands[1] = legitimize_tls_address (operands[1], tmp);
   else if (flag_pic
 	   && (CONSTANT_P (operands[1])
 	       || symbol_mentioned_p (operands[1])
 	       || label_mentioned_p (operands[1])))
-      operands[1] = legitimize_pic_address (operands[1], SImode,
-					    (!can_create_pseudo_p ()
-					     ? operands[0]
-					     : 0));
+    operands[1] =
+      legitimize_pic_address (operands[1], SImode, tmp);
   }
   "
 )
Index: gcc/config/pa/pa.md
===================================================================
--- a/src/gcc/config/pa/pa.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/pa/pa.md	(.../branches/gcc-7-branch)
@@ -5319,8 +5319,8 @@
 
 (define_insn "umulsidi3"
   [(set (match_operand:DI 0 "register_operand" "=f")
-	(mult:DI (zero_extend:DI (match_operand:SI 1 "nonimmediate_operand" "f"))
-		 (zero_extend:DI (match_operand:SI 2 "nonimmediate_operand" "f"))))]
+	(mult:DI (zero_extend:DI (match_operand:SI 1 "register_operand" "f"))
+		 (zero_extend:DI (match_operand:SI 2 "register_operand" "f"))))]
   "TARGET_PA_11 && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT"
   "xmpyu %1,%2,%0"
   [(set_attr "type" "fpmuldbl")
@@ -5328,7 +5328,7 @@
 
 (define_insn ""
   [(set (match_operand:DI 0 "register_operand" "=f")
-	(mult:DI (zero_extend:DI (match_operand:SI 1 "nonimmediate_operand" "f"))
+	(mult:DI (zero_extend:DI (match_operand:SI 1 "register_operand" "f"))
 		 (match_operand:DI 2 "uint32_operand" "f")))]
   "TARGET_PA_11 && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT && !TARGET_64BIT"
   "xmpyu %1,%R2,%0"
@@ -5337,7 +5337,7 @@
 
 (define_insn ""
   [(set (match_operand:DI 0 "register_operand" "=f")
-	(mult:DI (zero_extend:DI (match_operand:SI 1 "nonimmediate_operand" "f"))
+	(mult:DI (zero_extend:DI (match_operand:SI 1 "register_operand" "f"))
 		 (match_operand:DI 2 "uint32_operand" "f")))]
   "TARGET_PA_11 && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT && TARGET_64BIT"
   "xmpyu %1,%2R,%0"
@@ -6904,21 +6904,24 @@
   rtx stack = operands[2];
   rtx fp = operands[3];
 
-  lab = copy_to_reg (lab);
-
   emit_clobber (gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (VOIDmode)));
   emit_clobber (gen_rtx_MEM (BLKmode, hard_frame_pointer_rtx));
 
-  /* Restore the frame pointer.  The virtual_stack_vars_rtx is saved
-     instead of the hard_frame_pointer_rtx in the save area.  As a
-     result, an extra instruction is needed to adjust for the offset
+  lab = copy_to_reg (lab);
+
+  /* Restore the stack and frame pointers.  The virtual_stack_vars_rtx
+     is saved instead of the hard_frame_pointer_rtx in the save area.
+     As a result, an extra instruction is needed to adjust for the offset
      of the virtual stack variables and the hard frame pointer.  */
-  if (GET_CODE (fp) != REG)
-    fp = force_reg (Pmode, fp);
+  fp = copy_to_reg (fp);
+  emit_stack_restore (SAVE_NONLOCAL, stack);
+
+  /* Ensure the frame pointer move is not optimized.  */
+  emit_insn (gen_blockage ());
+  emit_clobber (hard_frame_pointer_rtx);
+  emit_clobber (frame_pointer_rtx);
   emit_move_insn (hard_frame_pointer_rtx, plus_constant (Pmode, fp, -8));
 
-  emit_stack_restore (SAVE_NONLOCAL, stack);
-
   emit_use (hard_frame_pointer_rtx);
   emit_use (stack_pointer_rtx);
 
@@ -8695,23 +8698,26 @@
   emit_clobber (gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (VOIDmode)));
   emit_clobber (gen_rtx_MEM (BLKmode, hard_frame_pointer_rtx));
 
-  /* Restore the frame pointer.  The virtual_stack_vars_rtx is saved
-     instead of the hard_frame_pointer_rtx in the save area.  We need
-     to adjust for the offset between these two values.  */
-  if (GET_CODE (fp) != REG)
-    fp = force_reg (Pmode, fp);
+  /* Load the label we are jumping through into r1 so that we know
+     where to look for it when we get back to setjmp's function for
+     restoring the gp.  */
+  emit_move_insn (pv, lab);
+
+  /* Restore the stack and frame pointers.  The virtual_stack_vars_rtx
+     is saved instead of the hard_frame_pointer_rtx in the save area.
+     We need to adjust for the offset between these two values.  */
+  fp = copy_to_reg (fp);
+  emit_stack_restore (SAVE_NONLOCAL, stack);
+
+  /* Ensure the frame pointer move is not optimized.  */
+  emit_insn (gen_blockage ());
+  emit_clobber (hard_frame_pointer_rtx);
+  emit_clobber (frame_pointer_rtx);
   emit_move_insn (hard_frame_pointer_rtx, plus_constant (Pmode, fp, -8));
 
-  /* This bit is the same as expand_builtin_longjmp.  */
-  emit_stack_restore (SAVE_NONLOCAL, stack);
   emit_use (hard_frame_pointer_rtx);
   emit_use (stack_pointer_rtx);
 
-  /* Load the label we are jumping through into r1 so that we know
-     where to look for it when we get back to setjmp's function for
-     restoring the gp.  */
-  emit_move_insn (pv, lab);
-
   /* Prevent the insns above from being scheduled into the delay slot
      of the interspace jump because the space register could change.  */
   emit_insn (gen_blockage ());
Index: gcc/config/pa/pa.c
===================================================================
--- a/src/gcc/config/pa/pa.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/pa/pa.c	(.../branches/gcc-7-branch)
@@ -10001,10 +10001,11 @@
   /* There is no way to load QImode or HImode values directly from memory
      to a FP register.  SImode loads to the FP registers are not zero
      extended.  On the 64-bit target, this conflicts with the definition
-     of LOAD_EXTEND_OP.  Thus, we can't allow changing between modes with
-     different sizes in the floating-point registers.  */
+     of LOAD_EXTEND_OP.  Thus, we reject all mode changes in the FP registers
+     except for DImode to SImode on the 64-bit target.  It is handled by
+     register renaming in pa_print_operand.  */
   if (MAYBE_FP_REG_CLASS_P (rclass))
-    return true;
+    return !(TARGET_64BIT && from == DImode && to == SImode);
 
   /* HARD_REGNO_MODE_OK places modes with sizes larger than a word
      in specific sets of registers.  Thus, we cannot allow changing
Index: gcc/dce.c
===================================================================
--- a/src/gcc/dce.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/dce.c	(.../branches/gcc-7-branch)
@@ -635,7 +635,10 @@
 
   /* Deleted a pure or const call.  */
   if (must_clean)
-    delete_unreachable_blocks ();
+    {
+      delete_unreachable_blocks ();
+      free_dominance_info (CDI_DOMINATORS);
+    }
 }
 
 
Index: gcc/tree-ssanames.c
===================================================================
--- a/src/gcc/tree-ssanames.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssanames.c	(.../branches/gcc-7-branch)
@@ -744,7 +744,12 @@
     {
       /* points-to info is not flow-sensitive.  */
       if (SSA_NAME_PTR_INFO (name))
-	mark_ptr_info_alignment_unknown (SSA_NAME_PTR_INFO (name));
+	{
+	  /* [E]VRP can derive context sensitive alignment info and
+	     non-nullness properties.  We must reset both.  */
+	  mark_ptr_info_alignment_unknown (SSA_NAME_PTR_INFO (name));
+	  SSA_NAME_PTR_INFO (name)->pt.null = 1;
+	}
     }
   else
     SSA_NAME_RANGE_INFO (name) = NULL;
Index: libgfortran/runtime/backtrace.c
===================================================================
--- a/src/libgfortran/runtime/backtrace.c	(.../tags/gcc_7_4_0_release)
+++ b/src/libgfortran/runtime/backtrace.c	(.../branches/gcc-7-branch)
@@ -135,14 +135,23 @@
 void
 show_backtrace (bool in_signal_handler)
 {
+  /* Note that libbacktrace allows the state to be accessed from
+     multiple threads, so we don't need to use a TLS variable for the
+     state here.  */
+  static struct backtrace_state *lbstate_saved;
   struct backtrace_state *lbstate;
   struct mystate state = { 0, false, in_signal_handler };
- 
-  lbstate = backtrace_create_state (NULL, __gthread_active_p (),
-				    error_callback, NULL);
 
-  if (lbstate == NULL)
-    return;
+  lbstate = __atomic_load_n (&lbstate_saved, __ATOMIC_RELAXED);
+  if (!lbstate)
+    {
+      lbstate = backtrace_create_state (NULL, __gthread_active_p (),
+					error_callback, NULL);
+      if (lbstate)
+	__atomic_store_n (&lbstate_saved, lbstate, __ATOMIC_RELAXED);
+      else
+	return;
+    }
 
   if (!BACKTRACE_SUPPORTED || (in_signal_handler && BACKTRACE_USES_MALLOC))
     {
Index: libgfortran/ChangeLog
===================================================================
--- a/src/libgfortran/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/libgfortran/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,43 @@
+2019-04-16  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-03-25  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR libgfortran/79540
+	* io/write_float.def (build_float_string): Don't copy digits when
+	ndigits is negative.
+
+2019-02-03  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR libfortran/88678
+	Revert:
+	2016-11-16  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR libfortran/78314
+	* config/fpu-glibc.h (support_fpu_trap): Use feenableexcept.
+
+2019-02-03  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR libfortran/88678
+	* config/fpu-glibc.h (set_fpu_trap_exceptions): Clear stalled
+	exception flags before changing trap mode.  Optimize to call
+	feenableexcept and fedisableexcept only once.
+
+2019-01-13  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/88776
+	* io/list_read.c (namelist_read): Use nml_err_ret path on read error
+	not based on stdin_unit.
+	* io/open.c (newunit): Free format buffer if the unit specified is for
+	stdin, stdout, or stderr.
+
+2018-12-06  Janne Blomqvist  <jb@gcc.gnu.org>
+
+	Backport from trunk
+	PR libfortran/88137
+	* runtime/backtrace.c (show_backtrace): Store backtrace state in a
+	static variable, initialize once.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: libgfortran/config/fpu-glibc.h
===================================================================
--- a/src/libgfortran/config/fpu-glibc.h	(.../tags/gcc_7_4_0_release)
+++ b/src/libgfortran/config/fpu-glibc.h	(.../branches/gcc-7-branch)
@@ -39,48 +39,56 @@
 
 void set_fpu_trap_exceptions (int trap, int notrap)
 {
+  int mode_set = 0, mode_clr = 0;
+
 #ifdef FE_INVALID
   if (trap & GFC_FPE_INVALID)
-    feenableexcept (FE_INVALID);
+    mode_set |= FE_INVALID;
   if (notrap & GFC_FPE_INVALID)
-    fedisableexcept (FE_INVALID);
+    mode_clr |= FE_INVALID;
 #endif
 
 /* Some glibc targets (like alpha) have FE_DENORMAL, but not many.  */
 #ifdef FE_DENORMAL
   if (trap & GFC_FPE_DENORMAL)
-    feenableexcept (FE_DENORMAL);
+    mode_set |= FE_DENORMAL;
   if (notrap & GFC_FPE_DENORMAL)
-    fedisableexcept (FE_DENORMAL);
+    mode_clr |= FE_DENORMAL;
 #endif
 
 #ifdef FE_DIVBYZERO
   if (trap & GFC_FPE_ZERO)
-    feenableexcept (FE_DIVBYZERO);
+    mode_set |= FE_DIVBYZERO;
   if (notrap & GFC_FPE_ZERO)
-    fedisableexcept (FE_DIVBYZERO);
+    mode_clr |= FE_DIVBYZERO;
 #endif
 
 #ifdef FE_OVERFLOW
   if (trap & GFC_FPE_OVERFLOW)
-    feenableexcept (FE_OVERFLOW);
+    mode_set |= FE_OVERFLOW;
   if (notrap & GFC_FPE_OVERFLOW)
-    fedisableexcept (FE_OVERFLOW);
+    mode_clr |= FE_OVERFLOW;
 #endif
 
 #ifdef FE_UNDERFLOW
   if (trap & GFC_FPE_UNDERFLOW)
-    feenableexcept (FE_UNDERFLOW);
+    mode_set |= FE_UNDERFLOW;
   if (notrap & GFC_FPE_UNDERFLOW)
-    fedisableexcept (FE_UNDERFLOW);
+    mode_clr |= FE_UNDERFLOW;
 #endif
 
 #ifdef FE_INEXACT
   if (trap & GFC_FPE_INEXACT)
-    feenableexcept (FE_INEXACT);
+    mode_set |= FE_INEXACT;
   if (notrap & GFC_FPE_INEXACT)
-    fedisableexcept (FE_INEXACT);
+    mode_clr |= FE_INEXACT;
 #endif
+
+  /* Clear stalled exception flags.  */
+  feclearexcept (FE_ALL_EXCEPT);
+
+  feenableexcept (mode_set);
+  fedisableexcept (mode_clr);
 }
 
 
@@ -121,41 +129,7 @@
 int
 support_fpu_trap (int flag)
 {
-  int exceptions = 0;
-  int old;
-
-  if (!support_fpu_flag (flag))
-    return 0;
-
-#ifdef FE_INVALID
-  if (flag & GFC_FPE_INVALID) exceptions |= FE_INVALID;
-#endif
-
-#ifdef FE_DIVBYZERO
-  if (flag & GFC_FPE_ZERO) exceptions |= FE_DIVBYZERO;
-#endif
-
-#ifdef FE_OVERFLOW
-  if (flag & GFC_FPE_OVERFLOW) exceptions |= FE_OVERFLOW;
-#endif
-
-#ifdef FE_UNDERFLOW
-  if (flag & GFC_FPE_UNDERFLOW) exceptions |= FE_UNDERFLOW;
-#endif
-
-#ifdef FE_DENORMAL
-  if (flag & GFC_FPE_DENORMAL) exceptions |= FE_DENORMAL;
-#endif
-
-#ifdef FE_INEXACT
-  if (flag & GFC_FPE_INEXACT) exceptions |= FE_INEXACT;
-#endif
-
-  old = feenableexcept (exceptions);
-  if (old == -1)
-    return 0;
-  fedisableexcept (exceptions & ~old);
-  return 1;
+  return support_fpu_flag (flag);
 }
 
 
Index: libgfortran/io/open.c
===================================================================
--- a/src/libgfortran/io/open.c	(.../tags/gcc_7_4_0_release)
+++ b/src/libgfortran/io/open.c	(.../branches/gcc-7-branch)
@@ -529,6 +529,14 @@
   if (u2 != NULL)
     unlock_unit (u2);
 
+  /* If the unit specified is preconnected with a file specified to be open,
+     then clear the format buffer.  */
+  if ((opp->common.unit == options.stdin_unit ||
+       opp->common.unit == options.stdout_unit ||
+       opp->common.unit == options.stderr_unit)
+      && (opp->common.flags & IOPARM_OPEN_HAS_FILE) != 0)
+    fbuf_destroy (u);
+
   /* Open file.  */
 
   s = open_external (opp, flags);
Index: libgfortran/io/list_read.c
===================================================================
--- a/src/libgfortran/io/list_read.c	(.../tags/gcc_7_4_0_release)
+++ b/src/libgfortran/io/list_read.c	(.../branches/gcc-7-branch)
@@ -3613,11 +3613,7 @@
   while (!dtp->u.p.input_complete)
     {
       if (!nml_get_obj_data (dtp, &prev_nl, nml_err_msg, sizeof nml_err_msg))
-	{
-	  if (dtp->u.p.current_unit->unit_number != options.stdin_unit)
-	    goto nml_err_ret;
-	  generate_error (&dtp->common, LIBERROR_READ_VALUE, nml_err_msg);
-        }
+	goto nml_err_ret;
 
       /* Reset the previous namelist pointer if we know we are not going
 	 to be doing multiple reads within a single namelist object.  */
Index: libgfortran/io/write_float.def
===================================================================
--- a/src/libgfortran/io/write_float.def	(.../tags/gcc_7_4_0_release)
+++ b/src/libgfortran/io/write_float.def	(.../branches/gcc-7-branch)
@@ -620,7 +620,7 @@
     }
 
   /* Set digits after the decimal point, padding with zeros.  */
-  if (nafter > 0)
+  if (ndigits >= 0 && nafter > 0)
     {
       if (nafter > ndigits)
 	i = ndigits;
@@ -627,7 +627,8 @@
       else
 	i = nafter;
 
-      memcpy (put, digits, i);
+      if (i > 0)
+	memcpy (put, digits, i);
       while (i < nafter)
 	put[i++] = '0';
 
Index: libcpp/line-map.c
===================================================================
--- a/src/libcpp/line-map.c	(.../tags/gcc_7_4_0_release)
+++ b/src/libcpp/line-map.c	(.../branches/gcc-7-branch)
@@ -753,6 +753,11 @@
       if (line_delta < 0
 	  || last_line != ORDINARY_MAP_STARTING_LINE_NUMBER (map)
 	  || SOURCE_COLUMN (map, highest) >= (1U << (column_bits - range_bits))
+	  || ( /* We can't reuse the map if the line offset is sufficiently
+		  large to cause overflow when computing location_t values.  */
+	      (to_line - ORDINARY_MAP_STARTING_LINE_NUMBER (map))
+	      >= (((uint64_t) 1)
+		  << (CHAR_BIT * sizeof (linenum_type) - column_bits)))
 	  || range_bits < map->m_range_bits)
 	map = linemap_check_ordinary
 	        (const_cast <line_map *>
Index: libcpp/ChangeLog
===================================================================
--- a/src/libcpp/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/libcpp/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,22 @@
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-18  Martin Liska  <mliska@suse.cz>
+
+	PR c++/89383
+	* line-map.c (linemap_line_start): Use 1UL in order
+	to not overflow.
+
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-11  Martin Liska  <mliska@suse.cz>
+
+	PR lto/88147
+	* line-map.c (linemap_line_start): Don't reuse the existing line
+	map if the line offset is sufficiently large to cause overflow
+	when computing location_t values.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: fixincludes/ChangeLog
===================================================================
--- a/src/fixincludes/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/fixincludes/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,23 @@
+2019-06-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-11  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR bootstrap/89864
+	* inclhack.def (darwin_ucred__Atomic): Do not supply test_text
+	for wrap fixes.
+	* fixincl.x: Regenerated.
+
+	Backport from mainline.
+	2019-04-18  Erik Schnetter  <schnetter@gmail.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+		    Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR bootstrap/89864
+	* inclhack.def (darwin_ucred__Atomic): New, work around _Atomic keyword
+	use in headers included by C++.
+	* fixincl.x: Regenerated.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: fixincludes/fixincl.x
===================================================================
--- a/src/fixincludes/fixincl.x	(.../tags/gcc_7_4_0_release)
+++ b/src/fixincludes/fixincl.x	(.../branches/gcc-7-branch)
@@ -1,12 +1,12 @@
 /*  -*- buffer-read-only: t -*- vi: set ro:
- * 
+ *
  * DO NOT EDIT THIS FILE   (fixincl.x)
- * 
- * It has been AutoGen-ed  Saturday February 25, 2017 at 03:25:44 PM EST
+ *
+ * It has been AutoGen-ed  May 30, 2019 at 04:05:59 PM by AutoGen 5.17.4
  * From the definitions    inclhack.def
  * and the template file   fixincl
  */
-/* DO NOT SVN-MERGE THIS FILE, EITHER Sat 25 Feb 2017 15:25:44 EST
+/* DO NOT SVN-MERGE THIS FILE, EITHER Thu May 30 16:05:59 BST 2019
  *
  * You must regenerate it.  Use the ./genfixes script.
  *
@@ -15,7 +15,7 @@
  * certain ANSI-incompatible system header files which are fixed to work
  * correctly with ANSI C and placed in a directory that GNU C will search.
  *
- * This file contains 248 fixup descriptions.
+ * This file contains 249 fixup descriptions.
  *
  * See README for more information.
  *
@@ -3262,6 +3262,48 @@
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * *
  *
+ *  Description of Darwin_Ucred__Atomic fix
+ */
+tSCC zDarwin_Ucred__AtomicName[] =
+     "darwin_ucred__Atomic";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zDarwin_Ucred__AtomicList[] =
+  "sys/ucred.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzDarwin_Ucred__AtomicMachs[] = {
+        "*-*-darwin*",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zDarwin_Ucred__AtomicSelect0[] =
+       "_Atomic";
+
+#define    DARWIN_UCRED__ATOMIC_TEST_CT  1
+static tTestDesc aDarwin_Ucred__AtomicTests[] = {
+  { TT_EGREP,    zDarwin_Ucred__AtomicSelect0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Darwin_Ucred__Atomic
+ */
+static const char* apzDarwin_Ucred__AtomicPatch[] = {
+    "wrap",
+    "#if (__STDC_VERSION__ < 201112L) || defined(__cplusplus)\n\
+# define _Atomic volatile\n\
+#endif\n",
+    "#if (__STDC_VERSION__ < 201112L) || defined(__cplusplus)\n\
+# undef _Atomic\n\
+#endif\n",
+    (char*)NULL };
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
  *  Description of Dec_Intern_Asm fix
  */
 tSCC zDec_Intern_AsmName[] =
@@ -10139,9 +10181,9 @@
  *
  *  List of all fixes
  */
-#define REGEX_COUNT          285
+#define REGEX_COUNT          286
 #define MACH_LIST_SIZE_LIMIT 187
-#define FIX_COUNT            248
+#define FIX_COUNT            249
 
 /*
  *  Enumerate the fixes
@@ -10222,6 +10264,7 @@
     DARWIN_STDINT_5_FIXIDX,
     DARWIN_STDINT_6_FIXIDX,
     DARWIN_STDINT_7_FIXIDX,
+    DARWIN_UCRED__ATOMIC_FIXIDX,
     DEC_INTERN_ASM_FIXIDX,
     DJGPP_WCHAR_H_FIXIDX,
     ECD_CURSOR_FIXIDX,
@@ -10773,6 +10816,11 @@
      DARWIN_STDINT_7_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
      aDarwin_Stdint_7Tests,   apzDarwin_Stdint_7Patch, 0 },
 
+  {  zDarwin_Ucred__AtomicName,    zDarwin_Ucred__AtomicList,
+     apzDarwin_Ucred__AtomicMachs,
+     DARWIN_UCRED__ATOMIC_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aDarwin_Ucred__AtomicTests,   apzDarwin_Ucred__AtomicPatch, 0 },
+
   {  zDec_Intern_AsmName,    zDec_Intern_AsmList,
      apzDec_Intern_AsmMachs,
      DEC_INTERN_ASM_TEST_CT, FD_MACH_ONLY,
Index: fixincludes/inclhack.def
===================================================================
--- a/src/fixincludes/inclhack.def	(.../tags/gcc_7_4_0_release)
+++ b/src/fixincludes/inclhack.def	(.../branches/gcc-7-branch)
@@ -1688,6 +1688,25 @@
 		"#define UINTMAX_C(v) (v ## ULL)";
 };
 
+/*  The SDK included with XCode 10.2 has the file <sys/ucred.h> that uses the
+    C11 _Atomic keyword (exposing it to C++ code).  The work-around here follows
+    the header in declaring the entity volatile when _Atomic is not available.
+*/
+fix = {
+    hackname  = darwin_ucred__Atomic;
+    mach      = "*-*-darwin*";
+    files     = sys/ucred.h;
+    select    = "_Atomic";
+    c_fix     = wrap;
+    c_fix_arg = "#if (__STDC_VERSION__ < 201112L) || defined(__cplusplus)\n"
+		"# define _Atomic volatile\n"
+		"#endif\n";
+    c_fix_arg = "#if (__STDC_VERSION__ < 201112L) || defined(__cplusplus)\n"
+		"# undef _Atomic\n"
+		"#endif\n";
+    test_text = ""; /* Don't provide this for wrap fixes.  */
+};
+
 /*
  *  Fix <c_asm.h> on Digital UNIX V4.0:
  *  It contains a prototype for a DEC C internal asm() function,

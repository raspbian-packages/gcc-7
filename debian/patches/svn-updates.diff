# DP: updates from the 7 branch upto 20191105 (r277823).

last_update()
{
	cat > ${dir}LAST_UPDATED <EOF
Tue Nov  5 12:31:46 CET 2019
Tue Nov  5 11:31:46 UTC 2019 (revision 277823)
EOF
}

LANG=C svn diff svn://gcc.gnu.org/svn/gcc/tags/gcc_7_4_0_release svn://gcc.gnu.org/svn/gcc/branches/gcc-7-branch \
	| sed -r 's,^--- (\S+)\t(\S+)(.*)$,--- a/src/\1\t\2,;s,^\+\+\+ (\S+)\t(\S+)(.*)$,+++ b/src/\1\t\2,' \
	| awk '/^Index:.*\.(class|texi)/ {skip=1; next} /^Index:/ { skip=0 } skip==0'

Index: libitm/ChangeLog
===================================================================
--- a/src/libitm/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/libitm/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,20 @@
+2019-09-28  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2018-08-03  Sergei Trofimovich  <slyfox@gentoo.org>
+
+	PR target/86712
+	* config/sh/sjlj.S: Adjust to use PIC vs normal code to avoid
+	absolute relocation in a shared library.
+
+2018-12-13  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backport from mainline
+	2018-12-13  Peter Bergner  <bergner@linux.ibm.com>
+
+	* config/powerpc/target.h (htm_available):  Add support for
+	PPC_FEATURE2_HTM_NO_SUSPEND.  Use __builtin_cpu_supports if available.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: libitm/config/powerpc/target.h
===================================================================
--- a/src/libitm/config/powerpc/target.h	(.../tags/gcc_7_4_0_release)
+++ b/src/libitm/config/powerpc/target.h	(.../branches/gcc-7-branch)
@@ -81,7 +81,20 @@
 static inline bool
 htm_available (void)
 {
-  return (getauxval (AT_HWCAP2) & PPC_FEATURE2_HAS_HTM) ? true : false;
+#ifdef __BUILTIN_CPU_SUPPORTS__
+  if (__builtin_cpu_supports ("htm-no-suspend")
+      || __builtin_cpu_supports ("htm"))
+    return true;
+#else
+  unsigned long htm_flags = PPC_FEATURE2_HAS_HTM
+#ifdef PPC_FEATURE2_HTM_NO_SUSPEND
+			    | PPC_FEATURE2_HTM_NO_SUSPEND
+#endif
+			    | 0;
+  if (getauxval (AT_HWCAP2) & htm_flags)
+    return true;
+#endif
+  return false;
 }
 
 static inline uint32_t
Index: libitm/config/sh/sjlj.S
===================================================================
--- a/src/libitm/config/sh/sjlj.S	(.../tags/gcc_7_4_0_release)
+++ b/src/libitm/config/sh/sjlj.S	(.../branches/gcc-7-branch)
@@ -53,7 +53,7 @@
 #else
 	cfi_def_cfa_offset (4*10)
 #endif
-#if defined HAVE_ATTRIBUTE_VISIBILITY || !defined __PIC__
+#if !defined __PIC__
 	mov.l	.Lbegin, r1
 	jsr	@r1
 	 mov	r15, r5
@@ -78,7 +78,7 @@
 
 	.align  2
 .Lbegin:
-#if defined HAVE_ATTRIBUTE_VISIBILITY || !defined __PIC__
+#if !defined __PIC__
 	.long	GTM_begin_transaction
 #else
 	.long	GTM_begin_transaction@PCREL-(.Lbegin0-.)
Index: libgomp/ChangeLog
===================================================================
--- a/src/libgomp/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/libgomp/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,24 @@
+2019-08-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-05-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR libgomp/90585
+	* plugin/plugin-hsa.c (print_kernel_dispatch, run_kernel): Use PRIu64
+	macro instead of "lu".
+	(release_kernel_dispatch): Likewise.  Cast shadow->debug to uintptr_t
+	before casting to void *.
+
+	2019-06-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/90811
+	* testsuite/libgomp.c/pr90811.c: New test.
+
+	2019-01-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89002
+	* testsuite/libgomp.c/pr89002.c: New test.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: libgomp/testsuite/libgomp.c/pr89002.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/pr89002.c	(.../tags/gcc_7_4_0_release)
+++ b/src/libgomp/testsuite/libgomp.c/pr89002.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,43 @@
+/* PR middle-end/89002 */
+
+extern void abort (void);
+
+int
+foo (int x)
+{
+  int a;
+  int *p = &a;
+
+#pragma omp taskloop lastprivate (a)
+  for (a = 0; a < x; ++a)
+    ;
+  return *p;
+}
+
+int
+bar (int x)
+{
+  int a;
+  int *p = &a;
+
+#pragma omp parallel
+#pragma omp single
+#pragma omp taskloop lastprivate (a)
+  for (a = 0; a < x; ++a)
+    ;
+  return *p;
+}
+
+int
+main ()
+{
+#pragma omp parallel
+#pragma omp single
+  {
+    if (foo (4) != 4)
+      abort ();
+  }
+  if (bar (6) != 6)
+    abort ();
+  return 0;
+}
Index: libgomp/testsuite/libgomp.c/pr90811.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/pr90811.c	(.../tags/gcc_7_4_0_release)
+++ b/src/libgomp/testsuite/libgomp.c/pr90811.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,29 @@
+/* PR target/90811 */
+
+int
+main ()
+{
+  long long a[100], b[100];
+  int i;
+  for (i = 0; i < 100; i++)
+    {
+      a[i] = i;
+      b[i] = i % 10;
+    }
+  #pragma omp target teams distribute parallel for simd map(tofrom: a[:100], b[:100])
+  for (i = 0; i < 100; i++)
+    {
+      long long c = 0;
+      const long long d[] = { 1, 3, 5, 7, 9 };
+      for (int j = 4; j >= 0; j--)
+         c = d[j] + b[i] * c;
+      a[i] += c;
+    }
+  for (i = 0; i < 100; i++)
+    {
+      const long long r[] = { 1, 26, 229, 976, 2849, 6646, 13381, 24284, 40801, 64594 };
+      if (a[i] != r[i % 10] + (i / 10 * 10))
+	__builtin_abort ();
+    }
+  return 0;
+}
Index: libgomp/plugin/plugin-hsa.c
===================================================================
--- a/src/libgomp/plugin/plugin-hsa.c	(.../tags/gcc_7_4_0_release)
+++ b/src/libgomp/plugin/plugin-hsa.c	(.../branches/gcc-7-branch)
@@ -1175,8 +1175,9 @@
 static void
 release_kernel_dispatch (struct GOMP_hsa_kernel_dispatch *shadow)
 {
-  HSA_DEBUG ("Released kernel dispatch: %p has value: %lu (%p)\n", shadow,
-	     shadow->debug, (void *) shadow->debug);
+  HSA_DEBUG ("Released kernel dispatch: %p has value: %" PRIu64 " (%p)\n",
+	     shadow, shadow->debug,
+	     (void *) (uintptr_t) shadow->debug);
 
   hsa_fns.hsa_memory_free_fn (shadow->kernarg_address);
 
@@ -1297,9 +1298,9 @@
   indent_stream (stderr, indent);
   fprintf (stderr, "kernarg_address: %p\n", dispatch->kernarg_address);
   indent_stream (stderr, indent);
-  fprintf (stderr, "object: %lu\n", dispatch->object);
+  fprintf (stderr, "object: %" PRIu64 "\n", dispatch->object);
   indent_stream (stderr, indent);
-  fprintf (stderr, "signal: %lu\n", dispatch->signal);
+  fprintf (stderr, "signal: %" PRIu64 "\n", dispatch->signal);
   indent_stream (stderr, indent);
   fprintf (stderr, "private_segment_size: %u\n",
 	   dispatch->private_segment_size);
@@ -1307,7 +1308,7 @@
   fprintf (stderr, "group_segment_size: %u\n",
 	   dispatch->group_segment_size);
   indent_stream (stderr, indent);
-  fprintf (stderr, "children dispatches: %lu\n",
+  fprintf (stderr, "children dispatches: %" PRIu64 "\n",
 	   dispatch->kernel_dispatch_count);
   indent_stream (stderr, indent);
   fprintf (stderr, "omp_num_threads: %u\n",
@@ -1615,7 +1616,7 @@
 	hsa_signal_t child_s;
 	child_s.handle = shadow->children_dispatches[i]->signal;
 
-	HSA_DEBUG ("Waiting for children completion signal: %lu\n",
+	HSA_DEBUG ("Waiting for children completion signal: %" PRIu64 "\n",
 		   shadow->children_dispatches[i]->signal);
 	hsa_fns.hsa_signal_load_acquire_fn (child_s);
       }
Index: libstdc++-v3/configure
===================================================================
--- a/src/libstdc++-v3/configure	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/configure	(.../branches/gcc-7-branch)
@@ -637,6 +637,7 @@
 XSL_STYLE_DIR
 XMLLINT
 XSLTPROC
+XMLCATALOG
 DOT
 DOXYGEN
 BUILD_INFO_FALSE
@@ -11605,7 +11606,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11608 "configure"
+#line 11609 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11711,7 +11712,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11714 "configure"
+#line 11715 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -15397,7 +15398,7 @@
   # Fake what AC_TRY_COMPILE does.
 
     cat > conftest.$ac_ext << EOF
-#line 15400 "configure"
+#line 15401 "configure"
 int main()
 {
   typedef bool atomic_type;
@@ -15432,7 +15433,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15435 "configure"
+#line 15436 "configure"
 int main()
 {
   typedef short atomic_type;
@@ -15467,7 +15468,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15470 "configure"
+#line 15471 "configure"
 int main()
 {
   // NB: _Atomic_word not necessarily int.
@@ -15503,7 +15504,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15506 "configure"
+#line 15507 "configure"
 int main()
 {
   typedef long long atomic_type;
@@ -15584,7 +15585,7 @@
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15587 "configure"
+#line 15588 "configure"
 int main()
 {
   _Decimal32 d1;
@@ -15626,7 +15627,7 @@
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15629 "configure"
+#line 15630 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
@@ -15660,7 +15661,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15663 "configure"
+#line 15664 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
@@ -80998,6 +80999,44 @@
 
 
 # Check for docbook
+# Extract the first word of "xmlcatalog", so it can be a program name with args.
+set dummy xmlcatalog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_XMLCATALOG+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$XMLCATALOG"; then
+  ac_cv_prog_XMLCATALOG="$XMLCATALOG" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_XMLCATALOG="yes"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_prog_XMLCATALOG" && ac_cv_prog_XMLCATALOG="no"
+fi
+fi
+XMLCATALOG=$ac_cv_prog_XMLCATALOG
+if test -n "$XMLCATALOG"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $XMLCATALOG" >&5
+$as_echo "$XMLCATALOG" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
 # Extract the first word of "xsltproc", so it can be a program name with args.
 set dummy xsltproc; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
@@ -81076,31 +81115,28 @@
 
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for docbook stylesheets for documentation creation" >&5
-$as_echo_n "checking for docbook stylesheets for documentation creation... " >&6; }
-glibcxx_stylesheets=no
-if test x${XSLTPROC} = xyes && echo '<title/>' | xsltproc --noout --nonet --xinclude http://docbook.sourceforge.net/release/xsl-ns/current/xhtml-1_1/docbook.xsl - 2>/dev/null; then
-  glibcxx_stylesheets=yes
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_stylesheets" >&5
-$as_echo "$glibcxx_stylesheets" >&6; }
+glibcxx_docbook_url=http://docbook.sourceforge.net/release/xsl-ns/current/
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for local stylesheet directory" >&5
 $as_echo_n "checking for local stylesheet directory... " >&6; }
 glibcxx_local_stylesheets=no
-if test x"$glibcxx_stylesheets" = x"yes"; then
-  if test -d /usr/share/sgml/docbook/xsl-ns-stylesheets; then
-    glibcxx_local_stylesheets=yes
-    XSL_STYLE_DIR=/usr/share/sgml/docbook/xsl-ns-stylesheets
-  fi
-  if test -d /usr/share/xml/docbook/stylesheet/docbook-xsl-ns; then
-    glibcxx_local_stylesheets=yes
-    XSL_STYLE_DIR=/usr/share/xml/docbook/stylesheet/docbook-xsl-ns
-  fi
-  if test -d /usr/share/xml/docbook/stylesheet/nwalsh5/current; then
-    glibcxx_local_stylesheets=yes
-    XSL_STYLE_DIR=/usr/share/xml/docbook/stylesheet/nwalsh5/current
-  fi
+if test x${XMLCATALOG} = xyes && xsl_style_dir=`xmlcatalog "" $glibcxx_docbook_url 2>/dev/null`
+then
+  XSL_STYLE_DIR=`echo $xsl_style_dir | sed -n 's;^file://;;p'`
+  glibcxx_local_stylesheets=yes
+else
+  for dir in \
+    /usr/share/sgml/docbook/xsl-ns-stylesheets \
+    /usr/share/xml/docbook/stylesheet/docbook-xsl-ns \
+    /usr/share/xml/docbook/stylesheet/nwalsh5/current \
+    /usr/share/xml/docbook/stylesheet/nwalsh/current
+  do
+    if test -d $dir; then
+      glibcxx_local_stylesheets=yes
+      XSL_STYLE_DIR=$dir
+      break
+    fi
+  done
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_local_stylesheets" >&5
 $as_echo "$glibcxx_local_stylesheets" >&6; }
@@ -81109,6 +81145,18 @@
 
   { $as_echo "$as_me:${as_lineno-$LINENO}: $XSL_STYLE_DIR" >&5
 $as_echo "$as_me: $XSL_STYLE_DIR" >&6;}
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for docbook stylesheets for documentation creation" >&5
+$as_echo_n "checking for docbook stylesheets for documentation creation... " >&6; }
+  glibcxx_stylesheets=no
+  if test x${XMLCATALOG} = xno || xmlcatalog "" $glibcxx_docbook_url/xhtml/docbook.xsl >/dev/null 2>&1; then
+    if test x${XSLTPROC} = xyes && echo '<title/>' | xsltproc --noout --nonet --xinclude $glibcxx_docbook_url/xhtml/docbook.xsl - 2>/dev/null; then
+      glibcxx_stylesheets=yes
+    fi
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_stylesheets" >&5
+$as_echo "$glibcxx_stylesheets" >&6; }
+
 else
   glibcxx_stylesheets=no
 fi
Index: libstdc++-v3/python/Makefile.in
===================================================================
--- a/src/libstdc++-v3/python/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/python/Makefile.in	(.../branches/gcc-7-branch)
@@ -234,6 +234,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/python/libstdcxx/v6/xmethods.py
===================================================================
--- a/src/libstdc++-v3/python/libstdcxx/v6/xmethods.py	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/python/libstdcxx/v6/xmethods.py	(.../branches/gcc-7-branch)
@@ -728,7 +728,7 @@
         return gdb.lookup_type('long')
 
     def __call__(self, obj):
-        refcounts = ['_M_refcount']['_M_pi']
+        refcounts = obj['_M_refcount']['_M_pi']
         return refcounts['_M_use_count'] if refcounts else 0
 
 class SharedPtrUniqueWorker(SharedPtrUseCountWorker):
Index: libstdc++-v3/Makefile.in
===================================================================
--- a/src/libstdc++-v3/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/Makefile.in	(.../branches/gcc-7-branch)
@@ -232,6 +232,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/scripts/make_exports.pl
===================================================================
--- a/src/libstdc++-v3/scripts/make_exports.pl	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/scripts/make_exports.pl	(.../branches/gcc-7-branch)
@@ -103,6 +103,14 @@
     # Ignore undefined and local symbols.
     next if (/^([^ ]+) [Ua-z] /);
 
+    # GCC does not export construction vtables from shared libraries.
+    # However the symbols are marked hidden, for Darwin that makes them
+    # also external "private_extern", which means that they show up in
+    # this list.  When ld64 encounters them it generates a warning that
+    # they cannot be exported, so trim them from the set now.
+    next if (/^construction vtable.*$/);
+    next if (/^__ZTC.*$/);
+
     # $sym is the name of the symbol, $noeh_sym is the same thing with
     # any '.eh' suffix removed.
     die "unknown nm output $_" if (! /^([^ ]+) [A-Z] /);
Index: libstdc++-v3/src/c++17/Makefile.in
===================================================================
--- a/src/libstdc++-v3/src/c++17/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/src/c++17/Makefile.in	(.../branches/gcc-7-branch)
@@ -0,0 +1,754 @@
+# Makefile.in generated by automake 1.15.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994-2017 Free Software Foundation, Inc.
+
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+am__is_gnu_make = { \
+  if test -z '$(MAKELEVEL)'; then \
+    false; \
+  elif test -n '$(MAKE_HOST)'; then \
+    true; \
+  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
+    true; \
+  else \
+    false; \
+  fi; \
+}
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+subdir = src/c++17
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \
+	$(top_srcdir)/../config/enable.m4 \
+	$(top_srcdir)/../config/futex.m4 \
+	$(top_srcdir)/../config/hwcaps.m4 \
+	$(top_srcdir)/../config/iconv.m4 \
+	$(top_srcdir)/../config/lead-dot.m4 \
+	$(top_srcdir)/../config/lib-ld.m4 \
+	$(top_srcdir)/../config/lib-link.m4 \
+	$(top_srcdir)/../config/lib-prefix.m4 \
+	$(top_srcdir)/../config/lthostflags.m4 \
+	$(top_srcdir)/../config/multi.m4 \
+	$(top_srcdir)/../config/no-executables.m4 \
+	$(top_srcdir)/../config/override.m4 \
+	$(top_srcdir)/../config/stdint.m4 \
+	$(top_srcdir)/../config/unwind_ipinfo.m4 \
+	$(top_srcdir)/../libtool.m4 $(top_srcdir)/../ltoptions.m4 \
+	$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \
+	$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/crossconfig.m4 \
+	$(top_srcdir)/linkage.m4 $(top_srcdir)/acinclude.m4 \
+	$(top_srcdir)/../config/gc++filt.m4 \
+	$(top_srcdir)/../config/tls.m4 $(top_srcdir)/../config/gthr.m4 \
+	$(top_srcdir)/../config/cet.m4 $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+DIST_COMMON = $(srcdir)/Makefile.am
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libc__17convenience_la_LIBADD =
+@ENABLE_DUAL_ABI_TRUE@am__objects_1 = cow-fs_dir.lo cow-fs_ops.lo \
+@ENABLE_DUAL_ABI_TRUE@	cow-fs_path.lo
+am__objects_2 = fs_dir.lo fs_ops.lo fs_path.lo memory_resource.lo \
+	$(am__objects_1)
+@ENABLE_DUAL_ABI_TRUE@am__objects_3 = cow-string-inst.lo
+@ENABLE_EXTERN_TEMPLATE_TRUE@am__objects_4 = ostream-inst.lo \
+@ENABLE_EXTERN_TEMPLATE_TRUE@	string-inst.lo $(am__objects_3)
+am_libc__17convenience_la_OBJECTS = $(am__objects_2) $(am__objects_4)
+libc__17convenience_la_OBJECTS = $(am_libc__17convenience_la_OBJECTS)
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
+AM_V_CXX = $(am__v_CXX_@AM_V@)
+am__v_CXX_ = $(am__v_CXX_@AM_DEFAULT_V@)
+am__v_CXX_0 = @echo "  CXX     " $@;
+am__v_CXX_1 = 
+CXXLD = $(CXX)
+AM_V_CXXLD = $(am__v_CXXLD_@AM_V@)
+am__v_CXXLD_ = $(am__v_CXXLD_@AM_DEFAULT_V@)
+am__v_CXXLD_0 = @echo "  CXXLD   " $@;
+am__v_CXXLD_1 = 
+SOURCES = $(libc__17convenience_la_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
+ETAGS = etags
+CTAGS = ctags
+ABI_TWEAKS_SRCDIR = @ABI_TWEAKS_SRCDIR@
+ACLOCAL = @ACLOCAL@
+ALLOCATOR_H = @ALLOCATOR_H@
+ALLOCATOR_NAME = @ALLOCATOR_NAME@
+AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
+AR = @AR@
+AS = @AS@
+ATOMICITY_SRCDIR = @ATOMICITY_SRCDIR@
+ATOMIC_FLAGS = @ATOMIC_FLAGS@
+ATOMIC_WORD_SRCDIR = @ATOMIC_WORD_SRCDIR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+BASIC_FILE_CC = @BASIC_FILE_CC@
+BASIC_FILE_H = @BASIC_FILE_H@
+CC = @CC@
+CCODECVT_CC = @CCODECVT_CC@
+CCOLLATE_CC = @CCOLLATE_CC@
+CCTYPE_CC = @CCTYPE_CC@
+CFLAGS = @CFLAGS@
+CLOCALE_CC = @CLOCALE_CC@
+CLOCALE_H = @CLOCALE_H@
+CLOCALE_INTERNAL_H = @CLOCALE_INTERNAL_H@
+CMESSAGES_CC = @CMESSAGES_CC@
+CMESSAGES_H = @CMESSAGES_H@
+CMONEY_CC = @CMONEY_CC@
+CNUMERIC_CC = @CNUMERIC_CC@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPU_DEFINES_SRCDIR = @CPU_DEFINES_SRCDIR@
+CPU_OPT_BITS_RANDOM = @CPU_OPT_BITS_RANDOM@
+CPU_OPT_EXT_RANDOM = @CPU_OPT_EXT_RANDOM@
+CSTDIO_H = @CSTDIO_H@
+CTIME_CC = @CTIME_CC@
+CTIME_H = @CTIME_H@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXFILT = @CXXFILT@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+C_INCLUDE_DIR = @C_INCLUDE_DIR@
+DBLATEX = @DBLATEX@
+DEBUG_FLAGS = @DEBUG_FLAGS@
+DEFS = @DEFS@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+ERROR_CONSTANTS_SRCDIR = @ERROR_CONSTANTS_SRCDIR@
+EXEEXT = @EXEEXT@
+EXTRA_CFLAGS = @EXTRA_CFLAGS@
+EXTRA_CXX_FLAGS = @EXTRA_CXX_FLAGS@
+FGREP = @FGREP@
+GLIBCXX_INCLUDES = @GLIBCXX_INCLUDES@
+GLIBCXX_LIBS = @GLIBCXX_LIBS@
+GREP = @GREP@
+HWCAP_CFLAGS = @HWCAP_CFLAGS@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LONG_DOUBLE_COMPAT_FLAGS = @LONG_DOUBLE_COMPAT_FLAGS@
+LTLIBICONV = @LTLIBICONV@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OPTIMIZE_CXXFLAGS = @OPTIMIZE_CXXFLAGS@
+OPT_LDFLAGS = @OPT_LDFLAGS@
+OS_INC_SRCDIR = @OS_INC_SRCDIR@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PDFLATEX = @PDFLATEX@
+RANLIB = @RANLIB@
+SECTION_FLAGS = @SECTION_FLAGS@
+SECTION_LDFLAGS = @SECTION_LDFLAGS@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+SYMVER_FILE = @SYMVER_FILE@
+TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@
+USE_NLS = @USE_NLS@
+VERSION = @VERSION@
+VTV_CXXFLAGS = @VTV_CXXFLAGS@
+VTV_CXXLINKFLAGS = @VTV_CXXLINKFLAGS@
+VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
+WARN_FLAGS = @WARN_FLAGS@
+XMLCATALOG = @XMLCATALOG@
+XMLLINT = @XMLLINT@
+XSLTPROC = @XSLTPROC@
+XSL_STYLE_DIR = @XSL_STYLE_DIR@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__leading_dot = @am__leading_dot@
+am__tar = @am__tar@
+am__untar = @am__untar@
+baseline_dir = @baseline_dir@
+baseline_subdir_switch = @baseline_subdir_switch@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+check_msgfmt = @check_msgfmt@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_shared = @enable_shared@
+enable_static = @enable_static@
+exec_prefix = @exec_prefix@
+get_gcc_base_ver = @get_gcc_base_ver@
+glibcxx_MOFILES = @glibcxx_MOFILES@
+glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@
+glibcxx_POFILES = @glibcxx_POFILES@
+glibcxx_builddir = @glibcxx_builddir@
+glibcxx_compiler_pic_flag = @glibcxx_compiler_pic_flag@
+glibcxx_compiler_shared_flag = @glibcxx_compiler_shared_flag@
+glibcxx_cxx98_abi = @glibcxx_cxx98_abi@
+glibcxx_localedir = @glibcxx_localedir@
+glibcxx_lt_pic_flag = @glibcxx_lt_pic_flag@
+glibcxx_prefixdir = @glibcxx_prefixdir@
+glibcxx_srcdir = @glibcxx_srcdir@
+glibcxx_toolexecdir = @glibcxx_toolexecdir@
+glibcxx_toolexeclibdir = @glibcxx_toolexeclibdir@
+gxx_include_dir = @gxx_include_dir@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+libtool_VERSION = @libtool_VERSION@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_host_flags = @lt_host_flags@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+multi_basedir = @multi_basedir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+port_specific_symbol_files = @port_specific_symbol_files@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+python_mod_dir = @python_mod_dir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+thread_header = @thread_header@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+toplevel_builddir = @toplevel_builddir@
+toplevel_srcdir = @toplevel_srcdir@
+
+# May be used by various substitution variables.
+gcc_version := $(shell @get_gcc_base_ver@ $(top_srcdir)/../gcc/BASE-VER)
+MAINT_CHARSET = latin1
+mkinstalldirs = $(SHELL) $(toplevel_srcdir)/mkinstalldirs
+PWD_COMMAND = $${PWDCMD-pwd}
+STAMP = echo timestamp >
+toolexecdir = $(glibcxx_toolexecdir)
+toolexeclibdir = $(glibcxx_toolexeclibdir)
+@ENABLE_WERROR_FALSE@WERROR_FLAG = 
+@ENABLE_WERROR_TRUE@WERROR_FLAG = -Werror
+@ENABLE_EXTERN_TEMPLATE_FALSE@XTEMPLATE_FLAGS = 
+@ENABLE_EXTERN_TEMPLATE_TRUE@XTEMPLATE_FLAGS = -fno-implicit-templates
+
+# These bits are all figured out from configure.  Look in acinclude.m4
+# or configure.ac to see how they are set.  See GLIBCXX_EXPORT_FLAGS.
+CONFIG_CXXFLAGS = \
+	$(SECTION_FLAGS) $(HWCAP_CFLAGS) -frandom-seed=$@
+
+WARN_CXXFLAGS = \
+	$(WARN_FLAGS) $(WERROR_FLAG) -fdiagnostics-show-location=once 
+
+
+# -I/-D flags to pass when compiling.
+AM_CPPFLAGS = $(GLIBCXX_INCLUDES) $(CPPFLAGS)
+
+# Convenience library for C++17 runtime.
+noinst_LTLIBRARIES = libc++17convenience.la
+headers = 
+@ENABLE_DUAL_ABI_FALSE@extra_string_inst_sources = 
+@ENABLE_DUAL_ABI_TRUE@extra_string_inst_sources = cow-string-inst.cc
+@ENABLE_DUAL_ABI_FALSE@extra_fs_sources = 
+@ENABLE_DUAL_ABI_TRUE@extra_fs_sources = \
+@ENABLE_DUAL_ABI_TRUE@	cow-fs_dir.cc \
+@ENABLE_DUAL_ABI_TRUE@	cow-fs_ops.cc \
+@ENABLE_DUAL_ABI_TRUE@	cow-fs_path.cc
+
+# XTEMPLATE_FLAGS =
+@ENABLE_EXTERN_TEMPLATE_FALSE@inst_sources = 
+
+# XTEMPLATE_FLAGS = -fno-implicit-templates
+@ENABLE_EXTERN_TEMPLATE_TRUE@inst_sources = \
+@ENABLE_EXTERN_TEMPLATE_TRUE@	ostream-inst.cc \
+@ENABLE_EXTERN_TEMPLATE_TRUE@	string-inst.cc \
+@ENABLE_EXTERN_TEMPLATE_TRUE@	$(extra_string_inst_sources)
+
+sources = \
+	fs_dir.cc \
+	fs_ops.cc \
+	fs_path.cc \
+	memory_resource.cc \
+	$(extra_fs_sources)
+
+libc__17convenience_la_SOURCES = $(sources)  $(inst_sources)
+
+# AM_CXXFLAGS needs to be in each subdirectory so that it can be
+# modified in a per-library or per-sub-library way.  Need to manually
+# set this option because CONFIG_CXXFLAGS has to be after
+# OPTIMIZE_CXXFLAGS on the compile line so that -O2 can be overridden
+# as the occasion calls for it.
+AM_CXXFLAGS = \
+	-std=gnu++17 \
+	$(glibcxx_lt_pic_flag) $(glibcxx_compiler_shared_flag) \
+	$(XTEMPLATE_FLAGS) $(VTV_CXXFLAGS) \
+	$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS) $(CONFIG_CXXFLAGS) \
+	-fimplicit-templates
+
+AM_MAKEFLAGS = \
+	"gxx_include_dir=$(gxx_include_dir)"
+
+
+# Libtool notes
+
+# 1) In general, libtool expects an argument such as `--tag=CXX' when
+# using the C++ compiler, because that will enable the settings
+# detected when C++ support was being configured.  However, when no
+# such flag is given in the command line, libtool attempts to figure
+# it out by matching the compiler name in each configuration section
+# against a prefix of the command line.  The problem is that, if the
+# compiler name and its initial flags stored in the libtool
+# configuration file don't match those in the command line, libtool
+# can't decide which configuration to use, and it gives up.  The
+# correct solution is to add `--tag CXX' to LTCXXCOMPILE and maybe
+# CXXLINK, just after $(LIBTOOL), so that libtool doesn't have to
+# attempt to infer which configuration to use.
+#
+# The second tag argument, `--tag disable-shared` means that libtool
+# only compiles each source once, for static objects. In actuality,
+# glibcxx_lt_pic_flag and glibcxx_compiler_shared_flag are added to
+# the libtool command that is used create the object, which is
+# suitable for shared libraries.  The `--tag disable-shared` must be
+# placed after --tag CXX lest things CXX undo the affect of
+# disable-shared.
+
+# 2) Need to explicitly set LTCXXCOMPILE so that EXTRA_CXX_FLAGS is
+# last. (That way, things like -O2 passed down from the toplevel can
+# be overridden by --enable-debug.)
+LTCXXCOMPILE = \
+	$(LIBTOOL) --tag CXX --tag disable-shared \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CXX) $(TOPLEVEL_INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) $(EXTRA_CXX_FLAGS)
+
+LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))
+
+# 3) We'd have a problem when building the shared libstdc++ object if
+# the rules automake generates would be used.  We cannot allow g++ to
+# be used since this would add -lstdc++ to the link line which of
+# course is problematic at this point.  So, we get the top-level
+# directory to configure libstdc++-v3 to use gcc as the C++
+# compilation driver.
+CXXLINK = \
+	$(LIBTOOL) --tag CXX --tag disable-shared \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CXX) \
+	$(VTV_CXXLINKFLAGS) \
+	$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .cc .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/fragment.am $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign --ignore-deps src/c++17/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign --ignore-deps src/c++17/Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+$(top_srcdir)/fragment.am $(am__empty):
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; \
+	locs=`for p in $$list; do echo $$p; done | \
+	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
+	      sort -u`; \
+	test -z "$$locs" || { \
+	  echo rm -f $${locs}; \
+	  rm -f $${locs}; \
+	}
+
+libc++17convenience.la: $(libc__17convenience_la_OBJECTS) $(libc__17convenience_la_DEPENDENCIES) $(EXTRA_libc__17convenience_la_DEPENDENCIES) 
+	$(AM_V_CXXLD)$(CXXLINK)  $(libc__17convenience_la_OBJECTS) $(libc__17convenience_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+.cc.o:
+	$(AM_V_CXX)$(CXXCOMPILE) -c -o $@ $<
+
+.cc.obj:
+	$(AM_V_CXX)$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+
+.cc.lo:
+	$(AM_V_CXX)$(LTCXXCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
+
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	set x; \
+	here=`pwd`; \
+	$(am__define_uniq_tagged_files); \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES cscopelist-am ctags \
+	ctags-am distclean distclean-compile distclean-generic \
+	distclean-libtool distclean-tags dvi dvi-am html html-am info \
+	info-am install install-am install-data install-data-am \
+	install-dvi install-dvi-am install-exec install-exec-am \
+	install-html install-html-am install-info install-info-am \
+	install-man install-pdf install-pdf-am install-ps \
+	install-ps-am install-strip installcheck installcheck-am \
+	installdirs maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \
+	uninstall-am
+
+.PRECIOUS: Makefile
+
+
+vpath % $(top_srcdir)/src/c++17
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: libstdc++-v3/src/Makefile.in
===================================================================
--- a/src/libstdc++-v3/src/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/src/Makefile.in	(.../branches/gcc-7-branch)
@@ -267,6 +267,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
@@ -992,7 +993,7 @@
 	fi; \
 	echo `date` > stamp-libstdc++convenience;
 stamp-debug:
-	if test ! -d ${debugdir}; then \
+	if test ! -d ${debugdir} || test ! -f ${debugdir}/Makefile ; then \
 	  mkdir -p ${debugdir}; \
 	  for d in $(SUBDIRS); do mkdir -p  ${debugdir}/$$d; done; \
 	  (cd ${debugdir}; \
Index: libstdc++-v3/src/filesystem/path.cc
===================================================================
--- a/src/libstdc++-v3/src/filesystem/path.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/src/filesystem/path.cc	(.../branches/gcc-7-branch)
@@ -333,6 +333,28 @@
   if (_M_pathname.empty())
     return;
 
+  {
+    // Approximate count of components, to reserve space in _M_cmpts vector:
+    int count = 1;
+    bool saw_sep_last = _S_is_dir_sep(_M_pathname[0]);
+    bool saw_non_sep = !saw_sep_last;
+    for (value_type c : _M_pathname)
+      {
+       if (_S_is_dir_sep(c))
+         saw_sep_last = true;
+       else if (saw_sep_last)
+         {
+           ++count;
+           saw_sep_last = false;
+           saw_non_sep = true;
+         }
+      }
+    if (saw_non_sep && saw_sep_last)
+      ++count; // empty filename after trailing slash
+    if (count > 1)
+      _M_cmpts.reserve(count);
+  }
+
   size_t pos = 0;
   const size_t len = _M_pathname.size();
 
@@ -355,9 +377,13 @@
 	      pos = 3;
 	      while (pos < len && !_S_is_dir_sep(_M_pathname[pos]))
 		++pos;
+	      if (pos == len)
+		{
+		  _M_type = _Type::_Root_name;
+		  return;
+		}
 	      _M_add_root_name(pos);
-	      if (pos < len) // also got root directory
-		_M_add_root_dir(pos);
+	      _M_add_root_dir(pos);
 	    }
 	  else
 	    {
@@ -366,6 +392,11 @@
 	      _M_add_root_dir(0);
 	    }
 	}
+      else if (len == 1) // got root directory only
+	{
+	  _M_type = _Type::_Root_dir;
+	  return;
+	}
       else // got root directory
 	_M_add_root_dir(0);
       ++pos;
@@ -374,6 +405,11 @@
   else if (len > 1 && _M_pathname[1] == L':')
     {
       // got disk designator
+      if (len == 2)
+	{
+	  _M_type = _Type::_Root_name;
+	  return;
+	}
       _M_add_root_name(2);
       if (len > 2 && _S_is_dir_sep(_M_pathname[2]))
 	_M_add_root_dir(2);
@@ -380,6 +416,17 @@
       pos = 2;
     }
 #endif
+  else
+    {
+      size_t n = 1;
+      for (; n < _M_pathname.size() && !_S_is_dir_sep(_M_pathname[n]); ++n)
+	{ }
+      if (n == _M_pathname.size())
+	{
+	  _M_type = _Type::_Filename;
+	  return;
+	}
+    }
 
   size_t back = pos;
   while (pos < len)
Index: libstdc++-v3/src/filesystem/Makefile.in
===================================================================
--- a/src/libstdc++-v3/src/filesystem/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/src/filesystem/Makefile.in	(.../branches/gcc-7-branch)
@@ -246,6 +246,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/src/Makefile.am
===================================================================
--- a/src/libstdc++-v3/src/Makefile.am	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/src/Makefile.am	(.../branches/gcc-7-branch)
@@ -321,7 +321,7 @@
 # Take care to fix all possibly-relative paths.
 debugdir = ${glibcxx_builddir}/src/debug
 stamp-debug:
-	if test ! -d ${debugdir}; then \
+	if test ! -d ${debugdir} || test ! -f ${debugdir}/Makefile ; then \
 	  mkdir -p ${debugdir}; \
 	  for d in $(SUBDIRS); do mkdir -p  ${debugdir}/$$d; done; \
 	  (cd ${debugdir}; \
Index: libstdc++-v3/src/c++98/Makefile.in
===================================================================
--- a/src/libstdc++-v3/src/c++98/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/src/c++98/Makefile.in	(.../branches/gcc-7-branch)
@@ -238,6 +238,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/src/c++11/Makefile.in
===================================================================
--- a/src/libstdc++-v3/src/c++11/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/src/c++11/Makefile.in	(.../branches/gcc-7-branch)
@@ -242,6 +242,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/configure.host
===================================================================
--- a/src/libstdc++-v3/configure.host	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/configure.host	(.../branches/gcc-7-branch)
@@ -230,16 +230,15 @@
     os_include_dir="os/newlib"
     OPT_LDFLAGS="${OPT_LDFLAGS} \$(lt_host_flags)"
     ;;
-  darwin | darwin[1-7] | darwin[1-7].*)
-    # On Darwin, performance is improved if libstdc++ is single-module.
-    # Up to at least 10.3.7, -flat_namespace is required for proper
-    # treatment of coalesced symbols.
+  darwin[4-7] | darwin[4-7].*)
+    # For earlier Darwin, performance is improved if libstdc++ is
+    # single-module. Up to at least 10.3.7, -flat_namespace is required
+    # for proper treatment of coalesced symbols.
     OPT_LDFLAGS="${OPT_LDFLAGS} -Wl,-single_module -Wl,-flat_namespace"
     os_include_dir="os/bsd/darwin"
     ;;
-  darwin[89] | darwin[89].* | darwin[1-9][0-9]* )
-    # On Darwin, performance is improved if libstdc++ is single-module,
-    # and on 8+ compatibility is better if not -flat_namespace.
+  darwin8 | darwin8.* )
+    # For 8+ compatibility is better if not -flat_namespace.
     OPT_LDFLAGS="${OPT_LDFLAGS} -Wl,-single_module"
     case "${host_cpu}" in
       i[34567]86 | x86_64)
@@ -248,6 +247,10 @@
     esac
     os_include_dir="os/bsd/darwin"
     ;;
+  darwin*)
+    # Post Darwin8, defaults should be sufficient.
+    os_include_dir="os/bsd/darwin"
+    ;;
   *djgpp*)      # leading * picks up "msdosdjgpp"
     os_include_dir="os/djgpp"
     error_constants_dir="os/djgpp"
Index: libstdc++-v3/configure.ac
===================================================================
--- a/src/libstdc++-v3/configure.ac	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/configure.ac	(.../branches/gcc-7-branch)
@@ -436,6 +436,7 @@
 AC_CHECK_PROG([DOT], dot, yes, no)
 
 # Check for docbook
+AC_CHECK_PROG([XMLCATALOG], xmlcatalog, yes, no)
 AC_CHECK_PROG([XSLTPROC], xsltproc, yes, no)
 AC_CHECK_PROG([XMLLINT], xmllint, yes, no)
 GLIBCXX_CONFIGURE_DOCBOOK
Index: libstdc++-v3/doc/xml/manual/allocator.xml
===================================================================
--- a/src/libstdc++-v3/doc/xml/manual/allocator.xml	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/doc/xml/manual/allocator.xml	(.../branches/gcc-7-branch)
@@ -502,12 +502,12 @@
   </biblioentry>
 
   <biblioentry>
-      <title>
-	<link xmlns:xlink="http://www.w3.org/1999/xlink"
-	      xlink:href="http://www.drdobbs.com/the-standard-librarian-what-are-allocato/184403759">
+    <title>
+      <link xmlns:xlink="http://www.w3.org/1999/xlink"
+	    xlink:href="https://web.archive.org/web/20190622154249/http://www.drdobbs.com/the-standard-librarian-what-are-allocato/184403759">
       The Standard Librarian: What Are Allocators Good For?
-	</link>
-      </title>
+      </link>
+    </title>
 
     <author><personname><firstname>Matt</firstname><surname>Austern</surname></personname></author>
     <publisher>
@@ -515,12 +515,13 @@
 	C/C++ Users Journal
       </publishername>
     </publisher>
+    <pubdate>2000-12</pubdate>
   </biblioentry>
 
   <biblioentry>
       <title>
 	<link xmlns:xlink="http://www.w3.org/1999/xlink"
-	      xlink:href="http://www.hoard.org/">
+	      xlink:href="http://hoard.org">
       The Hoard Memory Allocator
 	</link>
       </title>
Index: libstdc++-v3/doc/xml/manual/shared_ptr.xml
===================================================================
--- a/src/libstdc++-v3/doc/xml/manual/shared_ptr.xml	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/doc/xml/manual/shared_ptr.xml	(.../branches/gcc-7-branch)
@@ -239,7 +239,7 @@
    <orderedlist>
      <listitem>
        <para>
-       <constant>_S_Atomic</constant>
+       <constant>_S_atomic</constant>
        </para>
        <para>
 Selected when GCC supports a builtin atomic compare-and-swap operation
@@ -252,7 +252,7 @@
 
      <listitem>
        <para>
-       <constant>_S_Mutex</constant>
+       <constant>_S_mutex</constant>
        </para>
        <para>
 The _Sp_counted_base specialization for this policy contains a mutex,
@@ -263,7 +263,7 @@
 
      <listitem>
        <para>
-       <constant>_S_Single</constant>
+       <constant>_S_single</constant>
        </para>
        <para>
 This policy uses a non-reentrant add_ref_lock() with no locking. It is
Index: libstdc++-v3/doc/xml/manual/status_cxx2017.xml
===================================================================
--- a/src/libstdc++-v3/doc/xml/manual/status_cxx2017.xml	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/doc/xml/manual/status_cxx2017.xml	(.../branches/gcc-7-branch)
@@ -24,8 +24,8 @@
 </para>
 
 <para>
-The following table lists new library features that have been accepted into
-the C++17 working draft. The "Proposal" column provides a link to the
+The following table lists new library features that are included in
+the C++17 standard. The "Proposal" column provides a link to the
 ISO C++ committee proposal that describes the feature, while the "Status"
 column indicates the first version of GCC that contains an implementation of
 this feature (if it has been implemented).
@@ -381,7 +381,7 @@
 	</link>
       </entry>
       <entry align="center"> 7.1 </entry>
-      <entry><code> </code></entry>
+      <entry><code>__cpp_lib_raw_memory_algorithms &gt;= 201606L</code></entry>
     </row>
 
     <row>
@@ -789,7 +789,32 @@
              <code> __cpp_lib_to_chars >= 201611 </code></entry>
     </row>
 
+    <row>
+      <entry> Homogeneous interface for variant, any and optional </entry>
+      <entry>
+	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0032r3.pdf">
+	P0032R3
+	</link>
+      </entry>
+      <entry align="center"> 7.1  </entry>
+      <entry>
+             <code> __cpp_lib_any >= 201606 </code>,
+             <code> __cpp_lib_optional >= 201606 </code>,
+             <code> __cpp_lib_variant >= 201606 </code>
+      </entry>
+    </row>
 
+    <row>
+      <entry> Making Optional Greater Equal Again </entry>
+      <entry>
+	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0307r2.pdf">
+	P0307R2
+	</link>
+      </entry>
+      <entry align="center"> 7.1  </entry>
+      <entry> <code> __cpp_lib_optional >= 201606 </code> </entry>
+    </row>
+
   </tbody>
 </tgroup>
 </table>
Index: libstdc++-v3/doc/xml/manual/documentation_hacking.xml
===================================================================
--- a/src/libstdc++-v3/doc/xml/manual/documentation_hacking.xml	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/doc/xml/manual/documentation_hacking.xml	(.../branches/gcc-7-branch)
@@ -805,7 +805,7 @@
       </para>
 
       <para>
-	Generated files are output into separate sub directores of
+	Generated files are output into separate sub-directores of
 	<filename class="directory">doc/docbook/</filename> in the
 	build directory, based on the output format. For instance, the
 	HTML docs will be in <filename
@@ -813,6 +813,13 @@
       </para>
 
       <para>
+	The <screen>doc-html-docbook-regenerate</screen> target will generate
+	the HTML files and copy them back to the libstdc++ source tree.
+	This can be used to update the HTML files that are checked in to
+	version control.
+      </para>
+
+      <para>
 	If the Docbook stylesheets are installed in a custom location,
 	one can use the variable <literal>XSL_STYLE_DIR</literal> to
 	override the Makefile defaults. For example:
Index: libstdc++-v3/doc/Makefile.in
===================================================================
--- a/src/libstdc++-v3/doc/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/doc/Makefile.in	(.../branches/gcc-7-branch)
@@ -204,6 +204,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 
 # Validate existing XML structure.
 XMLLINT = xmllint
@@ -925,7 +926,6 @@
 
 ${docbook_outdir}/html:
 	mkdir -p ${docbook_outdir}/html
-	mkdir -p ${docbook_outdir}/html/ext
 	mkdir -p ${docbook_outdir}/html/images
 	mkdir -p ${docbook_outdir}/html/manual
 
@@ -977,6 +977,12 @@
 	$(STAMP) stamp-html-docbook
 
 doc-html-docbook: stamp-html-docbook-data
+
+# Generate the HTML pages and copy them back to the source tree.
+doc-html-docbook-regenerate: doc-html-docbook
+	$(INSTALL_DATA) ${docbook_outdir}/html/*.html ${top_srcdir}/doc/html
+	$(INSTALL_DATA) ${docbook_outdir}/html/images/* ${top_srcdir}/doc/html/images
+	$(INSTALL_DATA) ${docbook_outdir}/html/manual/*.html ${top_srcdir}/doc/html/manual
 stamp-html-single-docbook: $(xml_sources) ${docbook_outdir}/html
 	@echo "Generating html single file..."
 	$(XSLTPROC) $(XSLT_PARAM) $(XSLT_FLAGS) -o ${manual_html} \
Index: libstdc++-v3/doc/html/manual/status.html
===================================================================
--- a/src/libstdc++-v3/doc/html/manual/status.html	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/doc/html/manual/status.html	(.../branches/gcc-7-branch)
@@ -518,8 +518,8 @@
 </p><p>
 This section describes the C++17 and library TS support in the GCC 7 series.
 </p><p>
-The following table lists new library features that have been accepted into
-the C++17 working draft. The "Proposal" column provides a link to the
+The following table lists new library features that are included in
+the C++17 standard. The "Proposal" column provides a link to the
 ISO C++ committee proposal that describes the feature, while the "Status"
 column indicates the first version of GCC that contains an implementation of
 this feature (if it has been implemented).
@@ -657,7 +657,7 @@
 	<a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0040r3.html" target="_top">
 	P0040R3
 	</a>
-      </td><td align="center"> 7.1 </td><td align="left"><code class="code"> </code></td></tr><tr><td align="left"> <code class="code">shared_ptr::weak_type</code></td><td align="left">
+      </td><td align="center"> 7.1 </td><td align="left"><code class="code">__cpp_lib_raw_memory_algorithms &gt;= 201606L</code></td></tr><tr><td align="left"> <code class="code">shared_ptr::weak_type</code></td><td align="left">
 	<a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0163r0.html" target="_top">
 	P0163R0
 	</a>
@@ -811,7 +811,19 @@
 	P0067R5
 	</a>
       </td><td align="center"> 8 (only integral types supported) </td><td align="left"><code class="code"> __has_include(&lt;charconv&gt;) </code>
-             <code class="code"> __cpp_lib_to_chars &gt;= 201611 </code></td></tr></tbody></table></div></div><br class="table-break" /><p>
+             <code class="code"> __cpp_lib_to_chars &gt;= 201611 </code></td></tr><tr><td align="left"> Homogeneous interface for variant, any and optional </td><td align="left">
+	<a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0032r3.pdf" target="_top">
+	P0032R3
+	</a>
+      </td><td align="center"> 7.1  </td><td align="left">
+             <code class="code"> __cpp_lib_any &gt;= 201606 </code>,
+             <code class="code"> __cpp_lib_optional &gt;= 201606 </code>,
+             <code class="code"> __cpp_lib_variant &gt;= 201606 </code>
+      </td></tr><tr><td align="left"> Making Optional Greater Equal Again </td><td align="left">
+	<a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0307r2.pdf" target="_top">
+	P0307R2
+	</a>
+      </td><td align="center"> 7.1  </td><td align="left"> <code class="code"> __cpp_lib_optional &gt;= 201606 </code> </td></tr></tbody></table></div></div><br class="table-break" /><p>
 Note 1: This feature is supported in GCC 7.1 and 7.2 but before GCC 7.3 the
 <code class="code">__cpp_lib</code> macro is not defined, and compilation will fail if the
 header is included without using <code class="option">-std</code> to enable C++17 support.
Index: libstdc++-v3/doc/html/manual/memory.html
===================================================================
--- a/src/libstdc++-v3/doc/html/manual/memory.html	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/doc/html/manual/memory.html	(.../branches/gcc-7-branch)
@@ -314,13 +314,13 @@
     </em>. </span>
       isoc++_1998
     <span class="pagenums">20.4 Memory. </span></p></div><div class="biblioentry"><a id="id-1.3.4.4.4.3.9.3"></a><p><span class="title"><em>
-	<a class="link" href="http://www.drdobbs.com/the-standard-librarian-what-are-allocato/184403759" target="_top">
+      <a class="link" href="https://web.archive.org/web/20190622154249/http://www.drdobbs.com/the-standard-librarian-what-are-allocato/184403759" target="_top">
       The Standard Librarian: What Are Allocators Good For?
-	</a>
-      </em>. </span><span class="author"><span class="firstname">Matt</span> <span class="surname">Austern</span>. </span><span class="publisher"><span class="publishername">
+      </a>
+    </em>. </span><span class="author"><span class="firstname">Matt</span> <span class="surname">Austern</span>. </span><span class="publisher"><span class="publishername">
 	C/C++ Users Journal
-      . </span></span></p></div><div class="biblioentry"><a id="id-1.3.4.4.4.3.9.4"></a><p><span class="title"><em>
-	<a class="link" href="http://www.hoard.org/" target="_top">
+      . </span></span><span class="pubdate">2000-12. </span></p></div><div class="biblioentry"><a id="id-1.3.4.4.4.3.9.4"></a><p><span class="title"><em>
+	<a class="link" href="http://hoard.org" target="_top">
       The Hoard Memory Allocator
 	</a>
       </em>. </span><span class="author"><span class="firstname">Emery</span> <span class="surname">Berger</span>. </span></p></div><div class="biblioentry"><a id="id-1.3.4.4.4.3.9.5"></a><p><span class="title"><em>
@@ -554,7 +554,7 @@
 extra template parameter, even if it had a default value.  The
 available policies are:
     </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
-       <code class="constant">_S_Atomic</code>
+       <code class="constant">_S_atomic</code>
        </p><p>
 Selected when GCC supports a builtin atomic compare-and-swap operation
 on the target processor (see <a class="link" href="http://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html" target="_top">Atomic
@@ -562,13 +562,13 @@
 algorithm and GCC's atomic builtins, which provide the required memory
 synchronisation.
        </p></li><li class="listitem"><p>
-       <code class="constant">_S_Mutex</code>
+       <code class="constant">_S_mutex</code>
        </p><p>
 The _Sp_counted_base specialization for this policy contains a mutex,
 which is locked in add_ref_lock(). This policy is used when GCC's atomic
 builtins aren't available so explicit memory barriers are needed in places.
        </p></li><li class="listitem"><p>
-       <code class="constant">_S_Single</code>
+       <code class="constant">_S_single</code>
        </p><p>
 This policy uses a non-reentrant add_ref_lock() with no locking. It is
 used when libstdc++ is built without <code class="literal">--enable-threads</code>.
Index: libstdc++-v3/doc/html/manual/documentation_hacking.html
===================================================================
--- a/src/libstdc++-v3/doc/html/manual/documentation_hacking.html	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/doc/html/manual/documentation_hacking.html	(.../branches/gcc-7-branch)
@@ -381,11 +381,16 @@
       </p><p>
       </p><pre class="screen"><strong class="userinput"><code>make doc-xml-single-docbook</code></strong></pre><p>
       </p><p>
-	Generated files are output into separate sub directores of
+	Generated files are output into separate sub-directores of
 	<code class="filename">doc/docbook/</code> in the
 	build directory, based on the output format. For instance, the
 	HTML docs will be in <code class="filename">doc/docbook/html</code>.
       </p><p>
+	The </p><pre class="screen">doc-html-docbook-regenerate</pre><p> target will generate
+	the HTML files and copy them back to the libstdc++ source tree.
+	This can be used to update the HTML files that are checked in to
+	version control.
+      </p><p>
 	If the Docbook stylesheets are installed in a custom location,
 	one can use the variable <code class="literal">XSL_STYLE_DIR</code> to
 	override the Makefile defaults. For example:
Index: libstdc++-v3/doc/Makefile.am
===================================================================
--- a/src/libstdc++-v3/doc/Makefile.am	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/doc/Makefile.am	(.../branches/gcc-7-branch)
@@ -477,7 +477,6 @@
 
 ${docbook_outdir}/html:
 	mkdir -p ${docbook_outdir}/html
-	mkdir -p ${docbook_outdir}/html/ext
 	mkdir -p ${docbook_outdir}/html/images
 	mkdir -p ${docbook_outdir}/html/manual
 
@@ -546,6 +545,12 @@
 
 doc-html-docbook: stamp-html-docbook-data
 
+# Generate the HTML pages and copy them back to the source tree.
+doc-html-docbook-regenerate: doc-html-docbook
+	$(INSTALL_DATA) ${docbook_outdir}/html/*.html ${top_srcdir}/doc/html
+	$(INSTALL_DATA) ${docbook_outdir}/html/images/* ${top_srcdir}/doc/html/images
+	$(INSTALL_DATA) ${docbook_outdir}/html/manual/*.html ${top_srcdir}/doc/html/manual
+
 # HTML, all one page
 # NB: Have to generate customization XSL for UTF-8 output.
 manual_html = ${docbook_outdir}/html/libstdc++-manual-single.html
Index: libstdc++-v3/po/Makefile.in
===================================================================
--- a/src/libstdc++-v3/po/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/po/Makefile.in	(.../branches/gcc-7-branch)
@@ -204,6 +204,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/include/Makefile.in
===================================================================
--- a/src/libstdc++-v3/include/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/include/Makefile.in	(.../branches/gcc-7-branch)
@@ -204,6 +204,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/include/std/optional
===================================================================
--- a/src/libstdc++-v3/include/std/optional	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/include/std/optional	(.../branches/gcc-7-branch)
@@ -51,7 +51,7 @@
    *  @{
    */
 
-#define __cpp_lib_optional 201603
+#define __cpp_lib_optional 201606L
 
   template<typename _Tp>
     class optional;
Index: libstdc++-v3/include/std/any
===================================================================
--- a/src/libstdc++-v3/include/std/any	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/include/std/any	(.../branches/gcc-7-branch)
@@ -66,7 +66,7 @@
 #endif
   }
 
-#define __cpp_lib_any 201603
+#define __cpp_lib_any 201606L
 
   /**
    *  @brief A type-safe container of any type.
@@ -513,20 +513,34 @@
     }
   // @}
 
+  /// @cond undocumented
   template<typename _Tp>
     void* __any_caster(const any* __any)
     {
-      if constexpr (is_copy_constructible_v<decay_t<_Tp>>)
+      // any_cast<T> returns non-null if __any->type() == typeid(T) and
+      // typeid(T) ignores cv-qualifiers so remove them:
+      using _Up = remove_cv_t<_Tp>;
+      // The contained value has a decayed type, so if decay_t<U> is not U,
+      // then it's not possible to have a contained value of type U:
+      if constexpr (!is_same_v<decay_t<_Up>, _Up>)
+	return nullptr;
+      // Only copy constructible types can be used for contained values:
+      else if constexpr (!is_copy_constructible_v<_Up>)
+	return nullptr;
+      // First try comparing function addresses, which works without RTTI
+      else if (__any->_M_manager == &any::_Manager<_Up>::_S_manage
+#if __cpp_rtti
+	  || __any->type() == typeid(_Tp)
+#endif
+	  )
 	{
-	  if (__any->_M_manager == &any::_Manager<decay_t<_Tp>>::_S_manage)
-	    {
-	      any::_Arg __arg;
-	      __any->_M_manager(any::_Op_access, __any, &__arg);
-	      return __arg._M_obj;
-	    }
+	  any::_Arg __arg;
+	  __any->_M_manager(any::_Op_access, __any, &__arg);
+	  return __arg._M_obj;
 	}
       return nullptr;
     }
+  /// @endcond
 
   /**
    * @brief Access the contained object.
@@ -542,8 +556,9 @@
   template<typename _ValueType>
     inline const _ValueType* any_cast(const any* __any) noexcept
     {
-      if (__any)
-	return static_cast<_ValueType*>(__any_caster<_ValueType>(__any));
+      if constexpr (is_object_v<_ValueType>)
+	if (__any)
+	  return static_cast<_ValueType*>(__any_caster<_ValueType>(__any));
       return nullptr;
     }
 
@@ -550,8 +565,9 @@
   template<typename _ValueType>
     inline _ValueType* any_cast(any* __any) noexcept
     {
-      if (__any)
-	return static_cast<_ValueType*>(__any_caster<_ValueType>(__any));
+      if constexpr (is_object_v<_ValueType>)
+	if (__any)
+	  return static_cast<_ValueType*>(__any_caster<_ValueType>(__any));
       return nullptr;
     }
   // @}
Index: libstdc++-v3/include/std/variant
===================================================================
--- a/src/libstdc++-v3/include/std/variant	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/include/std/variant	(.../branches/gcc-7-branch)
@@ -71,7 +71,7 @@
 
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-#define __cpp_lib_variant 201603
+#define __cpp_lib_variant 201606L
 
   template<typename... _Types> class tuple;
   template<typename... _Types> class variant;
Index: libstdc++-v3/include/experimental/any
===================================================================
--- a/src/libstdc++-v3/include/experimental/any	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/include/experimental/any	(.../branches/gcc-7-branch)
@@ -300,7 +300,8 @@
     _Storage _M_storage;
 
     template<typename _Tp>
-      friend void* __any_caster(const any* __any);
+      friend enable_if_t<is_object<_Tp>::value, void*>
+      __any_caster(const any* __any);
 
     // Manage in-place contained object.
     template<typename _Tp>
@@ -410,19 +411,45 @@
     }
   // @}
 
+  /// @cond undocumented
   template<typename _Tp>
-    void* __any_caster(const any* __any)
+    enable_if_t<is_object<_Tp>::value, void*>
+    __any_caster(const any* __any)
     {
-      struct _None { };
-      using _Up = decay_t<_Tp>;
-      using _Vp = conditional_t<is_copy_constructible<_Up>::value, _Up, _None>;
-      if (__any->_M_manager != &any::_Manager<_Vp>::_S_manage)
-	return nullptr;
-      any::_Arg __arg;
-      __any->_M_manager(any::_Op_access, __any, &__arg);
-      return __arg._M_obj;
+      // any_cast<T> returns non-null if __any->type() == typeid(T) and
+      // typeid(T) ignores cv-qualifiers so remove them:
+      using _Up = remove_cv_t<_Tp>;
+      // The contained value has a decayed type, so if decay_t<U> is not U,
+      // then it's not possible to have a contained value of type U.
+      using __does_not_decay = is_same<decay_t<_Up>, _Up>;
+      // Only copy constructible types can be used for contained values.
+      using __is_copyable = is_copy_constructible<_Up>;
+      // If the type _Tp could never be stored in an any we don't want to
+      // instantiate _Manager<_Tp>, so use _Manager<any::_Op> instead, which
+      // is explicitly specialized and has a no-op _S_manage function.
+      using _Vp = conditional_t<__and_<__does_not_decay, __is_copyable>::value,
+				_Up, any::_Op>;
+      // First try comparing function addresses, which works without RTTI
+      if (__any->_M_manager == &any::_Manager<_Vp>::_S_manage
+#if __cpp_rtti
+	  || __any->type() == typeid(_Tp)
+#endif
+	  )
+	{
+	  any::_Arg __arg;
+	  __any->_M_manager(any::_Op_access, __any, &__arg);
+	  return __arg._M_obj;
+	}
+      return nullptr;
     }
 
+  // This overload exists so that std::any_cast<void(*)()>(a) is well-formed.
+  template<typename _Tp>
+    enable_if_t<!is_object<_Tp>::value, _Tp*>
+    __any_caster(const any*) noexcept
+    { return nullptr; }
+  /// @endcond
+
   /**
    * @brief Access the contained object.
    *
@@ -517,6 +544,14 @@
       }
     }
 
+  // Dummy specialization used by __any_caster.
+  template<>
+    struct any::_Manager_internal<any::_Op>
+    {
+      static void
+      _S_manage(_Op, const any*, _Arg*) { }
+    };
+
   // @} group any
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace fundamentals_v1
Index: libstdc++-v3/include/experimental/bits/fs_path.h
===================================================================
--- a/src/libstdc++-v3/include/experimental/bits/fs_path.h	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/include/experimental/bits/fs_path.h	(.../branches/gcc-7-branch)
@@ -182,7 +182,8 @@
     path(path&& __p) noexcept
     : _M_pathname(std::move(__p._M_pathname)), _M_type(__p._M_type)
     {
-      _M_split_cmpts();
+      if (_M_type == _Type::_Multi)
+	_M_split_cmpts();
       __p.clear();
     }
 
@@ -456,7 +457,7 @@
 	return _S_convert_loc(__tmp.data(), __tmp.data()+__tmp.size(), __loc);
       }
 
-    bool _S_is_dir_sep(value_type __ch)
+    static bool _S_is_dir_sep(value_type __ch)
     {
 #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
       return __ch == L'/' || __ch == preferred_separator;
Index: libstdc++-v3/include/experimental/type_traits
===================================================================
--- a/src/libstdc++-v3/include/experimental/type_traits	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/include/experimental/type_traits	(.../branches/gcc-7-branch)
@@ -254,12 +254,12 @@
 template<typename _Default, template<typename...> class _Op, typename... _Args>
   using detected_or_t = typename detected_or<_Default, _Op, _Args...>::type;
 
-template<typename Expected, template<typename...> class _Op, typename... _Args>
-  using is_detected_exact = is_same<Expected, detected_t<_Op, _Args...>>;
+template<typename _Expected, template<typename...> class _Op, typename... _Args>
+  using is_detected_exact = is_same<_Expected, detected_t<_Op, _Args...>>;
 
-template<typename Expected, template<typename...> class _Op, typename... _Args>
+template<typename _Expected, template<typename...> class _Op, typename... _Args>
   constexpr bool is_detected_exact_v
-    = is_detected_exact<Expected, _Op, _Args...>::value;
+    = is_detected_exact<_Expected, _Op, _Args...>::value;
 
 template<typename _To, template<typename...> class _Op, typename... _Args>
   using is_detected_convertible
Index: libstdc++-v3/include/bits/unique_ptr.h
===================================================================
--- a/src/libstdc++-v3/include/bits/unique_ptr.h	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/include/bits/unique_ptr.h	(.../branches/gcc-7-branch)
@@ -171,14 +171,9 @@
       // unique_ptr
       template<typename _Up, typename _Ep>
 	using __safe_conversion_up = __and_<
-	        is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
-                __not_<is_array<_Up>>,
-                __or_<__and_<is_reference<deleter_type>,
-                             is_same<deleter_type, _Ep>>,
-                      __and_<__not_<is_reference<deleter_type>>,
-                             is_convertible<_Ep, deleter_type>>
-                >
-              >;
+	  is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
+	  __not_<is_array<_Up>>
+        >;
 
       // Constructors.
 
@@ -419,16 +414,14 @@
       // helper template for detecting a safe conversion from another
       // unique_ptr
       template<typename _Up, typename _Ep,
-               typename _Up_up = unique_ptr<_Up, _Ep>,
-	       typename _Up_element_type = typename _Up_up::element_type>
+               typename _UPtr = unique_ptr<_Up, _Ep>,
+	       typename _UP_pointer = typename _UPtr::pointer,
+	       typename _UP_element_type = typename _UPtr::element_type>
 	using __safe_conversion_up = __and_<
           is_array<_Up>,
           is_same<pointer, element_type*>,
-          is_same<typename _Up_up::pointer, _Up_element_type*>,
-          is_convertible<_Up_element_type(*)[], element_type(*)[]>,
-          __or_<__and_<is_reference<deleter_type>, is_same<deleter_type, _Ep>>,
-                __and_<__not_<is_reference<deleter_type>>,
-                       is_convertible<_Ep, deleter_type>>>
+          is_same<_UP_pointer, _UP_element_type*>,
+          is_convertible<_UP_element_type(*)[], element_type(*)[]>
         >;
 
       // helper template for detecting a safe conversion from a raw pointer
@@ -513,8 +506,11 @@
 		typename = _DeleterConstraint<_Up>>
 	constexpr unique_ptr(nullptr_t) noexcept : _M_t() { }
 
-      template<typename _Up, typename _Ep,
-	       typename = _Require<__safe_conversion_up<_Up, _Ep>>>
+      template<typename _Up, typename _Ep, typename = _Require<
+	       __safe_conversion_up<_Up, _Ep>,
+	       typename conditional<is_reference<_Dp>::value,
+				    is_same<_Ep, _Dp>,
+				    is_convertible<_Ep, _Dp>>::type>>
 	unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 	: _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 	{ }
Index: libstdc++-v3/include/bits/stl_uninitialized.h
===================================================================
--- a/src/libstdc++-v3/include/bits/stl_uninitialized.h	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/include/bits/stl_uninitialized.h	(.../branches/gcc-7-branch)
@@ -827,6 +827,8 @@
 #endif
 
 #if __cplusplus > 201402L
+# define __cpp_lib_raw_memory_algorithms 201606L
+
   template <typename _ForwardIterator>
     inline void
     uninitialized_default_construct(_ForwardIterator __first,
Index: libstdc++-v3/include/bits/char_traits.h
===================================================================
--- a/src/libstdc++-v3/include/bits/char_traits.h	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/include/bits/char_traits.h	(.../branches/gcc-7-branch)
@@ -246,7 +246,7 @@
     __constant_char_array_p(const _CharT* __a, size_t __n)
     {
       size_t __i = 0;
-      while (__builtin_constant_p(__a[__i]) && __i < __n)
+      while (__i < __n && __builtin_constant_p(__a[__i]))
 	__i++;
       return __i == __n;
     }
Index: libstdc++-v3/include/bits/forward_list.tcc
===================================================================
--- a/src/libstdc++-v3/include/bits/forward_list.tcc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/include/bits/forward_list.tcc	(.../branches/gcc-7-branch)
@@ -381,7 +381,7 @@
       auto __iy = __ly.cbegin();
       while (__ix != __lx.cend() && __iy != __ly.cend())
         {
-          if (*__ix != *__iy)
+          if (!(*__ix == *__iy))
             return false;
           ++__ix;
           ++__iy;
@@ -451,9 +451,9 @@
                         __p = static_cast<_Node*>(__p->_M_next);
                         --__psize;
                       }
-                    else if (__comp(*__p->_M_valptr(), *__q->_M_valptr()))
+                    else if (!__comp(*__q->_M_valptr(), *__p->_M_valptr()))
                       {
-                        // First node of p is lower; e must come from p.
+                        // First node of q is not lower; e must come from p.
                         __e = __p;
                         __p = static_cast<_Node*>(__p->_M_next);
                         --__psize;
Index: libstdc++-v3/include/bits/random.h
===================================================================
--- a/src/libstdc++-v3/include/bits/random.h	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/include/bits/random.h	(.../branches/gcc-7-branch)
@@ -5982,9 +5982,9 @@
     size_t size() const noexcept
     { return _M_v.size(); }
 
-    template<typename OutputIterator>
+    template<typename _OutputIterator>
       void
-      param(OutputIterator __dest) const
+      param(_OutputIterator __dest) const
       { std::copy(_M_v.begin(), _M_v.end(), __dest); }
 
     // no copy functions
Index: libstdc++-v3/libsupc++/Makefile.in
===================================================================
--- a/src/libstdc++-v3/libsupc++/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/libsupc++/Makefile.in	(.../branches/gcc-7-branch)
@@ -277,6 +277,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/libsupc++/guard_error.cc
===================================================================
--- a/src/libstdc++-v3/libsupc++/guard_error.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/libsupc++/guard_error.cc	(.../branches/gcc-7-branch)
@@ -26,6 +26,6 @@
 
 namespace __gnu_cxx
 {
-  recursive_init_error::~recursive_init_error() throw() { }
+  recursive_init_error::recursive_init_error() noexcept { }
+  recursive_init_error::~recursive_init_error() noexcept { }
 }
-
Index: libstdc++-v3/libsupc++/new_opa.cc
===================================================================
--- a/src/libstdc++-v3/libsupc++/new_opa.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/libsupc++/new_opa.cc	(.../branches/gcc-7-branch)
@@ -114,9 +114,10 @@
     sz = 1;
 
 #if _GLIBCXX_HAVE_ALIGNED_ALLOC
-# ifdef _AIX
+# if defined _AIX || defined __APPLE__
   /* AIX 7.2.0.0 aligned_alloc incorrectly has posix_memalign's requirement
-   * that alignment is a multiple of sizeof(void*).  */
+   * that alignment is a multiple of sizeof(void*).
+   * OS X 10.15 has the same requirement.  */
   if (align < sizeof(void*))
     align = sizeof(void*);
 # endif
Index: libstdc++-v3/libsupc++/hash_bytes.cc
===================================================================
--- a/src/libstdc++-v3/libsupc++/hash_bytes.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/libsupc++/hash_bytes.cc	(.../branches/gcc-7-branch)
@@ -139,7 +139,7 @@
 
     // Remove the bytes not divisible by the sizeof(size_t).  This
     // allows the main loop to process the data as 64-bit integers.
-    const int len_aligned = len & ~0x7;
+    const size_t len_aligned = len & ~(size_t)0x7;
     const char* const end = buf + len_aligned;
     size_t hash = seed ^ (len * mul);
     for (const char* p = buf; p != end; p += 8)
Index: libstdc++-v3/libsupc++/cxxabi.h
===================================================================
--- a/src/libstdc++-v3/libsupc++/cxxabi.h	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/libsupc++/cxxabi.h	(.../branches/gcc-7-branch)
@@ -683,8 +683,9 @@
    *  @brief Exception thrown by __cxa_guard_acquire.
    *  @ingroup exceptions
    *
-   *  6.7[stmt.dcl]/4: If control re-enters the declaration (recursively)
-   *  while the object is being initialized, the behavior is undefined.
+   *  C++ 2011 6.7 [stmt.dcl]/4: If control re-enters the declaration
+   *  recursively while the variable is being initialized, the behavior
+   *  is undefined.
    *
    *  Since we already have a library function to handle locking, we might
    *  as well check for this situation and throw an exception.
@@ -694,8 +695,8 @@
   class recursive_init_error: public std::exception
   {
   public:
-    recursive_init_error() throw() { }
-    virtual ~recursive_init_error() throw ();
+    recursive_init_error() _GLIBCXX_NOTHROW;
+    virtual ~recursive_init_error() _GLIBCXX_NOTHROW;
   };
 }
 #endif // __cplusplus
Index: libstdc++-v3/ChangeLog
===================================================================
--- a/src/libstdc++-v3/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,278 @@
+2019-10-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-10-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/92143
+	* libsupc++/new_opa.cc (operator new) [__APPLE__]: Increase alignment
+	to at least sizeof(void*).
+
+	Backport from mainline
+	2019-10-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/Makefile.am (doc-html-docbook-regenerate): New target.
+	(${docbook_outdir}/html): Do not create unused 'html/ext' directory.
+	* doc/Makefile.in: Regenerate.
+	* doc/xml/manual/documentation_hacking.xml: Document new target.
+	* doc/html/*: Regenerate.
+
+	* doc/xml/manual/allocator.xml: Use archived copy of CUJ article.
+
+	Backport from mainline
+	2019-05-31  Gerald Pfeifer  <gerald@pfeifer.com>
+
+	* doc/xml/manual/allocator.xml: Move hoard.org back to http.
+
+2019-09-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	* python/libstdcxx/v6/xmethods.py (SharedPtrUseCountWorker.__call__):
+	Fix syntax error.
+
+2019-09-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR middle-end/89303
+	* testsuite/20_util/enable_shared_from_this/89303.cc: New test.
+
+2019-09-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/20_util/unique_ptr/assign/48635_neg.cc: Replace dg-error
+	with dg-prune-output for enable_if failure.
+	* testsuite/20_util/unique_ptr/cons/cv_qual_neg.cc: Add
+	dg-prune-output for enable_if failure.
+
+	Backport from mainline
+	2019-07-31  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/91308
+	* include/bits/unique_ptr.h (unique_ptr::__safe_conversion_up): Remove
+	constraints on deleter that should only apply to the constructor.
+	(unique_ptr<T[], D>::__safe_conversion_up): Likewise.
+	(unique_ptr<T[], D>::unique_ptr(unique_ptr<U, D>&&)): Restore
+	constraints on deleter here.
+	* testsuite/20_util/unique_ptr/assign/91308.cc: New test.
+
+2019-09-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-07-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/51333
+	* libsupc++/cxxabi.h (__gnu_cxx::recursive_init_error): Do not define
+	constructor inline.
+	* libsupc++/guard_error.cc (__gnu_cxx::recursive_init_error): Define
+	constructor.
+	* testsuite/18_support/51333.cc: New test.
+
+2019-09-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-06-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90770
+	* src/Makefile.am (stamp-debug): Also test for missing makefile.
+	* src/Makefile.in: Regenerate.
+
+2019-09-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/status_cxx2017.xml: Add feature test macro for
+	P0040R3.
+	* doc/html/*: Regenerate.
+
+	Backport from mainline
+	2019-06-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/status_cxx2017.xml: Fix outdated reference to
+	C++17 working draft.
+
+	Backport from mainline
+	2019-05-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/shared_ptr.xml: Fix names of lock policy constants.
+
+2019-09-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-05-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/random.h (seed_seq::param): Fix non-reserved name.
+	* include/experimental/type_traits (is_detected_exact)
+	(is_detected_exact_v): Likewise.
+	* testsuite/17_intro/names.cc: Check for more non-reserved names.
+	* testsuite/experimental/names.cc: New test.
+
+2019-06-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-05-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90634
+	* include/experimental/bits/fs_path.h (path::path(path&&)): Only call
+	_M_split_cmpts() for a path with multiple components.
+	(path::_S_is_dir_sep()): Add missing 'static' keyword to function.
+	* src/filesystem/path.cc (path::_M_split_cmpts()): Count number of
+	components and reserve space in vector. Return early when there is
+	only one component.
+	* testsuite/experimental/filesystem/path/construct/90634.cc: New test.
+
+2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-02-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/89466
+	* acinclude.m4 (GLIBCXX_CONFIGURE_DOCBOOK): Reorder check for local
+	stylesheet directories before check for xsltproc. Try to use
+	xmlcatalog to find local stylesheet directory before trying hardcoded
+	paths. Add path used by suse to hardcoded paths. Adjust xsltproc
+	check to look for the same stylesheet as doc/Makefile.am uses. Don't
+	use xsltproc if xmlcatalog fails to find a local stylesheet.
+	* configure.ac: Check for xmlcatalog.
+	* Makefile.in: Regenerate.
+	* configure: Likewise.
+	* doc/Makefile.in: Likewise.
+	* include/Makefile.in: Likewise.
+	* libsupc++/Makefile.in: Likewise.
+	* po/Makefile.in: Likewise.
+	* python/Makefile.in: Likewise.
+	* src/Makefile.in: Likewise.
+	* src/c++11/Makefile.in: Likewise.
+	* src/c++17/Makefile.in: Likewise.
+	* src/c++98/Makefile.in: Likewise.
+	* src/filesystem/Makefile.in: Likewise.
+	* testsuite/Makefile.in: Likewise.
+
+2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-01-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/88740
+	* testsuite/util/testsuite_hooks.h [stderr] (VERIFY): Use fprintf to
+	write to stderr instead of using printf.
+
+2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/experimental/any (__any_caster): Use RTTI if comparing
+	addresses fails, to support non-unique addresses in shared libraries.
+	* include/std/any (__any_caster): Likewise.
+	* testsuite/experimental/any/misc/any_cast_neg.cc: Use 0 for dg-error
+	line number.
+
+2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90220
+	* include/experimental/any (__any_caster): Constrain to only be
+	callable for object types. Use remove_cv_t instead of decay_t.
+	If the type decays or isn't copy constructible, compare the manager
+	function to a dummy specialization.
+	(__any_caster): Add overload constrained for non-object types.
+	(any::_Manager_internal<_Op>): Add dummy specialization.
+	* testsuite/experimental/any/misc/any_cast.cc: Test function types
+	and array types.
+
+	Backport from mainline
+	2019-04-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90220
+	* include/std/any (__any_caster): Use remove_cv_t instead of decay_t.
+	Avoid a runtime check for types that can never be stored in std::any.
+	* testsuite/20_util/any/misc/any_cast.cc: Test std::any_cast with
+	array types.
+
+	Backport from mainline
+	2019-04-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90220 (partial)
+	* include/std/any (any_cast<T>(any*), any_cast<T>(const any*)): Do
+	not attempt ill-formed static_cast to pointers to non-object types.
+	* testsuite/20_util/any/misc/any_cast.cc: Test std::any_cast with
+	function types.
+
+2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from mainline
+	2019-01-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/status_cxx2017.xml: Document P0032R3 and P0307R2
+	status.
+	* include/bits/stl_uninitialized.h (__cpp_lib_raw_memory_algorithms):
+	Define.
+	* include/std/any (__cpp_lib_any): Define as 201606L, because P0032R3
+	changes are supported.
+	* include/std/optional (__cpp_lib_optional): Likewise.
+	* include/std/variant (__cpp_lib_variant): Likewise.
+
+2019-05-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-04-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90105
+	* include/bits/forward_list.tcc (operator==): Do not use operator!= to
+	compare elements.
+	(forward_list<T, A>::sort(Comp)): When elements are equal take the one
+	earlier in the list, so that sort is stable.
+	* testsuite/23_containers/forward_list/operations/90105.cc: New test.
+	* testsuite/23_containers/forward_list/comparable.cc: Test with
+	types that meet the minimum EqualityComparable and LessThanComparable
+	requirements. Remove irrelevant comment.
+
+	Backport from mainline
+	2019-03-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/89629
+	* libsupc++/hash_bytes.cc [__SIZEOF_SIZE_T__ == 8] (_Hash_bytes):
+	Use correct type for len_aligned.
+	* testsuite/20_util/hash/89629.cc: New test.
+
+2019-02-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/89446
+	* include/bits/char_traits.h (__constant_char_array): Check index is
+	in range before dereferencing.
+	* testsuite/21_strings/basic_string_view/operators/char/89446.cc:
+	New test.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-12-06  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* scripts/make_exports.pl (check names): Dont try to export
+	construction vtable symbols.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-12-06  Jonathan Wakely  <jwakely@redhat.com>
+		    Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR libstdc++/64883
+	* testsuite/17_intro/headers/c++1998/all_attributes.cc: Don't test
+	always_inline on Darwin.
+	* testsuite/17_intro/headers/c++2011/all_attributes.cc: Likewise.
+	* testsuite/17_intro/headers/c++2014/all_attributes.cc: Likewise.
+	* testsuite/17_intro/headers/c++2017/all_attributes.cc: Likewise.
+	* testsuite/17_intro/headers/c++2020/all_attributes.cc: Likewise.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-08-25  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR libstdc++/70694
+	* configure.host (OPT_LDFLAGS): Don't append
+	-fvisibility-inlines-hidden for newer Darwin.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: libstdc++-v3/testsuite/Makefile.in
===================================================================
--- a/src/libstdc++-v3/testsuite/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/Makefile.in	(.../branches/gcc-7-branch)
@@ -204,6 +204,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/testsuite/18_support/51333.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/18_support/51333.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/18_support/51333.cc	(.../branches/gcc-7-branch)
@@ -0,0 +1,22 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-fkeep-inline-functions" }
+// { dg-do link }
+
+#include <cxxabi.h>
+int main() { } // PR libstdc++/51333
Index: libstdc++-v3/testsuite/23_containers/forward_list/operations/90105.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/23_containers/forward_list/operations/90105.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/23_containers/forward_list/operations/90105.cc	(.../branches/gcc-7-branch)
@@ -0,0 +1,60 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <forward_list>
+#include <testsuite_hooks.h>
+
+// PR libstdc++/90105 - std::forward_list::sort() is not "stable"
+
+struct X
+{
+  int key;
+  int val;
+};
+
+bool operator<(const X& l, const X& r)
+{ return l.key < r.key; }
+
+bool operator==(const X& l, const X& r)
+{ return l.key == r.key && l.val == r.val; }
+
+void
+test01()
+{
+  std::forward_list<X> l{ {1, 1}, {2, 2}, {1, 3}, {0, 4}, {2, 5}, {0, 6} };
+  l.sort();
+  std::forward_list<X> exp{ {0, 4}, {0, 6}, {1, 1}, {1, 3}, {2, 2}, {2, 5} };
+  VERIFY( l == exp );
+}
+
+void
+test02()
+{
+  std::forward_list<X> l{ {1, 1}, {1, 2}, {1, 3}, {1, 4}, {1, 5}, {1, 6} };
+  const std::forward_list<X> exp = l;
+  l.sort();
+  VERIFY( l == exp );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
Index: libstdc++-v3/testsuite/23_containers/forward_list/comparable.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/23_containers/forward_list/comparable.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/23_containers/forward_list/comparable.cc	(.../branches/gcc-7-branch)
@@ -17,15 +17,11 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-
-// NOTE: This makes use of the fact that we know how moveable
-// is implemented on list (via swap). If the implementation changed
-// this test may begin to fail.
-
 #include <forward_list>
 #include <testsuite_hooks.h>
 
-int main()
+void
+test01()
 {
   std::forward_list<double> a = {0.0, 1.0, 2.0, 3.0, 4.0};
   std::forward_list<double> b = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0};
@@ -43,6 +39,40 @@
   VERIFY((b >  a) == true);
   VERIFY((b >= a) == true);
   VERIFY((b <= a) == false);
+}
 
-  return 0;
+void
+test02()
+{
+  // The EqualityComparable requirements only require ==
+  struct X {
+    bool operator==(const X&) const { return true; }
+  };
+
+  std::forward_list<X> a(2);
+  const auto b = a;
+  VERIFY( a == b );
 }
+
+void
+test03()
+{
+  // The LessThanComparable requirements only require <
+  struct X {
+    bool operator<(const X&) const { return false; }
+  };
+
+  std::forward_list<X> a(2);
+  const auto b = a;
+  VERIFY( !(a < b) );
+  VERIFY( !(a > b) );
+  VERIFY( a <= b );
+  VERIFY( a >= b );
+}
+
+int main()
+{
+  test01();
+  test02();
+  test03();
+}
Index: libstdc++-v3/testsuite/21_strings/basic_string_view/operators/char/89446.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/21_strings/basic_string_view/operators/char/89446.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/21_strings/basic_string_view/operators/char/89446.cc	(.../branches/gcc-7-branch)
@@ -0,0 +1,28 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17 -fexceptions -fnon-call-exceptions -O1" }
+// { dg-do run { target { powerpc*-*-linux* i?86-*-linux* x86_64-*-linux* } } }
+// { dg-require-effective-target c++1z }
+
+#include <string_view>
+
+int main()
+{
+  std::string_view s1, s2;
+  return s1 != s2;
+}
Index: libstdc++-v3/testsuite/experimental/any/misc/any_cast.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/any/misc/any_cast.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/experimental/any/misc/any_cast.cc	(.../branches/gcc-7-branch)
@@ -24,6 +24,7 @@
 
 using std::experimental::any;
 using std::experimental::any_cast;
+using std::experimental::bad_any_cast;
 
 void test01()
 {
@@ -56,7 +57,6 @@
 
 void test02()
 {
-  using std::experimental::bad_any_cast;
   any x(1);
   auto p = any_cast<double>(&x);
   VERIFY(p == nullptr);
@@ -105,7 +105,7 @@
   MoveDeleted&& md3 = any_cast<MoveDeleted&&>(any(std::move(md)));
 }
 
-void test04()
+void test05()
 {
   // PR libstdc++/69321
   struct noncopyable {
@@ -117,10 +117,60 @@
   VERIFY( p == nullptr );
 }
 
+void test06()
+{
+  // The contained value of a std::any is always an object type,
+  // but any_cast does not forbid checking for function types.
+
+  any a(1);
+  void (*p1)() = any_cast<void()>(&a);
+  VERIFY( p1 == nullptr );
+  int (*p2)(int) = any_cast<int(int)>(&a);
+  VERIFY( p2 == nullptr );
+  int (*p3)() = any_cast<int()>(&const_cast<const any&>(a));
+  VERIFY( p3 == nullptr );
+
+  try {
+    any_cast<int(&)()>(a);
+    VERIFY( false );
+  } catch (const bad_any_cast&) {
+  }
+
+  try {
+    any_cast<int(&)()>(std::move(a));
+    VERIFY( false );
+  } catch (const bad_any_cast&) {
+  }
+
+  try {
+    any_cast<int(&)()>(const_cast<const any&>(a));
+    VERIFY( false );
+  } catch (const bad_any_cast&) {
+  }
+}
+
+void test07()
+{
+  int arr[3];
+  any a(arr);
+  VERIFY( a.type() == typeid(int*) );	// contained value is decayed
+
+  int (*p1)[3] = any_cast<int[3]>(&a);
+  VERIFY( a.type() != typeid(int[3]) ); // so any_cast should return nullptr
+  VERIFY( p1 == nullptr );
+  int (*p2)[] = any_cast<int[]>(&a);
+  VERIFY( a.type() != typeid(int[]) );	// so any_cast should return nullptr
+  VERIFY( p2 == nullptr );
+  const int (*p3)[] = any_cast<int[]>(&const_cast<const any&>(a));
+  VERIFY( p3 == nullptr );
+}
+
 int main()
 {
   test01();
   test02();
   test03();
-  test04();
+  test05();
+  test06();
+  test07();
 }
Index: libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc	(.../branches/gcc-7-branch)
@@ -25,5 +25,5 @@
   using std::experimental::any_cast;
 
   const any y(1);
-  any_cast<int&>(y); // { dg-error "qualifiers" "" { target { *-*-* } } 357 }
+  any_cast<int&>(y); // { dg-error "qualifiers" "" { target { *-*-* } } 0 }
 }
Index: libstdc++-v3/testsuite/experimental/filesystem/path/construct/90634.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/filesystem/path/construct/90634.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/experimental/filesystem/path/construct/90634.cc	(.../branches/gcc-7-branch)
@@ -0,0 +1,75 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-DUSE_FILESYSTEM_TS -lstdc++fs" }
+// { dg-do run { target c++11 } }
+// { dg-require-filesystem-ts "" }
+
+#include <experimental/filesystem>
+#include <cstdlib>
+#include <testsuite_hooks.h>
+
+std::size_t bytes_allocated = 0;
+
+void* operator new(std::size_t n)
+{
+  bytes_allocated += n;
+  return std::malloc(n);
+}
+
+void operator delete(void* p) noexcept { std::free(p); }
+#if __cpp_sized_deallocation
+void operator delete(void* p, std::size_t) noexcept { std::free(p); }
+#endif
+
+void
+test01()
+{
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  std::wstring s0;
+  std::wstring s1 = L"/";
+  std::wstring s2 = L"file";
+  std::wstring s3 = L"C:";
+  std::wstring s4 = L"\\";
+#else
+  std::string s0;
+  std::string s1 = "/";
+  std::string s2 = "file";
+  std::string s3 = "C:";
+  std::string s4 = "\\";
+#endif
+
+  using std::experimental::filesystem::path;
+
+  bytes_allocated = 0;
+  path p0 = std::move(s0);
+  VERIFY( bytes_allocated == 0 );
+  path p1 = std::move(s1);
+  VERIFY( bytes_allocated == 0 );
+  path p2 = std::move(s2);
+  VERIFY( bytes_allocated == 0 );
+  path p3 = std::move(s3);
+  VERIFY( bytes_allocated == 0 );
+  path p4 = std::move(s4);
+  VERIFY( bytes_allocated == 0 );
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/experimental/names.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/names.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/experimental/names.cc	(.../branches/gcc-7-branch)
@@ -0,0 +1,57 @@
+// Copyright (C) 2017-2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile }
+
+// Define macros for some common variables names that we must not use for
+// naming variables, parameters etc. in the library.
+
+#include "../17_intro/names.cc"
+// Filesystem
+#if __has_include(<experimental/filesystem>)
+# include <experimental/filesystem>
+#endif
+// Library Fundamentals
+#include <experimental/algorithm>
+#include <experimental/any>
+#include <experimental/array>
+#include <experimental/chrono>
+#include <experimental/deque>
+#include <experimental/forward_list>
+#include <experimental/functional>
+#include <experimental/iterator>
+#include <experimental/list>
+#include <experimental/map>
+#include <experimental/memory>
+#include <experimental/memory_resource>
+#include <experimental/numeric>
+#include <experimental/optional>
+#include <experimental/propagate_const>
+#include <experimental/random>
+#include <experimental/ratio>
+#include <experimental/regex>
+#include <experimental/set>
+#include <experimental/source_location>
+#include <experimental/string>
+#include <experimental/string_view>
+#include <experimental/system_error>
+#include <experimental/tuple>
+#include <experimental/type_traits>
+#include <experimental/unordered_map>
+#include <experimental/unordered_set>
+#include <experimental/utility>
+#include <experimental/vector>
Index: libstdc++-v3/testsuite/17_intro/names.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/17_intro/names.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/17_intro/names.cc	(.../branches/gcc-7-branch)
@@ -19,7 +19,6 @@
 
 // Define macros for some common variables names that we must not use for
 // naming variables, parameters etc. in the library.
-#define tmp (
 #define A (
 #define B (
 #define C (
@@ -99,6 +98,78 @@
 #define y (
 #define z (
 
+#define tmp (
+
+#if __cplusplus < 201703L
+// <charconv> defines to_chars_result::ptr and to_chars_result::ec
+#define ec (
+#define ptr (
+#endif
+
+// Common template parameter names
+#define OutputIterator		OutputIterator is not a reserved name
+#define InputIterator		InputIterator is not a reserved name
+#define ForwardIterator		ForwardIterator is not a reserved name
+#define BidirectionalIterator	BidirectionalIterator is not a reserved name
+#define RandomAccessIterator	RandomAccessIterator is not a reserved name
+#define RandomAccessOutputIterator	RandomAccessOutputIterator is not a reserved name
+#define RAIter			RAIter is not a reserved name
+#define FwdIter			FwdIter is not a reserved name
+#define OutIter			OutIter is not a reserved name
+#define InIter			InIter is not a reserved name
+
+#define Alloc			Alloc is not a reserved name
+#define BinaryFunction1		BinaryFunction1 is not a reserved name
+#define BinaryFunction2		BinaryFunction2 is not a reserved name
+#define Char			Char is not a reserved name
+#define CharT			CharT is not a reserved name
+#define Cmp			Cmp is not a reserved name
+#define Compare			Compare is not a reserved name
+#define Const_Iterator		Const_Iterator is not a reserved name
+#define Const_Key_Reference	Const_Key_Reference is not a reserved name
+#define Const_Node_Iter		Const_Node_Iter is not a reserved name
+#define Const_Pointer		Const_Pointer is not a reserved name
+#define Const_Reference		Const_Reference is not a reserved name
+#define Data			Data is not a reserved name
+#define DiffType		DiffType is not a reserved name
+#define Eq			Eq is not a reserved name
+#define ExecPolicy		ExecPolicy is not a reserved name
+#define Expected		Expected is not a reserved name
+#define External_Load_Access	External_Load_Access is not a reserved name
+#define External_Size_Access	External_Size_Access is not a reserved name
+#define Fn			Fn is not a reserved name
+#define Function		Function is not a reserved name
+#define Functor			Functor is not a reserved name
+#define Hash			Hash is not a reserved name
+#define H1			H1 is not a reserved name
+#define H2			H2 is not a reserved name
+#define Head			Head is not a reserved name
+#define It			It is not a reserved name
+#define Iter			Iter is not a reserved name
+#define Iterator		Iterator is not a reserved name
+#define Key			Key is not a reserved name
+#define Mapped			Mapped is not a reserved name
+#define Node			Node is not a reserved name
+#define Node_iter		Node_iter is not a reserved name
+#define Node_ptr		Node_ptr is not a reserved name
+#define Overflow		Overflow is not a reserved name
+#define Pointer			Pointer is not a reserved name
+#define Policy			Policy is not a reserved name
+#define Pred			Pred is not a reserved name
+#define Ptr			Ptr is not a reserved name
+#define Reference		Reference is not a reserved name
+#define Seq			Seq is not a reserved name
+#define Seq_RAIter		Seq_RAIter is not a reserved name
+#define Series			Series is not a reserved name
+#define Set			Set is not a reserved name
+#define String			String is not a reserved name
+#define Tp			Tp is not a reserved name
+#define Traits			Traits is not a reserved name
+#define Type			Type is not a reserved name
+#define Value			Value is not a reserved name
+#define ValueT			ValueT is not a reserved name
+#define ValueType		ValueType is not a reserved name
+
 #ifdef _AIX
 // See https://gcc.gnu.org/ml/libstdc++/2017-03/msg00015.html
 #undef f
@@ -116,4 +187,9 @@
 #undef y
 #endif
 
+#ifdef __sun__
+// See https://gcc.gnu.org/ml/libstdc++/2019-05/msg00175.html
+#undef ptr
+#endif
+
 #include <bits/stdc++.h>
Index: libstdc++-v3/testsuite/17_intro/headers/c++2014/all_attributes.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/17_intro/headers/c++2014/all_attributes.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/17_intro/headers/c++2014/all_attributes.cc	(.../branches/gcc-7-branch)
@@ -21,9 +21,9 @@
 // Ensure the library only uses the __name__ form for attributes.
 // Don't test 'const' and 'noreturn' because they are reserved anyway.
 #define abi_tag 1
-#define always_inline 1
 #ifndef __APPLE__
 // darwin headers use these, see PR 64883
+# define always_inline 1
 # define deprecated 1
 # define visibility 1
 #endif
Index: libstdc++-v3/testsuite/17_intro/headers/c++1998/all_attributes.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/17_intro/headers/c++1998/all_attributes.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/17_intro/headers/c++1998/all_attributes.cc	(.../branches/gcc-7-branch)
@@ -21,9 +21,9 @@
 // Ensure the library only uses the __name__ form for attributes.
 // Don't test 'const' because it is reserved anyway.
 #define abi_tag 1
-#define always_inline 1
 #ifndef __APPLE__
 // darwin headers use these, see PR 64883
+# define always_inline 1
 # define deprecated 1
 # define noreturn 1
 # define visibility 1
Index: libstdc++-v3/testsuite/17_intro/headers/c++2011/all_attributes.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/17_intro/headers/c++2011/all_attributes.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/17_intro/headers/c++2011/all_attributes.cc	(.../branches/gcc-7-branch)
@@ -21,11 +21,11 @@
 // Ensure the library only uses the __name__ form for attributes.
 // Don't test 'const' and 'noreturn' because they are reserved anyway.
 #define abi_tag 1
-#define always_inline 1
 #ifndef __APPLE__
 // darwin headers use these, see PR 64883
+# define always_inline 1
+# define deprecated 1
 # define visibility 1
-# define deprecated 1
 #endif
 #define packed 1
 #define pure 1
Index: libstdc++-v3/testsuite/util/testsuite_hooks.h
===================================================================
--- a/src/libstdc++-v3/testsuite/util/testsuite_hooks.h	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/util/testsuite_hooks.h	(.../branches/gcc-7-branch)
@@ -46,18 +46,25 @@
 #include <bits/c++config.h>
 #include <bits/functexcept.h>
 #include <ctime>
+#include <stdio.h>
 
 #ifdef _GLIBCXX_HAVE_SYS_STAT_H
 #include <sys/stat.h>
 #endif
 
+#ifdef stderr
+# define _VERIFY_PRINT(S, F, L, P, C) __builtin_fprintf(stderr, S, F, L, P, C)
+#else
+# define _VERIFY_PRINT(S, F, L, P, C) __builtin_printf(S, F, L, P, C)
+#endif
+
 #define VERIFY(fn)                                                      \
   do                                                                    \
   {                                                                     \
     if (! (fn))								\
       {									\
-	__builtin_printf("%s:%d: %s: Assertion '%s' failed.\n",		\
-			 __FILE__, __LINE__, __PRETTY_FUNCTION__, #fn); \
+	_VERIFY_PRINT("%s:%d: %s: Assertion '%s' failed.\n",		\
+		      __FILE__, __LINE__, __PRETTY_FUNCTION__, #fn);	\
 	__builtin_abort();						\
       }									\
   } while (false)
Index: libstdc++-v3/testsuite/20_util/enable_shared_from_this/89303.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/enable_shared_from_this/89303.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/enable_shared_from_this/89303.cc	(.../branches/gcc-7-branch)
@@ -0,0 +1,39 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-O1" }
+// { dg-do run { target c++11 } }
+
+// PR middle-end/89303
+
+#include <memory>
+
+class blob final: public std::enable_shared_from_this<blob>
+{
+  int* data;
+
+public:
+  blob() { data = new int; }
+  ~blob() { delete data; }
+};
+
+int
+main()
+{
+  std::shared_ptr<blob> tg = std::make_shared<blob>();
+  return tg->shared_from_this().use_count() - 2;
+}
Index: libstdc++-v3/testsuite/20_util/hash/89629.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/hash/89629.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/hash/89629.cc	(.../branches/gcc-7-branch)
@@ -0,0 +1,43 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target { lp64 || llp64 } } }
+// { dg-require-effective-target c++11 }
+// { dg-require-effective-target run_expensive_tests }
+
+#include <functional>
+#include <string>
+
+void
+test01()
+{
+  const std::size_t big = std::size_t(1) << 31;
+  std::string s;
+  try {
+    s.resize(big, 'a');
+  } catch (const std::bad_alloc&) {
+    return; // try to avoid a FAIL if memory allocation fails
+  }
+  // PR libstdc++/89629
+  (void) std::hash<std::string>{}(s);
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/20_util/any/misc/any_cast.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/any/misc/any_cast.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/any/misc/any_cast.cc	(.../branches/gcc-7-branch)
@@ -20,6 +20,7 @@
 
 #include <any>
 #include <string>
+#include <utility>
 #include <cstring>
 #include <testsuite_hooks.h>
 
@@ -130,6 +131,54 @@
   VERIFY( p == nullptr );
 }
 
+void test06()
+{
+  // The contained value of a std::any is always an object type,
+  // but std::any_cast does not forbid checking for function types.
+
+  any a(1);
+  void (*p1)() = any_cast<void()>(&a);
+  VERIFY( p1 == nullptr );
+  int (*p2)(int) = any_cast<int(int)>(&a);
+  VERIFY( p2 == nullptr );
+  int (*p3)() = any_cast<int()>(&std::as_const(a));
+  VERIFY( p3 == nullptr );
+
+  try {
+    any_cast<int(&)()>(a);
+    VERIFY( false );
+  } catch (const std::bad_any_cast&) {
+  }
+
+  try {
+    any_cast<int(&)()>(std::move(a));
+    VERIFY( false );
+  } catch (const std::bad_any_cast&) {
+  }
+
+  try {
+    any_cast<int(&)()>(std::as_const(a));
+    VERIFY( false );
+  } catch (const std::bad_any_cast&) {
+  }
+}
+
+void test07()
+{
+  int arr[3];
+  any a(arr);
+  VERIFY( a.type() == typeid(int*) );	// contained value is decayed
+
+  int (*p1)[3] = any_cast<int[3]>(&a);
+  VERIFY( a.type() != typeid(int[3]) ); // so any_cast should return nullptr
+  VERIFY( p1 == nullptr );
+  int (*p2)[] = any_cast<int[]>(&a);
+  VERIFY( a.type() != typeid(int[]) );	// so any_cast should return nullptr
+  VERIFY( p2 == nullptr );
+  const int (*p3)[] = any_cast<int[]>(&std::as_const(a));
+  VERIFY( p3 == nullptr );
+}
+
 int main()
 {
   test01();
@@ -137,4 +186,6 @@
   test03();
   test04();
   test05();
+  test06();
+  test07();
 }
Index: libstdc++-v3/testsuite/20_util/unique_ptr/cons/cv_qual_neg.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/unique_ptr/cons/cv_qual_neg.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/unique_ptr/cons/cv_qual_neg.cc	(.../branches/gcc-7-branch)
@@ -39,7 +39,7 @@
   std::unique_ptr<const A[]> cA3(p); // { dg-error "no matching function" }
   std::unique_ptr<volatile A[]> vA3(p); // { dg-error "no matching function" }
   std::unique_ptr<const volatile A[]> cvA3(p); // { dg-error "no matching function" }
-  // { dg-error "no type" "" { target *-*-* } 467 }
+  // { dg-prune-output "no type" }
 }
 
 template<typename T>
Index: libstdc++-v3/testsuite/20_util/unique_ptr/assign/48635_neg.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/unique_ptr/assign/48635_neg.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/unique_ptr/assign/48635_neg.cc	(.../branches/gcc-7-branch)
@@ -42,10 +42,9 @@
   std::unique_ptr<int, D&> ud(nullptr, d);
   ub = std::move(ud); // { dg-error "no match" }
   ub2 = ud; // { dg-error "no match" }
-// { dg-error "no type" "" { target *-*-* } 301 }
 
   std::unique_ptr<int[], B&> uba(nullptr, b);
   std::unique_ptr<int[], D&> uda(nullptr, d);
   uba = std::move(uda); // { dg-error "no match" }
-// { dg-error "no type" "" { target *-*-* } 560 }
 }
+// { dg-prune-output "no type" }
Index: libstdc++-v3/testsuite/20_util/unique_ptr/assign/91308.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/unique_ptr/assign/91308.cc	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/unique_ptr/assign/91308.cc	(.../branches/gcc-7-branch)
@@ -0,0 +1,46 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <memory>
+
+struct D1
+{
+  void operator()(int* p) const noexcept { }
+};
+
+struct D2 : D1
+{
+  D2& operator=(D1&&) noexcept { return *this; }
+};
+
+void
+test01()
+{
+  std::unique_ptr<int, D1> d1;
+  std::unique_ptr<int, D2> d2;
+  d2 = std::move(d1);
+}
+
+void
+test02()
+{
+  std::unique_ptr<int[], D1> d1;
+  std::unique_ptr<int[], D2> d2;
+  d2 = std::move(d1);
+}
Index: libstdc++-v3/acinclude.m4
===================================================================
--- a/src/libstdc++-v3/acinclude.m4	(.../tags/gcc_7_4_0_release)
+++ b/src/libstdc++-v3/acinclude.m4	(.../branches/gcc-7-branch)
@@ -642,28 +642,27 @@
 dnl
 AC_DEFUN([GLIBCXX_CONFIGURE_DOCBOOK], [
 
-AC_MSG_CHECKING([for docbook stylesheets for documentation creation])
-glibcxx_stylesheets=no
-if test x${XSLTPROC} = xyes && echo '<title/>' | xsltproc --noout --nonet --xinclude http://docbook.sourceforge.net/release/xsl-ns/current/xhtml-1_1/docbook.xsl - 2>/dev/null; then
-  glibcxx_stylesheets=yes
-fi
-AC_MSG_RESULT($glibcxx_stylesheets)
+glibcxx_docbook_url=http://docbook.sourceforge.net/release/xsl-ns/current/
 
 AC_MSG_CHECKING([for local stylesheet directory])
 glibcxx_local_stylesheets=no
-if test x"$glibcxx_stylesheets" = x"yes"; then
-  if test -d /usr/share/sgml/docbook/xsl-ns-stylesheets; then
-    glibcxx_local_stylesheets=yes
-    XSL_STYLE_DIR=/usr/share/sgml/docbook/xsl-ns-stylesheets
-  fi
-  if test -d /usr/share/xml/docbook/stylesheet/docbook-xsl-ns; then
-    glibcxx_local_stylesheets=yes
-    XSL_STYLE_DIR=/usr/share/xml/docbook/stylesheet/docbook-xsl-ns
-  fi
-  if test -d /usr/share/xml/docbook/stylesheet/nwalsh5/current; then
-    glibcxx_local_stylesheets=yes
-    XSL_STYLE_DIR=/usr/share/xml/docbook/stylesheet/nwalsh5/current
-  fi
+if test x${XMLCATALOG} = xyes && xsl_style_dir=`xmlcatalog "" $glibcxx_docbook_url 2>/dev/null`
+then
+  XSL_STYLE_DIR=`echo $xsl_style_dir | sed -n 's;^file://;;p'`
+  glibcxx_local_stylesheets=yes
+else
+  for dir in \
+    /usr/share/sgml/docbook/xsl-ns-stylesheets \
+    /usr/share/xml/docbook/stylesheet/docbook-xsl-ns \
+    /usr/share/xml/docbook/stylesheet/nwalsh5/current \
+    /usr/share/xml/docbook/stylesheet/nwalsh/current
+  do
+    if test -d $dir; then
+      glibcxx_local_stylesheets=yes
+      XSL_STYLE_DIR=$dir
+      break
+    fi
+  done
 fi
 AC_MSG_RESULT($glibcxx_local_stylesheets)
 
@@ -670,6 +669,16 @@
 if test x"$glibcxx_local_stylesheets" = x"yes"; then
   AC_SUBST(XSL_STYLE_DIR)
   AC_MSG_NOTICE($XSL_STYLE_DIR)
+
+  AC_MSG_CHECKING([for docbook stylesheets for documentation creation])
+  glibcxx_stylesheets=no
+  if test x${XMLCATALOG} = xno || xmlcatalog "" $glibcxx_docbook_url/xhtml/docbook.xsl >/dev/null 2>&1; then
+    if test x${XSLTPROC} = xyes && echo '<title/>' | xsltproc --noout --nonet --xinclude $glibcxx_docbook_url/xhtml/docbook.xsl - 2>/dev/null; then
+      glibcxx_stylesheets=yes
+    fi
+  fi
+  AC_MSG_RESULT($glibcxx_stylesheets)
+
 else
   glibcxx_stylesheets=no
 fi
Index: libiberty/simple-object-elf.c
===================================================================
--- a/src/libiberty/simple-object-elf.c	(.../tags/gcc_7_4_0_release)
+++ b/src/libiberty/simple-object-elf.c	(.../branches/gcc-7-branch)
@@ -479,6 +479,14 @@
       return NULL;
     }
 
+  if (eor->shstrndx == 0)
+    {
+      *errmsg = "invalid ELF shstrndx == 0";
+      *err = 0;
+      XDELETE (eor);
+      return NULL;
+    }
+
   return (void *) eor;
 }
 
Index: libiberty/ChangeLog
===================================================================
--- a/src/libiberty/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/libiberty/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,12 @@
+2019-07-25  Richard Biener  <rguenther@suse.de>
+
+	PR lto/90924
+	Backport from mainline
+	2019-07-12  Ren Kimura  <rkx1209dev@gmail.com>
+
+	* simple-object-elf.c (simple_object_elf_match): Check zero value
+	shstrndx.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: contrib/ChangeLog
===================================================================
--- a/src/contrib/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/contrib/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,7 @@
+2019-08-16  Uros Bizjak  <ubizjak@gmail.com>
+
+	* test_summary: Do not escape "=".
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: contrib/test_summary
===================================================================
--- a/src/contrib/test_summary	(.../tags/gcc_7_4_0_release)
+++ b/src/contrib/test_summary	(.../branches/gcc-7-branch)
@@ -126,7 +126,7 @@
   if (lang == "") lang = " "$2" "; else lang = " ";
 }
 $2 == "version" { save = $0; $1 = ""; $2 = ""; version = $0; gsub(/^ */, "", version); gsub(/\r$/, "", version); $0 = save; }
-/\===.*Summary/ { print ""; print; blanks=1; }
+/===.*Summary/ { print ""; print; blanks=1; }
 /tests ===/ || /^(Target|Host|Native)/ || $2 == "version" { print; blanks=1; }
 /^(XPASS|FAIL|UNRESOLVED|WARNING|ERROR|# of )/ { sub ("\r", ""); print; }
 /^using:/ { print ""; print; print ""; }
Index: libgcc/config.host
===================================================================
--- a/src/libgcc/config.host	(.../tags/gcc_7_4_0_release)
+++ b/src/libgcc/config.host	(.../branches/gcc-7-branch)
@@ -992,12 +992,12 @@
 	  md_unwind_header=rs6000/darwin-unwind.h
 	  ;;
 	esac
-	tmake_file="$tmake_file rs6000/t-ibm-ldouble"
-	extra_parts="$extra_parts crt2.o"
+	tmake_file="$tmake_file rs6000/t-ppc64-fp rs6000/t-ibm-ldouble"
+	extra_parts="$extra_parts crt2.o crt3_2.o libef_ppc.a dw_ppc.o"
 	;;
 powerpc64-*-darwin*)
 	tmake_file="$tmake_file rs6000/t-darwin64 rs6000/t-ibm-ldouble"
-	extra_parts="$extra_parts crt2.o"
+	extra_parts="$extra_parts crt2.o crt3_2.o libef_ppc.a dw_ppc.o"
 	;;
 powerpc*-*-freebsd*)
 	tmake_file="${tmake_file} rs6000/t-ppccomm rs6000/t-savresfgpr rs6000/t-crtstuff rs6000/t-freebsd t-softfp-sfdf t-softfp-excl t-softfp"
Index: libgcc/ChangeLog
===================================================================
--- a/src/libgcc/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/libgcc/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,43 @@
+2019-11-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-07-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config.host (powerpc-*-darwin*,powerpc64-*-darwin*): Revise crt
+	list.
+	* config/rs6000/t-darwin: Build crt3_2 for older systems.  Revise
+	mmacosx-version-min for crts to run across all system versions.
+	* config/rs6000/t-darwin64 (LIB2ADD): Remove.
+	* config/t-darwin: Revise mmacosx-version-min for crts to run across
+	system versions >= 10.4.
+
+2019-11-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-25  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config.host: Add libef_ppc.a to the extra files for powerpc-darwin.
+	* config/rs6000/t-darwin: (PPC_ENDFILE_SRC, PPC_ENDFILE_OBJS): New.
+	Build objects for the out of line save/restore register functions
+	so that they can be used for any supported Darwin version.
+	* config/t-darwin: Default the build Darwin version to Darwin8
+	(MacOS 10.4).
+
+2019-09-04  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-06  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/t-darwin: Ensure that the unwinder is built with
+	altivec enabled.
+
+2019-09-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-12  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/darwin-vecsave.S: Set .machine appropriately.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: libgcc/config/t-darwin
===================================================================
--- a/src/libgcc/config/t-darwin	(.../tags/gcc_7_4_0_release)
+++ b/src/libgcc/config/t-darwin	(.../branches/gcc-7-branch)
@@ -1,22 +1,16 @@
 # Set this as a minimum (unless overriden by arch t-files) since it's a
 # reasonable lowest common denominator that works for all our archs.
-HOST_LIBGCC2_CFLAGS += -mmacosx-version-min=10.5
+HOST_LIBGCC2_CFLAGS += -mmacosx-version-min=10.4
 
 crt3.o: $(srcdir)/config/darwin-crt3.c
-	$(crt_compile) $(DARWIN_EXTRA_CRT_BUILD_CFLAGS) -c $<
+	$(crt_compile) -mmacosx-version-min=10.4 -c $<
 
 crttms.o: $(srcdir)/config/darwin-crt-tm.c
-	$(crt_compile) $(DARWIN_EXTRA_CRT_BUILD_CFLAGS) -DSTART -c $<
+	$(crt_compile) -mmacosx-version-min=10.4 -DSTART -c $<
 
 crttme.o: $(srcdir)/config/darwin-crt-tm.c
-	$(crt_compile) $(DARWIN_EXTRA_CRT_BUILD_CFLAGS) -DEND -c $<
+	$(crt_compile) -mmacosx-version-min=10.4 -DEND -c $<
 
-# -pipe because there's an assembler bug, 4077127, which causes
-# it to not properly process the first # directive, causing temporary
-# file names to appear in stabs, causing the bootstrap to fail.  Using -pipe
-# works around this by not having any temporary file names.
-HOST_LIBGCC2_CFLAGS += -pipe
-
 # Use unwind-dw2-fde-darwin
 LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/config/unwind-dw2-fde-darwin.c \
   $(srcdir)/unwind-sjlj.c $(srcdir)/unwind-c.c
Index: libgcc/config/rs6000/t-darwin
===================================================================
--- a/src/libgcc/config/rs6000/t-darwin	(.../tags/gcc_7_4_0_release)
+++ b/src/libgcc/config/rs6000/t-darwin	(.../branches/gcc-7-branch)
@@ -1,23 +1,58 @@
-DARWIN_EXTRA_CRT_BUILD_CFLAGS = -mlongcall -mmacosx-version-min=10.4
 
 crt2.o: $(srcdir)/config/rs6000/darwin-crt2.c
-	$(crt_compile) $(DARWIN_EXTRA_CRT_BUILD_CFLAGS) -c $<
+	$(crt_compile) -mmacosx-version-min=10.1 -c $<
 
+# The sources for this indicate that there are some parts that
+# don't apply >= 10.4
+crt3_2.o: $(srcdir)/config/darwin-crt3.c
+	$(crt_compile) -mmacosx-version-min=10.1 -c $<
+
+# The outlined register save/restore functions need to run anywhere, and
+# they must be leaf functions suitable for use in an endfile.
+
+PPC_ENDFILE_SRC = \
+  $(srcdir)/config/rs6000/darwin-gpsave.S \
+  $(srcdir)/config/rs6000/darwin-fpsave.S \
+  $(srcdir)/config/rs6000/darwin-vecsave.S
+
+PPC_ENDFILE_OBJS = \
+ darwin-gpsave.o \
+ darwin-fpsave.o \
+ darwin-vecsave.o
+
+darwin-gpsave.o: $(srcdir)/config/rs6000/darwin-gpsave.S
+	$(crt_compile) -mmacosx-version-min=10.1 -c $<
+
+darwin-fpsave.o: $(srcdir)/config/rs6000/darwin-fpsave.S
+	$(crt_compile) -mmacosx-version-min=10.1 -c $<
+
+darwin-vecsave.o: $(srcdir)/config/rs6000/darwin-vecsave.S
+	$(crt_compile) -mmacosx-version-min=10.1 -c $<
+
+# We build these into a library, so that they are only linked as needed and not
+# forced into every object.
+
+libef_ppc.a: $(PPC_ENDFILE_OBJS)
+	$(AR_CREATE_FOR_TARGET) $@ $(PPC_ENDFILE_OBJS)
+	$(RANLIB_FOR_TARGET) $@
+
+dw_ppc.o: $(srcdir)/config/rs6000/darwin-world.S
+	$(crt_compile) -mmacosx-version-min=10.1 -c $<
+
 LIB2ADD = $(srcdir)/config/rs6000/darwin-tramp.S \
 	  $(srcdir)/config/darwin-64.c \
-	  $(srcdir)/config/rs6000/darwin-fpsave.S  \
-	  $(srcdir)/config/rs6000/darwin-gpsave.S  \
-	  $(srcdir)/config/rs6000/darwin-world.S \
-	  $(srcdir)/config/rs6000/ppc64-fp.c
+	  $(srcdir)/config/rs6000/darwin-world.S
 
-LIB2ADD_ST = \
-	  $(srcdir)/config/rs6000/darwin-vecsave.S
-
 # The .S files above are designed to run on all processors, even though
 # they use AltiVec instructions.
 # -Wa is used because -force_cpusubtype_ALL doesn't work with -dynamiclib.
-# -mmacosx-version-min=10.4 is used to provide compatibility for code from
-# earlier OSX versions.
-HOST_LIBGCC2_CFLAGS += -Wa,-force_cpusubtype_ALL -mmacosx-version-min=10.4
 
+HOST_LIBGCC2_CFLAGS += -Wa,-force_cpusubtype_ALL
+
+# Although the default for 10.4 is G3, we need the unwinder to be built
+# with vector support so that the "save/rest_world" outlined functions are
+# correctly invoked.
+unwind-dw2_s.o: HOST_LIBGCC2_CFLAGS += -maltivec
+unwind-dw2.o: HOST_LIBGCC2_CFLAGS += -maltivec
+
 LIB2ADDEH += $(srcdir)/config/rs6000/darwin-fallback.c
Index: libgcc/config/rs6000/t-darwin64
===================================================================
--- a/src/libgcc/config/rs6000/t-darwin64	(.../tags/gcc_7_4_0_release)
+++ b/src/libgcc/config/rs6000/t-darwin64	(.../branches/gcc-7-branch)
@@ -1,7 +1 @@
 LIB2_SIDITI_CONV_FUNCS = yes
-
-LIB2ADD = $(srcdir)/config/rs6000/darwin-tramp.S \
-	  $(srcdir)/config/darwin-64.c \
-	  $(srcdir)/config/rs6000/darwin-fpsave.S \
-	  $(srcdir)/config/rs6000/darwin-gpsave.S \
-	  $(srcdir)/config/rs6000/darwin-world.S
Index: libgcc/config/rs6000/darwin-vecsave.S
===================================================================
--- a/src/libgcc/config/rs6000/darwin-vecsave.S	(.../tags/gcc_7_4_0_release)
+++ b/src/libgcc/config/rs6000/darwin-vecsave.S	(.../branches/gcc-7-branch)
@@ -31,8 +31,14 @@
    (4 bytes) to do the operation; for Vector regs, 2 instructions are
    required (8 bytes.).   */
 
+/* With some assemblers, we need the correct machine directive to get the
+   right CPU type / subtype in the file header.  */
+#if	__ppc64__
+	.machine ppc64
+#else
 	.machine ppc7400
-.text
+#endif
+	.text
 	.align 2
 
 .private_extern saveVEC
Index: gcc/tree-vrp.c
===================================================================
--- a/src/gcc/tree-vrp.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-vrp.c	(.../branches/gcc-7-branch)
@@ -2535,10 +2535,13 @@
 		max_ovf = 1;
 	    }
 
-	  /* If we have overflow for the constant part and the resulting
-	     range will be symbolic, drop to VR_VARYING.  */
-	  if ((min_ovf && sym_min_op0 != sym_min_op1)
-	      || (max_ovf && sym_max_op0 != sym_max_op1))
+	  /* If the resulting range will be symbolic, we need to eliminate any
+	     explicit or implicit overflow introduced in the above computation
+	     because compare_values could make an incorrect use of it.  That's
+	     why we require one of the ranges to be a singleton.  */
+	  if ((sym_min_op0 != sym_min_op1 || sym_max_op0 != sym_max_op1)
+	      && (min_ovf || max_ovf
+		  || (min_op0 != max_op0 && min_op1 != max_op1)))
 	    {
 	      set_value_range_to_varying (vr);
 	      return;
Index: gcc/tree-complex.c
===================================================================
--- a/src/gcc/tree-complex.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-complex.c	(.../branches/gcc-7-branch)
@@ -75,6 +75,9 @@
    non-SSA_NAME/non-invariant args that need to be replaced by SSA_NAMEs.  */
 static vec<gphi *> phis_to_revisit;
 
+/* BBs that need EH cleanup.  */
+static bitmap need_eh_cleanup;
+
 /* Lookup UID in the complex_variable_components hashtable and return the
    associated tree.  */
 static tree
@@ -690,13 +693,12 @@
 static void
 update_complex_assignment (gimple_stmt_iterator *gsi, tree r, tree i)
 {
-  gimple *stmt;
-
+  gimple *old_stmt = gsi_stmt (*gsi);
   gimple_assign_set_rhs_with_ops (gsi, COMPLEX_EXPR, r, i);
-  stmt = gsi_stmt (*gsi);
+  gimple *stmt = gsi_stmt (*gsi);
   update_stmt (stmt);
-  if (maybe_clean_eh_stmt (stmt))
-    gimple_purge_dead_eh_edges (gimple_bb (stmt));
+  if (maybe_clean_or_replace_eh_stmt (old_stmt, stmt))
+    bitmap_set_bit (need_eh_cleanup, gimple_bb (stmt)->index);
 
   if (gimple_in_ssa_p (cfun))
     update_complex_components (gsi, gsi_stmt (*gsi), r, i);
@@ -1451,6 +1453,8 @@
     }
 
   update_stmt (stmt);
+  if (maybe_clean_eh_stmt (stmt))
+    bitmap_set_bit (need_eh_cleanup, gimple_bb (stmt)->index);
 }
 
 /* Expand inline asm that sets some complex SSA_NAMEs.  */
@@ -1668,6 +1672,8 @@
   init_parameter_lattice_values ();
   ssa_propagate (complex_visit_stmt, complex_visit_phi);
 
+  need_eh_cleanup = BITMAP_ALLOC (NULL);
+
   complex_variable_components = new int_tree_htab_type (10);
 
   complex_ssa_name_components.create (2 * num_ssa_names);
@@ -1711,11 +1717,15 @@
 
   gsi_commit_edge_inserts ();
 
+  unsigned todo
+    = gimple_purge_all_dead_eh_edges (need_eh_cleanup) ? TODO_cleanup_cfg : 0;
+  BITMAP_FREE (need_eh_cleanup);
+
   delete complex_variable_components;
   complex_variable_components = NULL;
   complex_ssa_name_components.release ();
   complex_lattice_values.release ();
-  return 0;
+  return todo;
 }
 
 namespace {
Index: gcc/ipa-icf-gimple.c
===================================================================
--- a/src/gcc/ipa-icf-gimple.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ipa-icf-gimple.c	(.../branches/gcc-7-branch)
@@ -994,6 +994,9 @@
   if (gimple_asm_input_p (g1) != gimple_asm_input_p (g2))
     return false;
 
+  if (gimple_asm_inline_p (g1) != gimple_asm_inline_p (g2))
+    return false;
+
   if (gimple_asm_ninputs (g1) != gimple_asm_ninputs (g2))
     return false;
 
Index: gcc/opts-common.c
===================================================================
--- a/src/gcc/opts-common.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/opts-common.c	(.../branches/gcc-7-branch)
@@ -438,7 +438,8 @@
 
   extra_args = 0;
 
-  opt_index = find_opt (argv[0] + 1, lang_mask);
+  const char *opt_value = argv[0] + 1;
+  opt_index = find_opt (opt_value, lang_mask);
   i = 0;
   while (opt_index == OPT_SPECIAL_unknown
 	 && i < ARRAY_SIZE (option_map))
@@ -641,7 +642,24 @@
   /* Check if this is a switch for a different front end.  */
   if (!option_ok_for_language (option, lang_mask))
     errors |= CL_ERR_WRONG_LANG;
+  else if (strcmp (option->opt_text, "-Werror=") == 0
+	   && strchr (opt_value, ',') == NULL)
+    {
+      /* Verify that -Werror argument is a valid warning
+	 for a language.  */
+      char *werror_arg = xstrdup (opt_value + 6);
+      werror_arg[0] = 'W';
 
+      size_t warning_index = find_opt (werror_arg, lang_mask);
+      if (warning_index != OPT_SPECIAL_unknown)
+	{
+	  const struct cl_option *warning_option
+	    = &cl_options[warning_index];
+	  if (!option_ok_for_language (warning_option, lang_mask))
+	    errors |= CL_ERR_WRONG_LANG;
+	}
+    }
+
   /* Convert the argument to lowercase if appropriate.  */
   if (arg && option->cl_tolower)
     {
Index: gcc/c-family/ChangeLog
===================================================================
--- a/src/gcc/c-family/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/c-family/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,36 @@
+2019-09-05  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-08-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR pch/61250
+	* c-lex.c (c_lex_with_flags):  Don't call
+	c_common_no_more_pch () from here.
+
+2019-08-30  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-05-15  Richard Biener  <rguenther@suse.de>
+
+	PR c/90474
+	* c-common.c (c_common_mark_addressable_vec): Also mark
+	a COMPOUND_LITERAL_EXPR_DECL addressable similar to
+	c_mark_addressable.
+
+2019-08-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-06-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/90954
+	* c-omp.c (c_finish_omp_atomic): Allow tree_invariant_p in addition
+	to SAVE_EXPR in first operand of a COMPOUND_EXPR.
+
+2019-04-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* c-ada-spec.c (print_destructor): Deal with deleting destructors.
+	(dump_ada_declaration) <FUNCTION_DECL>: Likewise.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: gcc/c-family/c-common.c
===================================================================
--- a/src/gcc/c-family/c-common.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/c-family/c-common.c	(.../branches/gcc-7-branch)
@@ -6529,6 +6529,8 @@
     return;
   if (!VAR_P (t) || !DECL_HARD_REGISTER (t))
     TREE_ADDRESSABLE (t) = 1;
+  if (TREE_CODE (t) == COMPOUND_LITERAL_EXPR)
+    TREE_ADDRESSABLE (COMPOUND_LITERAL_EXPR_DECL (t)) = 1;
 }
 
 
Index: gcc/c-family/c-lex.c
===================================================================
--- a/src/gcc/c-family/c-lex.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/c-family/c-lex.c	(.../branches/gcc-7-branch)
@@ -387,7 +387,6 @@
 c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags,
 		  int lex_flags)
 {
-  static bool no_more_pch;
   const cpp_token *tok;
   enum cpp_ttype type;
   unsigned char add_flags = 0;
@@ -621,12 +620,6 @@
   if (cpp_flags)
     *cpp_flags = tok->flags | add_flags;
 
-  if (!no_more_pch)
-    {
-      no_more_pch = true;
-      c_common_no_more_pch ();
-    }
-
   timevar_pop (TV_CPP);
 
   return type;
Index: gcc/c-family/c-omp.c
===================================================================
--- a/src/gcc/c-family/c-omp.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/c-family/c-omp.c	(.../branches/gcc-7-branch)
@@ -256,7 +256,7 @@
   if (TREE_CODE (x) == COMPOUND_EXPR)
     {
       pre = TREE_OPERAND (x, 0);
-      gcc_assert (TREE_CODE (pre) == SAVE_EXPR);
+      gcc_assert (TREE_CODE (pre) == SAVE_EXPR || tree_invariant_p (pre));
       x = TREE_OPERAND (x, 1);
     }
   gcc_assert (TREE_CODE (x) == MODIFY_EXPR);
Index: gcc/c-family/c-ada-spec.c
===================================================================
--- a/src/gcc/c-family/c-ada-spec.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/c-family/c-ada-spec.c	(.../branches/gcc-7-branch)
@@ -2663,6 +2663,8 @@
   tree decl_name = DECL_NAME (DECL_ORIGIN (t));
 
   pp_string (buffer, "Delete_");
+  if (strncmp (IDENTIFIER_POINTER (DECL_NAME (t)), "__del", 5) == 0)
+    pp_string (buffer, "And_Free_");
   pp_ada_tree_identifier (buffer, decl_name, t, false);
 }
 
@@ -2915,8 +2917,9 @@
 	  if (DECL_ARTIFICIAL (t))
 	    return 0;
 
-	  /* Only consider constructors/destructors for complete objects.  */
-	  if (strncmp (IDENTIFIER_POINTER (decl_name), "__comp", 6) != 0)
+	  /* Only consider complete constructors and deleting destructors.  */
+	  if (strncmp (IDENTIFIER_POINTER (decl_name), "__comp", 6) != 0
+	      && strncmp (IDENTIFIER_POINTER (decl_name), "__del", 5) != 0)
 	    return 0;
 	}
 
Index: gcc/tree-loop-distribution.c
===================================================================
--- a/src/gcc/tree-loop-distribution.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-loop-distribution.c	(.../branches/gcc-7-branch)
@@ -64,6 +64,7 @@
 #include "cfgloop.h"
 #include "tree-scalar-evolution.h"
 #include "tree-vectorizer.h"
+#include "tree-eh.h"
 
 
 /* A Reduced Dependence Graph (RDG) vertex representing a statement.  */
@@ -815,6 +816,7 @@
 
   nb_bytes = build_size_arg_loc (loc, partition->main_dr, partition->niter,
 				 partition->plus_one);
+  nb_bytes = rewrite_to_non_trapping_overflow (nb_bytes);
   nb_bytes = force_gimple_operand_gsi (&gsi, nb_bytes, true, NULL_TREE,
 				       false, GSI_CONTINUE_LINKING);
   mem = build_addr_arg_loc (loc, partition->main_dr, nb_bytes);
@@ -871,6 +873,7 @@
 
   nb_bytes = build_size_arg_loc (loc, partition->main_dr, partition->niter,
 				 partition->plus_one);
+  nb_bytes = rewrite_to_non_trapping_overflow (nb_bytes);
   nb_bytes = force_gimple_operand_gsi (&gsi, nb_bytes, true, NULL_TREE,
 				       false, GSI_CONTINUE_LINKING);
   dest = build_addr_arg_loc (loc, partition->main_dr, nb_bytes);
Index: gcc/c/ChangeLog
===================================================================
--- a/src/gcc/c/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/c/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,100 @@
+2019-09-05  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-08-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR pch/61250
+	* c-parser.c (c_parse_file): Call c_common_no_more_pch ()
+	after determining that the first token is not
+	PRAGMA_GCC_PCH_PREPROCESS.
+
+2019-08-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90108
+	* c-decl.c (merge_decls): If remove is main variant and
+	DECL_ORIGINAL_TYPE is some other type, remove a DECL_ORIGINAL_TYPE
+	variant that has newdecl as TYPE_NAME if any.
+
+	2019-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/89933
+	* c-decl.c (merge_decls): When newdecl's type is its main variant,
+	don't try to remove it from the variant list, but instead assert
+	it has no variants.
+
+	2019-03-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/89734
+	* c-decl.c (grokdeclarator): Call c_build_qualified_type on function
+	return type even if quals_used is 0.  Formatting fixes.
+
+2019-01-16  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from mainline
+	2019-01-07  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/88720
+	PR c/88726
+	* c-decl.c (pop_scope): Use TREE_PUBLIC and b->nested to determine
+	whether a function is nested, not DECL_EXTERNAL.  Diagnose inline
+	functions declared but never defined only for external scope, not
+	for other scopes.
+
+2018-01-02  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR inline-asm/55681
+	* c-parser.c (c_parser_asm_statement): Update grammar.  Allow any
+	combination of volatile and goto, in any order, without repetitions.
+
+	Backport from trunk
+	2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* c-parser.c (c_parser_asm_statement): Detect the inline keyword
+	after asm.  Pass a flag for it to build_asm_expr.
+	* c-tree.h (build_asm_expr): Update declaration.
+	* c-typeck.c (build_asm_stmt): Add is_inline parameter.  Use it to
+	set ASM_INLINE_P.
+
+	Backport from trunk
+	2018-12-08  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* c-parser (c_parser_asm_statement) [RID_INLINE]: Delete stray line
+	setting "quals".
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* c-parser.c (c_parser_asm_statement): Rewrite the loop to work without
+	"done" boolean variable.
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* c-parser.c (c_parser_asm_statement): Keep track of the location each
+	asm qualifier is first seen; use that to give nicer "duplicate asm
+	qualifier" messages.  Delete 'quals" variable, instead pass the
+	"is_volatile_ flag to build_asm_stmt directly.
+	* c-tree.h (build_asm_stmt): Make the first arg bool instead of tree.
+	* c-typeck.c (build_asm_stmt): Ditto; adjust.
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* c-parser.c (c_parser_asm_statement) <RID_CONST, RID_RESTRICT>: Give
+	a more specific error message (instead of just falling through).
+
+	And extra for the backport
+	2019-01-02  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* c-parser.c (c_parser_asm_statement): Output a warning instead of an
+	error for const and restrict.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: gcc/c/c-parser.c
===================================================================
--- a/src/gcc/c/c-parser.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/c/c-parser.c	(.../branches/gcc-7-branch)
@@ -6089,61 +6089,104 @@
 }
 
 /* Parse an asm statement, a GNU extension.  This is a full-blown asm
-   statement with inputs, outputs, clobbers, and volatile tag
-   allowed.
+   statement with inputs, outputs, clobbers, and volatile, inline, and goto
+   tags allowed.
 
+   asm-qualifier:
+     volatile
+     inline
+     goto
+
+   asm-qualifier-list:
+     asm-qualifier-list asm-qualifier
+     asm-qualifier
+
    asm-statement:
-     asm type-qualifier[opt] ( asm-argument ) ;
-     asm type-qualifier[opt] goto ( asm-goto-argument ) ;
+     asm asm-qualifier-list[opt] ( asm-argument ) ;
 
    asm-argument:
      asm-string-literal
      asm-string-literal : asm-operands[opt]
      asm-string-literal : asm-operands[opt] : asm-operands[opt]
-     asm-string-literal : asm-operands[opt] : asm-operands[opt] : asm-clobbers[opt]
-
-   asm-goto-argument:
+     asm-string-literal : asm-operands[opt] : asm-operands[opt] \
+       : asm-clobbers[opt]
      asm-string-literal : : asm-operands[opt] : asm-clobbers[opt] \
        : asm-goto-operands
 
-   Qualifiers other than volatile are accepted in the syntax but
-   warned for.  */
+   The form with asm-goto-operands is valid if and only if the
+   asm-qualifier-list contains goto, and is the only allowed form in that case.
+   Duplicate asm-qualifiers are not allowed.  */
 
 static tree
 c_parser_asm_statement (c_parser *parser)
 {
-  tree quals, str, outputs, inputs, clobbers, labels, ret;
-  bool simple, is_goto;
+  tree str, outputs, inputs, clobbers, labels, ret;
+  bool simple;
   location_t asm_loc = c_parser_peek_token (parser)->location;
   int section, nsections;
 
   gcc_assert (c_parser_next_token_is_keyword (parser, RID_ASM));
   c_parser_consume_token (parser);
-  if (c_parser_next_token_is_keyword (parser, RID_VOLATILE))
+
+  /* Handle the asm-qualifier-list.  */
+  location_t volatile_loc = UNKNOWN_LOCATION;
+  location_t inline_loc = UNKNOWN_LOCATION;
+  location_t goto_loc = UNKNOWN_LOCATION;
+  for (;;)
     {
-      quals = c_parser_peek_token (parser)->value;
-      c_parser_consume_token (parser);
-    }
-  else if (c_parser_next_token_is_keyword (parser, RID_CONST)
-	   || c_parser_next_token_is_keyword (parser, RID_RESTRICT))
-    {
-      warning_at (c_parser_peek_token (parser)->location,
-		  0,
-		  "%E qualifier ignored on asm",
-		  c_parser_peek_token (parser)->value);
-      quals = NULL_TREE;
-      c_parser_consume_token (parser);
-    }
-  else
-    quals = NULL_TREE;
+      c_token *token = c_parser_peek_token (parser);
+      location_t loc = token->location;
+      switch (token->keyword)
+	{
+	case RID_VOLATILE:
+	  if (volatile_loc)
+	    {
+	      error_at (loc, "duplicate asm qualifier %qE", token->value);
+	      inform (volatile_loc, "first seen here");
+	    }
+	  else
+	    volatile_loc = loc;
+	  c_parser_consume_token (parser);
+	  continue;
 
-  is_goto = false;
-  if (c_parser_next_token_is_keyword (parser, RID_GOTO))
-    {
-      c_parser_consume_token (parser);
-      is_goto = true;
+	case RID_INLINE:
+	  if (inline_loc)
+	    {
+	      error_at (loc, "duplicate asm qualifier %qE", token->value);
+	      inform (inline_loc, "first seen here");
+	    }
+	  else
+	    inline_loc = loc;
+	  c_parser_consume_token (parser);
+	  continue;
+
+	case RID_GOTO:
+	  if (goto_loc)
+	    {
+	      error_at (loc, "duplicate asm qualifier %qE", token->value);
+	      inform (goto_loc, "first seen here");
+	    }
+	  else
+	    goto_loc = loc;
+	  c_parser_consume_token (parser);
+	  continue;
+
+	case RID_CONST:
+	case RID_RESTRICT:
+	  warning_at (loc, 0, "%qE is not an asm qualifier", token->value);
+	  c_parser_consume_token (parser);
+	  continue;
+
+	default:
+	  break;
+	}
+      break;
     }
 
+  bool is_volatile = (volatile_loc != UNKNOWN_LOCATION);
+  bool is_inline = (inline_loc != UNKNOWN_LOCATION);
+  bool is_goto = (goto_loc != UNKNOWN_LOCATION);
+
   /* ??? Follow the C++ parser rather than using the
      lex_untranslated_string kludge.  */
   parser->lex_untranslated_string = true;
@@ -6216,8 +6259,9 @@
   if (!c_parser_require (parser, CPP_SEMICOLON, "expected %<;%>"))
     c_parser_skip_to_end_of_block_or_statement (parser);
 
-  ret = build_asm_stmt (quals, build_asm_expr (asm_loc, str, outputs, inputs,
-					       clobbers, labels, simple));
+  ret = build_asm_stmt (is_volatile,
+			build_asm_expr (asm_loc, str, outputs, inputs,
+					clobbers, labels, simple, is_inline));
 
  error:
   parser->lex_untranslated_string = false;
@@ -18170,6 +18214,8 @@
 
   if (c_parser_peek_token (&tparser)->pragma_kind == PRAGMA_GCC_PCH_PREPROCESS)
     c_parser_pragma_pch_preprocess (&tparser);
+  else
+    c_common_no_more_pch ();
 
   the_parser = ggc_alloc<c_parser> ();
   *the_parser = tparser;
Index: gcc/c/c-typeck.c
===================================================================
--- a/src/gcc/c/c-typeck.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/c/c-typeck.c	(.../branches/gcc-7-branch)
@@ -9669,9 +9669,9 @@
    (guaranteed to be 'volatile' or null) and ARGS (represented using
    an ASM_EXPR node).  */
 tree
-build_asm_stmt (tree cv_qualifier, tree args)
+build_asm_stmt (bool is_volatile, tree args)
 {
-  if (!ASM_VOLATILE_P (args) && cv_qualifier)
+  if (is_volatile)
     ASM_VOLATILE_P (args) = 1;
   return add_stmt (args);
 }
@@ -9680,10 +9680,12 @@
    some INPUTS, and some CLOBBERS.  The latter three may be NULL.
    SIMPLE indicates whether there was anything at all after the
    string in the asm expression -- asm("blah") and asm("blah" : )
-   are subtly different.  We use a ASM_EXPR node to represent this.  */
+   are subtly different.  We use a ASM_EXPR node to represent this.
+   LOC is the location of the asm, and IS_INLINE says whether this
+   is asm inline.  */
 tree
 build_asm_expr (location_t loc, tree string, tree outputs, tree inputs,
-		tree clobbers, tree labels, bool simple)
+		tree clobbers, tree labels, bool simple, bool is_inline)
 {
   tree tail;
   tree args;
@@ -9801,6 +9803,7 @@
      as volatile.  */
   ASM_INPUT_P (args) = simple;
   ASM_VOLATILE_P (args) = (noutputs == 0);
+  ASM_INLINE_P (args) = is_inline;
 
   return args;
 }
Index: gcc/c/c-tree.h
===================================================================
--- a/src/gcc/c/c-tree.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/c/c-tree.h	(.../branches/gcc-7-branch)
@@ -659,8 +659,9 @@
 extern void check_compound_literal_type (location_t, struct c_type_name *);
 extern tree c_start_case (location_t, location_t, tree, bool);
 extern void c_finish_case (tree, tree);
-extern tree build_asm_expr (location_t, tree, tree, tree, tree, tree, bool);
-extern tree build_asm_stmt (tree, tree);
+extern tree build_asm_expr (location_t, tree, tree, tree, tree, tree, bool,
+			    bool);
+extern tree build_asm_stmt (bool, tree);
 extern int c_types_compatible_p (tree, tree);
 extern tree c_begin_compound_stmt (bool);
 extern tree c_end_compound_stmt (location_t, tree, bool);
Index: gcc/c/c-decl.c
===================================================================
--- a/src/gcc/c/c-decl.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/c/c-decl.c	(.../branches/gcc-7-branch)
@@ -1235,8 +1235,9 @@
 	      && DECL_ABSTRACT_ORIGIN (p) != 0
 	      && DECL_ABSTRACT_ORIGIN (p) != p)
 	    TREE_ADDRESSABLE (DECL_ABSTRACT_ORIGIN (p)) = 1;
-	  if (!DECL_EXTERNAL (p)
+	  if (!TREE_PUBLIC (p)
 	      && !DECL_INITIAL (p)
+	      && !b->nested
 	      && scope != file_scope
 	      && scope != external_scope)
 	    {
@@ -1252,7 +1253,7 @@
 		 in the same translation unit."  */
 	      if (!flag_gnu89_inline
 		  && !lookup_attribute ("gnu_inline", DECL_ATTRIBUTES (p))
-		  && scope != external_scope)
+		  && scope == external_scope)
 		pedwarn (input_location, 0,
 			 "inline function %q+D declared but never defined", p);
 	      DECL_EXTERNAL (p) = 1;
@@ -2347,13 +2348,33 @@
       if (TYPE_NAME (TREE_TYPE (newdecl)) == newdecl)
 	{
 	  tree remove = TREE_TYPE (newdecl);
-	  for (tree t = TYPE_MAIN_VARIANT (remove); ;
-	       t = TYPE_NEXT_VARIANT (t))
-	    if (TYPE_NEXT_VARIANT (t) == remove)
-	      {
-		TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (remove);
-		break;
-	      }
+	  if (TYPE_MAIN_VARIANT (remove) == remove)
+	    {
+	      gcc_assert (TYPE_NEXT_VARIANT (remove) == NULL_TREE);
+	      /* If remove is the main variant, no need to remove that
+		 from the list.  One of the DECL_ORIGINAL_TYPE
+		 variants, e.g. created for aligned attribute, might still
+		 refer to the newdecl TYPE_DECL though, so remove that one
+		 in that case.  */
+	      if (DECL_ORIGINAL_TYPE (newdecl)
+		  && DECL_ORIGINAL_TYPE (newdecl) != remove)
+		for (tree t = TYPE_MAIN_VARIANT (DECL_ORIGINAL_TYPE (newdecl));
+		     t; t = TYPE_MAIN_VARIANT (t))
+		  if (TYPE_NAME (TYPE_NEXT_VARIANT (t)) == newdecl)
+		    {
+		      TYPE_NEXT_VARIANT (t)
+			= TYPE_NEXT_VARIANT (TYPE_NEXT_VARIANT (t));
+		      break;
+		    }
+	    }	    
+	  else
+	    for (tree t = TYPE_MAIN_VARIANT (remove); ;
+		 t = TYPE_NEXT_VARIANT (t))
+	      if (TYPE_NEXT_VARIANT (t) == remove)
+		{
+		  TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (remove);
+		  break;
+		}
 	}
     }
 
@@ -6360,10 +6381,12 @@
 		  quals_used &= TYPE_QUAL_ATOMIC;
 		if (quals_used && VOID_TYPE_P (type) && really_funcdef)
 		  pedwarn (specs_loc, 0,
-			   "function definition has qualified void return type");
+			   "function definition has qualified void "
+			   "return type");
 		else
 		  warning_at (specs_loc, OPT_Wignored_qualifiers,
-			   "type qualifiers ignored on function return type");
+			      "type qualifiers ignored on function "
+			      "return type");
 
 		/* Ensure an error for restrict on invalid types; the
 		   DR#423 resolution is not entirely clear about
@@ -6373,8 +6396,7 @@
 		    && (!POINTER_TYPE_P (type)
 			|| !C_TYPE_OBJECT_OR_INCOMPLETE_P (TREE_TYPE (type))))
 		  error_at (loc, "invalid use of %<restrict%>");
-		if (quals_used)
-		  type = c_build_qualified_type (type, quals_used);
+		type = c_build_qualified_type (type, quals_used);
 	      }
 	    type_quals = TYPE_UNQUALIFIED;
 
Index: gcc/cfgloopmanip.c
===================================================================
--- a/src/gcc/cfgloopmanip.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cfgloopmanip.c	(.../branches/gcc-7-branch)
@@ -1023,6 +1023,7 @@
   target->warned_aggressive_loop_optimizations
     |= loop->warned_aggressive_loop_optimizations;
   target->in_oacc_kernels_region = loop->in_oacc_kernels_region;
+  target->owned_clique = loop->owned_clique;
 }
 
 /* Copies copy of LOOP as subloop of TARGET loop, placing newly
Index: gcc/optabs.c
===================================================================
--- a/src/gcc/optabs.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/optabs.c	(.../branches/gcc-7-branch)
@@ -3811,7 +3811,7 @@
 
 	  /* Must make sure the size fits the insn's mode.  */
 	  if ((CONST_INT_P (size)
-	       && INTVAL (size) >= (1 << GET_MODE_BITSIZE (cmp_mode)))
+	       && UINTVAL (size) > GET_MODE_MASK (cmp_mode))
 	      || (GET_MODE_BITSIZE (GET_MODE (size))
 		  > GET_MODE_BITSIZE (cmp_mode)))
 	    continue;
@@ -3830,7 +3830,7 @@
 	goto fail;
 
       /* Otherwise call a library function.  */
-      result = emit_block_comp_via_libcall (XEXP (x, 0), XEXP (y, 0), size);
+      result = emit_block_comp_via_libcall (x, y, size);
 
       x = result;
       y = const0_rtx;
Index: gcc/DATESTAMP
===================================================================
--- a/src/gcc/DATESTAMP	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/DATESTAMP	(.../branches/gcc-7-branch)
@@ -1 +1 @@
-20181206
+20191105
Index: gcc/valtrack.c
===================================================================
--- a/src/gcc/valtrack.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/valtrack.c	(.../branches/gcc-7-branch)
@@ -56,8 +56,6 @@
 cleanup_auto_inc_dec (rtx src, machine_mode mem_mode ATTRIBUTE_UNUSED)
 {
   rtx x = src;
-  if (!AUTO_INC_DEC)
-    return copy_rtx (x);
 
   const RTX_CODE code = GET_CODE (x);
   int i;
Index: gcc/lra.c
===================================================================
--- a/src/gcc/lra.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/lra.c	(.../branches/gcc-7-branch)
@@ -1670,10 +1670,12 @@
 
     case SCRATCH:
     case CONST_DOUBLE:
-    case CONST_INT:
     case CONST_VECTOR:
       return val;
 
+    case CONST_INT:
+      return val + UINTVAL (x);
+
     default:
       break;
     }
Index: gcc/tree-ssa-loop-ch.c
===================================================================
--- a/src/gcc/tree-ssa-loop-ch.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssa-loop-ch.c	(.../branches/gcc-7-branch)
@@ -99,7 +99,7 @@
     }
 
   last = last_stmt (header);
-  if (gimple_code (last) != GIMPLE_COND)
+  if (!last || gimple_code (last) != GIMPLE_COND)
     {
       if (dump_file && (dump_flags & TDF_DETAILS))
 	fprintf (dump_file,
@@ -373,11 +373,23 @@
 		{
 		  gimple *stmt = gsi_stmt (bsi);
 		  if (gimple_code (stmt) == GIMPLE_COND)
-		    gimple_set_no_warning (stmt, true);
+		    {
+		      tree lhs = gimple_cond_lhs (stmt);
+		      if (gimple_cond_code (stmt) != EQ_EXPR
+			  && gimple_cond_code (stmt) != NE_EXPR
+			  && INTEGRAL_TYPE_P (TREE_TYPE (lhs))
+			  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (lhs)))
+			gimple_set_no_warning (stmt, true);
+		    }
 		  else if (is_gimple_assign (stmt))
 		    {
 		      enum tree_code rhs_code = gimple_assign_rhs_code (stmt);
-		      if (TREE_CODE_CLASS (rhs_code) == tcc_comparison)
+		      tree rhs1 = gimple_assign_rhs1 (stmt);
+		      if (TREE_CODE_CLASS (rhs_code) == tcc_comparison
+			  && rhs_code != EQ_EXPR
+			  && rhs_code != NE_EXPR
+			  && INTEGRAL_TYPE_P (TREE_TYPE (rhs1))
+			  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (rhs1)))
 			gimple_set_no_warning (stmt, true);
 		    }
 		}
Index: gcc/tree-ssa-strlen.c
===================================================================
--- a/src/gcc/tree-ssa-strlen.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssa-strlen.c	(.../branches/gcc-7-branch)
@@ -936,10 +936,18 @@
     return false;
 
   tree callee = gimple_call_fndecl (stmt);
+  tree decl = builtin_decl_explicit (DECL_FUNCTION_CODE (callee));
+  if (decl
+      && decl != callee
+      && !gimple_builtin_call_types_compatible_p (stmt, decl))
+    return false;
+
   switch (DECL_FUNCTION_CODE (callee))
     {
     case BUILT_IN_MEMCMP:
     case BUILT_IN_MEMCMP_EQ:
+    case BUILT_IN_STRCMP:
+    case BUILT_IN_STRNCMP:
     case BUILT_IN_STRCHR:
     case BUILT_IN_STRCHR_CHKP:
     case BUILT_IN_STRLEN:
@@ -964,6 +972,8 @@
     case BUILT_IN_STPCPY_CHK:
     case BUILT_IN_STPCPY_CHKP:
     case BUILT_IN_STPCPY_CHK_CHKP:
+    case BUILT_IN_STPNCPY:
+    case BUILT_IN_STPNCPY_CHK:
     case BUILT_IN_STRCAT:
     case BUILT_IN_STRCAT_CHK:
     case BUILT_IN_STRCAT_CHKP:
@@ -972,6 +982,10 @@
     case BUILT_IN_STRCPY_CHK:
     case BUILT_IN_STRCPY_CHKP:
     case BUILT_IN_STRCPY_CHK_CHKP:
+    case BUILT_IN_STRNCAT:
+    case BUILT_IN_STRNCAT_CHK:
+    case BUILT_IN_STRNCPY:
+    case BUILT_IN_STRNCPY_CHK:
       /* The above functions should be neither const nor pure.  Punt if they
 	 aren't.  */
       if (gimple_vdef (stmt) == NULL_TREE || gimple_vuse (stmt) == NULL_TREE)
Index: gcc/tree.c
===================================================================
--- a/src/gcc/tree.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree.c	(.../branches/gcc-7-branch)
@@ -6456,6 +6456,11 @@
 	     a function global scope, unless declared static.  */
 	  if (current_function_decl != NULL_TREE && !TREE_STATIC (node))
 	    TREE_PUBLIC (node) = 1;
+	  /* Clear TREE_STATIC because DECL_EXTERNAL is set, unless
+	     it is a C++ static data member.  */
+	  if (DECL_CONTEXT (node) == NULL_TREE
+	      || !RECORD_OR_UNION_TYPE_P (DECL_CONTEXT (node)))
+	    TREE_STATIC (node) = 0;
 	}
 
       if (*no_add_attrs == false)
Index: gcc/tree.h
===================================================================
--- a/src/gcc/tree.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree.h	(.../branches/gcc-7-branch)
@@ -912,6 +912,11 @@
   (TREE_CHECK2 (NODE, VAR_DECL, \
 		RESULT_DECL)->decl_common.decl_nonshareable_flag)
 
+/* In a PARM_DECL, set for Fortran hidden string length arguments that some
+   buggy callers don't pass to the callee.  */
+#define DECL_HIDDEN_STRING_LENGTH(NODE) \
+  (TREE_CHECK (NODE, PARM_DECL)->decl_common.decl_nonshareable_flag)
+
 /* In a CALL_EXPR, means that the call is the jump from a thunk to the
    thunked-to function.  */
 #define CALL_FROM_THUNK_P(NODE) (CALL_EXPR_CHECK (NODE)->base.protected_flag)
@@ -1231,6 +1236,9 @@
    ASM_OPERAND with no operands.  */
 #define ASM_INPUT_P(NODE) (ASM_EXPR_CHECK (NODE)->base.static_flag)
 #define ASM_VOLATILE_P(NODE) (ASM_EXPR_CHECK (NODE)->base.public_flag)
+/* Nonzero if we want to consider this asm as minimum length and cost
+   for inlining decisions.  */
+#define ASM_INLINE_P(NODE) (ASM_EXPR_CHECK (NODE)->base.protected_flag)
 
 /* COND_EXPR accessors.  */
 #define COND_EXPR_COND(NODE)	(TREE_OPERAND (COND_EXPR_CHECK (NODE), 0))
Index: gcc/ipa-cp.c
===================================================================
--- a/src/gcc/ipa-cp.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ipa-cp.c	(.../branches/gcc-7-branch)
@@ -810,7 +810,7 @@
   topo->stack = XCNEWVEC (struct cgraph_node *, symtab->cgraph_count);
 
   gcc_checking_assert (topo->stack_top == 0);
-  topo->nnodes = ipa_reduced_postorder (topo->order, true, true, NULL);
+  topo->nnodes = ipa_reduced_postorder (topo->order, true, NULL);
 }
 
 /* Free information about strongly connected components and the arrays in
@@ -1072,7 +1072,6 @@
   if (TREE_CODE_CLASS (code) == tcc_binary)
     {
       tree type = TREE_TYPE (operand);
-      gcc_assert (INTEGRAL_TYPE_P (type));
       widest_int o_value, o_mask;
       get_value_and_mask (operand, &o_value, &o_mask);
 
@@ -2819,12 +2818,19 @@
   estimate_ipcp_clone_size_and_time (node, known_csts, known_contexts,
 				     known_aggs_ptrs, &size, &time,
 				     &hints);
-  time_benefit = base_time - time
-    + devirtualization_time_bonus (node, known_csts, known_contexts,
-				   known_aggs_ptrs)
-    + hint_time_bonus (hints)
-    + removable_params_cost + est_move_cost;
 
+  /* Extern inline functions have no cloning local time benefits because they
+     will be inlined anyway.  The only reason to clone them is if it enables
+     optimization in any of the functions they call.  */
+  if (DECL_EXTERNAL (node->decl) && DECL_DECLARED_INLINE_P (node->decl))
+    time_benefit = 0;
+  else
+    time_benefit = base_time - time
+      + devirtualization_time_bonus (node, known_csts, known_contexts,
+				     known_aggs_ptrs)
+      + hint_time_bonus (hints)
+      + removable_params_cost + est_move_cost;
+
   gcc_checking_assert (size >=0);
   /* The inliner-heuristics based estimates may think that in certain
      contexts some functions do not have any size at all but we want
Index: gcc/tree-scalar-evolution.c
===================================================================
--- a/src/gcc/tree-scalar-evolution.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-scalar-evolution.c	(.../branches/gcc-7-branch)
@@ -280,6 +280,7 @@
 #include "params.h"
 #include "tree-ssa-propagate.h"
 #include "gimple-fold.h"
+#include "tree-into-ssa.h"
 
 static tree analyze_scalar_evolution_1 (struct loop *, tree, tree);
 static tree analyze_scalar_evolution_for_address_of (struct loop *loop,
@@ -866,7 +867,7 @@
       gimple *stmt;
 
       stmt = last_stmt (exit_edge->src);
-      if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))
+      if (gcond *cond_stmt = safe_dyn_cast <gcond *> (stmt))
 	res = cond_stmt;
     }
 
@@ -1412,6 +1413,11 @@
       return build_polynomial_chrec (loop->num, init_cond, right);
     }
 
+  /* The affine code only deals with pointer and integer types.  */
+  if (!POINTER_TYPE_P (type)
+      && !INTEGRAL_TYPE_P (type))
+    return chrec_dont_know;
+
   /* Try harder to check if they are equal.  */
   tree_to_aff_combination_expand (left, type, &aff1, &peeled_chrec_map);
   tree_to_aff_combination_expand (step_val, type, &aff2, &peeled_chrec_map);
@@ -1532,7 +1538,10 @@
 follow_copies_to_constant (tree var)
 {
   tree res = var;
-  while (TREE_CODE (res) == SSA_NAME)
+  while (TREE_CODE (res) == SSA_NAME
+	 /* We face not updated SSA form in multiple places and this walk
+	    may end up in sibling loops so we have to guard it.  */
+	 && !name_registered_for_update_p (res))
     {
       gimple *def = SSA_NAME_DEF_STMT (res);
       if (gphi *phi = dyn_cast <gphi *> (def))
Index: gcc/rtlanal.c
===================================================================
--- a/src/gcc/rtlanal.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/rtlanal.c	(.../branches/gcc-7-branch)
@@ -357,10 +357,10 @@
   if (to == from)
     return 0;
 
-  /* It is not safe to call INITIAL_ELIMINATION_OFFSET
-     before the reload pass.  We need to give at least
-     an estimation for the resulting frame size.  */
-  if (! reload_completed)
+  /* It is not safe to call INITIAL_ELIMINATION_OFFSET before the epilogue
+     is completed, but we need to give at least an estimate for the stack
+     pointer based on the frame size.  */
+  if (!epilogue_completed)
     {
       offset1 = crtl->outgoing_args_size + get_frame_size ();
 #if !STACK_GROWS_DOWNWARD
@@ -4636,7 +4636,7 @@
 	       || ((extend_op = load_extend_op (inner_mode)) == SIGN_EXTEND
 		   ? val_signbit_known_set_p (inner_mode, nonzero)
 		   : extend_op != ZERO_EXTEND)
-	       || (!MEM_P (SUBREG_REG (x)) && !REG_P (SUBREG_REG (x))))
+	       || !MEM_P (SUBREG_REG (x)))
 	      && GET_MODE_PRECISION (GET_MODE (x))
 		  > GET_MODE_PRECISION (inner_mode))
 	    nonzero
Index: gcc/internal-fn.c
===================================================================
--- a/src/gcc/internal-fn.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/internal-fn.c	(.../branches/gcc-7-branch)
@@ -2770,6 +2770,56 @@
   0
 };
 
+/* Return true if IFN is some form of load from memory.  */
+
+bool
+internal_load_fn_p (internal_fn fn)
+{
+  switch (fn)
+    {
+    case IFN_MASK_LOAD:
+    case IFN_LOAD_LANES:
+      return true;
+
+    default:
+      return false;
+    }
+}
+
+/* Return true if IFN is some form of store to memory.  */
+
+bool
+internal_store_fn_p (internal_fn fn)
+{
+  switch (fn)
+    {
+    case IFN_MASK_STORE:
+    case IFN_STORE_LANES:
+      return true;
+
+    default:
+      return false;
+    }
+}
+
+/* If FN takes a vector mask argument, return the index of that argument,
+   otherwise return -1.  */
+
+int
+internal_fn_mask_index (internal_fn fn)
+{
+  switch (fn)
+    {
+    case IFN_MASK_LOAD:
+    case IFN_MASK_STORE:
+      return 2;
+
+    default:
+      return -1;
+    }
+}
+
+
 /* Expand STMT as though it were a call to internal function FN.  */
 
 void
Index: gcc/internal-fn.h
===================================================================
--- a/src/gcc/internal-fn.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/internal-fn.h	(.../branches/gcc-7-branch)
@@ -176,6 +176,10 @@
 					    optimization_type);
 extern bool set_edom_supported_p (void);
 
+extern bool internal_load_fn_p (internal_fn);
+extern bool internal_store_fn_p (internal_fn);
+extern int internal_fn_mask_index (internal_fn);
+
 extern void expand_internal_call (gcall *);
 extern void expand_internal_call (internal_fn, gcall *);
 extern void expand_PHI (internal_fn, gcall *);
Index: gcc/builtins.c
===================================================================
--- a/src/gcc/builtins.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/builtins.c	(.../branches/gcc-7-branch)
@@ -2508,7 +2508,7 @@
   tree arg;
 
   if (!validate_arglist (exp, REAL_TYPE, VOID_TYPE))
-    gcc_unreachable ();
+    return NULL_RTX;
 
   arg = CALL_EXPR_ARG (exp, 0);
 
@@ -2644,7 +2644,7 @@
   enum built_in_function fallback_fn = BUILT_IN_NONE;
 
   if (!validate_arglist (exp, REAL_TYPE, VOID_TYPE))
-     gcc_unreachable ();
+    return NULL_RTX;
 
   arg = CALL_EXPR_ARG (exp, 0);
 
@@ -9774,6 +9774,9 @@
 static void
 maybe_emit_free_warning (tree exp)
 {
+  if (call_expr_nargs (exp) != 1)
+    return;
+
   tree arg = CALL_EXPR_ARG (exp, 0);
 
   STRIP_NOPS (arg);
Index: gcc/final.c
===================================================================
--- a/src/gcc/final.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/final.c	(.../branches/gcc-7-branch)
@@ -4490,7 +4490,11 @@
   assemble_start_function (current_function_decl, fnname);
   final_start_function (get_insns (), asm_out_file, optimize);
   final (get_insns (), asm_out_file, optimize);
-  if (flag_ipa_ra)
+  if (flag_ipa_ra
+      /* Functions with naked attributes are supported only with basic asm
+	 statements in the body, thus for supported use cases the information
+	 on clobbered registers is not available.  */
+      && !lookup_attribute ("naked", DECL_ATTRIBUTES (current_function_decl)))
     collect_fn_hard_reg_usage ();
   final_end_function ();
 
Index: gcc/input.c
===================================================================
--- a/src/gcc/input.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/input.c	(.../branches/gcc-7-branch)
@@ -3480,6 +3480,34 @@
   ASSERT_EQ (num_cases_tested, 2 * 12);
 }
 
+/* Verify that when presented with a consecutive pair of locations with
+   a very large line offset, we don't attempt to consolidate them into
+   a single ordinary linemap where the line offsets within the line map
+   would lead to overflow (PR lto/88147).  */
+
+static void
+test_line_offset_overflow ()
+{
+  line_table_test ltt (line_table_case (5, 0));
+
+  linemap_add (line_table, LC_ENTER, false, "foo.c", 0);
+  linemap_line_start (line_table, 1, 100);
+  location_t loc_a = linemap_line_start (line_table, 2578, 255);
+  assert_loceq ("foo.c", 2578, 0, loc_a);
+
+  const line_map_ordinary *ordmap_a = LINEMAPS_LAST_ORDINARY_MAP (line_table);
+  ASSERT_EQ (ordmap_a->m_column_and_range_bits, 13);
+  ASSERT_EQ (ordmap_a->m_range_bits, 5);
+
+  location_t loc_b = linemap_line_start (line_table, 404198, 512);
+  assert_loceq ("foo.c", 404198, 0, loc_b);
+
+  /* We should have started a new linemap, rather than attempting to store
+     a very large line offset.  */
+  const line_map_ordinary *ordmap_b = LINEMAPS_LAST_ORDINARY_MAP (line_table);
+  ASSERT_NE (ordmap_a, ordmap_b);
+}
+
 /* Run all of the selftests within this file.  */
 
 void
@@ -3518,6 +3546,8 @@
   for_each_line_table_case (test_lexer_char_constants);
 
   test_reading_source_line ();
+
+  test_line_offset_overflow ();
 }
 
 } // namespace selftest
Index: gcc/cfghooks.c
===================================================================
--- a/src/gcc/cfghooks.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cfghooks.c	(.../branches/gcc-7-branch)
@@ -1067,7 +1067,7 @@
    AFTER.  */
 
 basic_block
-duplicate_block (basic_block bb, edge e, basic_block after)
+duplicate_block (basic_block bb, edge e, basic_block after, copy_bb_data *id)
 {
   edge s, n;
   basic_block new_bb;
@@ -1083,7 +1083,7 @@
 
   gcc_checking_assert (can_duplicate_block_p (bb));
 
-  new_bb = cfg_hooks->duplicate_block (bb);
+  new_bb = cfg_hooks->duplicate_block (bb, id);
   if (after)
     move_block_after (new_bb, after);
 
@@ -1355,6 +1355,7 @@
   unsigned i, j;
   basic_block bb, new_bb, dom_bb;
   edge e;
+  copy_bb_data id;
 
   /* Duplicate bbs, update dominators, assign bbs to loops.  */
   for (i = 0; i < n; i++)
@@ -1361,7 +1362,7 @@
     {
       /* Duplicate.  */
       bb = bbs[i];
-      new_bb = new_bbs[i] = duplicate_block (bb, NULL, after);
+      new_bb = new_bbs[i] = duplicate_block (bb, NULL, after, &id);
       after = new_bb;
       bb->flags |= BB_DUPLICATED;
       if (bb->loop_father)
Index: gcc/cfghooks.h
===================================================================
--- a/src/gcc/cfghooks.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cfghooks.h	(.../branches/gcc-7-branch)
@@ -54,7 +54,20 @@
   bool run;
 };
 
+typedef int_hash <unsigned short, 0> dependence_hash;
 
+/* Optional data for duplicate_block.   */
+
+struct copy_bb_data
+{
+  copy_bb_data() : dependence_map (NULL) {}
+  ~copy_bb_data () { delete dependence_map; }
+
+  /* A map from the copied BBs dependence info cliques to
+     equivalents in the BBs duplicated to.  */
+  hash_map<dependence_hash, unsigned short> *dependence_map;
+};
+
 struct cfg_hooks
 {
   /* Name of the corresponding ir.  */
@@ -112,7 +125,7 @@
   bool (*can_duplicate_block_p) (const_basic_block a);
 
   /* Duplicate block A.  */
-  basic_block (*duplicate_block) (basic_block a);
+  basic_block (*duplicate_block) (basic_block a, copy_bb_data *);
 
   /* Higher level functions representable by primitive operations above if
      we didn't have some oddities in RTL and Tree representations.  */
@@ -227,7 +240,8 @@
 extern void predict_edge (edge e, enum br_predictor predictor, int probability);
 extern bool predicted_by_p (const_basic_block bb, enum br_predictor predictor);
 extern bool can_duplicate_block_p (const_basic_block);
-extern basic_block duplicate_block (basic_block, edge, basic_block);
+extern basic_block duplicate_block (basic_block, edge, basic_block,
+				    copy_bb_data * = NULL);
 extern bool block_ends_with_call_p (basic_block bb);
 extern bool empty_block_p (basic_block);
 extern basic_block split_block_before_cond_jump (basic_block);
Index: gcc/fold-const.c
===================================================================
--- a/src/gcc/fold-const.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fold-const.c	(.../branches/gcc-7-branch)
@@ -3044,10 +3044,16 @@
       switch (TREE_CODE (arg0))
 	{
 	case INDIRECT_REF:
-	  if (!(flags & OEP_ADDRESS_OF)
-	      && (TYPE_ALIGN (TREE_TYPE (arg0))
-		  != TYPE_ALIGN (TREE_TYPE (arg1))))
-	    return 0;
+	  if (!(flags & OEP_ADDRESS_OF))
+	    {
+	      if (TYPE_ALIGN (TREE_TYPE (arg0))
+		  != TYPE_ALIGN (TREE_TYPE (arg1)))
+		return 0;
+	      /* Verify that the access types are compatible.  */
+	      if (TYPE_MAIN_VARIANT (TREE_TYPE (arg0))
+		  != TYPE_MAIN_VARIANT (TREE_TYPE (arg1)))
+		return 0;
+	    }
 	  flags &= ~OEP_ADDRESS_OF;
 	  return OP_SAME (0);
 
@@ -4159,7 +4165,7 @@
      There are problems with FP fields since the type_for_size call
      below can fail for, e.g., XFmode.  */
   if (! INTEGRAL_TYPE_P (TREE_TYPE (exp)))
-    return 0;
+    return NULL_TREE;
 
   /* We are interested in the bare arrangement of bits, so strip everything
      that doesn't affect the machine mode.  However, record the type of the
@@ -4175,7 +4181,7 @@
       exp = TREE_OPERAND (exp, 0);
       STRIP_NOPS (exp); STRIP_NOPS (and_mask);
       if (TREE_CODE (and_mask) != INTEGER_CST)
-	return 0;
+	return NULL_TREE;
     }
 
   inner = get_inner_reference (exp, pbitsize, pbitpos, &offset, pmode,
@@ -4187,8 +4193,12 @@
       || (! AGGREGATE_TYPE_P (TREE_TYPE (inner))
 	  && compare_tree_int (TYPE_SIZE (TREE_TYPE (inner)),
 			       *pbitpos + *pbitsize) < 0))
-    return 0;
+    return NULL_TREE;
 
+  unsigned_type = lang_hooks.types.type_for_size (*pbitsize, 1);
+  if (unsigned_type == NULL_TREE)
+    return NULL_TREE;
+
   *exp_ = exp;
 
   /* If the number of bits in the reference is the same as the bitsize of
@@ -4198,7 +4208,6 @@
     *punsignedp = TYPE_UNSIGNED (outer_type);
 
   /* Compute the mask to access the bitfield.  */
-  unsigned_type = lang_hooks.types.type_for_size (*pbitsize, 1);
   precision = TYPE_PRECISION (unsigned_type);
 
   mask = build_int_cst_type (unsigned_type, -1);
@@ -10726,8 +10735,7 @@
 		strlen(ptr) != 0   =>  *ptr != 0
 	 Other cases should reduce to one of these two (or a constant)
 	 due to the return value of strlen being unsigned.  */
-      if (TREE_CODE (arg0) == CALL_EXPR
-	  && integer_zerop (arg1))
+      if (TREE_CODE (arg0) == CALL_EXPR && integer_zerop (arg1))
 	{
 	  tree fndecl = get_callee_fndecl (arg0);
 
@@ -10735,12 +10743,17 @@
 	      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL
 	      && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_STRLEN
 	      && call_expr_nargs (arg0) == 1
-	      && TREE_CODE (TREE_TYPE (CALL_EXPR_ARG (arg0, 0))) == POINTER_TYPE)
+	      && (TREE_CODE (TREE_TYPE (CALL_EXPR_ARG (arg0, 0)))
+		  == POINTER_TYPE))
 	    {
-	      tree iref = build_fold_indirect_ref_loc (loc,
-						   CALL_EXPR_ARG (arg0, 0));
+	      tree ptrtype
+		= build_pointer_type (build_qualified_type (char_type_node,
+							    TYPE_QUAL_CONST));
+	      tree ptr = fold_convert_loc (loc, ptrtype,
+					   CALL_EXPR_ARG (arg0, 0));
+	      tree iref = build_fold_indirect_ref_loc (loc, ptr);
 	      return fold_build2_loc (loc, code, type, iref,
-				  build_int_cst (TREE_TYPE (iref), 0));
+				      build_int_cst (TREE_TYPE (iref), 0));
 	    }
 	}
 
Index: gcc/gimple-ssa-sprintf.c
===================================================================
--- a/src/gcc/gimple-ssa-sprintf.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/gimple-ssa-sprintf.c	(.../branches/gcc-7-branch)
@@ -3353,10 +3353,10 @@
 	 are badly declared.  */
       && !stmt_ends_bb_p (info.callstmt))
     {
-      tree cst = build_int_cst (integer_type_node, minretval);
+      tree cst = build_int_cst (lhs ? TREE_TYPE (lhs) : integer_type_node,
+				minretval);
 
-      if (lhs == NULL_TREE
-	  && info.nowrite)
+      if (lhs == NULL_TREE && info.nowrite)
 	{
 	  /* Remove the call to the bounded function with a zero size
 	     (e.g., snprintf(0, 0, "%i", 123)) if there is no lhs.  */
@@ -3397,7 +3397,7 @@
 	    }
 	}
     }
-  else if (lhs)
+  else if (lhs && types_compatible_p (TREE_TYPE (lhs), integer_type_node))
     {
       bool setrange = false;
 
Index: gcc/omp-low.c
===================================================================
--- a/src/gcc/omp-low.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/omp-low.c	(.../branches/gcc-7-branch)
@@ -853,6 +853,7 @@
       ctx->cb.copy_decl = omp_copy_decl;
       ctx->cb.eh_lp_nr = 0;
       ctx->cb.transform_call_graph_edges = CB_CGE_MOVE;
+      ctx->cb.dont_remap_vla_if_no_change = true;
       ctx->depth = 1;
     }
 
@@ -2888,8 +2889,10 @@
 	  case GIMPLE_OMP_FOR:
 	    if (gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_TASKLOOP)
 	      goto ordered_in_taskloop;
-	    if (omp_find_clause (gimple_omp_for_clauses (ctx->stmt),
-				 OMP_CLAUSE_ORDERED) == NULL)
+	    tree o;
+	    o = omp_find_clause (gimple_omp_for_clauses (ctx->stmt),
+				 OMP_CLAUSE_ORDERED);
+	    if (o == NULL)
 	      {
 		error_at (gimple_location (stmt),
 			  "%<ordered%> region must be closely nested inside "
@@ -2896,6 +2899,15 @@
 			  "a loop region with an %<ordered%> clause");
 		return false;
 	      }
+	    if (OMP_CLAUSE_ORDERED_EXPR (o) != NULL_TREE
+		&& omp_find_clause (c, OMP_CLAUSE_DEPEND) == NULL_TREE)
+	      {
+		error_at (gimple_location (stmt),
+			  "%<ordered%> region without %<depend%> clause may "
+			  "not be closely nested inside a loop region with "
+			  "an %<ordered%> clause with a parameter");
+		return false;
+	      }
 	    return true;
 	  case GIMPLE_OMP_TARGET:
 	    if (gimple_omp_target_kind (ctx->stmt)
Index: gcc/objc/ChangeLog
===================================================================
--- a/src/gcc/objc/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/objc/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,14 @@
+2019-09-05  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* objc/objc-act.h (OCTI_INSTANCE_TYPE, OCTI_INSTANCETYPE_NAME): New.
+	(objc_global_trees): Add instance type and name.
+	(INSTANCE_TYPEDEF_NAME): New.
+	* objc/objc-act.c (synth_module_prologue): Build decls for
+	objc_instancetype_type and objc_instancetype_name.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: gcc/objc/objc-act.c
===================================================================
--- a/src/gcc/objc/objc-act.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/objc/objc-act.c	(.../branches/gcc-7-branch)
@@ -2944,12 +2944,14 @@
   objc_class_reference = xref_tag (RECORD_TYPE, objc_class_id);
 
   objc_object_type = build_pointer_type (objc_object_reference);
+  objc_instancetype_type = build_pointer_type (objc_object_reference);
   objc_class_type = build_pointer_type (objc_class_reference);
 
   objc_object_name = get_identifier (OBJECT_TYPEDEF_NAME);
+  objc_instancetype_name = get_identifier (INSTANCE_TYPEDEF_NAME);
   objc_class_name = get_identifier (CLASS_TYPEDEF_NAME);
 
-  /* Declare the 'id' and 'Class' typedefs.  */
+  /* Declare the 'id', 'instancetype' and 'Class' typedefs.  */
   type = lang_hooks.decls.pushdecl (build_decl (input_location,
 						TYPE_DECL,
 						objc_object_name,
@@ -2958,6 +2960,12 @@
 
   type = lang_hooks.decls.pushdecl (build_decl (input_location,
 						TYPE_DECL,
+						objc_instancetype_name,
+						objc_instancetype_type));
+  TREE_NO_WARNING (type) = 1;
+
+  type = lang_hooks.decls.pushdecl (build_decl (input_location,
+						TYPE_DECL,
 						objc_class_name,
 						objc_class_type));
   TREE_NO_WARNING (type) = 1;
Index: gcc/objc/objc-act.h
===================================================================
--- a/src/gcc/objc/objc-act.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/objc/objc-act.h	(.../branches/gcc-7-branch)
@@ -313,6 +313,7 @@
     OCTI_SUPER_TYPE,
     OCTI_SEL_TYPE,
     OCTI_ID_TYPE,
+    OCTI_INSTANCE_TYPE,
     OCTI_CLS_TYPE,
     OCTI_NST_TYPE,
     OCTI_PROTO_TYPE,
@@ -368,6 +369,7 @@
     OCTI_OBJ_ID,
     OCTI_CLS_ID,
     OCTI_ID_NAME,
+    OCTI_INSTANCETYPE_NAME,
     OCTI_CLASS_NAME,
     OCTI_CNST_STR_ID,
     OCTI_CNST_STR_TYPE,
@@ -443,6 +445,7 @@
 #define objc_super_type		objc_global_trees[OCTI_SUPER_TYPE]
 #define objc_selector_type		objc_global_trees[OCTI_SEL_TYPE]
 #define objc_object_type	objc_global_trees[OCTI_ID_TYPE]
+#define objc_instancetype_type	objc_global_trees[OCTI_INSTANCE_TYPE]
 #define objc_class_type		objc_global_trees[OCTI_CLS_TYPE]
 #define objc_instance_type	objc_global_trees[OCTI_NST_TYPE]
 #define objc_protocol_type	objc_global_trees[OCTI_PROTO_TYPE]
@@ -570,7 +573,8 @@
 
 #define objc_object_id		objc_global_trees[OCTI_OBJ_ID]
 #define objc_class_id		objc_global_trees[OCTI_CLS_ID]
-#define objc_object_name		objc_global_trees[OCTI_ID_NAME]
+#define objc_object_name        objc_global_trees[OCTI_ID_NAME]
+#define objc_instancetype_name	objc_global_trees[OCTI_INSTANCETYPE_NAME]
 #define objc_class_name		objc_global_trees[OCTI_CLASS_NAME]
 
 /* Constant string classes.  */
@@ -608,6 +612,7 @@
 /* Reserved tag definitions.  */
 
 #define OBJECT_TYPEDEF_NAME		"id"
+#define INSTANCE_TYPEDEF_NAME		"instancetype"
 #define CLASS_TYPEDEF_NAME		"Class"
 
 #define TAG_OBJECT			"objc_object"
Index: gcc/ipa-reference.c
===================================================================
--- a/src/gcc/ipa-reference.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ipa-reference.c	(.../branches/gcc-7-branch)
@@ -730,7 +730,7 @@
      the global information.  All the nodes within a cycle will have
      the same info so we collapse cycles first.  Then we can do the
      propagation in one pass from the leaves to the roots.  */
-  order_pos = ipa_reduced_postorder (order, true, true, ignore_edge_p);
+  order_pos = ipa_reduced_postorder (order, true, ignore_edge_p);
   if (dump_file)
     ipa_print_order (dump_file, "reduced", order, order_pos);
 
Index: gcc/toplev.c
===================================================================
--- a/src/gcc/toplev.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/toplev.c	(.../branches/gcc-7-branch)
@@ -1981,6 +1981,36 @@
 	else
 	  int_n_enabled_p[i] = false;
 
+      /* Initialize mpfrs exponent range.  This is important to get
+         underflow/overflow in a reasonable timeframe.  */
+      machine_mode mode;
+      int min_exp = -1;
+      int max_exp = 1;
+      for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT);
+	   mode != VOIDmode;
+	   mode = GET_MODE_WIDER_MODE (mode))
+	if (SCALAR_FLOAT_MODE_P (mode))
+	  {
+	    const real_format *fmt = REAL_MODE_FORMAT (mode);
+	    if (fmt)
+	      {
+		/* fmt->emin - fmt->p + 1 should be enough but the
+		   back-and-forth dance in real_to_decimal_for_mode we
+		   do for checking fails due to rounding effects then.  */
+		if ((fmt->emin - fmt->p) < min_exp)
+		  min_exp = fmt->emin - fmt->p;
+		if (fmt->emax > max_exp)
+		  max_exp = fmt->emax;
+	      }
+	  }
+      /* E.g. mpc_norm assumes it can square a number without bothering with
+	 with range scaling, so until that is fixed, double the minimum
+	 and maximum exponents, plus add some buffer for arithmetics
+	 on the squared numbers.  */
+      if (mpfr_set_emin (2 * (min_exp - 1))
+	  || mpfr_set_emax (2 * (max_exp + 1)))
+	sorry ("mpfr not configured to handle all float modes");
+
       /* Set up the back-end if requested.  */
       if (!no_backend)
 	backend_init ();
Index: gcc/tree-ssa-sccvn.c
===================================================================
--- a/src/gcc/tree-ssa-sccvn.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssa-sccvn.c	(.../branches/gcc-7-branch)
@@ -1981,9 +1981,20 @@
 	  tree rhs = gimple_assign_rhs1 (def_stmt);
 	  if (TREE_CODE (rhs) == SSA_NAME)
 	    rhs = SSA_VAL (rhs);
+	  unsigned pad = 0;
+	  enum machine_mode mode = TYPE_MODE (TREE_TYPE (rhs));
+	  if (BYTES_BIG_ENDIAN
+	      && (SCALAR_INT_MODE_P (mode)
+		  || ALL_SCALAR_FIXED_POINT_MODE_P (mode)
+		  || SCALAR_FLOAT_MODE_P (mode)))
+	    {
+	      /* On big-endian the padding is at the 'front' so
+		 just skip the initial bytes.  */
+	      pad = GET_MODE_SIZE (mode) - size2 / BITS_PER_UNIT;
+	    }
 	  len = native_encode_expr (gimple_assign_rhs1 (def_stmt),
 				    buffer, sizeof (buffer),
-				    (offset - offset2) / BITS_PER_UNIT);
+				    (offset - offset2) / BITS_PER_UNIT + pad);
 	  if (len > 0 && len * BITS_PER_UNIT >= ref->size)
 	    {
 	      tree type = vr->type;
@@ -2029,6 +2040,7 @@
       base2 = get_ref_base_and_extent (gimple_assign_lhs (def_stmt),
 				       &offset2, &size2, &maxsize2,
 				       &reverse);
+      tree def_rhs = gimple_assign_rhs1 (def_stmt);
       if (!reverse
 	  && maxsize2 != -1
 	  && maxsize2 == size2
@@ -2041,11 +2053,14 @@
 	     according to endianness.  */
 	  && (! INTEGRAL_TYPE_P (vr->type)
 	      || ref->size == TYPE_PRECISION (vr->type))
-	  && ref->size % BITS_PER_UNIT == 0)
+	  && ref->size % BITS_PER_UNIT == 0
+	  && (! INTEGRAL_TYPE_P (TREE_TYPE (def_rhs))
+	      || (TYPE_PRECISION (TREE_TYPE (def_rhs))
+		  == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (def_rhs))))))
 	{
 	  code_helper rcode = BIT_FIELD_REF;
 	  tree ops[3];
-	  ops[0] = SSA_VAL (gimple_assign_rhs1 (def_stmt));
+	  ops[0] = SSA_VAL (def_rhs);
 	  ops[1] = bitsize_int (ref->size);
 	  ops[2] = bitsize_int (offset - offset2);
 	  tree val = vn_nary_build_or_lookup (rcode, vr->type, ops);
@@ -3572,7 +3587,17 @@
 		  ops[0] = vn_nary_op_lookup_pieces
 		      (2, gimple_assign_rhs_code (def), type, ops, NULL);
 		  /* We have wider operation available.  */
-		  if (ops[0])
+		  if (ops[0]
+		      /* If the leader is a wrapping operation we can
+			 insert it for code hoisting w/o introducing
+			 undefined overflow.  If it is not it has to
+			 be available.  See PR86554.  */
+		      && (TYPE_OVERFLOW_WRAPS (TREE_TYPE (ops[0]))
+			  || TREE_CODE (ops[0]) != SSA_NAME
+			  || SSA_NAME_IS_DEFAULT_DEF (ops[0])
+			  || dominated_by_p_w_unex
+			       (gimple_bb (stmt),
+				gimple_bb (SSA_NAME_DEF_STMT (ops[0])))))
 		    {
 		      unsigned lhs_prec = TYPE_PRECISION (type);
 		      unsigned rhs_prec = TYPE_PRECISION (TREE_TYPE (rhs1));
@@ -5133,3 +5158,54 @@
 
   return false;
 }
+
+/* Return true if the reference operation REF may trap.  */
+
+bool
+vn_reference_may_trap (vn_reference_t ref)
+{
+  switch (ref->operands[0].opcode)
+    {
+    case MODIFY_EXPR:
+    case CALL_EXPR:
+      /* We do not handle calls.  */
+    case ADDR_EXPR:
+      /* And toplevel address computations never trap.  */
+      return false;
+    default:;
+    }
+
+  vn_reference_op_t op;
+  unsigned i;
+  FOR_EACH_VEC_ELT (ref->operands, i, op)
+    {
+      switch (op->opcode)
+	{
+	case WITH_SIZE_EXPR:
+	case TARGET_MEM_REF:
+	  /* Always variable.  */
+	  return true;
+	case COMPONENT_REF:
+	  if (op->op1 && TREE_CODE (op->op1) == SSA_NAME)
+	    return true;
+	  break;
+	case ARRAY_RANGE_REF:
+	case ARRAY_REF:
+	  if (TREE_CODE (op->op0) == SSA_NAME)
+	    return true;
+	  break;
+	case MEM_REF:
+	  /* Nothing interesting in itself, the base is separate.  */
+	  break;
+	/* The following are the address bases.  */
+	case SSA_NAME:
+	  return true;
+	case ADDR_EXPR:
+	  if (op->op0)
+	    return tree_could_trap_p (TREE_OPERAND (op->op0, 0));
+	  return false;
+	default:;
+	}
+    }
+  return false;
+}
Index: gcc/tree-ssa-sccvn.h
===================================================================
--- a/src/gcc/tree-ssa-sccvn.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssa-sccvn.h	(.../branches/gcc-7-branch)
@@ -237,6 +237,7 @@
 bool vn_nary_op_eq (const_vn_nary_op_t const vno1,
 		    const_vn_nary_op_t const vno2);
 bool vn_nary_may_trap (vn_nary_op_t);
+bool vn_reference_may_trap (vn_reference_t);
 bool vn_reference_eq (const_vn_reference_t const, const_vn_reference_t const);
 unsigned int get_max_value_id (void);
 unsigned int get_next_value_id (void);
Index: gcc/ChangeLog
===================================================================
--- a/src/gcc/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,2268 @@
+2019-11-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-13  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_indirection_name): Rework the
+	function to emit linker-visible symbols only for indirections
+	in the data section.  Clean up the code and update comments.
+
+2019-11-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-09  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (darwin_override_options): Make the check for
+	Objective-C ABI version more specific for 64bit code.
+
+	Backport from mainline
+	2019-10-06  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (darwin_override_options): Adjust objective-c
+	ABI version error messages to avoid punctuation and contracted
+	negations.
+
+2019-11-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-07-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.h (REAL_LIBGCC_SPEC): Adjust for earlier Darwin.
+	(STARTFILE_SPEC): Split crt3 into a separate spec.
+	(DARWIN_EXTRA_SPECS): Add crt2 and crt3 spec.
+	(DARWIN_CRT2_SPEC): New.
+	(DARWIN_CRT3_SPEC): New.
+	(MIN_LD64_OMIT_STUBS): Revise to 62.1.
+	* config/rs6000/darwin.h (DARWIN_CRT2_SPEC): Revise conditions.
+	(DARWIN_CRT3_SPEC): New.
+
+2019-11-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-27  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/darwin.h (ENDFILE_SPEC): Correct whitespace in the
+	spec.
+
+	Backport from mainline
+	2019-06-25  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/darwin.h (ENDFILE_SPEC): New.
+
+2019-11-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (darwin_emit_unwind_label): New default to false.
+	(darwin_override_options): Set darwin_emit_unwind_label as needed.
+
+2019-11-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-08-13 Iain Sandoe <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_indirect_call_target): Rename symbol stub
+	flag.
+	(darwin_override_options): Likewise.
+	* config/darwin.h: Likewise.
+	* config/darwin.opt: Likewise.
+	* config/i386/i386.c (output_pic_addr_const): Likewise.
+	* config/rs6000/darwin.h: Likewise.
+	* config/rs6000/rs6000.c (rs6000_call_darwin_1): Likewise.
+	* config/i386/darwin.h (TARGET_MACHO_PICSYM_STUBS): Rename to ...
+	... this TARGET_MACHO_SYMBOL_STUBS.
+	(FUNCTION_PROFILER):Likewise.
+	* config/i386/i386.h: Likewise.
+
+	Backport from mainline
+	2019-06-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_indirect_call_target): Use renamed
+	darwin_picsymbol_stubs to decide on output.
+	(darwin_override_options): Handle darwin_picsymbol_stubs.
+	* config/darwin.h (MIN_LD64_OMIT_STUBS): New.
+	(LD64_VERSION): Revise default.
+	* config/darwin.opt: (mpic-symbol-stubs): New option.
+	(darwin_picsymbol_stubs): New variable.
+	* config/i386/darwin.h (TARGET_MACHO_BRANCH_ISLANDS):
+	rename to TARGET_MACHO_PICSYM_STUBS.
+	* config/i386/i386.c (output_pic_addr_const): Likewise.
+	* config/i386/i386.h Likewise.
+	* config/rs6000/darwin.h: Likewise.
+	* config/rs6000/rs6000.c (rs6000_call_darwin_1): Use renamed
+	darwin_picsymbol_stubs.
+
+2019-11-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-28  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config.gcc (powerpc-*-darwin*, powerpc64-*-darwin*): Remove
+	override on extra_headers.
+
+2019-11-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-27  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/rs6000.c (darwin_rs6000_override_options): Honour
+	user-specified float mode choice for kernel mode code.
+
+2019-11-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/darwin.h: Handle GCC target pragma.
+
+2019-10-29  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-17  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/65342
+	* config/rs6000/darwin.md (movdi_low, movsi_low_st): Delete.
+	(movdi_low_st): Delete.
+	* config/rs6000/rs6000.c
+	(darwin_rs6000_legitimate_lo_sum_const_p): New.
+	(mem_operand_gpr): Validate Mach-O LO_SUM cases separately.
+	* config/rs6000/rs6000.md (movsi_low): Delete.
+
+2019-10-29  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-12  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/67183
+	* config/darwin.c (machopic_indirection): New field to flag
+	non-lazy-symbol-pointers in the data section.
+	(machopic_indirection_name): Compute if an indirection should
+	appear in the data section.
+	(machopic_output_data_section_indirection): New callback split
+	from machopic_output_indirection.
+	(machopic_output_stub_indirection): Likewise.
+	(machopic_output_indirection): Retain the code for non-lazy
+	symbol pointers in their regular section.
+	(machopic_finish): Use the new callbacks to order the indirection
+	output.
+
+2019-10-29  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-12  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin-protos.h (machopic_finish): Delete.
+	* config/darwin.c (machopic_finish): Make static.
+
+	Backport from mainline
+	2019-10-09  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_indirect_data_reference): Set flag to
+	indicate that the new symbol is an indirection.
+	(machopic_indirect_call_target): Likewise.
+	* config/darwin.h (MACHO_SYMBOL_FLAG_INDIRECTION): New.
+	(MACHO_SYMBOL_INDIRECTION_P): New.
+	(MACHO_SYMBOL_FLAG_STATIC): Adjust bit number.
+
+	Backport from mainline
+	2019-10-08  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_indirect_data_reference): Check for
+	required indirections before making direct access to defined
+	values.
+	(machopic_output_indirection): Place the indirected pointes for
+	required indirections into the non-lazy symbol pointers section.
+	(darwin_encode_section_info):
+	* config/darwin.h (MACHO_SYMBOL_FLAG_MUST_INDIRECT): New.
+	(MACHO_SYMBOL_MUST_INDIRECT_P): New.
+
+	Backport from mainline
+	2019-10-07  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_output_indirection): Don't put
+	hidden symbol indirections into the .data section, use the
+	non-lazy symbol pointers section as normal.
+	(darwin_encode_section_info): Record if a symbol is hidden.
+	* config/darwin.h (MACHO_SYMBOL_FLAG_HIDDEN_VIS): New.
+	(MACHO_SYMBOL_HIDDEN_VIS_P): New.
+
+	Backport from mainline
+	2019-10-07  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_symbol_defined_p): Use symbol flag
+	predicates instead of accessing bits directly.
+	(machopic_indirect_call_target): Likewise.
+	(machopic_output_indirection): Likewise.
+	(darwin_encode_section_info): Improve description.  Use renamed
+	symbol flags.  Use predicate macros for variables and functions.
+	* config/darwin.h:
+	Rename MACHO_SYMBOL_VARIABLE to MACHO_SYMBOL_FLAG_VARIABLE.
+	Rename MACHO_SYMBOL_DEFINED to MACHO_SYMBOL_FLAG_DEFINED.
+	Rename MACHO_SYMBOL_STATIC to MACHO_SYMBOL_FLAG_STATIC.
+	(MACHO_SYMBOL_VARIABLE_P): New.
+	(MACHO_SYMBOL_DEFINED_P):New.
+	(MACHO_SYMBOL_STATIC_P): New.
+	* config/i386/darwin.h (MACHO_SYMBOL_FLAG_VARIABLE): Delete.
+	(SYMBOL_FLAG_SUBT_DEP): New.
+	* config/rs6000/darwin.h (SYMBOL_FLAG_SUBT_DEP): New.
+
+2019-10-29  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-05  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/59888
+	* config/darwin.c (darwin_rodata_section): Add relocation flag,
+	choose const_data section for constants with relocations.
+	(machopic_select_section): Pass relocation flag to
+	darwin_rodata_section ().
+
+2019-10-29  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-09-21  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_legitimize_pic_address): Check
+	for lra, rather than reload.
+
+2019-10-29  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/87243
+	* config/darwin-driver.c (maybe_get_sysroot_from_sdkroot): New.
+	(darwin_driver_init): Use the sysroot provided by SDKROOT when that
+	is available and the user has not set one on the command line.
+
+2019-10-29  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-07-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.h (DRIVER_SELF_SPECS): Remove the linker cases.
+	(RDYNAMIC): Rename to, DARWIN_RDYNAMIC.
+	(DARWIN_PIE_SPEC, DARWIN_NOPIE_SPEC): Adjust to remove the Xlinker
+	clauses.
+	(LINK_COMMAND_SPEC_A): Add DARWIN_RDYNAMIC, DARWIN_PIE_SPEC and
+	DARWIN_NOPIE_SPEC.
+
+	Backport from mainline
+	2019-06-19  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.h (DRIVER_SELF_SPECS): Add RDYNAMIC, DARWIN_PIE_SPEC
+	and DARWIN_NOPIE_SPEC.
+	(RDYNAMIC): New, modified from DARWIN_EXPORT_DYNAMIC.
+	(DARWIN_PIE_SPEC): Collate from darwin.h and darwin9.h.
+	(DARWIN_NOPIE_SPEC): Collate from darwin10.h.
+	(DARWIN_NOCOMPACT_UNWIND): New from darwin10.h
+	(DARWIN_EXPORT_DYNAMIC): Delete.
+	* config/darwin10.h (LINK_GCC_C_SEQUENCE_SPEC): Move no_compact_unwind
+	and pie options processing to  darwin.h.
+	* config/darwin9.h (DARWIN_PIE_SPEC): Move pie processing to darwin.h
+
+2019-10-25  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backport from mainline
+	2019-05-08  Mihail Ionescu  <mihail.ionescu@arm.com>
+	    Richard Earnshaw  <rearnsha@arm.com>
+	PR target/88167
+	* config/arm/arm.c (thumb1_prologue_unused_call_clobbered_lo_regs): New
+	function.
+	(thumb1_epilogue_unused_call_clobbered_lo_regs): New function.
+	(thumb1_compute_save_core_reg_mask): Don't force a spare work
+	register if both the epilogue and prologue can use call-clobbered
+	regs.
+	(thumb1_unexpanded_epilogue): Use
+	thumb1_epilogue_unused_call_clobbered_lo_regs.  Reverse the logic for
+	picking temporaries for restoring high regs to match that of the
+	prologue where possible.
+	(thumb1_expand_prologue): Add any usable call-clobbered low registers to
+	the list of work registers.  Detect if the return address is still live
+	at the end of the prologue and avoid using it for a work register if so.
+	If the return address is not live, add LR to the list of pushable regs
+	after the first pass.
+
+2019-10-24  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-10-17  Richard Biener  <rguenther@suse.de>
+
+	PR debug/91887
+	* dwarf2out.c (gen_formal_parameter_die): Also try to match
+	context_die against a DW_TAG_GNU_formal_parameter_pack parent.
+
+	2019-09-19  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91812
+	* tree-ssa-phiprop.c (propagate_with_phi): Do not replace
+	volatile loads.
+
+2019-10-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR tree-optimization/92131
+	* tree-vrp.c (extract_range_from_plus_minus_expr): If the resulting
+	range would be symbolic, drop to varying for any explicit overflow
+	in the constant part or if neither range is a singleton.
+
+2019-10-18  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from trunk
+	2019-10-18  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/86040
+	* config/avr/avr.c (avr_out_lpm): Do not shortcut-return.
+
+2019-10-17  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2019-03-15  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR rtl-optimization/89721
+	* lra-constraints (invariant_p): Return false if side_effects_p holds.
+
+2019-10-17  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backport from mainline
+	2019-05-03  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/89400
+	* config/arm/arm.md (unaligned_loadsi): Add variant for thumb1.
+	Restrict 'all' variant to 32-bit configurations.
+	(unaligned_loadhiu): Likewise.
+	(unaligned_storehi): Likewise.
+	(unaligned_storesi): Likewise.
+	(unaligned_loadhis): Disable when compiling for thumb1.
+
+2019-10-16  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backport from mainline
+	2019-10-08  Tulio Magno Quites Machado Filho  <tuliom@linux.ibm.com>
+
+	* config.gcc: Move -L usage from LINK_OS_EXTRA_SPEC32 and
+	LINK_OS_EXTRA_SPEC64 to MD_STARTFILE_PREFIX and
+	MD_STARTFILE_PREFIX_1 when using --with-advance-toolchain.
+
+2019-10-11  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2019-10-10  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/88630
+	* config/sh/sh.h (TARGET_FPU_SH4_300): New macro.
+	* config/sh/sh.c (sh_option_override): Enable fsca and fsrra insns
+	also for TARGET_FPU_SH4_300.
+	(sh_emit_mode_set): Check for TARGET_FPU_SH4_300 instead of
+	TARGET_SH4_300.
+	* config/sh/sh.md (toggle_pr): Add TARGET_FPU_SH4_300 condition.
+	(negsf2): Expand to either negsf2_fpscr or negsf2_no_fpscr.
+	(*negsf2_i): Split into ...
+	(negsf2_fpscr, negsf2_no_fpscr): ... these new patterns.
+	(abssf2): Expand to either abssf2_fpsc or abssf2_no_fpsc.
+	(**abssf2_i): Split into ...
+	(abssf2_fpscr, abssf2_no_fpscr): ... these new patterns.
+	(negdf2): Expand to either negdf2_fpscr or negdf2_no_fpscr.
+	(*negdf2_i): Split into ...
+	(negdf2_fpscr, negdf2_no_fpscr): ... these new patterns.
+	(absdf2): Expand to either absdf2_fpscr or absdf2_no_fpsc.
+	(**abssf2_i): Split into ...
+	(absdf2_fpscr, absdf2_no_fpscr): ... these new patterns.
+
+2019-10-07  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	Backport from mainline
+	2019-10-01  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/91275
+	* config/rs6000/rs6000.c (rtx_is_swappable_p): Don't swap
+	vpmsumd.
+
+2019-10-01  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+
+	2019-10-01  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/88562
+	* config/sh/sh.c (sh_extending_set_of_reg::use_as_extended_reg): Use
+	sh_check_add_incdec_notes to preserve REG_INC notes when replacing
+	a memory access insn.
+
+2019-09-28  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-12  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/82920
+	* config/i386/darwin.h (CC1_SPEC): Report -mx32 as an error for
+	Darwin.
+
+2019-09-28  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-12  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/82920
+	* config/i386/i386.c (ix86_output_jmp_thunk_or_indirect): New.
+	(ix86_output_indirect_branch_via_reg): Use output mechanism
+	accounting for __USER_LABEL_PREFIX__.
+	(ix86_output_indirect_branch_via_push): Likewise.
+	(ix86_output_function_return): Likewise.
+	(ix86_output_indirect_function_return): Likewise.
+
+2019-09-28  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2019-09-28  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/80672
+	* config/sh/sh.c (parse_validate_atomic_model_option): Use
+	std::string::compare instead of std::string::find.
+
+2019-09-28  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2018-07-15  Jeff Law  <law@redhat.com>
+
+	PR target/85993
+	* config/sh/sh.c (output_mi_thunk): Remove dead conditional
+	block.
+
+2019-09-27  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.opt (prebind, noprebind, seglinkedit,
+	noseglinkedit): Add RejectNegative.
+
+	Backport from mainline
+	2019-06-14  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.opt: Add RejectNegative where needed, reorder
+	and add minimal functional descriptions.
+
+2019-09-23  Max Filippov  <jcmvbkbc@gmail.com>
+
+	Backport from mainline
+	2019-06-18  Max Filippov  <jcmvbkbc@gmail.com>
+
+	* config/xtensa/xtensa.c (xtensa_expand_prologue): Add stack
+	pointer adjustment for the case of no callee-saved registers and
+	stack frame bigger than 128 bytes.
+
+2019-09-20  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (pa_trampoline_init): Remove spurious extended
+	characters.
+
+2019-09-20  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-06-06  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	PR rtl-optimization/88751
+	* ira.c (ira): Use the number of the actually referenced registers
+	when calculating the threshold.
+
+2019-09-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/89795
+	* rtlanal.c (nonzero_bits1) <SUBREG>: Do not propagate results from
+	inner REGs to paradoxical SUBREGs if WORD_REGISTER_OPERATIONS is set.
+
+2019-09-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/87853
+	* config/i386/emmintrin.h (_mm_cmpeq_epi8): Use casts to __v16qi
+	instead of __v16qs.
+
+	PR target/91704
+	* config/i386/avxintrin.h (__v32qs): New typedef.
+	* config/i386/avx2intrin.h (_mm256_cmpgt_epi8): Use casts to __v32qs
+	instead of __v32qi.
+
+2019-09-08  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-12-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/i386/darwin.h (TARGET_ASM_OUTPUT_IDENT): New.
+
+2019-08-22  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-05-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/i386/darwin.h (ASM_OUTPUT_MAX_SKIP_ALIGN): New.
+
+2019-09-05  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-08-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/darwin.h (TARGET_OS_CPP_BUILTINS): Add asserts
+	for cpu and machine.  Factor 64/32b builtins.
+
+	Backport from mainline
+	2019-06-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/darwin.h: (__PPC__, __PPC64__): New.
+
+2019-09-05  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-08-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR pch/61250
+	* ggc-page.c (ggc_pch_read): Read the ggc_pch_ondisk structure
+	and issue any diagnostics needed before collecting the pre-PCH
+	state.
+
+2019-09-05  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-07-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR bootstrap/87030
+	* config/i386/darwin.h (REAL_LIBGCC_SPEC): Revert change from r273749.
+
+	PR bootstrap/87030
+	* config/i386/darwin.h (REAL_LIBGCC_SPEC): Move from here...
+	* config/i386/darwin32-biarch.h .. to here.
+	* config/i386/darwin64-biarch.h: Adjust comments.
+	* config/rs6000/darwin32-biarch.h: Likewise.
+	* config/rs6000/darwin64-biarch.h: Likewise.
+	* config.gcc: Missed commit from r273746
+	(*-*-darwin*): Don't include CPU t-darwin here.
+	(i[34567]86-*-darwin*): Adjust to use biarch files. Produce
+	an error message if i686-darwin configuration is attempted for
+	Darwin >= 18.
+
+	Backport from mainline
+	2019-07-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR bootstrap/87030
+	* config.gcc (*-*-darwin*): Don't include CPU t-darwin here.
+	(i[34567]86-*-darwin*): Adjust to use biarch files. Produce
+	an error message if i686-darwin configuration is attempted for
+	Darwin >= 18.
+	(x86_64-*-darwin*): Switch to single multilib for Darwin >= 18.
+	(powerpc-*-darwin*): Use biarch files where needed.
+	(powerpc64-*-darwin*): Likewise.
+	* config/i386/darwin.h (REAL_LIBGCC_SPEC): Move to new biarch file.
+	(DARWIN_ARCH_SPEC, DARWIN_SUBARCH_SPEC): Revise for default single
+	arch case.
+	* config/i386/darwin32-biarch.h: New.
+	* config/i386/darwin64.h: Rename.
+	* gcc/config/i386/darwin64-biarch.h: To this.
+	* config/i386/t-darwin: Rename.
+	* gcc/config/i386/t-darwin32-biarch: To this.
+	* config/i386/t-darwin64: Rename.
+	* gcc/config/i386/t-darwin64-biarch: To this.
+	* config/rs6000/darwin32-biarch.h: New.
+	* config/rs6000/darwin64.h: Rename.
+	* config/rs6000/darwin64-biarch.h: To this.
+	(DARWIN_ARCH_SPEC, DARWIN_SUBARCH_SPEC): Revise for default single
+	arch case.
+	* config/rs6000/t-darwin8: Rename.
+	* config/rs6000/t-darwin32-biarch: To this.
+	* config/rs6000/t-darwin64 Rename.
+	* config/rs6000/t-darwin64-biarch: To this.
+
+2019-09-05  Richard Biener  <rguenther@suse.de>
+
+	* lto-streamer.h (LTO_minor_version): Bump.
+
+	Backport from mainline
+	2019-05-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90328
+	* tree-data-ref.h (dr_may_alias_p): Pass in the actual loop nest.
+	* tree-data-ref.c (dr_may_alias_p): Check whether the clique
+	is valid in the loop nest before using it.
+	(initialize_data_dependence_relation): Adjust.
+	* graphite-scop-detection.c (build_alias_set): Pass the SCOP enclosing
+	loop as loop-nest to dr_may_alias_p.
+
+	2019-03-08  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89578
+	* cfgloop.h (struct loop): Add owned_clique field.
+	* cfgloopmanip.c (copy_loop_info): Copy it.
+	* tree-cfg.c (gimple_duplicate_bb): Do not remap owned_clique
+	cliques.
+	* tree-inline.c (copy_loops): Remap owned_clique.
+	* lto-streamer-in.c (input_cfg): Stream owned_clique.
+	* lto-streamer-out.c (output_cfg): Likewise.
+
+	2019-02-22  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/87609
+	* tree-cfg.c (gimple_duplicate_bb): Only remap inlined cliques.
+
+	2019-02-22  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/87609
+	* cfghooks.h (dependence_hash): New typedef.
+	(struct copy_bb_data): New type.
+	(cfg_hooks::duplicate_block): Adjust to take a copy_bb_data argument.
+	(duplicate_block): Likewise.
+	* cfghooks.c (duplicate_block): Pass down copy_bb_data.
+	(copy_bbs): Create and pass down copy_bb_data.
+	* cfgrtl.c (cfg_layout_duplicate_bb): Adjust.
+	(rtl_duplicate_bb): Likewise.
+	* tree-cfg.c (gimple_duplicate_bb): If the copy_bb_data arg is not NULL
+	remap dependence info.
+
+	2019-02-22  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/87609
+	* tree-core.h (tree_base): Document special clique values.
+	* tree-inline.c (remap_dependence_clique): Do not use the
+	special clique value of one.
+	(maybe_set_dependence_info): Use clique one.
+	(clear_dependence_clique): New callback.
+	(compute_dependence_clique): Clear clique one from all refs
+	before assigning it (again).
+
+2019-08-27  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-07-07  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (darwin_override_options): Make a final check on PIC
+	options.
+
+2019-09-04  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-07-07  Iain Sandoe  <iain@sandoe.co.uk>
+	* config/darwin.c (darwin_override_options): Don't jam symbol stubs
+	on for kernel code.
+
+2019-09-04  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-27  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/rs6000.c (darwin_rs6000_override_options): Do not
+	use longcall for 64b code.
+
+2019-09-04  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-19  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin-driver.c (darwin_driver_init): Fix off-by-one errors
+	in computing the number of options to be moved.
+
+	Backport from mainline
+	2019-06-13  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin-driver.c (validate_macosx_version_min): New.
+	(darwin_default_min_version): Cleanup and validate supplied version.
+	(darwin_driver_init): Likewise and push cleaned version into opts.
+
+2019-09-04  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-03-26  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	PR tree-optimization/81740
+	* tree-vect-data-refs.c (vect_analyze_data_ref_dependence):
+	In case of outer loop vectorization, check for backward dependence
+	at the inner loop if outer loop dependence is reversed.
+
+2019-09-04  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-11-23  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/88149
+	* tree-vect-slp.c (vect_slp_analyze_node_operations): Detect
+	the case where there are two different def types for the
+	same operand at different operand position in the same stmt.
+
+2019-09-04  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-04-09  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* tree-vect-data-refs.c (vect_get_smallest_scalar_type): Always
+	use gimple_expr_type for load and store calls.  Skip over the
+	condition argument in a conditional internal function.
+	Protect use of TREE_INT_CST_LOW.
+
+	2019-04-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90006
+	* tree-vect-data-refs.c (vect_get_smallest_scalar_type): Handle
+	calls like lrint.
+
+	2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89698
+	* fold-const.c (operand_equal_p): For INDIRECT_REF check
+	that the access types are similar.
+
+	2019-01-18  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/88903
+	* tree-vect-stmts.c (vectorizable_shift): Verify we see all
+	scalar stmts a SLP shift amount is composed of when detecting
+	shifts by scalars.
+
+	2018-12-11  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/88448
+	PR middle-end/88415
+	* tree-complex.c (update_complex_assignment): Properly transfer
+	or clean EH info around gimple_assign_set_rhs_with_ops.
+
+	2018-11-15  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/88030
+	* tree-complex.c (need_eh_cleanup): New global.
+	(update_complex_assignment): Mark blocks that need EH update.
+	(expand_complex_comparison): Likewise.
+	(tree_lower_complex): Allocate and deallocate need_eh_cleanup,
+	perform EH cleanup and schedule CFG cleanup if that did anything.
+
+	2018-11-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/87929
+	* tree-complex.c (expand_complex_comparison): Clean EH.
+
+	2017-07-25  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gimple.c (gimple_assign_set_rhs_with_ops): Do not ask gsi_replace
+	to update EH info here.
+
+2019-09-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-05-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin-c.c (darwin_register_objc_includes): Do not
+	prepend the sysroot when building gnu-runtime header search
+	paths.
+
+2019-09-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-05-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (darwin_file_end): Use switch_to_section ()
+	instead of direct output of the asm.
+
+2019-09-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-08-22 Iain Sandoe <iain@sandoe.co.uk>
+
+	* config/darwin.h (LINK_COMMAND_SPEC_A): Update lto options
+	to match gcc/gcc.c.
+
+2019-09-02  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89710
+	* tree-ssa-loop-ch.c (should_duplicate_loop_header_p): Use
+	safe_dyn_cast.
+
+	2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89572
+	* tree-scalar-evolution.c (get_loop_exit_condition): Use
+	safe_dyn_cast.
+	* tree-ssa-loop-ivcanon.c (canonicalize_loop_induction_variables):
+	Use gimple_location_safe.
+
+	2019-02-18  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89296
+	* tree-ssa-loop-ch.c (ch_base::copy_headers): Restrict setting
+	of no-warning flag to cases that might emit the bogus warning.
+
+	2019-01-31  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89135
+	* tree-ssa-phiprop.c (pass_phiprop::execute): Skip blocks
+	with abnormal preds.
+
+2019-09-02  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-07-19  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91200
+	* tree-ssa-phiopt.c (cond_store_replacement): Check we have
+	no PHI nodes in middle-bb.
+
+	2019-07-15  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/91162
+	* tree-cfg.c (move_block_to_fn): When releasing a virtual PHI
+	node make sure to replace all uses with something valid.
+
+	2019-07-11  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/91131
+	* gimplify.c (gimplify_compound_literal_expr): Force a temporary
+	when the object is volatile and we have not cleared it even though
+	there are no nonzero elements.
+
+	2019-07-10  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91126
+	* tree-ssa-sccvn.c (n_walk_cb_data::push_partial_def): Adjust
+	native encoding offset for BYTES_BIG_ENDIAN.
+	(vn_reference_lookup_3): Likewise.
+
+	2019-07-10  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91126
+	* tree-ssa-sccvn.c (vn_reference_lookup_3): Adjust
+	native encoding offset for BYTES_BIG_ENDIAN.
+
+	2019-04-29  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90278
+	* tree-ssa-forwprop.c (pass_forwprop::execute): Transfer/clean
+	EH on comparison simplification.
+
+	2019-04-11  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90020
+	* tree-ssa-sccvn.c (vn_reference_may_trap): New function.
+	* tree-ssa-sccvn.h (vn_reference_may_trap): Declare.
+	* tree-ssa-pre.c (compute_avail): Use it to not put
+	possibly trapping references after a call that might not
+	return into EXP_GEN.
+	* gcse.c (compute_hash_table_work): Do not elide
+	marking a block containing a call if the call might not
+	return.
+
+2019-09-02  Bin Cheng  <bin.linux@linux.alibaba.com>
+
+	Backport from mainline
+	2019-07-18  Bin Cheng  <bin.linux@linux.alibaba.com>
+
+	PR tree-optimization/91137
+	* tree-ssa-loop-ivopts.c (struct ivopts_data): New field.
+	(tree_ssa_iv_optimize_init, alloc_iv, tree_ssa_iv_optimize_finalize):
+	Init, use and fini the above new field.
+	(determine_base_object_1): New function.
+	(determine_base_object): Reimplement using walk_tree.
+
+2019-08-30  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-05-27  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90637
+	* tree-ssa-sink.c (statement_sink_location): Honor the
+	computed sink location for single-uses.
+
+	* gcc.dg/gomp/pr90637.c: New testcase.
+
+	2019-06-21  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90930
+	* tree-ssa-reassoc.c (rewrite_expr_tree_parallel): Set visited
+	flag on new stmts to avoid re-processing them.
+
+	2019-04-25  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/90194
+	* match.pd: Add pattern to simplify view-conversion of an
+	empty constructor.
+
+	2019-04-24  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/90213
+	* gimple-fold.c (fold_const_aggregate_ref_1): Do multiplication
+	by size and BITS_PER_UNIT on poly-wide-ints.
+
+	2019-04-15  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90071
+	* tree-ssa-reassoc.c (init_range_entry): Do not pick up
+	abnormal operands from def stmts.
+
+	2019-03-13  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89677
+	* tree-scalar-evolution.c (simplify_peeled_chrec): Do not
+	throw FP expressions at tree-affine.
+
+2019-08-30  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2019-08-22  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/91481
+	* config/rs6000/rs6000.md (unspec): Delete UNSPEC_DARN, UNSPEC_DARN_32,
+	and UNSPEC_DARN_RAW.
+	(unspecv): New enumerator values UNSPECV_DARN, UNSPECV_DARN_32, and
+	UNSPECV_DARN_RAW.
+	(darn_32): Use an unspec_volatile, and UNSPECV_DARN_32.
+	(darn_raw): Use an unspec_volatile, and UNSPECV_DARN_RAW.
+	(darn): Use an unspec_volatile, and UNSPECV_DARN.
+
+2019-08-30  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2019-08-22  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* config/rs6000/altivec.md (unspec): Delete UNSPEC_DARN, UNSPEC_DARN_32,
+	UNSPEC_DARN_RAW, UNSPEC_CMPRB, UNSPEC_CMPRB2, UNSPEC_CMPEQB; move to...
+	* config/rs6000/rs6000.md (unspec): ... here.
+	* config/rs6000/altivec.md (darn_32, darn_raw, darn, cmprb,
+	*cmprb_internal, setb_signed, setb_unsigned, cmprb2, *cmprb2_internal,
+	cmpeqb, *cmpeqb_internal): Delete, move to...
+	* config/rs6000/rs6000.md (darn_32, darn_raw, darn, cmprb,
+	*cmprb_internal, setb_signed, setb_unsigned, cmprb2, *cmprb2_internal,
+	cmpeqb, *cmpeqb_internal): ... here.
+
+2019-08-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-07-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/91150
+	* config/i386/i386.c (expand_vec_perm_blend): Change mask type
+	from unsigned to unsigned HOST_WIDE_INT.  For E_V64QImode cast
+	comparison to unsigned HOST_WIDE_INT before shifting it left.
+
+	2019-07-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/78884
+	* gimplify.c (struct gimplify_omp_ctx): Add add_safelen1 member.
+	(gimplify_bind_expr): If seeing TREE_ADDRESSABLE VLA inside of simd
+	loop body, set ctx->add_safelen1 instead of making it GOVD_PRIVATE.
+	(gimplify_adjust_omp_clauses): Add safelen (1) clause if
+	ctx->add_safelen1 is set.
+
+	PR rtl-optimization/90756
+	* explow.c (promote_ssa_mode): Always use TYPE_MODE, don't bypass it
+	for VECTOR_TYPE_P.
+
+	2019-06-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/90760
+	* symtab.c (symtab_node::set_section): Allow being called on aliases
+	as long as they aren't analyzed yet.
+
+	2019-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/90139
+	* tree-outof-ssa.c (get_temp_reg): If reg_mode is BLKmode, return
+	assign_temp instead of gen_reg_rtx.
+
+	2019-06-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/90811
+	* config/nvptx/nvptx.c (nvptx_output_softstack_switch): Use and.b%d
+	instead of and.u%d.
+
+	2019-05-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/90329
+	* lto-streamer.h (LTO_minor_version): Bump to 1.
+
+	2019-05-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/90329
+	* tree-core.h (struct tree_decl_common): Document
+	decl_nonshareable_flag for PARM_DECLs.
+	* tree.h (DECL_HIDDEN_STRING_LENGTH): Define.
+	* calls.c (expand_call): Don't try tail call if caller
+	has any DECL_HIDDEN_STRING_LENGTH PARM_DECLs that are or might be
+	passed on the stack and callee needs to pass any arguments on the
+	stack.
+	* tree-streamer-in.c (unpack_ts_decl_common_value_fields): Use
+	else if instead of series of mutually exclusive ifs.  Handle
+	DECL_HIDDEN_STRING_LENGTH for PARM_DECLs.
+	* tree-streamer-out.c (pack_ts_decl_common_value_fields): Likewise.
+
+	2019-04-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/90187
+	* config/i386/i386.c (ix86_expand_sse_fp_minmax): Force if_true into
+	a register if both if_true and if_false are MEMs.
+
+	PR tree-optimization/90208
+	* tree-cfg.c (remove_bb): Move forced labels from removed bbs
+	after labels of new_bb, not before them.
+
+	2019-04-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/90082
+	* dce.c (can_delete_call): New function.
+	(deletable_insn_p, mark_insn): Use it.
+
+	PR tree-optimization/90090
+	* tree-ssa-math-opts.c (is_division_by): Ignore divisions that can
+	throw internally.
+
+	2019-04-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/89998
+	* gimple-ssa-sprintf.c (try_substitute_return_value): Use lhs type
+	instead of integer_type_node if possible, don't add ranges if return
+	type is not compatible with int.
+	* gimple-fold.c (gimple_fold_builtin_sprintf,
+	gimple_fold_builtin_snprintf): Use lhs type instead of hardcoded
+	integer_type_node.
+
+	2019-03-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/89872
+	* gimplify.c (gimplify_compound_literal_expr): Don't optimize a
+	non-addressable complit into its initializer if it is volatile.
+
+	2019-03-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89621
+	* tree-inline.h (struct copy_body_data): Add
+	dont_remap_vla_if_no_change flag.
+	* tree-inline.c (remap_type_3, remap_type_2): New functions.
+	(remap_type): Don't remap vla types if id->dont_remap_vla_if_no_change
+	and remap_type_2 returns false.
+	* omp-low.c (new_omp_context): Set ctx->cb.dont_remap_vla_if_no_change.
+
+	2019-03-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/89752
+	* lra-constraints.c (process_alt_operands) <reg>: For BLKmode, don't
+	update this_alternative nor this_alternative_set.
+
+	2019-03-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/89768
+	* loop-unroll.c (unroll_loop_constant_iterations): Use gen_int_mode
+	instead of GEN_INT.
+	(unroll_loop_runtime_iterations): Likewise.
+
+	PR target/89752
+	* gimplify.c (gimplify_asm_expr): For output argument with
+	TREE_ADDRESSABLE type, clear allows_reg if it allows memory, otherwise
+	diagnose error.
+
+	PR target/89726
+	* config/i386/i386.c (ix86_expand_floorceildf_32): In ceil
+	compensation use x2 += 1 instead of x2 -= -1 and when honoring
+	signed zeros, do another copysign after the compensation.
+
+	2019-03-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/89704
+	* dwarf2out.c (add_const_value_attribute): Return false for MINUS,
+	SIGN_EXTEND and ZERO_EXTEND.
+
+	2019-03-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/89679
+	* expmed.c (expand_mult_const): Don't add a REG_EQUAL note if it
+	would contain a paradoxical SUBREG.
+
+	PR tree-optimization/89703
+	* tree-ssa-strlen.c (valid_builtin_call): Punt if stmt call types
+	aren't compatible also with builtin_decl_explicit.  Check pure
+	or non-pure status of BUILT_IN_STR{{,N}CMP,N{LEN,{CAT,CPY}{,_CHK}}}
+	and BUILT_IN_STPNCPY{,_CHK}.
+
+	2019-03-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/88588
+	* omp-simd-clone.c (ipa_simd_modify_stmt_ops): Handle PHI args.
+	(ipa_simd_modify_function_body): Handle PHIs.
+
+	2019-03-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89663
+	* builtins.c (expand_builtin_int_roundingfn,
+	expand_builtin_int_roundingfn_2): Return NULL_RTX instead of
+	gcc_unreachable if validate_arglist fails.
+
+	2019-03-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/88568
+	* tree.c (handle_dll_attribute): Don't clear TREE_STATIC for
+	dllimport on VAR_DECLs with RECORD_TYPE or UNION_TYPE DECL_CONTEXT.
+
+	2019-03-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/89587
+	* config/rs6000/t-linux (MULTIARCH_DIRNAME): Set to non-empty only
+	if_multiarch.
+
+	PR middle-end/89590
+	* builtins.c (maybe_emit_free_warning): Punt if free doesn't have
+	exactly one argument.
+
+	2019-02-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/89520
+	* convert.c (convert_to_real_1, convert_to_integer_1): Punt for
+	builtins if they don't have a single scalar floating point argument.
+	Formatting fixes.
+
+	2019-02-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89412
+	* expr.c (expand_assignment): If result is a MEM, use change_address
+	instead of simplify_gen_subreg.
+
+	2019-02-20  Jakub Jelinek  <jakub@redhat.com>
+		    David Malcolm  <dmalcolm@redhat.com>
+
+	PR middle-end/89091
+	* fold-const.c (decode_field_reference): Return NULL_TREE if
+	lang_hooks.types.type_for_size returns NULL.  Check it before
+	overwriting *exp_.  Use return NULL_TREE instead of return 0.
+
+	2019-02-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/88074
+	PR middle-end/89415
+	* toplev.c (do_compile): Double the emin/emax exponents to workaround
+	buggy mpc_norm.
+
+	2019-02-19  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/88074
+	* toplev.c (do_compile): Initialize mpfr's exponent range
+	based on available float modes.
+
+	2019-02-18  Jakub Jelinek  <jakub@redhat.com>
+ 
+	PR target/89361
+	* config/s390/s390.c (s390_indirect_branch_attrvalue,
+	s390_indirect_branch_settings): Define unconditionally.
+	(s390_set_current_function): Likewise, but guard the whole body except
+	the s390_indirect_branch_settings call with
+	#if S390_USE_TARGET_ATTRIBUTE.
+	(TARGET_SET_CURRENT_FUNCTION): Redefine unconditionally.
+
+	2019-02-15  Richard Biener  <rguenther@suse.de>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/89278
+	* tree-loop-distribution.c: Include tree-eh.h.
+	(generate_memset_builtin, generate_memcpy_builtin): Call
+	rewrite_to_non_trapping_overflow on builtin->size before passing it
+	to force_gimple_operand_gsi.
+
+	2019-02-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR other/89342
+	* optc-save-gen.awk: Handle optimize_fast like optimize_size or
+	optimize_debug.
+	* opth-gen.awk: Likewise.
+
+	2019-02-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/89354
+	* combine.c (make_extraction): Punt if extraction_mode is narrower
+	than len bits.
+
+	PR tree-optimization/89314
+	* fold-const.c (fold_binary_loc): Cast strlen argument to
+	const char * before dereferencing it.  Formatting fixes.
+
+	2019-02-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89303
+	* tree-ssa-structalias.c (set_uids_in_ptset): Or in vi->is_heap_var
+	into pt->vars_contains_escaped_heap instead of setting
+	pt->vars_contains_escaped_heap to it.
+
+	PR middle-end/89281
+	* optabs.c (prepare_cmp_insn): Use UINTVAL (size) instead of
+	INTVAL (size), compare it to GET_MODE_MASK instead of
+	1 << GET_MODE_BITSIZE.
+
+	2019-02-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89246
+	* config/i386/i386.c (ix86_simd_clone_compute_vecsize_and_simdlen):
+	If !node->definition and TYPE_ARG_TYPES is non-NULL, use
+	TYPE_ARG_TYPES instead of DECL_ARGUMENTS.
+
+	2019-01-16  David Malcolm  <dmalcolm@redhat.com>
+
+	PR target/88861
+	* combine.c (delete_noop_moves): Convert to "bool" return,
+	returning true if any edges are eliminated.
+	(combine_instructions): Also return true if delete_noop_moves
+	returns true.
+
+	2019-02-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/89234
+	* except.c (copy_reg_eh_region_note_forward): Return if note_or_insn
+	is a NOTE, CODE_LABEL etc. - rtx_insn * other than INSN_P.
+	(copy_reg_eh_region_note_backward): Likewise.
+
+	2019-02-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/89188
+	* dce.c (delete_unmarked_insns): Don't remove no-op moves if they
+	can throw, non-call exceptions are enabled and we can't delete
+	dead exceptions or alter cfg.  Set must_clean if
+	delete_insn_and_edges returns true, don't set it blindly for calls.
+
+	PR rtl-optimization/89195
+	* combine.c (make_extraction): For MEMs, don't extract bytes outside
+	of the original MEM.
+
+	PR target/89186
+	* optabs.c (prepare_cmp_insn): Pass x and y to
+	emit_block_comp_via_libcall rather than XEXP (x, 0) and XEXP (y, 0).
+
+	2019-02-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/87887
+	* config/i386/i386.c (ix86_simd_clone_compute_vecsize_and_simdlen):
+	Punt with warning on aggregate return or argument types.  Ignore
+	type/mode checking for uniform arguments.
+
+	2019-02-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/88107
+	* tree-cfg.c (find_outermost_region_in_block): Add ALL argument,
+	instead of assertion that eh_region_outermost is non-NULL, if it
+	is NULL, set *ALL to true and return NULL.
+	(move_sese_region_to_fn): Adjust caller, if all is set, call
+	duplicate_eh_regions with NULL region.
+
+	2019-01-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/66676
+	PR ipa/89104
+	* omp-simd-clone.c (simd_clone_clauses_extract)
+	<case OMP_CLAUSE_ALIGNED>: Ignore clauses with NULL
+	OMP_CLAUSE_ALIGNED_ALIGNMENT.
+
+	2019-01-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89002
+	* gimplify.c (gimplify_omp_for): When adding OMP_CLAUSE_*_GIMPLE_SEQ
+	for lastprivate/linear IV, push gimplify context around gimplify_assign
+	and, if it needed any temporaries, pop it into a gimple bind around the
+	sequence.
+
+	2019-01-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/87214
+	* config/i386/sse.md
+	(<mask_codefor>avx512dq_shuf_<shuffletype>64x2_1<mask_name>,
+	avx512f_shuf_<shuffletype>64x2_1<mask_name>): Ensure the
+	first constants in pairs are multiples of 2.  Formatting fixes.
+	(avx512vl_shuf_<shuffletype>32x4_1<mask_name>,
+	avx512vl_shuf_<shuffletype>32x4_1<mask_name>): Ensure the
+	first constants in each quadruple are multiples of 4.  Formatting fixes.
+
+	2019-01-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/49429
+	PR target/49454
+	PR rtl-optimization/86334
+	PR target/88906
+	* expr.c (emit_block_move_hints): Move marking of MEM_EXPRs
+	addressable from here...
+	(emit_block_op_via_libcall): ... to here.
+
+	2019-01-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/88870
+	* dce.c (deletable_insn_p): Never delete const/pure calls that can
+	throw if we can't alter the cfg or delete dead exceptions.
+	(mark_insn): Don't call find_call_stack_args for such calls.
+
+	2019-01-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/88568
+	* tree.c (handle_dll_attribute): Clear TREE_STATIC after setting
+	DECL_EXTERNAL.
+
+	2019-01-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/82564
+	PR target/88620
+	* expr.c (expand_assignment): For calls returning VLA structures
+	if to_rtx is not a MEM, force it into a stack temporary.
+
+	2019-01-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/88594
+	* config/i386/i386.c (ix86_expand_divmod_libfunc): Use mode instead
+	of GET_MODE (opN) as modes of the libcall arguments.
+
+	2019-01-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/88644
+	* dwarf2out.c (modified_type_die): If type is equal to sizetype,
+	change it to qualified_type.
+
+	2018-12-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/85594
+	PR middle-end/88553
+	* omp-expand.c (extract_omp_for_update_vars): Regimplify the condition
+	if needed.
+	(expand_omp_for_generic): Don't clobber t temporary for ordered loops.
+
+	PR rtl-optimization/88563
+	* expr.c (expand_expr_real_2) <case WIDEN_MULT_EXPR>: Swap innermode
+	and mode arguments to convert_modes.  Likewise swap mode and word_mode
+	arguments.  Handle both arguments with VOIDmode before convert_modes
+	of one of them.  Formatting fixes.
+
+	2018-12-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/88470
+	* cfgcleanup.c (outgoing_edges_match): If the function is
+	shrink-wrapped and bb1 ends with a JUMP_INSN with a single fake
+	edge to EXIT, return false.
+
+	PR rtl-optimization/88416
+	* valtrack.c (cleanup_auto_inc_dec): Handle pre/post-inc/dec/modify
+	even if !AUTO_INC_DEC.
+
+	2018-12-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/85593
+	* final.c (rest_of_handle_final): Don't call collect_fn_hard_reg_usage
+	for functions with naked attribute.
+
+	2018-11-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/87895
+	* omp-simd-clone.c (ipa_simd_modify_function_body): When removing
+	or replacing GIMPLE_RETURN, set EDGE_FALLTHRU on the edge to EXIT.
+	(simd_clone_adjust): Don't set EDGE_FALLTHRU here. In a loop that
+	redirects edges to EXIT to edges to incr_bb, iterate while EXIT
+	has any preds and always use EDGE_PRED (, 0).
+
+	2018-10-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/87647
+	* varasm.c (decode_addr_const): Handle COMPOUND_LITERAL_EXPR.
+
+	2018-10-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/85488
+	PR middle-end/87649
+	* omp-low.c (check_omp_nesting_restrictions): Diagnose ordered without
+	depend closely nested inside of loop with ordered clause with
+	a parameter.
+
+2019-08-25  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR target/91533
+	Backport from mainline
+	2019-06-30  Uro Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/sse.md (ssse3_abs<mode>2): Rename from abs<mode>2.
+	* config/i386/i386-builtin.def (__builtin_ia32_pabsb):
+	Use CODE_FOR_ssse3_absv8qi2.
+	(__builtin_ia32_pabsw): Use CODE_FOR_ssse3_absv4hi2.
+	(__builtin_ia32_pabsd): Use CODE_FOR_ssse3_absv2si2.
+
+2019-08-21  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91510
+	Backport from mainline
+	2017-09-26  Martin Jambor  <mjambor@suse.cz>
+
+	* tree-sra.c (compare_access_positions): Put integral types first,
+	stabilize sorting of integral types, remove conditions putting
+	non-full-precision integers last.
+	(sort_and_splice_var_accesses): Disable scalarization if a
+	non-integert would be represented by a non-full-precision integer.
+
+2019-08-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/91347
+	* dse.c (scan_insn): Call add_wild_read for non-const/memset tail calls
+	before reload if HARD_FRAME_POINTER_IS_ARG_POINTER.
+
+2019-07-22  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-07-22  Martin Liska  <mliska@suse.cz>
+
+	PR driver/91172
+	* opts-common.c (decode_cmdline_option): Decode
+	argument of -Werror and check it for a wrong language.
+	* opts-global.c (complain_wrong_lang): Remove such case.
+
+2019-07-16  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	Backport from mainline
+	2019-03-05  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	PR target/89222
+	* config/arm/arm.md (movsi): Use targetm.cannot_force_const_mem
+	to decide when to split off a non-zero offset from a symbol.
+	* config/arm/arm.c (arm_cannot_force_const_mem): Disallow offsets
+	in function symbols.
+
+2019-07-15  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-07-01  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/vector.md: Fix shift count operand printing.
+
+2019-07-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/91136
+	* df-core.c (ACCESSING REFS): Fix typos in comment.
+	* resource.c (mark_target_live_reg): Add artificial defs that occur at
+	the beginning of the block to the initial set of live registers.
+
+2019-06-28  Jeff Law  <law@redhat.com>
+
+	Backport from mainline
+	2019-06-21  Jeff Law  <law@redhat.com>
+
+	PR tree-optimization/90949
+	* tree-ssa-copy.c (fini_copy_prop): Use reset_flow_sensitive_info.
+	* tree-ssanames.c (reset_flow_sensitive_info): Reset non-null state.
+
+2019-06-27  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-06-25  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/90939
+	* ipa-cp.c (ipcp_bits_lattice::meet_with): Remove assert.
+
+2019-06-16  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR middle-end/64242
+	* config/pa/pa.md (nonlocal_goto): Restore frame pointer last.  Add
+	frame clobbers and schedule block.
+	(builtin_longjmp): Likewise.
+
+2019-05-24  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/90530
+	* config/pa/pa.c (pa_cannot_change_mode_class): Accept mode changes
+	from DImode to SImode in floating-point registers on 64-bit target.
+	* config/pa/pa.md (umulsidi3): Change nonimmediate_operand to
+	register_operand in xmpyu patterns.
+
+2019-05-23  Uro Bizjak  <ubizjak@gmail.com>
+
+	Backported from mainline
+	2019-05-21  Uro Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/cpuid.h (__cpuid): For 32bit targets, zero
+	%ebx and %ecx bafore calling cpuid with leaf 1 or
+	non-constant leaf argument.
+
+	2019-05-21  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR target/90547
+	* config/i386/i386.md (anddi_1 to andsi_1_zext splitter):
+	Avoid calling gen_lowpart with CONST operand.
+
+2019-05-20  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-05-07  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/89765
+	* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):
+	In handling of ALTIVEC_BUILTIN_VEC_INSERT, use modular arithmetic
+	to compute vector element selector for both constant and variable
+	operands.
+
+2019-01-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/86215
+	Backport from mainline
+	2017-09-25  Iain Sandoe  <iain@codesourcery.com>
+
+	PR target/80556
+	* config/i386/darwin.h (REAL_LIB_SPEC): New; put libSystem ahead
+	of libgcc_eh for m64.
+	* config/i386/darwin64.h: Likewise.
+
+2019-05-15  David Edelsohn  <dje.gcc@gmail.com>
+
+	Backport from mainline
+	2019-04-11  David Edelsohn  <dje.gcc@gmail.com>
+	* xcoffout.h (xcoff_private_rodata_section_name): Declare.
+	* xcoffout.c (xcoff_private_rodata_section_name): Define.
+	* config/rs6000/rs6000.c (rs6000_xcoff_asm_init_sections): Create
+	read_only_private_data_section using coff_private_rodata_section_name.
+	(rs6000_xcoff_file_start): Generate coff_private_rodata_section_name.
+
+	2018-12-04  David Edelsohn  <dje.gcc@gmail.com>
+	2018-12-13  David Edelsohn  <dje.gcc@gmail.com>
+	PR target/61976
+	* config/rs6000/rs6000.c (rs6000_function_arg): Don't pass aggregates
+	in FPRs on AIX. Ensure type is non-NULL.
+	(rs6000_arg_partial_bytes): Same.
+
+2019-05-15  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config/arm/t-rtems: Replace -march=armv7-m multilibs with
+	-mcpu=cortex-m3 and -mcpu=cortex-m4 multilibs.
+
+2019-05-13  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-05-06  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/89424
+	* config/rs6000/rs6000.c (rs6000_expand_vector_extract): Add
+	handling of V1TImode.
+
+2019-05-07  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline:
+	2019-01-25  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR middle-end/89037
+	* varasm.c (output_constructor_bitfield): Use wi::extract_uhwi
+	instead of accessing TREE_INT_CST_ELT directly.
+
+2019-05-01  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	Backport from mainline.
+	2019-04-30  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+	PR target/86538
+	* config/aarch64/aarch64-c.c (aarch64_update_cpp_builtins):
+	Define __ARM_FEATURE_ATOMICS
+
+2019-04-30  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	PR target/90075
+	* config/aarch64/iterators.md (V_INT_EQUIV): Add mode for
+	integer equivalent of floating point values.
+
+	Backport from mainline
+	2018-12-11  Richard Earnshaw  <Richard.Earnshaw@arm.com>
+	PR target/37369
+	* config/aarch64/iterators.md (sizem1): Add sizes for
+	SFmode and DFmode.
+	(Vbtype): Add SFmode mapping.
+	* config/aarch64/aarch64.md (copysigndf3, copysignsf3): Delete.
+	(copysign<GPF:mode>3): New expand pattern.
+	(copysign<GPF:mode>3_insn): New insn pattern.
+
+2019-04-22  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-03-15  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/87532
+	* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):
+	When handling vec_extract, use modular arithmetic to allow
+	constant selectors greater than vector length.
+	* config/rs6000/rs6000.c (rs6000_expand_vector_extract): Allow
+	V1TImode vectors to have constant selector values greater than 0.
+	Use modular arithmetic to compute vector index.
+	(rs6000_split_vec_extract_var): Use modular arithmetic to compute
+	index for in-memory vectors.  Correct code generation for
+	in-register vectors.  Use inner mode of vector rather than mode of
+	destination for move instruction.
+	(altivec_expand_vec_ext_builtin): Use modular arithmetic to
+	compute index.
+
+	2019-04-12  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/87532
+	* config/rs6000/vsx.md (*vsx_extract_<mode>_<VS_scalar>mode_var):
+	Use QI inner mode with V16QI vector mode.
+
+2019-04-19  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	Backport from trunk
+	2018-05-23  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* doc/sourcebuild.texi (Endianness): New subsubsection.
+
+2019-04-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-03-08  Martin Liska  <mliska@suse.cz>
+
+	PR target/86952
+	* config/i386/i386.c (ix86_option_override_internal): Disable
+	jump tables when retpolines are used.
+
+2019-04-10  Matthew Malcomson  <matthew.malcomson@arm.com>
+
+	PR target/90024
+	* config/arm/arm.c (neon_valid_immediate): Disallow VOIDmode parameter.
+	* config/arm/constraints.md (Dm, DN, Dn): Split previous Dn constraint
+	into three.
+	* config/arm/neon.md (*neon_mov<mode>): Account for TImode and DImode
+	differences directly.
+	(*smax<mode>3_neon, vashl<mode>3, vashr<mode>3_imm): Use Dm constraint.
+
+2019-04-07  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR target/89945
+	* config/i386/i386.md (anddi_1 to andsi_1_zext splitter):
+	Avoid calling gen_lowpart with SYMBOL_REF and LABEL_REF operand.
+
+2019-04-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2019-02-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* rtlanal.c (get_initial_register_offset): Fall back to the estimate
+	as long as the epilogue isn't completed.
+
+2019-04-03  Richard Biener  <rguenther@suse.de>
+
+	PR lto/89896
+	* lto-wrapper.c (run_gcc): Avoid implicit rules making
+	the all target phony.
+
+2019-04-02  Xiong Hu Luo <luoxhu@linux.ibm.com>
+
+	Backport from trunk r250477.
+
+	2017-07-24  Carl Love  <cel@us.ibm.com>
+
+	* config/rs6000/rs6000-c.c: Add support for built-in functions
+	vector float vec_extract_fp32_from_shorth (vector unsigned short);
+	vector float vec_extract_fp32_from_shortl (vector unsigned short);
+	* config/rs6000/altivec.h (vec_extract_fp_from_shorth,
+	vec_extract_fp_from_shortl): Add defines for the two builtins.
+	* config/rs6000/rs6000-builtin.def (VEXTRACT_FP_FROM_SHORTH,
+	VEXTRACT_FP_FROM_SHORTL): Add BU_P9V_OVERLOAD_1 and BU_P9V_VSX_1
+	new builtins.
+	* config/rs6000/vsx.md vsx_xvcvhpsp): Add define_insn.
+	(vextract_fp_from_shorth, vextract_fp_from_shortl): Add define_expands.
+	* doc/extend.texi: Update the built-in documentation file for the
+	new built-in function.
+
+	Backport from trunk r255555.
+
+	2017-12-11  Carl Love  <cel@us.ibm.com>
+
+	* config/rs6000/altivec.h (vec_extract_fp32_from_shorth,
+	vec_extract_fp32_from_shortl]): Add #defines.
+	* config/rs6000/rs6000-builtin.def (VSLDOI_2DI): Add macro expansion.
+	* config/rs6000/rs6000-c.c (ALTIVEC_BUILTIN_VEC_UNPACKH,
+	ALTIVEC_BUILTIN_VEC_UNPACKL, ALTIVEC_BUILTIN_VEC_AND,
+	ALTIVEC_BUILTIN_VEC_SLD, ALTIVEC_BUILTIN_VEC_SRL,
+	ALTIVEC_BUILTIN_VEC_SRO, ALTIVEC_BUILTIN_VEC_SLD,
+	ALTIVEC_BUILTIN_VEC_SLL): Add expansions.
+	* doc/extend.texi: Add documentation for the added builtins.
+
+2019-03-28  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-11-05  Martin Liska  <mliska@suse.cz>
+
+	PR web/87829
+	* doc/invoke.texi: Remove options that are
+	not disabled with -Os.
+
+2019-02-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-02-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89253
+	* tree-ssa-loop-split.c (tree_ssa_split_loops): Check we can
+	duplicate the loop.
+
+	2019-02-08  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89223
+	* tree-data-ref.c (initialize_matrix_A): Fail if constant
+	doesn't fit in HWI.
+	(analyze_subscript_affine_affine): Handle failure from
+	initialize_matrix_A.
+
+	2019-01-28  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/88739
+	* tree-ssa-sccvn.c (vn_reference_lookup_3): Avoid generating
+	BIT_FIELD_REFs of non-mode-precision integral operands.
+
+2019-03-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-01-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/86554
+	* tree-ssa-sccvn.c (visit_nary_op): When value-numbering to
+	expressions with different overflow behavior make sure there's an
+	available expression on the path.
+
+	2018-11-20  Richard Biener  <rguenther@suse.de>
+ 
+	PR tree-optimization/88105
+	* tree-ssa-dom.c (pass_dominator::execute): Do not walk
+	backedges.
+
+	2018-03-08  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/84552
+	* tree-scalar-evolution.c: Include tree-into-ssa.h.
+	(follow_copies_to_constant): Do not follow SSA names registered
+	for update.
+
+2019-03-21  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	* config/rs6000/rs6000.c (rs6000_analyze_swaps): Rebuild
+	ud- and du-chains between phases.
+
+2019-03-21  Matthias Klose  <doko@ubuntu.com>
+
+	Backport from mainline
+	2019-02-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89505
+	* tree-ssa-structalias.c (compute_dependence_clique): Make sure
+	to handle restrict pointed-to vars with multiple subvars
+	correctly.
+
+2019-03-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2019-03-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/89523
+	* config/i386/i386.c (ix86_print_operand): Handle 'M' to add
+	addr32 prefix to VSIB address for X32.
+	* config/i386/sse.md (*avx512pf_gatherpf<mode>sf_mask): Prepend
+	"%M2" to opcode.
+	(*avx512pf_gatherpf<mode>df_mask): Likewise.
+	(*avx512pf_scatterpf<mode>sf_mask): Likewise.
+	(*avx512pf_scatterpf<mode>df_mask): Likewise.
+	(*avx2_gathersi<mode>): Prepend "%M3" to opcode.
+	(*avx2_gathersi<mode>_2): Prepend "%M2" to opcode.
+	(*avx2_gatherdi<mode>): Prepend "%M3" to opcode.
+	(*avx2_gatherdi<mode>_2): Prepend "%M2" to opcode.
+	(*avx2_gatherdi<mode>_3): Prepend "%M3" to opcode.
+	(*avx2_gatherdi<mode>_4): Prepend "%M2" to opcode.`
+	(*avx512f_gathersi<mode>): Prepend "%M4" to opcode.
+	(*avx512f_gathersi<mode>_2): Prepend "%M3" to opcode.
+	(*avx512f_gatherdi<mode>): Prepend "%M4" to opcode.
+	(*avx512f_gatherdi<mode>_2): Prepend "%M3" to opcode.
+	(*avx512f_scattersi<mode>): Prepend "%M0" to opcode.
+	(*avx512f_scatterdi<mode>): Likewise.
+
+2019-03-14  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-03-07  Martin Jambor  <mjambor@suse.cz>
+
+	PR lto/87525
+	* ipa-cp.c (perform_estimation_of_a_value): Account zero time benefit
+	for extern inline functions.
+
+2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-02-16  Jakub Jelinek  <jakub@redhat.com>
+ 
+	PR target/84272
+	* config/aarch64/cortex-a57-fma-steering.c (fma_forest::merge_forest):
+	Use ++iter rather than iter++ for std::list iterators.
+	(func_fma_steering::dfs): Likewise.  Don't delete nodes right away,
+	defer deleting them until all nodes in the forest are processed.  Do
+	free even leaf nodes.  Change to_process into auto_vec.
+
+2019-03-13  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2019-03-08  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* config/arm/arm.h (TARGET_FP16_TO_DOUBLE): Add TARGET_VFP_DOUBLE
+	requirement.
+
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-11  David Malcolm  <dmalcolm@redhat.com>
+
+	PR lto/88147
+	* input.c (selftest::test_line_offset_overflow): New selftest.
+	(selftest::input_c_tests): Call it.
+
+2019-03-07  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	Backport of r268834 from mainline to gcc-7-branch.
+	2019-02-13  Xiong Hu Luo  <luoxhu@linux.vnet.ibm.com>
+
+	* config/rs6000/altivec.h (vec_sbox_be, vec_cipher_be,
+	vec_cipherlast_be, vec_ncipher_be, vec_ncipherlast_be): New #defines.
+	* config/rs6000/crypto.md (CR_vqdi): New define_mode_iterator.
+	(crypto_vsbox_<mode>, crypto_<CR_insn>_<mode>): New define_insns.
+	* config/rs6000/rs6000-builtin.def (VSBOX_BE): New BU_CRYPTO_1.
+	(VCIPHER_BE, VCIPHERLAST_BE, VNCIPHER_BE, VNCIPHERLAST_BE):
+	New BU_CRYPTO_2.
+	* config/rs6000/rs6000.c (builtin_function_type)
+	<CRYPTO_BUILTIN_VSBOX_BE, CRYPTO_BUILTIN_VCIPHER_BE,
+	CRYPTO_BUILTIN_VCIPHERLAST_BE, CRYPTO_BUILTIN_VNCIPHER_BE,
+	CRYPTO_BUILTIN_VNCIPHERLAST_BE>: New switch options.
+	* doc/extend.texi (vec_sbox_be, vec_cipher_be, vec_cipherlast_be,
+	vec_ncipher_be, vec_ncipherlast_be): New builtin functions.
+
+2019-02-27  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR target/89397
+	* config/i386/i386.c (ix86_atomic_assign_expand_fenv): Check
+	TARGET_SSE in addition to TARGET_SSE_MATH.
+
+	(ix86_excess_precision): Ditto.
+	(ix86_float_exceptions_rounding_supported_p): Ditto.
+	(use_rsqrt_p): Ditto.
+	* config/i386/sse.md (rsqrt<mode>2): Ditto.
+
+2019-02-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-14  Martin Liska  <mliska@suse.cz>
+
+	PR rtl-optimization/89242
+	* dce.c (delete_unmarked_insns): Call free_dominance_info we
+	process a transformation.
+
+2019-02-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-11  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/89009
+	* ipa-cp.c (build_toporder_info): Remove usage of a param.
+	* ipa-inline.c (inline_small_functions): Likewise.
+	* ipa-pure-const.c (propagate_pure_const): Likewise.
+	(propagate_nothrow): Likewise.
+	* ipa-reference.c (propagate): Likewise.
+	* ipa-utils.c (struct searchc_env): Remove unused field.
+	(searchc): Always search across AVAIL_INTERPOSABLE.
+	(ipa_reduced_postorder): Always allow AVAIL_INTERPOSABLE as
+	the only called IPA pure const can properly not propagate
+	across interposable boundary.
+	* ipa-utils.h (ipa_reduced_postorder): Remove param.
+
+2019-02-11  Stefan Agner  <stefan@agner.ch>
+
+	Backport from mainline.
+	2019-01-10  Stefan Agner  <stefan@agner.ch>
+
+	PR target/88648
+	* config/arm/arm.c (arm_option_override_internal): Force
+	opts->x_inline_asm_unified to true only if TARGET_THUMB2_P.
+
+2019-02-09  Alan Modra  <amodra@gmail.com>
+
+	PR target/88343
+	* config/rs6000/rs6000.c (rs6000_reg_live_or_pic_offset_p): Match
+	logic in rs6000_emit_prologue emitting pic_offset_table setup.
+
+2019-02-08  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2018-06-11  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/85755
+	* config/rs6000/rs6000.md (*movdi_internal32): Put constraint modifiers
+	on the correct operand.
+	(*movdi_internal64): Ditto.
+
+2019-02-06  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-01-30  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+	* config/rs6000/rs6000-c.c (altivec-resolve_overloaded_builtin):
+	Change handling of ALTIVEC_BUILTIN_VEC_EXTRACT.  Coerce result to
+	type of vector element when vec_extract is implemented by direct
+	move.
+
+2019-02-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/i386/i386.c (ix86_expand_prologue): Emit a memory blockage
+	after restoring registers saved to allocate the frame on Windows.
+
+2019-02-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-02-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	PR target/88856
+	* config/s390/s390.md: Remove load and test FP splitter.
+
+2019-02-04  Bill Schmidt  <wshmidt@linux.ibm.com>
+
+	PR target/87064
+	Backport from mainline
+
+	2019-01-30  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/87064
+	* config/rs6000/vsx.md (*vsx_reduc_<VEC_reduc_name>_v4sf_scalar):
+	Disable for little-endian.
+
+	2019-01-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/87064
+	* config/rs6000/vsx.md (*vsx_reduc_<VEC_reduc_name>_v2df_scalar):
+	Disable for little endian.
+
+2018-01-31  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	Backport from mainline
+	2018-01-31  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR tree-optimization/89008
+	* gimple-ssa-strength-reduction.c (slsr_process_mul): Don't
+	process anything of the form X * 0.
+
+2019-01-31  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-01-31  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/89115
+	* lra.c (lra_rtx_hash): Properly hash CONST_INT values.
+
+	2019-01-30  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/89115
+	* opts.c (default_options_optimization): Reduce
+	PARAM_MAX_DSE_ACTIVE_LOCAL_STORES by a factor of 10 at -O1.
+	Make PARAM_LOOP_INVARIANT_MAX_BBS_IN_LOOP reduction relative
+	to the default.
+
+2019-01-30  Kewen Lin  <linkw@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-01-17  Kewen Lin  <linkw@gcc.gnu.org>
+
+	* doc/extend.texi: Add four new prototypes for vec_ld and seven new
+	prototypes for vec_st.
+	* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Add entries
+	for scalar address type variants of altivec_vec_ld/altivec_vec_st,
+	mainly on signed/unsigned long long and double.
+
+2019-01-27  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR target/88948
+	* rtl.h (prepare_copy_insn): New prototype.
+	* gcse.c (prepare_copy_insn): New function, split out from
+	process_insert_insn.
+	(process_insert_insn): Use prepare_copy_insn.
+	* store-motion.c (replace_store_insn): Use prepare_copy_insn
+	instead of gen_move_insn.
+
+2019-01-24  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR target/88998
+	* config/i386/sse.md (sse2_cvtpi2pd): Add SSE alternatives.
+	Disparage MMX alternative.
+	(sse2_cvtpd2pi): Ditto.
+	(sse2_cvttpd2pi): Ditto.
+
+2019-01-24  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-01-23  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89008
+	* tree-ssa-reassoc.c (eliminate_using_constants): For * 0 do
+	not leave another stray operand.
+
+2019-01-22  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR target/88938
+	* config/i386/i386.c (ix86_expand_builtin) [case IX86_BUILTIN_BEXTRI32,
+	case IX86_BUILTIN_BEXTRI64]: Sanitize operands.
+
+2019-01-18  Uro Bizjak  <ubizjak@gmail.com>
+
+	* config/alpha/alpha.c (alpha_gimplify_va_arg):
+	Handle split indirect COMPLEX_TYPE arguments.
+
+2019-01-16  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from mainline
+	2018-12-10  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/88214
+	* ipa-prop.c (determine_locally_known_aggregate_parts): Make sure
+	we check pointers against pointers.
+
+2019-01-09  Eric Botcazou  <ebotcazou@adacore.com>
+	    James Clarke  <jrtc27@jrtc27.com>
+
+	PR target/84010
+	* config/sparc/sparc.c (sparc_legitimize_tls_address): Only use Pmode
+	consistently in TLS address generation and adjust code to the renaming
+	of patterns.  Mark calls to __tls_get_addr as const.
+	* config/sparc/sparc.md (tgd_hi22): Turn into...
+	(tgd_hi22<P:mode>): ...this and use Pmode throughout.
+	(tgd_lo10): Turn into...
+	(tgd_lo10<P:mode>): ...this and use Pmode throughout.
+	(tgd_add32): Merge into...
+	(tgd_add64): Likewise.
+	(tgd_add<P:mode>): ...this and use Pmode throughout.
+	(tldm_hi22): Turn into...
+	(tldm_hi22<P:mode>): ...this and use Pmode throughout.
+	(tldm_lo10): Turn into...
+	(tldm_lo10<P:mode>): ...this and use Pmode throughout.
+	(tldm_add32): Merge into...
+	(tldm_add64): Likewise.
+	(tldm_add<P:mode>): ...this and use Pmode throughout.
+	(tldm_call32): Merge into...
+	(tldm_call64): Likewise.
+	(tldm_call<P:mode>): ...this and use Pmode throughout.
+	(tldo_hix22): Turn into...
+	(tldo_hix22<P:mode>): ...this and use Pmode throughout.
+	(tldo_lox10): Turn into...
+	(tldo_lox10<P:mode>): ...this and use Pmode throughout.
+	(tldo_add32): Merge into...
+	(tldo_add64): Likewise.
+	(tldo_add<P:mode>): ...this and use Pmode throughout.
+	(tie_hi22): Turn into...
+	(tie_hi22<P:mode>): ...this and use Pmode throughout.
+	(tie_lo10): Turn into...
+	(tie_lo10<P:mode>): ...this and use Pmode throughout.
+	(tie_ld64): Use DImode throughout.
+	(tie_add32): Merge into...
+	(tie_add64): Likewise.
+	(tie_add<P:mode>): ...this and use Pmode throughout.
+	(tle_hix22_sp32): Merge into...
+	(tle_hix22_sp64): Likewise.
+	(tle_hix22<P:mode>): ...this and use Pmode throughout.
+	(tle_lox22_sp32): Merge into...
+	(tle_lox22_sp64): Likewise.
+	(tle_lox22<P:mode>): ...this and use Pmode throughout.
+	(*tldo_ldub_sp32): Merge into...
+	(*tldo_ldub_sp64): Likewise.
+	(*tldo_ldub<P:mode>): ...this and use Pmode throughout.
+	(*tldo_ldub1_sp32): Merge into...
+	(*tldo_ldub1_sp64): Likewise.
+	(*tldo_ldub1<P:mode>): ...this and use Pmode throughout.
+	(*tldo_ldub2_sp32): Merge into...
+	(*tldo_ldub2_sp64): Likewise.
+	(*tldo_ldub2<P:mode>): ...this and use Pmode throughout.
+	(*tldo_ldsb1_sp32): Merge into...
+	(*tldo_ldsb1_sp64): Likewise.
+	(*tldo_ldsb1<P:mode>): ...this and use Pmode throughout.
+	(*tldo_ldsb2_sp32): Merge into...
+	(*tldo_ldsb2_sp64): Likewise.
+	(*tldo_ldsb2<P:mode>): ...this and use Pmode throughout.
+	(*tldo_ldub3_sp64): Use DImode throughout.
+	(*tldo_ldsb3_sp64): Likewise.
+	(*tldo_lduh_sp32): Merge into...
+	(*tldo_lduh_sp64): Likewise.
+	(*tldo_lduh<P:mode>): ...this and use Pmode throughout.
+	(*tldo_lduh1_sp32): Merge into...
+	(*tldo_lduh1_sp64): Likewise.
+	(*tldo_lduh1<P:mode>): ...this and use Pmode throughout.
+	(*tldo_ldsh1_sp32): Merge into...
+	(*tldo_ldsh1_sp64): Likewise.
+	(*tldo_ldsh1<P:mode>): ...this and use Pmode throughout.
+	(*tldo_lduh2_sp64): Use DImode throughout.
+	(*tldo_ldsh2_sp64): Likewise.
+	(*tldo_lduw_sp32): Merge into...
+	(*tldo_lduw_sp64): Likewise.
+	(*tldo_lduw<P:mode>): ...this and use Pmode throughout.
+	(*tldo_lduw1_sp64): Use DImode throughout.
+	(*tldo_ldsw1_sp64): Likewise.
+	(*tldo_ldx_sp64): Likewise.
+	(*tldo_stb_sp32): Merge into...
+	(*tldo_stb_sp64): Likewise.
+	(*tldo_stb<P:mode>): ...this and use Pmode throughout.
+	(*tldo_sth_sp32): Merge into...
+	(*tldo_sth_sp64): Likewise.
+	(*tldo_sth<P:mode>): ...this and use Pmode throughout.
+	(*tldo_stw_sp32): Merge into...
+	(*tldo_stw_sp64): Likewise.
+	(*tldo_stw<P:mode>): ...this and use Pmode throughout.
+	(*tldo_stx_sp64): Use DImode throughout.
+
+2019-01-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* doc/invoke.texi (-Os): Add reference to -finline-functions.
+	(-finline-small-functions): Add references to -O3 and -Os.
+	(-findirect-inlining): Likewise.
+	(-finline-functions): Add references to -Os, -fprofile-use and
+	-fauto-profile.
+
+2019-01-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	revert:
+	2018-12-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	backport from mainline.
+	2018-12-12 Segher Boessenkool  <segher@kernel.crashing.org>
+		   Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/88343
+	* config/rs6000/rs6000.c (save_reg_p): Do not save the picbase reg
+	unless it has been used.
+	(first_reg_to_save): Remove dead code.
+
+2019-01-02  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR inline-asm/55681
+	* doc/extend.texi (Basic Asm): Update grammar.
+	(Extended Asm): Update grammar.
+
+	Backport from trunk
+	2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* doc/extend.texi (Using Assembly Language with C): Document asm inline.
+	(Size of an asm): Fix typo.  Document asm inline.
+	* gimple-pretty-print.c (dump_gimple_asm): Handle asm inline.
+	* gimple.h (enum gf_mask): Add GF_ASM_INLINE.
+	(gimple_asm_set_volatile): Fix typo.
+	(gimple_asm_inline_p): New.
+	(gimple_asm_set_inline): New.
+	* gimplify.c (gimplify_asm_expr): Propagate the asm inline flag from
+	tree to gimple.
+	* ipa-icf-gimple.c (func_checker::compare_gimple_asm): Compare the
+	gimple_asm_inline_p flag, too.
+	* tree-core.h (tree_base): Document that protected_flag is ASM_INLINE_P
+	in an ASM_EXPR.
+	* tree-inline.c (estimate_num_insns): If gimple_asm_inline_p return
+	a minimum size for an asm.
+	* tree.h (ASM_INLINE_P): New.
+
+2018-12-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	backport from mainline.
+	2018-12-12 Segher Boessenkool  <segher@kernel.crashing.org>
+		   Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/88343
+	* config/rs6000/rs6000.c (save_reg_p): Do not save the picbase reg
+	unless it has been used.
+	(first_reg_to_save): Remove dead code.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-12-06  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR c++/87380
+	* config/darwin.h (TARGET_WEAK_NOT_IN_ARCHIVE_TOC) Remove, use the
+	default.
+	* config/rs6000/darwin7.h (TARGET_WEAK_NOT_IN_ARCHIVE_TOC): New.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-12-06  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/78444
+	* config/i386/darwin.h (STACK_BOUNDARY): Remove macro.
+	* config/i386/i386.c (ix86_compute_frame_layout): Ensure at least 128b
+	stack alignment in non-leaf functions.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-08-15  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/81685
+	* config/darwin.h: (DEBUG_STR_OFFSETS_SECTION, DEBUG_LOCLISTS_SECTION,
+	DEBUG_RNGLISTS_SECTION) new macros.  (DEBUG_PUBNAMES_SECTION,
+	DEBUG_PUBTYPES_SECTION) update to include GNU variant.
+
+2018-12-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2018-12-10  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/88418
+	* config/i386/i386.c (ix86_expand_sse_cmp): For vector modes,
+	check operand 1 with vector_operand predicate.
+	(ix86_expand_sse_movcc): For vector modes, check op_true with
+	vector_operand, not nonimmediate_operand.
+
+2018-12-19  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	Backport from mainline
+	2018-12-18  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	* doc/extend.texi (PowerPC Altivec/VSX Built-in Functions):
+	Describe when a typedef name can be used as the type specifier for
+	a vector type, and when it cannot.
+
+2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/88213
+	* config/rs6000/vsx.md (*vsx_extract_<P:mode>_<VSX_D:mode>_load):
+	Require TARGET_POWERPC64.
+
+2018-12-17  Senthil Kumar Selvaraj  <senthilkumar.selvaraj@microchip.com>
+
+	Backport from trunk
+	2018-12-17  Senthil Kumar Selvaraj  <senthilkumar.selvaraj@microchip.com>
+
+	PR rtl-optimization/88253
+	* combine.c (combine_simplify_rtx): Test for side-effects before
+	substituting by zero.
+
+2018-12-15  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2018-12-14  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR rtl-optimization/88001
+	* function.c (match_asm_constraints_1): Don't invalidly share RTL.
+
+2018-12-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2018-12-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/s390-builtins.def (s390_vec_double_s64): Map to
+	s390_vec_double_s64 instead of s390_vcdgb.
+	(s390_vec_double_u64): Map to s390_vec_double_u64 instead of
+	s390_vcdlgb.
+
+2018-12-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2018-12-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/vx-builtins.md ("vec_ctd_s64", "vec_ctd_u64")
+	("vec_ctsl", "vec_ctul"): Replace 0 with VEC_NOINEXACT.
+	("vec_double_s64", "vec_double_u64"): Replace 4 with VEC_INEXACT.
+
+2018-12-12  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backport from mainline
+	2018-12-07  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/87496
+	* config/rs6000/rs6000.c (rs6000_option_override_internal): Disallow
+	-mabi=ieeelongdouble and -mabi=ibmlongdouble without -mlong-double-128.
+	Do not error for -mabi=ibmlongdouble and no ISA 2.06 support.
+	* doc/invoke.texi: Document -mabi=ibmlongdouble and -mabi=ieeelongdouble
+	require -mlong-double-128.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
@@ -19,13 +2288,13 @@
 	* gcc/dwarf2out.c (FUNC_SECOND_SECT_LABEL): New.
 	(dwarf2out_switch_text_section): Generate a local label for the second
 	function sub-section and apply it as the second FDE start label.
-	* gcc/final.c (final_scan_insn_1): Emit second FDE label after the second
-	sub-section start.
+	* gcc/final.c (final_scan_insn_1): Emit second FDE label after the
+	second sub-section start.
 
 2018-11-26  Iain Sandoe  <iain@sandoe.co.uk>
 
 	2018-08-15  Iain Sandoe  <iain@sandoe.co.uk>
- 
+
 	* config/darwin.c
 	(darwin_function_switched_text_sections): Delete.
 	* gcc/config/darwin.h
Index: gcc/testsuite/gcc.target/powerpc/vsx-vector-6.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.c	(.../branches/gcc-7-branch)
@@ -1,81 +0,0 @@
-/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
-/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
-/* { dg-require-effective-target powerpc_vsx_ok } */
-/* { dg-options "-mvsx -O2" } */
-
-#include <altivec.h>
-
-void foo (vector double *out, vector double *in, vector long *p_l, vector bool long *p_b, vector unsigned char *p_uc, int *i)
-{
-  vector double in0 = in[0];
-  vector double in1 = in[1];
-  vector double in2 = in[2];
-  vector long inl = *p_l;
-  vector bool long inb = *p_b;
-  vector unsigned char uc = *p_uc;
-
-  *out++ = vec_abs (in0);
-  *out++ = vec_add (in0, in1);
-  *out++ = vec_and (in0, in1);
-  *out++ = vec_and (in0, inb);
-  *out++ = vec_and (inb, in0);
-  *out++ = vec_andc (in0, in1);
-  *out++ = vec_andc (in0, inb);
-  *out++ = vec_andc (inb, in0);
-  *out++ = vec_ceil (in0);
-  *p_b++ = vec_cmpeq (in0, in1);
-  *p_b++ = vec_cmpgt (in0, in1);
-  *p_b++ = vec_cmpge (in0, in1);
-  *p_b++ = vec_cmplt (in0, in1);
-  *p_b++ = vec_cmple (in0, in1);
-  *out++ = vec_div (in0, in1);
-  *out++ = vec_floor (in0);
-  *out++ = vec_madd (in0, in1, in2);
-  *out++ = vec_msub (in0, in1, in2);
-  *out++ = vec_max (in0, in1);
-  *out++ = vec_min (in0, in1);
-  *out++ = vec_msub (in0, in1, in2);
-  *out++ = vec_mul (in0, in1);
-  *out++ = vec_nearbyint (in0);
-  *out++ = vec_nmadd (in0, in1, in2);
-  *out++ = vec_nmsub (in0, in1, in2);
-  *out++ = vec_nor (in0, in1);
-  *out++ = vec_or (in0, in1);
-  *out++ = vec_or (in0, inb);
-  *out++ = vec_or (inb, in0);
-  *out++ = vec_perm (in0, in1, uc);
-  *out++ = vec_rint (in0);
-  *out++ = vec_sel (in0, in1, inl);
-  *out++ = vec_sel (in0, in1, inb);
-  *out++ = vec_sub (in0, in1);
-  *out++ = vec_sqrt (in0);
-  *out++ = vec_trunc (in0);
-  *out++ = vec_xor (in0, in1);
-  *out++ = vec_xor (in0, inb);
-  *out++ = vec_xor (inb, in0);
-
-  *i++ = vec_all_eq (in0, in1);
-  *i++ = vec_all_ge (in0, in1);
-  *i++ = vec_all_gt (in0, in1);
-  *i++ = vec_all_le (in0, in1);
-  *i++ = vec_all_lt (in0, in1);
-  *i++ = vec_all_nan (in0);
-  *i++ = vec_all_ne (in0, in1);
-  *i++ = vec_all_nge (in0, in1);
-  *i++ = vec_all_ngt (in0, in1);
-  *i++ = vec_all_nle (in0, in1);
-  *i++ = vec_all_nlt (in0, in1);
-  *i++ = vec_all_numeric (in0);
-  *i++ = vec_any_eq (in0, in1);
-  *i++ = vec_any_ge (in0, in1);
-  *i++ = vec_any_gt (in0, in1);
-  *i++ = vec_any_le (in0, in1);
-  *i++ = vec_any_lt (in0, in1);
-  *i++ = vec_any_nan (in0);
-  *i++ = vec_any_ne (in0, in1);
-  *i++ = vec_any_nge (in0, in1);
-  *i++ = vec_any_ngt (in0, in1);
-  *i++ = vec_any_nle (in0, in1);
-  *i++ = vec_any_nlt (in0, in1);
-  *i++ = vec_any_numeric (in0);
-}
Index: gcc/testsuite/gcc.target/powerpc/altivec-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/altivec-7.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/altivec-7.c	(.../branches/gcc-7-branch)
@@ -1,46 +0,0 @@
-/* Origin: Aldy Hernandez  <aldyh@redhat.com>  */
-
-/* { dg-do compile { target powerpc*-*-* } } */
-/* { dg-require-effective-target powerpc_altivec_ok } */
-/* { dg-options "-maltivec" } */
-
-#include <altivec.h>
-
-int **intp;
-int *var_int;
-unsigned int **uintp;
-vector pixel *varpixel;
-vector signed char *vecchar;
-vector signed int *vecint;
-vector signed short *vecshort;
-vector unsigned char *vecuchar;
-vector unsigned int *vecuint;
-vector unsigned short *vecushort;
-vector float *vecfloat;
-
-int main ()
-{
-  *vecfloat++ = vec_andc((vector bool int)vecint[0], vecfloat[1]);
-  *vecfloat++ = vec_andc(vecfloat[0], (vector bool int)vecint[1]);
-  *vecfloat++ = vec_vxor((vector bool int)vecint[0], vecfloat[1]);
-  *vecfloat++ = vec_vxor(vecfloat[0], (vector bool int)vecint[1]);
-  *varpixel++ = vec_packpx(vecuint[0], vecuint[1]);
-  *varpixel++ = vec_vpkpx(vecuint[0], vecuint[1]);
-  *vecshort++ = vec_vmulosb(vecchar[0], vecchar[1]);
-  *vecint++ = vec_ld(var_int[0], intp[1]);
-  *vecint++ = vec_lde(var_int[0], intp[1]);
-  *vecint++ = vec_ldl(var_int[0], intp[1]);
-  *vecint++ = vec_lvewx(var_int[0], intp[1]);
-  *vecint++ = vec_unpackh(vecshort[0]);
-  *vecint++ = vec_unpackl(vecshort[0]);
-  *vecushort++ = vec_andc((vector bool short)vecshort[0], vecushort[1]);
-  *vecushort++ = vec_andc(vecushort[0], (vector bool short)vecshort[1]);
-  *vecushort++ = vec_vxor((vector bool short)vecshort[0], vecushort[1]);
-  *vecushort++ = vec_vxor(vecushort[0], (vector bool short)vecshort[1]);
-  *vecuint++ = vec_ld(var_int[0], uintp[1]);
-  *vecuint++ = vec_lvx(var_int[0], uintp[1]);
-  *vecuint++ = vec_vmsumubm(vecuchar[0], vecuchar[1], vecuint[2]);
-  *vecuchar++ = vec_xor(vecuchar[0], (vector unsigned char)vecchar[1]);
-
-  return 0;
-}
Index: gcc/testsuite/gcc.target/powerpc/altivec-7.h
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/altivec-7.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/altivec-7.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,47 @@
+/* Origin: Aldy Hernandez  <aldyh@redhat.com>  */
+
+/* This test code is included into altivec-7-be.c and altivec-7-le.c.  
+   The two files have the tests for the number of instructions generated for
+   LE versus BE.  */
+
+#include <altivec.h>
+
+int **intp;
+int *var_int;
+unsigned int **uintp;
+vector pixel *varpixel;
+vector signed char *vecchar;
+vector signed int *vecint;
+vector signed short *vecshort;
+vector unsigned char *vecuchar;
+vector unsigned int *vecuint;
+vector unsigned short *vecushort;
+vector float *vecfloat;
+
+int main ()
+{
+  *vecfloat++ = vec_andc((vector bool int)vecint[0], vecfloat[1]);
+  *vecfloat++ = vec_andc(vecfloat[0], (vector bool int)vecint[1]);
+  *vecfloat++ = vec_vxor((vector bool int)vecint[0], vecfloat[1]);
+  *vecfloat++ = vec_vxor(vecfloat[0], (vector bool int)vecint[1]);
+  *varpixel++ = vec_packpx(vecuint[0], vecuint[1]);
+  *varpixel++ = vec_vpkpx(vecuint[0], vecuint[1]);
+  *vecshort++ = vec_vmulesb(vecchar[0], vecchar[1]);
+  *vecshort++ = vec_vmulosb(vecchar[0], vecchar[1]);
+  *vecint++ = vec_ld(var_int[0], intp[1]);
+  *vecint++ = vec_lde(var_int[0], intp[1]);
+  *vecint++ = vec_ldl(var_int[0], intp[1]);
+  *vecint++ = vec_lvewx(var_int[0], intp[1]);
+  *vecint++ = vec_unpackh(vecshort[0]);
+  *vecint++ = vec_unpackl(vecshort[0]);
+  *vecushort++ = vec_andc((vector bool short)vecshort[0], vecushort[1]);
+  *vecushort++ = vec_andc(vecushort[0], (vector bool short)vecshort[1]);
+  *vecushort++ = vec_vxor((vector bool short)vecshort[0], vecushort[1]);
+  *vecushort++ = vec_vxor(vecushort[0], (vector bool short)vecshort[1]);
+  *vecuint++ = vec_ld(var_int[0], uintp[1]);
+  *vecuint++ = vec_lvx(var_int[0], uintp[1]);
+  *vecuint++ = vec_vmsumubm(vecuchar[0], vecuchar[1], vecuint[2]);
+  *vecuchar++ = vec_xor(vecuchar[0], (vector unsigned char)vecchar[1]);
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr87496-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr87496-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr87496-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,10 @@
+/* PR target/87496 */
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
+/* { dg-options "-O2 -mcpu=power7 -mabi=ieeelongdouble -mlong-double-64 -Wno-psabi" } */
+
+int i;
+
+/* { dg-error "'-mabi=ieeelongdouble' requires '-mlong-double-128'" "PR87496" { target *-*-* } 0 } */
+/* { dg-warning "using IEEE extended precision long double" "" { target *-*-* } 0 } */
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-19b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,109 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned long long int e0 (vector unsigned long long int v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned long long int e3 (vector unsigned long long int v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+unsigned long long int me0 (vector unsigned long long int *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned long long int me3 (vector unsigned long long int *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned long long int ei (vector unsigned long long int v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+unsigned long long int mei (vector unsigned long long int *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned long long int dv = { CONST0, CONST1 };
+  unsigned long long int d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/altivec-13.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/altivec-13.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/altivec-13.c	(.../branches/gcc-7-branch)
@@ -1,6 +1,7 @@
 /* { dg-do compile { target powerpc*-*-* } } */
 /* { dg-require-effective-target powerpc_altivec_ok } */
 /* { dg-options "-maltivec" } */
+
 /* Author: Ziemowit Laski  <zlaski@apple.com>  */
 
 /* This test case exercises intrinsic/argument combinations that,
@@ -7,15 +8,70 @@
    while not in the Motorola AltiVec PIM, have nevertheless crept
    into the AltiVec vernacular over the years.  */
 
+/* Tests requiring VSX support (vector long long and vector double) have
+   been moved over to vsx-13.c.  */
+
 #include <altivec.h>
 
-void foo (void) 
+void foo (void)
 {
   vector bool int boolVec1 = (vector bool int) vec_splat_u32(3);
   vector bool short boolVec2 = (vector bool short) vec_splat_u16(3);
   vector bool char boolVec3 = (vector bool char) vec_splat_u8(3);
-
+  vector signed char vsc1, vsc2, vscz;
+  vector unsigned char vuc1, vuc2, vucz;
+  vector signed short int vssi1, vssi2, vssiz;
+  vector signed int vsi1, vsi2, vsiz;
+  vector unsigned int vui1, vui2, vuiz;
+  vector unsigned short int vusi1, vusi2, vusiz;
+  vector pixel vp1, vp2, vpz;
+  vector float vf1, vf2, vfz;
+  
   boolVec1 = vec_sld( boolVec1, boolVec1, 4 );
   boolVec2 = vec_sld( boolVec2, boolVec2, 2 );
   boolVec3 = vec_sld( boolVec3, boolVec3, 1 );
+
+  vscz = vec_sld( vsc1, vsc2, 1 );
+  vucz = vec_sld( vuc1, vuc2, 1 );
+  vsiz = vec_sld( vsi1, vsi2, 1 );
+  vuiz = vec_sld( vui1, vui2, 1 );
+  vssiz = vec_sld( vssi1, vssi2, 1 );
+  vusiz = vec_sld( vusi1, vusi2, 1 );
+  
+  vfz = vec_sld( vf1, vf2, 1 );
+
+  vpz = vec_sld( vp1, vp2, 1 );
+
+  vucz = vec_srl(vuc1, vuc2);
+  vsiz = vec_srl(vsi1, vuc2);
+  vuiz = vec_srl(vui1, vuc2);
+  vpz = vec_srl(vp1, vuc2);
+  vssiz = vec_srl(vssi1, vuc2);
+  vusiz = vec_srl(vusi1, vuc2);
+
+  vscz = vec_sro(vsc1, vsc2);
+  vscz = vec_sro(vsc1, vuc2);
+  vucz = vec_sro(vuc1, vsc2);
+  vucz = vec_sro(vuc1, vuc2);
+  vsiz = vec_sro(vsi1, vsc2);
+  vsiz = vec_sro(vsi1, vuc2);
+  vuiz = vec_sro(vui1, vsc2);
+  vuiz = vec_sro(vui1, vuc2);
+  vpz = vec_sro(vp1, vsc2);
+  vpz = vec_sro(vp1, vuc2);
+  vssiz = vec_sro(vssi1, vsc2);
+  vssiz = vec_sro(vssi1, vuc2);
+  vusiz = vec_sro(vusi1, vsc2);
+  vusiz = vec_sro(vusi1, vuc2);
+  vfz = vec_sro(vf1, vsc2);
+  vfz = vec_sro(vf1, vuc2);
 }
+
+/* Expected results:
+   vec_sld          vsldoi
+   vec_srl          vsr
+   vec_sro          vsro  */
+
+/* { dg-final { scan-assembler-times "vsldoi" 11 } } */
+/* { dg-final { scan-assembler-times "vsr " 6 } } */
+/* { dg-final { scan-assembler-times "vsro" 16 } } */
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-18d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18d.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18d.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,148 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Unsigned Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned int s3 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector unsigned int s1 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector unsigned int s21 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector unsigned int s30 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned int ms3 (vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector unsigned int ms1(vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector unsigned int ms21(vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector unsigned int ms30(vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned int ci (vector unsigned int v, int i, unsigned int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned int mci(vector unsigned int *vp, int i, unsigned int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, unsigned char *argv[]) {
+  vector unsigned int sv = { CONST0, CONST1, CONST2, CONST3 };
+
+  sv = s3 (sv, CONST2);
+  if (sv [3] != CONST2)
+    abort ();
+
+  sv = s1 (sv, CONST2);
+  if (sv [1] != CONST2)
+    abort ();
+
+  sv = s21 (sv, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = s30 (sv, CONST1);
+  if (sv [2] != CONST1)
+    abort ();
+
+  sv = ms3 (&sv, CONST0);
+  if (sv [3] != CONST0)
+    abort ();
+
+  sv = ms1 (&sv, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = ms21 (&sv, CONST1);
+  if (sv [1] != CONST1)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [2] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = ci (sv, 2, CONST0);
+  if (sv [2] != CONST0)
+    abort ();
+
+  sv = ci (sv, 15, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = ci (sv, 28, CONST3);
+  if (sv [0] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 5, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = mci (&sv, 12, CONST2);
+  if (sv [0] != CONST2)
+    abort ();
+
+  sv = mci (&sv, 25, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 16, CONST1);
+  if (sv [0] != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr91275.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr91275.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr91275.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,26 @@
+/* Test that we generate vpmsumd correctly without a swap error.  */
+
+/* { dg-do run { target { p8vector_hw } } } */
+/* { dg-options "-O2 -std=gnu11" } */
+
+#include <altivec.h>
+
+int main() {
+
+  const unsigned long long r0l = 0x8e7dfceac070e3a0;
+  vector unsigned long long r0 = (vector unsigned long long) {r0l, 0}, v;
+  const vector unsigned long long pd
+    = (vector unsigned long long) {0xc2LLU << 56, 0};
+
+  v = __builtin_crypto_vpmsumd ((vector unsigned long long) {r0[0], 0}, pd);
+
+#if __LITTLE_ENDIAN__
+  if (v[0] != 0x4000000000000000 || v[1] != 0x65bd7ab605a4a8ff)
+    __builtin_abort ();
+#else
+  if (v[1] != 0x4000000000000000 || v[0] != 0x65bd7ab605a4a8ff)
+    __builtin_abort ();
+#endif
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr87496-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr87496-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr87496-3.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,9 @@
+/* PR target/87496 */
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-options "-O2 -mabi=ibmlongdouble -mlong-double-64 -Wno-psabi" } */
+
+int i;
+
+/* { dg-error "'-mabi=ibmlongdouble' requires '-mlong-double-128'" "PR87496" { target *-*-* } 0 } */
+/* { dg-warning "using IBM extended precision long double" "" { target *-*-* } 0 } */
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-19c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19c.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,122 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+#define CONST2		(3 * 31415926539LL)
+#define CONST3		(4 * 31415926539LL)
+#define CONST4		(5 * 31415926539LL)
+#define CONST5		(6 * 31415926539LL)
+#define CONST6		(7 * 31415926539LL)
+#define CONST7		(8 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned long long int
+e0 (vector unsigned long long int v, unsigned long long int x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector unsigned long long int
+e3 (vector unsigned long long int v, unsigned long long int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned long long int
+me0 (vector unsigned long long int *vp, unsigned long long int x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector unsigned long long int
+me3 (vector unsigned long long int *vp, unsigned long long int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned long long int
+ei (vector unsigned long long int v, int i, unsigned long long int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned long long int
+mei (vector unsigned long long int *vp, int i, unsigned long long int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned long long int dv = { CONST0, CONST1 };
+  unsigned long long int d;
+
+  dv = e0 (dv, CONST7);
+  if (dv [0] != CONST7)
+    abort ();
+
+  dv = e3 (dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = me0 (&dv, CONST4);
+  if (dv [0] != CONST4)
+    abort ();
+
+  dv = me3 (&dv, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = ei (dv, 0, CONST5);
+  if (dv [0] != CONST5)
+    abort ();
+
+  dv = ei (dv, 1, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = ei (dv, 2, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 3, CONST6);
+  if (dv [1] != CONST6)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 3, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-10a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+short s3 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 3);
+}
+
+short s7 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 7);
+}
+
+short s21 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 21);
+}
+
+short s30 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+short ms3 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 3);
+}
+
+short ms7 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 7);
+}
+
+short ms21 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 21);
+}
+
+short ms30 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+short ci (vector short v, int i)
+{
+  return __builtin_vec_ext_v8hi (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+short mci (vector short *vp, int i)
+{
+  return __builtin_vec_ext_v8hi (*vp, i);
+}
+
+
+int main (int argc, short *argv[]) {
+  vector short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  short s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s7 (sv);
+  if (s != CONST7)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST5)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms7 (&sv);
+  if (s != CONST7)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST5)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST7)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/builtins-3-p8.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/builtins-3-p8.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/builtins-3-p8.c	(.../branches/gcc-7-branch)
@@ -17,6 +17,34 @@
   return vec_pack (x, y);
 }
 
+vector unsigned char
+test_vsi_packs_vusi_vusi (vector unsigned short x,
+                          vector unsigned short y)
+{
+  return vec_packs (x, y);
+}
+
+vector signed char
+test_vsi_packs_vssi_vssi (vector signed short x,
+                          vector signed short y)
+{
+  return vec_packs (x, y);
+}
+
+vector signed short int
+test_vsi_packs_vsi_vsi (vector signed int x,
+			vector signed int y)
+{
+  return vec_packs (x, y);
+}
+
+vector unsigned short int
+test_vsi_packs_vui_vui (vector unsigned int x,
+			vector unsigned int y)
+{
+  return vec_packs (x, y);
+}
+
 vector long long
 test_nabs_long_long (vector long long x)
 {
@@ -37,6 +65,48 @@
   return vec_packs (x, y);
 }
 
+vector unsigned char
+test_vsi_packsu_vssi_vssi (vector signed short x,
+			   vector signed short y)
+{
+  return vec_packsu (x, y);
+}
+
+vector unsigned char
+test_vsi_packsu_vusi_vusi (vector unsigned short x,
+			   vector unsigned short y)
+{
+  return vec_packsu (x, y);
+}
+
+vector unsigned int
+test_vsi_packsu_vsll_vsll (vector signed long long x,
+			   vector signed long long y)
+{
+  return vec_packsu (x, y);
+}
+
+vector unsigned int
+test_vsi_packsu_vull_vull (vector unsigned long long x,
+			   vector unsigned long long y)
+{
+  return vec_packsu (x, y);
+}
+
+vector unsigned short int
+test_vsi_packsu_vsi_vsi (vector signed int x,
+			 vector signed int y)
+{
+  return vec_packsu (x, y);
+}
+
+vector unsigned short int
+test_vsi_packsu_vui_vui (vector unsigned int x,
+			 vector unsigned int y)
+{
+  return vec_packsu (x, y);
+}
+
 /* Expected test results:
 
      test_eq_long_long          1 vcmpequd inst
@@ -43,7 +113,9 @@
      test_pack_float            1 vpkudum inst
      test_nabs_long_long        1 vspltisw, 1 vsubudm, 1 vminsd
      test_vsi_packs_vsll_vsll   1 vpksdss
-     test_vui_packs_vull_vull   1 vpkudus */
+     test_vui_packs_vull_vull   1 vpkudus
+     test_vui_packs_vssi_vssi   1 vpkshss
+     test_vsi_packsu_vssi_vssi  1 vpkshus */
 
 /* { dg-final { scan-assembler-times "vcmpequd" 1 } } */
 /* { dg-final { scan-assembler-times "vpkudum"  1 } } */
@@ -51,4 +123,9 @@
 /* { dg-final { scan-assembler-times "vsubudm"  1 } } */
 /* { dg-final { scan-assembler-times "vminsd"   1 } } */
 /* { dg-final { scan-assembler-times "vpksdss"  1 } } */
-/* { dg-final { scan-assembler-times "vpkudus"  1 } } */  
+/* { dg-final { scan-assembler-times "vpkudus"  2 } } */  
+/* { dg-final { scan-assembler-times "vpkuhus"  2 } } */
+/* { dg-final { scan-assembler-times "vpkshss"  1 } } */
+/* { dg-final { scan-assembler-times "vpkshus"  1 } } */
+/* { dg-final { scan-assembler-times "vpksdus"  1 } } */
+/* { dg-final { scan-assembler-times "vpkuwus"  2 } } */
Index: gcc/testsuite/gcc.target/powerpc/pr80125.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr80125.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr80125.c	(.../branches/gcc-7-branch)
@@ -16,7 +16,7 @@
   vector int k = vec_mergel (i, j);
   vector int l = vec_sl (k, c);
   vector int m = vec_sl (l, d);
-  vector char o;
+  vector unsigned char o;
   vector int p = vec_perm (m, n, o);
   e = vec_sra (p, c);
   vec_st (e, 0, a);
Index: gcc/testsuite/gcc.target/powerpc/darn-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/darn-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/darn-3.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-O2 -mcpu=power9" } */
+
+static int darn32(void) { return __builtin_darn_32(); }
+
+int four(void)
+{
+	int sum = 0;
+	int i;
+	for (i = 0; i < 4; i++)
+		sum += darn32();
+	return sum;
+}
+
+/* { dg-final { scan-assembler-times {(?n)\mdarn .*,0\M} 4 } } */
Index: gcc/testsuite/gcc.target/powerpc/vsx-vector-6.h
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,167 @@
+/* This test code is included into vsx-vector-6-be.c and vsx-vector-6-le.c.  
+   The two files have the tests for the number of instructions generated for
+   LE versus BE.  */
+
+#include <altivec.h>
+
+void foo (vector double *out, vector double *in, vector long *p_l, vector bool long *p_b,
+	  vector unsigned char *p_uc, int *i, vector float *p_f,
+	  vector bool char *outbc, vector bool int *outbi,
+	  vector bool short *outbsi, vector int *outsi,
+	  vector unsigned int *outui, vector signed char *outsc,
+	  vector unsigned char *outuc)
+{
+  vector double in0 = in[0];
+  vector double in1 = in[1];
+  vector double in2 = in[2];
+  vector long inl = *p_l;
+  vector bool long inb = *p_b;
+  vector bool long long inbl0;
+  vector bool long long inbl1;
+  vector unsigned char uc = *p_uc;
+  vector float inf0;
+  vector float inf1;
+  vector float inf2;
+  vector char inc0;
+  vector char inc1;
+  vector bool char inbc0;
+  vector bool char inbc1;
+  vector bool short inbs0;
+  vector bool short inbs1;
+  vector bool int inbi0;
+  vector bool int inbi1;
+  vector signed short int inssi0, inssi1;
+  vector unsigned short int inusi0, inusi1;
+  vector signed int insi0, insi1;
+  vector unsigned int inui0, inui1;
+  vector unsigned char inuc0, inuc1;
+  
+  *out++ = vec_abs (in0);
+  *out++ = vec_add (in0, in1);
+  *out++ = vec_and (in0, in1);
+  *out++ = vec_and (in0, inb);
+  *out++ = vec_and (inb, in0);
+  *out++ = vec_andc (in0, in1);
+  *out++ = vec_andc (in0, inb);
+  *out++ = vec_andc (inb, in0);
+  *out++ = vec_andc (inbl0, in0);
+  *out++ = vec_andc (in0, inbl0);
+
+  *out++ = vec_ceil (in0);
+  *p_b++ = vec_cmpeq (in0, in1);
+  *p_b++ = vec_cmpgt (in0, in1);
+  *p_b++ = vec_cmpge (in0, in1);
+  *p_b++ = vec_cmplt (in0, in1);
+  *p_b++ = vec_cmple (in0, in1);
+  *out++ = vec_div (in0, in1);
+  *out++ = vec_floor (in0);
+  *out++ = vec_madd (in0, in1, in2);
+  *out++ = vec_msub (in0, in1, in2);
+  *out++ = vec_max (in0, in1);
+  *out++ = vec_min (in0, in1);
+  *out++ = vec_msub (in0, in1, in2);
+  *out++ = vec_mul (in0, in1);
+  *out++ = vec_nearbyint (in0);
+  *out++ = vec_nmadd (in0, in1, in2);
+  *out++ = vec_nmsub (in0, in1, in2);
+  *out++ = vec_nor (in0, in1);
+  *out++ = vec_or (in0, in1);
+  *out++ = vec_or (in0, inb);
+  *out++ = vec_or (inb, in0);
+  *out++ = vec_perm (in0, in1, uc);
+  *out++ = vec_rint (in0);
+  *out++ = vec_sel (in0, in1, inl);
+  *out++ = vec_sel (in0, in1, inb);
+  *out++ = vec_sub (in0, in1);
+  *out++ = vec_sqrt (in0);
+  *out++ = vec_trunc (in0);
+  *out++ = vec_xor (in0, in1);
+  *out++ = vec_xor (in0, inb);
+  *out++ = vec_xor (inb, in0);
+
+  *i++ = vec_all_eq (in0, in1);
+  *i++ = vec_all_ge (in0, in1);
+  *i++ = vec_all_gt (in0, in1);
+  *i++ = vec_all_le (in0, in1);
+  *i++ = vec_all_lt (in0, in1);
+  *i++ = vec_all_nan (in0);
+  *i++ = vec_all_ne (in0, in1);
+  *i++ = vec_all_nge (in0, in1);
+  *i++ = vec_all_ngt (in0, in1);
+  *i++ = vec_all_nle (in0, in1);
+  *i++ = vec_all_nlt (in0, in1);
+  *i++ = vec_all_numeric (in0);
+  *i++ = vec_any_eq (in0, in1);
+  *i++ = vec_any_ge (in0, in1);
+  *i++ = vec_any_gt (in0, in1);
+  *i++ = vec_any_le (in0, in1);
+  *i++ = vec_any_lt (in0, in1);
+  *i++ = vec_any_nan (in0);
+  *i++ = vec_any_ne (in0, in1);
+  *i++ = vec_any_nge (in0, in1);
+  *i++ = vec_any_ngt (in0, in1);
+  *i++ = vec_any_nle (in0, in1);
+  *i++ = vec_any_nlt (in0, in1);
+  *i++ = vec_any_numeric (in0);
+
+  *p_f++ = vec_msub (inf0, inf1, inf2);
+  *p_f++ = vec_nmsub (inf0, inf1, inf2);
+  *p_f++ = vec_nmadd (inf0, inf1, inf2);
+  *p_f++ = vec_or (inf0, inf1);
+  *p_f++ = vec_trunc (inf0);
+  
+  *out++ = vec_or (inbl0, in0);
+  *out++ = vec_or (in0, inbl0);
+
+  *out++ = vec_nor (in0, in1);
+
+  *outbc++ = vec_nor (inbc0, inbc1);
+  *outbc++ = vec_andc (inbc0, inbc1);
+  *outbc++ = vec_or (inbc0, inbc1);
+
+  *outuc++ = vec_max (inuc0, inuc1);
+
+  *outbi++ = vec_andc (inbi0, inbi1);
+  *outbsi++ = vec_andc (inbs0, inbs1);
+
+  *outbsi++ = vec_andc (inbs0, inbs1);
+
+  *outbi++ = vec_nor (inbi0, inbi1);
+  *outbi++ = vec_or (inbi0, inbi1);
+
+  *outbsi++ = vec_nor (inbs0, inbs1);
+  *outbsi++ = vec_or (inbs0, inbs1);
+
+  *outsi++ = vec_msums(inssi0, inssi1, insi0);
+  *outui++ = vec_msums(inusi0, inusi1, inui0);
+
+  *p_f++ = vec_nor (inf0, inf1);
+
+  *p_f++ = vec_andc (inf0, inf1);
+  *p_f++ = vec_andc (inbi0, inf0);
+  *p_f++ = vec_andc (inf0, inbi0);
+
+  *in++ = vec_andc (inbl0, in1);
+  *in++ = vec_andc (in0, inbl1);
+}
+
+int main()
+{
+  vector double *out;
+  vector double *in;
+  vector long *p_l;
+  vector bool long *p_b;
+  vector unsigned char *p_uc;
+  int *i;
+  vector float *p_f;
+  vector bool char *outbc;
+  vector bool int *outbi;
+  vector bool short *outbsi;
+  vector int *outsi;
+  vector unsigned int *outui;
+  vector signed char *outsc;
+  vector unsigned char *outuc;
+
+  foo (out, in, p_l, p_b, p_uc, i, p_f, outbc,
+       outbi, outbsi, outsi, outui, outsc, outuc);
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-19d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19d.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19d.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,122 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+#define CONST2		(3 * 31415926539LL)
+#define CONST3		(4 * 31415926539LL)
+#define CONST4		(5 * 31415926539LL)
+#define CONST5		(6 * 31415926539LL)
+#define CONST6		(7 * 31415926539LL)
+#define CONST7		(8 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned long long int
+e0 (vector unsigned long long int v, unsigned long long int x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector unsigned long long int
+e3 (vector unsigned long long int v, unsigned long long int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned long long int
+me0 (vector unsigned long long int *vp, unsigned long long int x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector unsigned long long int
+me3 (vector unsigned long long int *vp, unsigned long long int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned long long int
+ei (vector unsigned long long int v, int i, unsigned long long int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned long long int
+mei (vector unsigned long long int *vp, int i, unsigned long long int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned long long int dv = { CONST0, CONST1 };
+  unsigned long long int d;
+
+  dv = e0 (dv, CONST7);
+  if (dv [0] != CONST7)
+    abort ();
+
+  dv = e3 (dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = me0 (&dv, CONST4);
+  if (dv [0] != CONST4)
+    abort ();
+
+  dv = me3 (&dv, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = ei (dv, 0, CONST5);
+  if (dv [0] != CONST5)
+    abort ();
+
+  dv = ei (dv, 1, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = ei (dv, 2, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 3, CONST6);
+  if (dv [1] != CONST6)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 3, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-10b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+short s3 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 3);
+}
+
+short s7 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 7);
+}
+
+short s21 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 21);
+}
+
+short s30 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+short ms3 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 3);
+}
+
+short ms7 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 7);
+}
+
+short ms21 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 21);
+}
+
+short ms30 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+short ci (vector short v, int i)
+{
+  return __builtin_vec_ext_v8hi (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+short mci (vector short *vp, int i)
+{
+  return __builtin_vec_ext_v8hi (*vp, i);
+}
+
+
+int main (int argc, short *argv[]) {
+  vector short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  short s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s7 (sv);
+  if (s != CONST7)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST5)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms7 (&sv);
+  if (s != CONST7)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST5)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST7)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-11a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+int s3 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 3);
+}
+
+int s1 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 1);
+}
+
+int s21 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 21);
+}
+
+int s30 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+int ms3 (vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 3);
+}
+
+int ms1(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 1);
+}
+
+int ms21(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 21);
+}
+
+int ms30(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+int ci (vector int v, int i)
+{
+  return __builtin_vec_ext_v4si (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+int mci(vector int *vp, int i)
+{
+  return __builtin_vec_ext_v4si (*vp, i);
+}
+
+
+int main (int argc, int *argv[]) {
+  vector int sv = { CONST0, CONST1, CONST2, CONST3 };
+  int s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s1 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms1 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST3)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-9a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,164 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+signed char c0 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 0);
+}
+
+signed char c9 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 9);
+}
+
+signed char c21 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 21);
+}
+
+signed char c30 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+signed char mc0 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 0);
+}
+
+signed char mc9 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 9);
+}
+
+signed char mc21 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 21);
+}
+
+signed char mc30 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+signed char ci (vector signed char v, int i)
+{
+  return __builtin_vec_ext_v16qi (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+signed char mci(vector signed char *vp, int i) {
+  return __builtin_vec_ext_v16qi (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector signed char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  signed char c;
+
+  c = c0 (cv);
+  if (c != CONST0)
+    abort ();
+
+  c = c9 (cv);
+  if (c != CONST9)
+    abort ();
+
+  c = c21 (cv);
+  if (c != CONST5)
+    abort ();
+
+  c = c30 (cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = mc0 (&cv);
+  if (c != CONST0)
+    abort ();
+
+  c = mc9 (&cv);
+  if (c != CONST9)
+    abort ();
+
+  c = mc21 (&cv);
+  if (c != CONST5)
+    abort ();
+
+  c = mc30 (&cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = ci (cv, 8);
+  if (c != CONST8)
+    abort ();
+
+  c = ci (cv, 13);
+  if (c != CONSTD)
+    abort ();
+
+  c = ci (cv, 23);
+  if (c != CONST7)
+    abort ();
+
+  c = ci (cv, 31);
+  if (c != CONSTF)
+    abort ();
+
+  c = mci (&cv, 5);
+  if (c != CONST5)
+    abort ();
+
+  c = mci (&cv, 12);
+  if (c != CONSTC)
+    abort ();
+
+  c = mci (&cv, 25);
+  if (c != CONST9)
+    abort ();
+
+  c = mci (&cv, 16);
+  if (c != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-20a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+/* Define this after PR89424 is addressed.  */
+#define PR89424
+
+extern void abort (void);
+
+#define CONST0		(((unsigned __int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned __int128 e0 (vector unsigned __int128 v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned __int128 e3 (vector unsigned __int128 v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+unsigned __int128 me0 (vector unsigned __int128 *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned __int128 me3 (vector unsigned __int128 *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+#ifdef PR89424
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned __int128 ei (vector unsigned __int128 v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+unsigned __int128 mei (vector unsigned __int128 *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+#endif
+
+int main (int argc, char *argv[]) {
+  vector unsigned __int128 dv = { CONST0 };
+  unsigned __int128 d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST0)
+    abort ();
+
+#ifdef PR89424
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+#endif
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-10c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10c.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector short s3 (vector short v, short x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector short s7 (vector short v, short x)
+{
+  return vec_insert (x, v, 7);
+}
+
+vector short s21 (vector short v, short x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector short s30 (vector short v, short x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector short ms3 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector short ms7 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 7);
+}
+
+vector short ms21 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector short ms30 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector short ci (vector short v, int i, short x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector short mci (vector short *vp, int i, short x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, short *argv[]) {
+  vector short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  short s;
+
+  sv = s3 (sv, CONST6);
+  if (sv [3] != CONST6)
+    abort ();
+
+  sv = s7 (sv, CONST4);
+  if (sv [7] != CONST4)
+    abort ();
+
+  sv = s21 (sv, CONST3);
+  if (sv [5] != CONST3)
+    abort ();
+
+  sv = s30 (sv, CONST2);
+  if (sv [6] != CONST2)
+    abort ();
+
+  sv = ms3 (&sv, CONST5);
+  if (sv [3] != CONST5)
+    abort ();
+
+  sv = ms7 (&sv, CONST1);
+  if (sv [7] != CONST1)
+    abort ();
+
+  sv = ms21 (&sv, CONST2);
+  if (sv [5] != CONST2)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [6] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST6);
+  if (sv [5] != CONST6)
+    abort ();
+
+  sv = ci (sv, 2, CONST4);
+  if (sv [2] != CONST4)
+    abort ();
+
+  sv = ci (sv, 15, CONST3);
+  if (sv [7] != CONST3)
+    abort ();
+
+  sv = ci (sv, 28, CONST3);
+  if (sv [4] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 5, CONST3);
+  if (sv [5] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 12, CONST7);
+  if (sv [4] != CONST7)
+    abort ();
+
+  sv = mci (&sv, 25, CONST6);
+  if (sv [1] != CONST6)
+    abort ();
+
+  sv = mci (&sv, 16, CONST5);
+  if (sv [0] != CONST5)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/altivec_vld_vst_addr-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/altivec_vld_vst_addr-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/altivec_vld_vst_addr-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,184 @@
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-maltivec" } */
+
+/* Test vec_ld and vec_st can support both scalar and vector
+   type address points, the list is:
+     - address of unsigned char/short/int
+     - address of signed char/short/int
+     - address of float
+     - address of vector unsigned char/short/int
+     - address of vector signed char/short/int
+     - address of vector float */
+#include <altivec.h>
+
+/* Test vec_ld can allow scalar and vector type address. */
+vector unsigned char
+test_vld_scalar_uc (const unsigned char *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector unsigned short
+test_vld_scalar_us (const unsigned short *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector unsigned int
+test_vld_scalar_ui (const unsigned int *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector signed char
+test_vld_scalar_sc (const signed char *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector signed short
+test_vld_scalar_ss (const signed short *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector signed int
+test_vld_scalar_si (const signed int *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector float
+test_vld_scalar_f (const float *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector unsigned char
+test_vld_vector_uc (const vector unsigned char *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector unsigned short
+test_vld_vector_us (const vector unsigned short *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector unsigned int
+test_vld_vector_ui (const vector unsigned int *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector signed char
+test_vld_vector_sc (const vector signed char *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector signed short
+test_vld_vector_ss (const vector signed short *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector signed int
+test_vld_vector_si (const vector signed int *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector float
+test_vld_vector_f (const vector float *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+/* Test vec_st can allow scalar and vector type address. */
+
+void
+test_vst_scalar_uc (vector unsigned char v, unsigned char *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_scalar_us (vector unsigned short v, unsigned short *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_scalar_ui (vector unsigned int v, unsigned int *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_scalar_sc (vector signed char v, signed char *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_scalar_ss (vector signed short v, signed short *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_scalar_si (vector signed int v, signed int *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_scalar_f (vector float v, float *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_uc (vector unsigned char v, vector unsigned char *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_us (vector unsigned short v, vector unsigned short *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_ui (vector unsigned int v, vector unsigned int *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_sc (vector signed char v, vector signed char *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_ss (vector signed short v, vector signed short *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_si (vector signed int v, vector signed int *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_f (vector float v, vector float *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
Index: gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c	(.../branches/gcc-7-branch)
@@ -4,6 +4,7 @@
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
 /* { dg-options "-mcpu=power8 -O2 -ftree-vectorize -fvect-cost-model=dynamic -fno-unroll-loops -fno-unroll-all-loops" } */
 
+#include <altivec.h>
 typedef vector unsigned long long	crypto_t;
 typedef vector unsigned long long	v2di_t;
 typedef vector unsigned int		v4si_t;
@@ -10,31 +11,56 @@
 typedef vector unsigned short		v8hi_t;
 typedef vector unsigned char		v16qi_t;
 
-crypto_t crpyto1 (crypto_t a)
+crypto_t crypto1 (crypto_t a)
 {
   return __builtin_crypto_vsbox (a);
 }
 
+v16qi_t crypto1_be (v16qi_t a)
+{
+  return vec_sbox_be (a);
+}
+
 crypto_t crypto2 (crypto_t a, crypto_t b)
 {
   return __builtin_crypto_vcipher (a, b);
 }
 
+v16qi_t crypto2_be (v16qi_t a, v16qi_t b)
+{
+  return vec_cipher_be (a, b);
+}
+
 crypto_t crypto3 (crypto_t a, crypto_t b)
 {
   return __builtin_crypto_vcipherlast (a, b);
 }
 
+v16qi_t crypto3_be (v16qi_t a, v16qi_t b)
+{
+  return vec_cipherlast_be (a, b);
+}
+
 crypto_t crypto4 (crypto_t a, crypto_t b)
 {
   return __builtin_crypto_vncipher (a, b);
 }
 
+v16qi_t crypto4_be (v16qi_t a, v16qi_t b)
+{
+  return vec_ncipher_be (a, b);
+}
+
 crypto_t crypto5 (crypto_t a, crypto_t b)
 {
   return __builtin_crypto_vncipherlast (a, b);
 }
 
+v16qi_t crypto5_be (v16qi_t a, v16qi_t b)
+{
+  return vec_ncipherlast_be (a, b);
+}
+
 v16qi_t crypto6a (v16qi_t a, v16qi_t b, v16qi_t c)
 {
   return __builtin_crypto_vpermxor (a, b, c);
@@ -117,15 +143,15 @@
 
 /* Note space is used after the instruction so that vcipherlast does not match
    vcipher.  */
-/* { dg-final { scan-assembler-times "vcipher "      1 } } */
-/* { dg-final { scan-assembler-times "vcipherlast "  1 } } */
-/* { dg-final { scan-assembler-times "vncipher "     1 } } */
-/* { dg-final { scan-assembler-times "vncipherlast " 1 } } */
+/* { dg-final { scan-assembler-times "vcipher "      2 } } */
+/* { dg-final { scan-assembler-times "vcipherlast "  2 } } */
+/* { dg-final { scan-assembler-times "vncipher "     2 } } */
+/* { dg-final { scan-assembler-times "vncipherlast " 2 } } */
 /* { dg-final { scan-assembler-times "vpermxor "     4 } } */
 /* { dg-final { scan-assembler-times "vpmsumb "      2 } } */
 /* { dg-final { scan-assembler-times "vpmsumd "      2 } } */
 /* { dg-final { scan-assembler-times "vpmsumh "      2 } } */
 /* { dg-final { scan-assembler-times "vpmsumw "      2 } } */
-/* { dg-final { scan-assembler-times "vsbox "        1 } } */
+/* { dg-final { scan-assembler-times "vsbox "        2 } } */
 /* { dg-final { scan-assembler-times "vshasigmad "   2 } } */
 /* { dg-final { scan-assembler-times "vshasigmaw "   2 } } */
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-11b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+int s3 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 3);
+}
+
+int s1 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 1);
+}
+
+int s21 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 21);
+}
+
+int s30 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+int ms3 (vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 3);
+}
+
+int ms1(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 1);
+}
+
+int ms21(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 21);
+}
+
+int ms30(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+int ci (vector int v, int i)
+{
+  return __builtin_vec_ext_v4si (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+int mci(vector int *vp, int i)
+{
+  return __builtin_vec_ext_v4si (*vp, i);
+}
+
+
+int main (int argc, int *argv[]) {
+  vector int sv = { CONST0, CONST1, CONST2, CONST3 };
+  int s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s1 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms1 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST3)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/builtins-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/builtins-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/builtins-2.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do run { target { powerpc64le-*-* } } } */
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-require-effective-target vsx_hw } */
 /* { dg-options "-mcpu=power8 " } */
 
 #include <altivec.h>
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-uint128-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-uint128-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-uint128-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,27 @@
+/* Test to verify that the vec_extract from a vector of
+   unsigned __int128s remains unsigned.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(unsigned __int128 ul) {
+
+  vector unsigned __int128 v = vec_splats(ul);
+
+  if (vec_extract (v, 0) < ul)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (((__int128) 0xf600000000000000LL) << 64);
+  test1 (((__int128) 0x7600000000000000LL) << 64);
+  test1 (((__int128) 0x0600000000000000LL) << 64);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-9b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,164 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+signed char c0 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 0);
+}
+
+signed char c9 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 9);
+}
+
+signed char c21 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 21);
+}
+
+signed char c30 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+signed char mc0 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 0);
+}
+
+signed char mc9 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 9);
+}
+
+signed char mc21 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 21);
+}
+
+signed char mc30 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+signed char ci (vector signed char v, int i)
+{
+  return __builtin_vec_ext_v16qi (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+signed char mci(vector signed char *vp, int i) {
+  return __builtin_vec_ext_v16qi (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector signed char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  signed char c;
+
+  c = c0 (cv);
+  if (c != CONST0)
+    abort ();
+
+  c = c9 (cv);
+  if (c != CONST9)
+    abort ();
+
+  c = c21 (cv);
+  if (c != CONST5)
+    abort ();
+
+  c = c30 (cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = mc0 (&cv);
+  if (c != CONST0)
+    abort ();
+
+  c = mc9 (&cv);
+  if (c != CONST9)
+    abort ();
+
+  c = mc21 (&cv);
+  if (c != CONST5)
+    abort ();
+
+  c = mc30 (&cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = ci (cv, 8);
+  if (c != CONST8)
+    abort ();
+
+  c = ci (cv, 13);
+  if (c != CONSTD)
+    abort ();
+
+  c = ci (cv, 23);
+  if (c != CONST7)
+    abort ();
+
+  c = ci (cv, 31);
+  if (c != CONSTF)
+    abort ();
+
+  c = mci (&cv, 5);
+  if (c != CONST5)
+    abort ();
+
+  c = mci (&cv, 12);
+  if (c != CONSTC)
+    abort ();
+
+  c = mci (&cv, 25);
+  if (c != CONST9)
+    abort ();
+
+  c = mci (&cv, 16);
+  if (c != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-20b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+/* Define this after PR89424 is addressed.  */
+#define PR89424
+
+extern void abort (void);
+
+#define CONST0		(((unsigned __int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned __int128 e0 (vector unsigned __int128 v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned __int128 e3 (vector unsigned __int128 v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+unsigned __int128 me0 (vector unsigned __int128 *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned __int128 me3 (vector unsigned __int128 *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+#ifdef PR89424
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned __int128 ei (vector unsigned __int128 v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+unsigned __int128 mei (vector unsigned __int128 *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+#endif
+
+int main (int argc, char *argv[]) {
+  vector unsigned __int128 dv = { CONST0 };
+  unsigned __int128 d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST0)
+    abort ();
+
+#ifdef PR89424
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+#endif
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-12a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,109 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+long long int e0 (vector long long int v)
+{
+  return __builtin_vec_ext_v2di (v, 0);
+}
+
+long long int e3 (vector long long int v)
+{
+  return __builtin_vec_ext_v2di (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+long long int me0 (vector long long int *vp)
+{
+  return __builtin_vec_ext_v2di (*vp, 0);
+}
+
+long long int me3 (vector long long int *vp)
+{
+  return __builtin_vec_ext_v2di (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+long long int ei (vector long long int v, int i)
+{
+  return __builtin_vec_ext_v2di (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+long long int mei (vector long long int *vp, int i)
+{
+  return __builtin_vec_ext_v2di (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector long long int dv = { CONST0, CONST1 };
+  long long int d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-10d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10d.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10d.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector short s3 (vector short v, short x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector short s7 (vector short v, short x)
+{
+  return vec_insert (x, v, 7);
+}
+
+vector short s21 (vector short v, short x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector short s30 (vector short v, short x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector short ms3 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector short ms7 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 7);
+}
+
+vector short ms21 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector short ms30 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector short ci (vector short v, int i, short x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector short mci (vector short *vp, int i, short x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, short *argv[]) {
+  vector short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  short s;
+
+  sv = s3 (sv, CONST6);
+  if (sv [3] != CONST6)
+    abort ();
+
+  sv = s7 (sv, CONST4);
+  if (sv [7] != CONST4)
+    abort ();
+
+  sv = s21 (sv, CONST3);
+  if (sv [5] != CONST3)
+    abort ();
+
+  sv = s30 (sv, CONST2);
+  if (sv [6] != CONST2)
+    abort ();
+
+  sv = ms3 (&sv, CONST5);
+  if (sv [3] != CONST5)
+    abort ();
+
+  sv = ms7 (&sv, CONST1);
+  if (sv [7] != CONST1)
+    abort ();
+
+  sv = ms21 (&sv, CONST2);
+  if (sv [5] != CONST2)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [6] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST6);
+  if (sv [5] != CONST6)
+    abort ();
+
+  sv = ci (sv, 2, CONST4);
+  if (sv [2] != CONST4)
+    abort ();
+
+  sv = ci (sv, 15, CONST3);
+  if (sv [7] != CONST3)
+    abort ();
+
+  sv = ci (sv, 28, CONST3);
+  if (sv [4] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 5, CONST3);
+  if (sv [5] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 12, CONST7);
+  if (sv [4] != CONST7)
+    abort ();
+
+  sv = mci (&sv, 25, CONST6);
+  if (sv [1] != CONST6)
+    abort ();
+
+  sv = mci (&sv, 16, CONST5);
+  if (sv [0] != CONST5)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/altivec_vld_vst_addr-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/altivec_vld_vst_addr-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/altivec_vld_vst_addr-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,92 @@
+/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-options "-mvsx" } */
+
+/* Note that vector long long and vector double type require vsx support. */
+
+/* Test vec_ld and vec_st can support both scalar and vector
+   type address points, the list is:
+     - address of unsigned long long
+     - address of signed long long
+     - address of double
+     - address of vector unsigned long long
+     - address of vector signed long long
+     - address of vector double */
+#include <altivec.h>
+
+/* Test vec_ld can allow scalar and vector type address. */
+
+vector unsigned long long
+test_vld_scalar_ul (const unsigned long long *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector signed long long
+test_vld_scalar_sl (const signed long long *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector double
+test_vld_scalar_d (const double *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector unsigned long long
+test_vld_vector_ul (const vector unsigned long long *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector signed long long
+test_vld_vector_sl (const vector signed long long *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector double
+test_vld_vector_d (const vector double *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+/* Test vec_st can allow scalar and vector type address. */
+
+void
+test_vst_scalar_ul (vector unsigned long long v, unsigned long long *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_scalar_sl (vector signed long long v, signed long long *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_scalar_d (vector double v, double *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_ul (vector unsigned long long v,
+		    vector unsigned long long *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_sl (vector signed long long v, vector signed long long *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_d (vector double v, vector double *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
Index: gcc/testsuite/gcc.target/powerpc/pr64205.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr64205.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr64205.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
-/* { dg-skip-if "" { powerpc*-*-aix* } { "*" } { "" } } */
+/* { dg-require-effective-target dfp } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=G5" } } */
 /* { dg-options "-O2 -mcpu=G5 -maltivec" } */
 
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-slong-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-slong-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-slong-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,27 @@
+/* Test to verify that the vec_extract from a vector of
+   signed longs remains signed.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(signed long long int sl) {
+
+  vector signed long long int v = vec_splats(sl);
+
+  if (vec_extract (v, 0) > sl)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (0xf600000000000000LL);
+  test1 (0x7600000000000000LL);
+  test1 (0x0600000000000000LL);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-ushort-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-ushort-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-ushort-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,29 @@
+/* Test to verify that the vec_extract from a vector of
+   signed shorts remains signed.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(unsigned short us) {
+  int use;
+
+  vector unsigned short v = vec_splats(us);
+  use = vec_extract(v,0);
+
+  if (use != us)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (0xf600);
+  test1 (0x7600);
+  test1 (0x0600);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-11c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11c.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector int s3 (vector int v, int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector int s1 (vector int v, int x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector int s21 (vector int v, int x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector int s30 (vector int v, int x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector int ms3  (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector int ms1 (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector int ms21 (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector int ms30 (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector int ci (vector int v, int i, int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector int mci(vector int *vp, int i, int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, int *argv[]) {
+  vector int sv = { CONST0, CONST1, CONST2, CONST3 };
+  int s;
+
+  sv = s3 (sv, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = s1 (sv, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = s21 (sv, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = s30 (sv, CONST1);
+  if (sv [2] != CONST1)
+    abort ();
+
+  sv = ms3 (&sv, CONST2);
+  if (sv [3] != CONST2)
+    abort ();
+
+  sv = ms1 (&sv, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = ms21 (&sv, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [2] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = ci (sv, 2, CONST3);
+  if (sv [2] != CONST3)
+    abort ();
+
+  sv = ci (sv, 15, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = ci (sv, 28, CONST3);
+  if (sv [0] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 5, CONST2);
+  if (sv [1] != CONST2)
+    abort ();
+
+  sv = mci (&sv, 12, CONST1);
+  if (sv [0] != CONST1)
+    abort ();
+
+  sv = mci (&sv, 25, CONST2);
+  if (sv [1] != CONST2)
+    abort ();
+
+  sv = mci (&sv, 16, CONST3);
+  if (sv [0] != CONST3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/builtins-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/builtins-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/builtins-3.c	(.../branches/gcc-7-branch)
@@ -59,6 +59,170 @@
 	return vec_nabs (x);
 }
 
+vector signed char
+test_sll_vsc_vsc_vsuc (vector signed char x, vector unsigned char y)
+{
+	return vec_sll (x, y);
+}
+
+vector unsigned char
+test_sll_vuc_vuc_vuc (vector unsigned char x, vector unsigned char y)
+{
+	return vec_sll (x, y);
+}
+
+vector signed int
+test_sll_vsi_vsi_vuc (vector signed int x, vector unsigned char y)
+{
+	return vec_sll (x, y);
+}
+
+vector unsigned int
+test_sll_vui_vui_vuc (vector unsigned int x, vector unsigned char y)
+{
+	return vec_sll (x, y);
+}
+
+vector bool long long
+test_sll_vbll_vbll_vuc (vector bool long long x,
+			vector unsigned char y)
+{
+	return vec_sll (x, y);
+}
+
+vector bool long long
+test_sll_vbll_vbll_vull (vector bool long long x,
+			vector unsigned long long y)
+{
+	return vec_sll (x, y);
+}
+
+vector bool long long
+test_sll_vbll_vbll_vus (vector bool long long x,
+			vector unsigned short y)
+{
+	return vec_sll (x, y);
+}
+vector pixel
+test_sll_vp_vp_vuc (vector pixel x, vector unsigned char y)
+{
+	return vec_sll (x, y);
+}
+
+vector signed short int
+test_sll_vssi_vssi_vuc (vector signed short x, vector unsigned char y)
+{
+	return vec_sll (x, y);
+}
+
+vector unsigned short int
+test_sll_vusi_vusi_vuc (vector unsigned short x, vector unsigned char y)
+{
+	return vec_sll (x, y);
+}
+
+vector signed char
+test_slo_vsc_vsc_vsc (vector signed char x, vector signed char y)
+{
+	return vec_slo (x, y);
+}
+
+vector signed char
+test_slo_vsc_vsc_vuc (vector signed char x, vector unsigned char y)
+{
+	return vec_slo (x, y);
+}
+
+vector unsigned char
+test_slo_vuc_vuc_vsc (vector unsigned char x, vector signed char y)
+{
+	return vec_slo (x, y);
+}
+
+vector unsigned char
+test_slo_vuc_vuc_vuc (vector unsigned char x, vector unsigned char y)
+{
+	return vec_slo (x, y);
+}
+
+vector signed int
+test_slo_vsi_vsi_vsc (vector signed int x, vector signed char y)
+{
+	return vec_slo (x, y);
+}
+
+vector signed int
+test_slo_vsi_vsi_vuc (vector signed int x, vector unsigned char y)
+{
+	return vec_slo (x, y);
+}
+
+vector unsigned int
+test_slo_vui_vui_vsc (vector unsigned int x, vector signed char y)
+{
+	return vec_slo (x, y);
+}
+
+vector unsigned int
+test_slo_vui_vui_vuc (vector unsigned int x, vector unsigned char y)
+{
+	return vec_slo (x, y);
+}
+
+vector pixel
+test_slo_vp_vp_vsc (vector pixel int x, vector signed char y)
+{
+	return vec_slo (x, y);
+}
+
+vector pixel
+test_slo_vp_vp_vuc (vector pixel int x, vector unsigned char y)
+{
+	return vec_slo (x, y);
+}
+
+vector signed short int
+test_slo_vssi_vssi_vsc (vector signed short int x, vector signed char y)
+{
+	return vec_slo (x, y);
+}
+
+vector signed short int
+test_slo_vssi_vssi_vuc (vector signed short int x, vector unsigned char y)
+{
+	return vec_slo (x, y);
+}
+
+vector unsigned short int
+test_slo_vusi_vusi_vsc (vector unsigned short int x, vector signed char y)
+{
+	return vec_slo (x, y);
+}
+
+vector unsigned short int
+test_slo_vusi_vusi_vuc (vector unsigned short int x, vector unsigned char y)
+{
+	return vec_slo (x, y);
+}
+
+vector float
+test_slo_vf_vf_vsc (vector float x, vector signed char y)
+{
+	return vec_slo (x, y);
+}
+
+vector float
+test_slo_vf_vf_vuc (vector float x, vector unsigned char y)
+ {
+ 	return vec_slo (x, y);
+ }
+
+vector int
+test_cmpb_float (vector float x, vector float y)
+{
+	return vec_cmpb (x, y);
+}
+
 /* Expected test results:
 
      test_eq_char              1 vcmpequb inst
@@ -69,7 +233,8 @@
      test_nabs_short           1 vspltisw, 1 vsubuhm, 1 vminsh
      test_nabs_int             1 vspltisw, 1 vsubuwm, 1 vminsw
      test_nabs_float           1 xvnabssp
-     test_nabs_double          1 xvnabsdp */
+     test_nabs_double          1 xvnabsdp
+     test_cmpb_float           1 vcmpbfp */
 
 /* { dg-final { scan-assembler-times "vcmpequb" 1 } } */
 /* { dg-final { scan-assembler-times "vcmpequh" 1 } } */
@@ -84,4 +249,5 @@
 /* { dg-final { scan-assembler-times "vspltisw" 3 } } */
 /* { dg-final { scan-assembler-times "xvnabssp" 1 } } */
 /* { dg-final { scan-assembler-times "xvnabsdp" 1 } } */
+/* { dg-final { scan-assembler-times "vcmpbfp"  1 } } */
 
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-9c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9c.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,164 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector signed char c0 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector signed char c9 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 9);
+}
+
+vector signed char c21 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector signed char c30 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector signed char mc0 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector signed char mc9 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 9);
+}
+
+vector signed char mc21 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector signed char mc30 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector signed char ci (vector signed char v, int i, signed char x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector signed char mci(vector signed char *vp, int i, signed char x) {
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector signed char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  signed char c;
+
+  cv = c0 (cv, CONSTF);
+  if (cv [0] != CONSTF)
+    abort ();
+
+  cv = c9 (cv, CONST7);
+  if (cv [9] != CONST7)
+    abort ();
+
+  cv = c21 (cv, CONSTA);
+  if (cv [5] != CONSTA)
+    abort ();
+
+  cv = c30 (cv, CONSTC);
+  if (cv [14] != CONSTC)
+    abort ();
+
+  cv = mc0 (&cv, CONSTB);
+  if (cv [0] != CONSTB)
+    abort ();
+
+  cv = mc9 (&cv, CONST1);
+  if (cv [9] != CONST1)
+    abort ();
+
+  cv = mc21 (&cv, CONST7);
+  if (cv [5] != CONST7)
+    abort ();
+
+  cv = mc30 (&cv, CONST2);
+  if (cv [14] != CONST2)
+    abort ();
+
+  cv = ci (cv, 8, CONST4);
+  if (cv [8] != CONST4)
+    abort ();
+
+  cv = ci (cv, 13, CONSTB);
+  if (cv [13] != CONSTB)
+    abort ();
+
+  cv = ci (cv, 23, CONST3);
+  if (cv [7] != CONST3)
+    abort ();
+
+  cv = ci (cv, 31, CONST2);
+  if (cv [15] != CONST2)
+    abort ();
+
+  cv = mci (&cv, 5, CONST1);
+  if (cv [5] != CONST1)
+    abort ();
+
+  cv = mci (&cv, 12, CONST3);
+  if (cv [12] != CONST3)
+    abort ();
+
+  cv = mci (&cv, 25, CONST5);
+  if (cv [9] != CONST5)
+    abort ();
+
+  cv = mci (&cv, 16, CONSTD);
+  if (cv [0] != CONSTD)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-uint-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-uint-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-uint-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,29 @@
+/* Test to verify that the vec_extract from a vector of
+   unsigned ints remains unsigned.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(unsigned int ui) {
+  long long int uie;
+
+  vector unsigned int v = vec_splats(ui);
+  uie = vec_extract(v,0);
+
+  if (uie != ui)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (0xf6000000);
+  test1 (0x76000000);
+  test1 (0x06000000);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-20c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20c.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(((unsigned __int128) 31415926539) << 60)
+#define CONST1		(((unsigned __int128) 31415926539) << 54)
+#define CONST2		(((unsigned __int128) 31415926539) << 48)
+#define CONST3		(((unsigned __int128) 31415926539) << 32)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned __int128 e0 (vector unsigned __int128 v, unsigned __int128 x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector unsigned __int128 e3 (vector unsigned __int128 v, unsigned __int128 x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned __int128
+me0 (vector unsigned __int128 *vp, unsigned __int128 x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector unsigned __int128
+me3 (vector unsigned __int128 *vp, unsigned __int128 x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned __int128
+ei (vector unsigned __int128 v, int i, unsigned __int128 x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned __int128
+mei (vector unsigned __int128 *vp, int i, unsigned __int128 x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned __int128 dv = { CONST0 };
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e3 (dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me0 (&dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me3 (&dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 0, CONST0);
+  if (dv [0] != CONST0)
+    abort ();
+
+  dv = ei (dv, 1, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 2, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = ei (dv, 3, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 0, CONST0);
+  if (dv [0] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 1, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 2, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 3, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-12b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,109 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+long long int e0 (vector long long int v)
+{
+  return __builtin_vec_ext_v2di (v, 0);
+}
+
+long long int e3 (vector long long int v)
+{
+  return __builtin_vec_ext_v2di (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+long long int me0 (vector long long int *vp)
+{
+  return __builtin_vec_ext_v2di (*vp, 0);
+}
+
+long long int me3 (vector long long int *vp)
+{
+  return __builtin_vec_ext_v2di (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+long long int ei (vector long long int v, int i)
+{
+  return __builtin_vec_ext_v2di (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+long long int mei (vector long long int *vp, int i)
+{
+  return __builtin_vec_ext_v2di (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector long long int dv = { CONST0, CONST1 };
+  long long int d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-schar-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-schar-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-schar-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,29 @@
+/* Test to verify that the vec_extract from a vector of
+   signed chars remains signed.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(signed char sc) {
+  int sce;
+
+  vector signed char v = vec_splats(sc);
+  sce = vec_extract(v,0);
+
+  if (sce != sc)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (0xf6);
+  test1 (0x76);
+  test1 (0x06);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-7.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-7.c	(.../branches/gcc-7-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-skip-if "not implemented for Darwin" { powerpc*-*-darwin* } } */
 /* { dg-additional-options "-mno-speculate-indirect-jumps" } */
 /* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-13a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,124 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+/* Define this after PR89424 is addressed.  */
+#define PR89424
+
+/* Define this after PR89626 is addressed.  */
+#undef PR89626
+
+#ifdef PR89626
+#define SIGNED
+#else
+#define SIGNED signed
+#endif
+
+extern void abort (void);
+
+#define CONST0		(((SIGNED __int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+SIGNED __int128 e0 (vector SIGNED __int128 v)
+{
+  return __builtin_vec_ext_v1ti (v, 0);
+}
+
+SIGNED __int128 e3 (vector SIGNED __int128 v)
+{
+  return __builtin_vec_ext_v1ti (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+SIGNED __int128 me0 (vector SIGNED __int128 *vp)
+{
+  return __builtin_vec_ext_v1ti (*vp, 0);
+}
+
+SIGNED __int128 me3 (vector SIGNED __int128 *vp)
+{
+  return __builtin_vec_ext_v1ti (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+#ifdef PR89424
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+SIGNED __int128 ei (vector SIGNED __int128 v, int i)
+{
+  return __builtin_vec_ext_v1ti (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+SIGNED __int128 mei (vector SIGNED __int128 *vp, int i)
+{
+  return __builtin_vec_ext_v1ti (*vp, i);
+}
+#endif
+
+int main (int argc, char *argv[]) {
+  vector SIGNED __int128 dv = { CONST0 };
+  SIGNED __int128 d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST0)
+    abort ();
+
+#ifdef PR89424
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+#endif
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-11d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11d.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11d.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector int s3 (vector int v, int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector int s1 (vector int v, int x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector int s21 (vector int v, int x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector int s30 (vector int v, int x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector int ms3  (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector int ms1 (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector int ms21 (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector int ms30 (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector int ci (vector int v, int i, int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector int mci(vector int *vp, int i, int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, int *argv[]) {
+  vector int sv = { CONST0, CONST1, CONST2, CONST3 };
+  int s;
+
+  sv = s3 (sv, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = s1 (sv, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = s21 (sv, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = s30 (sv, CONST1);
+  if (sv [2] != CONST1)
+    abort ();
+
+  sv = ms3 (&sv, CONST2);
+  if (sv [3] != CONST2)
+    abort ();
+
+  sv = ms1 (&sv, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = ms21 (&sv, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [2] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = ci (sv, 2, CONST3);
+  if (sv [2] != CONST3)
+    abort ();
+
+  sv = ci (sv, 15, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = ci (sv, 28, CONST3);
+  if (sv [0] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 5, CONST2);
+  if (sv [1] != CONST2)
+    abort ();
+
+  sv = mci (&sv, 12, CONST1);
+  if (sv [0] != CONST1)
+    abort ();
+
+  sv = mci (&sv, 25, CONST2);
+  if (sv [1] != CONST2)
+    abort ();
+
+  sv = mci (&sv, 16, CONST3);
+  if (sv [0] != CONST3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p7.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p7.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,42 @@
+/* { dg-do compile { target { lp64 && be } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-options "-mvsx -O2 -mcpu=power7 -dp" } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
+
+/* Expected instruction counts for Power 7 */
+
+/* { dg-final { scan-assembler-times "xvabsdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvadddp" 1 } } */
+/* { dg-final { scan-assembler-times "xxlnor" 5 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpeqdp\s} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpeqdp\.\s} 5 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgtdp\s} 2 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgtdp\.\s} 5 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgedp\s} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgedp\.\s} 6 } } */
+/* { dg-final { scan-assembler-times "xvrdpim" 1 } } */
+/* { dg-final { scan-assembler-times "xvmaddadp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmsubadp" 1 } } */
+/* { dg-final { scan-assembler-times "xvsubdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmaxdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmindp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmuldp" 1 } } */
+/* { dg-final { scan-assembler-times "vperm" 2 } } */
+/* { dg-final { scan-assembler-times "xvrdpic" 2 } } */
+/* { dg-final { scan-assembler-times "xvsqrtdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvrdpiz" 1 } } */
+/* { dg-final { scan-assembler-times "xvmsubasp" 1 } } */
+/* { dg-final { scan-assembler-times "xvnmaddasp" 1 } } */
+/* { dg-final { scan-assembler-times "xvnmaddadp" 1 } } */
+/* { dg-final { scan-assembler-times "xvnmsubadp" 1 } } */
+/* { dg-final { scan-assembler-times "vmsumshs" 2 } } */
+/* { dg-final { scan-assembler-times "xxland" 13 } } */
+/* { dg-final { scan-assembler-times "xxlxor" 2 } } */
+/* { dg-final { scan-assembler-times "xxsel" 4 } } */
+/* { dg-final { scan-assembler-times "xvrdpip" 1 } } */
+/* { dg-final { scan-assembler-times "xvdivdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvrdpi" 7 } } */
+
+/* Source code for the test in vsx-vector-6.h */
+#include "vsx-vector-6.h"
Index: gcc/testsuite/gcc.target/powerpc/pr71785.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr71785.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr71785.c	(.../branches/gcc-7-branch)
@@ -1,6 +1,11 @@
 /* { dg-do compile { target { powerpc*-*-* } } } */
 /* { dg-options "-O2" } */
-/* { dg-final { scan-assembler-not {\mb\M} } } */
+/* We have to lose the default pic codegen on Darwin.  */
+/* { dg-additional-options "-mdynamic-no-pic" { target powerpc*-*-darwin* } } */
+/* ... and account for the out-of-line GPR restore.  */
+/* { dg-final { scan-assembler-times {\mb[ \t]*restGPR} 1 { target powerpc*-*-darwin* } } } */
+/* { dg-final { scan-assembler-not {\mb[ \t]L} { target powerpc*-*-darwin* } } } */
+/* { dg-final { scan-assembler-not {\mb\M} { target { ! powerpc*-*-darwin* } } } } */
 
 /* Check that all computed gotos in this testcase end up unfactored completely.
    If some is not there will be a unconditional jump left; if all works fine,
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-9d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9d.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9d.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,164 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector signed char c0 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector signed char c9 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 9);
+}
+
+vector signed char c21 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector signed char c30 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector signed char mc0 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector signed char mc9 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 9);
+}
+
+vector signed char mc21 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector signed char mc30 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector signed char ci (vector signed char v, int i, signed char x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector signed char mci(vector signed char *vp, int i, signed char x) {
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector signed char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  signed char c;
+
+  cv = c0 (cv, CONSTF);
+  if (cv [0] != CONSTF)
+    abort ();
+
+  cv = c9 (cv, CONST7);
+  if (cv [9] != CONST7)
+    abort ();
+
+  cv = c21 (cv, CONSTA);
+  if (cv [5] != CONSTA)
+    abort ();
+
+  cv = c30 (cv, CONSTC);
+  if (cv [14] != CONSTC)
+    abort ();
+
+  cv = mc0 (&cv, CONSTB);
+  if (cv [0] != CONSTB)
+    abort ();
+
+  cv = mc9 (&cv, CONST1);
+  if (cv [9] != CONST1)
+    abort ();
+
+  cv = mc21 (&cv, CONST7);
+  if (cv [5] != CONST7)
+    abort ();
+
+  cv = mc30 (&cv, CONST2);
+  if (cv [14] != CONST2)
+    abort ();
+
+  cv = ci (cv, 8, CONST4);
+  if (cv [8] != CONST4)
+    abort ();
+
+  cv = ci (cv, 13, CONSTB);
+  if (cv [13] != CONSTB)
+    abort ();
+
+  cv = ci (cv, 23, CONST3);
+  if (cv [7] != CONST3)
+    abort ();
+
+  cv = ci (cv, 31, CONST2);
+  if (cv [15] != CONST2)
+    abort ();
+
+  cv = mci (&cv, 5, CONST1);
+  if (cv [5] != CONST1)
+    abort ();
+
+  cv = mci (&cv, 12, CONST3);
+  if (cv [12] != CONST3)
+    abort ();
+
+  cv = mci (&cv, 25, CONST5);
+  if (cv [9] != CONST5)
+    abort ();
+
+  cv = mci (&cv, 16, CONSTD);
+  if (cv [0] != CONSTD)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr79909.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr79909.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr79909.c	(.../branches/gcc-7-branch)
@@ -1,6 +1,7 @@
 /* PR rtl-optimization/79909 */
 /* { dg-do compile } */
 /* { dg-options "-O2 -mxl-compat" } */
+/* { dg-require-effective-target dfp } */
 
 typedef float T __attribute__ ((mode (TD)));
 T b, c, d, e, f, g;
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-20d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20d.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20d.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(((unsigned __int128) 31415926539) << 60)
+#define CONST1		(((unsigned __int128) 31415926539) << 54)
+#define CONST2		(((unsigned __int128) 31415926539) << 48)
+#define CONST3		(((unsigned __int128) 31415926539) << 32)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned __int128 e0 (vector unsigned __int128 v, unsigned __int128 x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector unsigned __int128 e3 (vector unsigned __int128 v, unsigned __int128 x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned __int128
+me0 (vector unsigned __int128 *vp, unsigned __int128 x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector unsigned __int128
+me3 (vector unsigned __int128 *vp, unsigned __int128 x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned __int128
+ei (vector unsigned __int128 v, int i, unsigned __int128 x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned __int128
+mei (vector unsigned __int128 *vp, int i, unsigned __int128 x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned __int128 dv = { CONST0 };
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e3 (dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me0 (&dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me3 (&dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 0, CONST0);
+  if (dv [0] != CONST0)
+    abort ();
+
+  dv = ei (dv, 1, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 2, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = ei (dv, 3, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 0, CONST0);
+  if (dv [0] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 1, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 2, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 3, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-12c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12c.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,112 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+#define CONST2		(3 * 31415926539LL)
+#define CONST3		(4 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector long long int e0 (vector long long int v, long long int x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector long long int e3 (vector long long int v, long long int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector long long int me0 (vector long long int *vp, long long int x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector long long int me3 (vector long long int *vp, long long int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector long long int ei (vector long long int v, int i, long long int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector long long int mei (vector long long int *vp, int i, long long int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector long long int dv = { CONST0, CONST1 };
+  long long int d;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e3 (dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = me0 (&dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me3 (&dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = ei (dv, 0, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 1, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = ei (dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 3, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 3, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-13b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,124 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+/* Define this after PR89424 is addressed.  */
+#define PR89424
+
+/* Define this after PR89626 is addressed.  */
+#undef PR89626
+
+#ifdef PR89626
+#define SIGNED
+#else
+#define SIGNED signed
+#endif
+
+extern void abort (void);
+
+#define CONST0		(((SIGNED __int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+SIGNED __int128 e0 (vector SIGNED __int128 v)
+{
+  return __builtin_vec_ext_v1ti (v, 0);
+}
+
+SIGNED __int128 e3 (vector SIGNED __int128 v)
+{
+  return __builtin_vec_ext_v1ti (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+SIGNED __int128 me0 (vector SIGNED __int128 *vp)
+{
+  return __builtin_vec_ext_v1ti (*vp, 0);
+}
+
+SIGNED __int128 me3 (vector SIGNED __int128 *vp)
+{
+  return __builtin_vec_ext_v1ti (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+#ifdef PR89424
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+SIGNED __int128 ei (vector SIGNED __int128 v, int i)
+{
+  return __builtin_vec_ext_v1ti (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+SIGNED __int128 mei (vector SIGNED __int128 *vp, int i)
+{
+  return __builtin_vec_ext_v1ti (*vp, i);
+}
+#endif
+
+int main (int argc, char *argv[]) {
+  vector SIGNED __int128 dv = { CONST0 };
+  SIGNED __int128 d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST0)
+    abort ();
+
+#ifdef PR89424
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+#endif
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p8.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p8.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p8.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,54 @@
+/* { dg-do compile { target lp64 } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-options "-mvsx -O2 -mcpu=power8" } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+/* Expected instruction counts for Power 8.  */
+
+/* { dg-final { scan-assembler-times "xvabsdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvadddp" 1 } } */
+/* { dg-final { scan-assembler-times "xxlnor" 6 { target le } } } */
+/* { dg-final { scan-assembler-times "xxlnor" 5 { target be } } } */
+
+/* We generate xxlor instructions for many reasons other than or'ing vector
+   operands or calling __builtin_vec_or(), which  means we cannot rely on
+   their usage counts being stable.  Therefore, we just ensure at least one
+   xxlor instruction was generated.  */
+/* { dg-final { scan-assembler "xxlor" } } */
+
+/* { dg-final { scan-assembler-times {\mxvcmpeqdp\s} 0 { target le } } } */
+/* { dg-final { scan-assembler-times {\mxvcmpeqdp\s} 1 { target be } } } */
+/* { dg-final { scan-assembler-times {\mxvcmpeqdp\.\s} 6 { target le } } } */
+/* { dg-final { scan-assembler-times {\mxvcmpeqdp\.\s} 5 { target be } } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgtdp\s} 2 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgtdp\.\s} 5 { target le } } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgtdp\.\s} 6 { target be } } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgedp\s} 2 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgedp\.\s} 4 } } */
+/* { dg-final { scan-assembler-times "xvrdpim" 1 } } */
+/* { dg-final { scan-assembler-times "xvmaddadp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmsubadp" 1 } } */
+/* { dg-final { scan-assembler-times "xvsubdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmaxdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmindp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmuldp" 1 } } */
+/* { dg-final { scan-assembler-times "vperm" 1 } } */
+/* { dg-final { scan-assembler-times "xvrdpic" 1 } } */
+/* { dg-final { scan-assembler-times "xvsqrtdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvrdpiz" 1 } } */
+/* { dg-final { scan-assembler-times "xvmsubasp" 1 } } */
+/* { dg-final { scan-assembler-times "xvnmaddasp" 1 } } */
+/* { dg-final { scan-assembler-times "xvnmaddadp" 1 } } */
+/* { dg-final { scan-assembler-times "xvnmsubadp" 1 } } */
+/* { dg-final { scan-assembler-times "vmsumshs" 1 } } */
+/* { dg-final { scan-assembler-times "xxland" 9 { target le } } } */
+/* { dg-final { scan-assembler-times "xxland" 13 { target be } } } */
+/* { dg-final { scan-assembler-times "xxlxor" 2 } } */
+/* { dg-final { scan-assembler-times "xxsel" 2 } } */
+/* { dg-final { scan-assembler-times "xvrdpip" 1 } } */
+/* { dg-final { scan-assembler-times "xvdivdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvrdpi" 5 } } */
+
+/* Source code for the test in vsx-vector-6.h */
+#include "vsx-vector-6.h"
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-14a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,126 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		((float) (3.1415926539))
+#define CONST1		((float) (3.1415926539 * 2))
+#define CONST2		((float) (3.1415926539 * 3))
+#define CONST3		((float) (3.1415926539 * 4))
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+float e0(vector float v){ return __builtin_vec_ext_v4sf (v, 0); }
+float e1(vector float v){ return __builtin_vec_ext_v4sf (v, 1); }
+float e7(vector float v){ return __builtin_vec_ext_v4sf (v, 7); }
+float e8(vector float v){ return __builtin_vec_ext_v4sf (v, 8); }
+
+/* Test for vector residing in memory.  */
+float me0(vector float *vp){ return __builtin_vec_ext_v4sf (*vp, 0); }
+float me1(vector float *vp){ return __builtin_vec_ext_v4sf (*vp, 1); }
+
+float me13(vector float *vp)
+{
+  return __builtin_vec_ext_v4sf (*vp, 13);
+}
+
+float me15(vector float *vp)
+{
+  return __builtin_vec_ext_v4sf (*vp, 15);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+float ei(vector float v, int i)
+{
+  return __builtin_vec_ext_v4sf (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+float mei(vector float *vp, int i)
+{
+  return __builtin_vec_ext_v4sf (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector float dv = { CONST0, CONST1, CONST2, CONST3 };
+  float d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e1 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = e7 (dv);
+  if (d != CONST3)
+    abort ();
+
+  d = e8 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me1 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me13 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me15 (&dv);
+  if (d != CONST3)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST2)
+    abort ();
+
+  d = ei (dv, 11);
+  if (d != CONST3)
+    abort ();
+
+  d = ei (dv, 17);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 15);
+  if (d != CONST3)
+    abort ();
+
+  d = mei (&dv, 6);
+  if (d != CONST2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-12d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12d.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12d.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,112 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+#define CONST2		(3 * 31415926539LL)
+#define CONST3		(4 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector long long int e0 (vector long long int v, long long int x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector long long int e3 (vector long long int v, long long int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector long long int me0 (vector long long int *vp, long long int x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector long long int me3 (vector long long int *vp, long long int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector long long int ei (vector long long int v, int i, long long int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector long long int mei (vector long long int *vp, int i, long long int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector long long int dv = { CONST0, CONST1 };
+  long long int d;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e3 (dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = me0 (&dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me3 (&dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = ei (dv, 0, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 1, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = ei (dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 3, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 3, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-13c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13c.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+#define SIGNED signed
+
+extern void abort (void);
+
+#define CONST0		(((SIGNED __int128) 31415926539) << 60)
+#define CONST1		(((SIGNED __int128) 31415926539) << 55)
+#define CONST2		(((SIGNED __int128) 31415926539) << 50)
+#define CONST3		(((SIGNED __int128) 31415926539) << 45)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector SIGNED __int128 e0 (vector SIGNED __int128 v, SIGNED __int128 x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector SIGNED __int128 e3 (vector SIGNED __int128 v, SIGNED __int128 x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector SIGNED __int128 me0 (vector SIGNED __int128 *vp, SIGNED __int128 x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector SIGNED __int128 me3 (vector SIGNED __int128 *vp, SIGNED __int128 x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector SIGNED __int128
+ei (vector SIGNED __int128 v, int i, SIGNED __int128 x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector SIGNED __int128
+mei (vector SIGNED __int128 *vp, int i, SIGNED __int128 x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector SIGNED __int128 dv = { CONST0 };
+  SIGNED __int128 d;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e3 (dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me0 (&dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me3 (&dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 1, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = ei (dv, 2, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 3, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 0, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 1, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 3, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p9.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p9.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p9.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,39 @@
+/* { dg-do compile { target lp64 } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-options "-mvsx -O2 -mcpu=power9" } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+
+/* Expected instruction counts for Power9. */
+
+/* { dg-final { scan-assembler-times "xvabsdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvadddp" 1 } } */
+/* { dg-final { scan-assembler-times "xxlnor" 5 } } */
+
+/* We generate xxlor instructions for many reasons other than or'ing vector
+   operands or calling __builtin_vec_or(), which  means we cannot rely on
+   their usage counts being stable.  Therefore, we just ensure at least one
+   xxlor instruction was generated.  */
+/* { dg-final { scan-assembler "xxlor" } } */
+
+/* { dg-final { scan-assembler-times "xvcmpeqdp" 7 } } */
+/* { dg-final { scan-assembler-times "xvcmpgtdp" 8 } } */
+/* { dg-final { scan-assembler-times "xvcmpgedp" 7 } } */
+/* { dg-final { scan-assembler-times "xvrdpim" 1 } } */
+/* { dg-final { scan-assembler-times "xvmaddadp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmsubadp" 1 } } */
+/* { dg-final { scan-assembler-times "xvsubdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmaxdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmindp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmuldp" 1 } } */
+/* { dg-final { scan-assembler-times "vperm" 1 } } */
+/* { dg-final { scan-assembler-times "xvrdpic" 1 } } */
+/* { dg-final { scan-assembler-times "xvsqrtdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvrdpiz" 1 } } */
+/* { dg-final { scan-assembler-times "xvmsubasp" 1 } } */
+/* { dg-final { scan-assembler-times "xvnmaddasp" 1 } } */
+/* { dg-final { scan-assembler-times "vmsumshs" 1 } } */
+/* { dg-final { scan-assembler-times "xxland" 13 } } */
+
+/* Source code for the test in vsx-vector-6.h */
+#include "vsx-vector-6.h"
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,14 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-O2 -mvsx" } */
+
+#define TYPE unsigned char
+/* ELEMENTS is number of elements in a vector of TYPE.  */
+#define ELEMENTS 16
+#define INITIAL \
+  {  3, 2, 3, 4, 5, 6, 7, 8, 240, 241, 242, 243, 244, 245, 246, 247 }
+
+#define DO_TRACE
+#define DISABLE_INLINE_OF_GET_AUTO_N
+
+#include "vec-extract-v16qiu-v2.h"
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-14b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,126 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		((float) (3.1415926539))
+#define CONST1		((float) (3.1415926539 * 2))
+#define CONST2		((float) (3.1415926539 * 3))
+#define CONST3		((float) (3.1415926539 * 4))
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+float e0(vector float v){ return __builtin_vec_ext_v4sf (v, 0); }
+float e1(vector float v){ return __builtin_vec_ext_v4sf (v, 1); }
+float e7(vector float v){ return __builtin_vec_ext_v4sf (v, 7); }
+float e8(vector float v){ return __builtin_vec_ext_v4sf (v, 8); }
+
+/* Test for vector residing in memory.  */
+float me0(vector float *vp){ return __builtin_vec_ext_v4sf (*vp, 0); }
+float me1(vector float *vp){ return __builtin_vec_ext_v4sf (*vp, 1); }
+
+float me13(vector float *vp)
+{
+  return __builtin_vec_ext_v4sf (*vp, 13);
+}
+
+float me15(vector float *vp)
+{
+  return __builtin_vec_ext_v4sf (*vp, 15);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+float ei(vector float v, int i)
+{
+  return __builtin_vec_ext_v4sf (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+float mei(vector float *vp, int i)
+{
+  return __builtin_vec_ext_v4sf (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector float dv = { CONST0, CONST1, CONST2, CONST3 };
+  float d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e1 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = e7 (dv);
+  if (d != CONST3)
+    abort ();
+
+  d = e8 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me1 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me13 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me15 (&dv);
+  if (d != CONST3)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST2)
+    abort ();
+
+  d = ei (dv, 11);
+  if (d != CONST3)
+    abort ();
+
+  d = ei (dv, 17);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 15);
+  if (d != CONST3)
+    abort ();
+
+  d = mei (&dv, 6);
+  if (d != CONST2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/stabs-attrib-vect-darwin.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/stabs-attrib-vect-darwin.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/stabs-attrib-vect-darwin.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* Test Attribute Vector associated with vector type stabs.  */
 /* { dg-do compile { target powerpc*-*-darwin* } } */
+/* { dg-require-effective-target stabs } */
 /* { dg-options "-gstabs+ -fno-eliminate-unused-debug-types -faltivec" } */
 
 int main ()
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-15a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,113 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(3.1415926539)
+#define CONST1		(3.1415926539 * 2)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+double e0(vector double v){ return __builtin_vec_ext_v2df (v, 0); }
+double e1(vector double v){ return __builtin_vec_ext_v2df (v, 1); }
+double e2(vector double v){ return __builtin_vec_ext_v2df (v, 2); }
+double e3(vector double v){ return __builtin_vec_ext_v2df (v, 3); }
+
+/* Test for vector residing in memory.  */
+double me0(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 0); }
+double me1(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 1); }
+double me2(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 2); }
+double me3(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 3); }
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+double ei(vector double v, int i){ return __builtin_vec_ext_v2df (v, i); }
+
+/* Test for variable selector and vector residing in memory.  */
+double mei(vector double *vp, int i){ return __builtin_vec_ext_v2df (*vp, i); }
+
+
+int main (int argc, char *argv[]) {
+  vector double dv;
+  double d;
+  dv[0] = CONST0;
+  dv[1] = CONST1;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e1 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = e2 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me1 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me2 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-13d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13d.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13d.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+#define SIGNED signed
+
+extern void abort (void);
+
+#define CONST0		(((SIGNED __int128) 31415926539) << 60)
+#define CONST1		(((SIGNED __int128) 31415926539) << 55)
+#define CONST2		(((SIGNED __int128) 31415926539) << 50)
+#define CONST3		(((SIGNED __int128) 31415926539) << 45)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector SIGNED __int128 e0 (vector SIGNED __int128 v, SIGNED __int128 x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector SIGNED __int128 e3 (vector SIGNED __int128 v, SIGNED __int128 x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector SIGNED __int128 me0 (vector SIGNED __int128 *vp, SIGNED __int128 x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector SIGNED __int128 me3 (vector SIGNED __int128 *vp, SIGNED __int128 x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector SIGNED __int128
+ei (vector SIGNED __int128 v, int i, SIGNED __int128 x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector SIGNED __int128
+mei (vector SIGNED __int128 *vp, int i, SIGNED __int128 x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector SIGNED __int128 dv = { CONST0 };
+  SIGNED __int128 d;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e3 (dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me0 (&dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me3 (&dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 1, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = ei (dv, 2, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 3, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 0, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 1, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 3, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/p8vector-builtin-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/p8vector-builtin-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/p8vector-builtin-2.c	(.../branches/gcc-7-branch)
@@ -9,6 +9,14 @@
 typedef vector long long		v_sign;
 typedef vector unsigned long long	v_uns;
 typedef vector bool long long		v_bool;
+typedef vector bool char		v_bchar;
+typedef vector bool int 		v_bint;
+typedef vector bool short		v_bshort;
+typedef vector signed int		v_sint;
+typedef vector unsigned int		v_uint;
+typedef vector signed char		v_schar;
+typedef vector unsigned char		v_uchar;
+typedef vector float			v_float;
 
 v_sign sign_add_1 (v_sign a, v_sign b)
 {
@@ -191,6 +199,77 @@
   return vec_vsrad (a, b);
 }
 
+v_bchar vbchar_eq (v_bchar a, v_bchar b)
+{
+  return vec_cmpeq (a, b);
+}
+
+v_bchar vbschar_eq (v_schar a, v_schar b)
+{
+  return vec_cmpeq (a, b);
+}
+
+v_bchar vuchar_eq (v_uchar a, v_uchar b)
+{
+  return vec_cmpeq (a, b);
+}
+
+v_bint vbint_eq (v_bint a, v_bint b)
+{
+  return vec_cmpeq (a, b);
+}
+
+v_bint vsint_eq (v_sint a, v_sint b)
+{
+  return vec_cmpeq (a, b);
+}
+
+v_bint vuint_eq (v_uint a, v_uint b)
+{
+  return vec_cmpeq (a, b);
+}
+
+v_bool vbool_eq (v_bool a, v_bool b)
+{
+  return vec_cmpeq (a, b);
+}
+
+v_bint vbint_ne (v_bint a, v_bint b)
+{
+  return vec_cmpne (a, b);
+}
+
+v_bint vsint_ne (v_sint a, v_sint b)
+{
+  return vec_cmpne (a, b);
+}
+
+v_bint vuint_ne (v_uint a, v_uint b)
+{
+  return vec_cmpne (a, b);
+}
+
+v_bool vbool_ne (v_bool a, v_bool b)
+{
+  return vec_cmpne (a, b);
+}
+
+v_bool vsign_ne (v_sign a, v_sign b)
+{
+  return vec_cmpne (a, b);
+}
+
+v_bool vuns_ne (v_uns a, v_uns b)
+{
+  return vec_cmpne (a, b);
+}
+
+v_bshort vbshort_ne (v_bshort a, v_bshort b)
+{
+  return vec_cmpne (a, b);
+}
+
+
 /* { dg-final { scan-assembler-times "vaddudm" 	5 } } */
 /* { dg-final { scan-assembler-times "vsubudm" 	6 } } */
 /* { dg-final { scan-assembler-times "vmaxsd"  	4 } } */
@@ -197,9 +276,11 @@
 /* { dg-final { scan-assembler-times "vminsd"  	3 } } */
 /* { dg-final { scan-assembler-times "vmaxud"  	2 } } */
 /* { dg-final { scan-assembler-times "vminud"  	2 } } */
-/* { dg-final { scan-assembler-times "vcmpequd" 2 } } */
+/* { dg-final { scan-assembler-times "vcmpequd" 6 } } */
 /* { dg-final { scan-assembler-times "vcmpgtsd" 1 } } */
 /* { dg-final { scan-assembler-times "vcmpgtud" 1 } } */
 /* { dg-final { scan-assembler-times "vrld"     3 } } */
 /* { dg-final { scan-assembler-times "vsld"     5 } } */
 /* { dg-final { scan-assembler-times "vsrad"    3 } } */
+/* { dg-final { scan-assembler-times "vcmpequb" 3 } } */
+/* { dg-final { scan-assembler-times "vcmpequw" 6 } } */
Index: gcc/testsuite/gcc.target/powerpc/vsx-13.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-13.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-13.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,42 @@
+/* { dg-do compile { target powerpc*-*-* } } */
+/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-options "-mvsx" } */
+
+/* Variations of tests that require VSX support.  This is a variation of
+   the altivec-13.c testcase.  */
+
+#include <altivec.h>
+
+void foo (void)
+{
+
+  vector signed char vsc1, vsc2, vscz;
+  vector unsigned char vuc1, vuc2, vucz;
+  vector bool long long vubll1, vubll2, vubllz;
+  vector signed int long long vsill1, vsill2, vsillz;
+  vector unsigned int long long vuill1, vuill2, vuillz;
+  vector double vd1, vd2, vdz;
+
+  vubllz = vec_sld( vubll1, vubll2, 1 );
+  vsillz = vec_sld( vsill1, vsill2, 1 );
+  vuillz = vec_sld( vuill1, vuill2, 1 );
+
+  vsillz = vec_srl(vsill1, vuc2);
+  vuillz = vec_srl(vuill1, vuc2);
+
+  vsillz = vec_sro(vsill1, vsc2);
+  vsillz = vec_sro(vsill1, vuc2);
+  vuillz = vec_sro(vuill1, vsc2);
+  vuillz = vec_sro(vuill1, vuc2);
+
+  vdz = vec_sld( vd1, vd2, 1 );
+}
+
+/* Expected results:
+   vec_sld          vsldoi
+   vec_srl          vsr
+   vec_sro          vsro  */
+
+/* { dg-final { scan-assembler-times "vsldoi" 4 } } */
+/* { dg-final { scan-assembler-times "vsr " 2 } } */
+/* { dg-final { scan-assembler-times "vsro" 4 } } */
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,14 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-O2 -mvsx" } */
+
+#define TYPE unsigned char
+/* ELEMENTS is number of elements in a vector of TYPE.  */
+#define ELEMENTS 16
+#define INITIAL \
+  {  3, 2, 3, 4, 5, 6, 7, 8, 240, 241, 242, 243, 244, 245, 246, 247 }
+
+#define DO_TRACE
+#undef DISABLE_INLINE_OF_GET_AUTO_N
+
+#include "vec-extract-v16qiu-v2.h"
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-14c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14c.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		((float) (3.1415926539))
+#define CONST1		((float) (3.1415926539 * 2))
+#define CONST2		((float) (3.1415926539 * 3))
+#define CONST3		((float) (3.1415926539 * 4))
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector float e0(vector float v, float x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector float e1(vector float v, float x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector float e7(vector float v, float x)
+{
+  return vec_insert (x, v, 7);
+}
+
+vector float e8(vector float v, float x)
+{
+  return vec_insert (x, v, 8);
+}
+
+/* Test for vector residing in memory.  */
+vector float me0(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector float me1(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector float me13(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 13);
+}
+
+vector float me15(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 15);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector float ei(vector float v, int i, float x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector float mei(vector float *vp, int i, float x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector float dv = { CONST0, CONST1, CONST2, CONST3 };
+  float d;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e1 (dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = e7 (dv, CONST2);
+  if (dv [3] != CONST2)
+    abort ();
+
+  dv = e8 (dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me0 (&dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me1 (&dv, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = me13 (&dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = me15 (&dv, CONST1);
+  if (dv [3] != CONST1)
+    abort ();
+
+  dv = ei (dv, 0, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 2, CONST1);
+  if (dv [2] != CONST1)
+    abort ();
+
+  dv = ei (dv, 11, CONST0);
+  if (dv [3] != CONST0)
+    abort ();
+
+  dv = ei (dv, 17, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 15, CONST1);
+  if (dv [3] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 6, CONST0);
+  if (dv [2] != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/bfp/bfp.exp
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/bfp/bfp.exp	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/bfp/bfp.exp	(.../branches/gcc-7-branch)
@@ -16,9 +16,11 @@
 # along with GCC; see the file COPYING3.  If not see
 # <http://www.gnu.org/licenses/>.
 
-# Exit immediately if this isn't a PowerPC target or if the target is aix.
+# Exit immediately if this isn't a PowerPC target or if the target is
+#aix or Darwin.
 if { (![istarget powerpc*-*-*] && ![istarget rs6000-*-*])
-     || [istarget "powerpc*-*-aix*"] } then {
+     || [istarget "powerpc*-*-aix*"]
+     || [istarget "powerpc*-*-darwin*"]  } then {
   return
 }
 
Index: gcc/testsuite/gcc.target/powerpc/pr87532.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr87532.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr87532.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,72 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <stdlib.h>
+#include <stddef.h>
+#include <altivec.h>
+#include <stdio.h>
+
+static void
+check (unsigned char, unsigned char) __attribute__((__noinline__));
+
+static __attribute__((altivec(vector__))) unsigned char
+deoptimize (__attribute__((altivec(vector__))) unsigned char)
+__attribute__((__noinline__));
+
+static __attribute__((altivec(vector__))) unsigned char
+deoptimize (__attribute__((altivec(vector__))) unsigned char a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+// Toggle this attribute inline/noinline to see pass/fail.
+// fails with the noinline attribute applied.
+__attribute__ ((__noinline__))
+unsigned char
+get_auto_n (__attribute__((altivec(vector__))) unsigned char a, size_t n)
+{
+  return (unsigned char) __builtin_vec_extract (a, n);
+}
+
+void
+do_auto (__attribute__((altivec(vector__))) unsigned char a)
+{
+  size_t i;
+  for (i = 1; i < 3 ; i++)
+  {
+    do
+      {
+	printf ("get_auto_n (a, %d) produces 0x0%x\n",
+		i, (int) get_auto_n (a, i));
+
+	if ((int) get_auto_n (a,i) > 250) abort();
+      } while (0);
+  }
+}
+
+int
+main (void)
+{
+  size_t i;
+  __attribute__((altivec(vector__))) unsigned char x =
+    { 3, 2, 3, 8, 5, 6, 7, 8, 240, 241, 242, 243, 244, 245, 246, 247 };
+  __attribute__((altivec(vector__))) unsigned char a;
+
+  printf (" first elements of x are: %d %d %d %d %d\n",
+	  x[0], x[1], x[2], x[3], x[4]);
+
+  a = deoptimize (x);
+
+  printf (" after deoptimization, first elements of a are: %d %d %d %d %d\n",
+	  a[0], a[1], a[2], a[3], a[4]);
+
+  do_auto (a);
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-15b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,113 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(3.1415926539)
+#define CONST1		(3.1415926539 * 2)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+double e0(vector double v){ return __builtin_vec_ext_v2df (v, 0); }
+double e1(vector double v){ return __builtin_vec_ext_v2df (v, 1); }
+double e2(vector double v){ return __builtin_vec_ext_v2df (v, 2); }
+double e3(vector double v){ return __builtin_vec_ext_v2df (v, 3); }
+
+/* Test for vector residing in memory.  */
+double me0(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 0); }
+double me1(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 1); }
+double me2(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 2); }
+double me3(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 3); }
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+double ei(vector double v, int i){ return __builtin_vec_ext_v2df (v, i); }
+
+/* Test for variable selector and vector residing in memory.  */
+double mei(vector double *vp, int i){ return __builtin_vec_ext_v2df (*vp, i); }
+
+
+int main (int argc, char *argv[]) {
+  vector double dv;
+  double d;
+  dv[0] = CONST0;
+  dv[1] = CONST1;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e1 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = e2 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me1 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me2 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-sint128-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-sint128-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-sint128-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,27 @@
+/* Test to verify that the vec_extract from a vector of
+   signed __int128s remains signed.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(signed __int128 st) {
+
+  vector signed __int128 v = vec_splats(st);
+
+  if (vec_extract (v, 0) > st)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (((__int128) 0xf600000000000000LL) << 64);
+  test1 (((__int128) 0x7600000000000000LL) << 64);
+  test1 (((__int128) 0x0600000000000000LL) << 64);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-16a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,165 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned char c0 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned char c9 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 9);
+}
+
+unsigned char c21 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned char c30 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned char mc0 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned char mc9 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 9);
+}
+
+unsigned char mc21 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned char mc30 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned char ci (vector unsigned char v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned char mci (vector unsigned char *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector unsigned char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  unsigned char c;
+
+  c = c0 (cv);
+  if (c != CONST0)
+    abort ();
+
+  c = c9 (cv);
+  if (c != CONST9)
+    abort ();
+
+  c = c21 (cv);
+  if (c != CONST5)
+    abort ();
+
+  c = c30 (cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = mc0 (&cv);
+  if (c != CONST0)
+    abort ();
+
+  c = mc9 (&cv);
+  if (c != CONST9)
+    abort ();
+
+  c = mc21 (&cv);
+  if (c != CONST5)
+    abort ();
+
+  c = mc30 (&cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = ci (cv, 8);
+  if (c != CONST8)
+    abort ();
+
+  c = ci (cv, 13);
+  if (c != CONSTD)
+    abort ();
+
+  c = ci (cv, 23);
+  if (c != CONST7)
+    abort ();
+
+  c = ci (cv, 31);
+  if (c != CONSTF)
+    abort ();
+
+  c = mci (&cv, 5);
+  if (c != CONST5)
+    abort ();
+
+  c = mci (&cv, 12);
+  if (c != CONSTC)
+    abort ();
+
+  c = mci (&cv, 25);
+  if (c != CONST9)
+    abort ();
+
+  c = mci (&cv, 16);
+  if (c != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-14d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14d.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14d.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		((float) (3.1415926539))
+#define CONST1		((float) (3.1415926539 * 2))
+#define CONST2		((float) (3.1415926539 * 3))
+#define CONST3		((float) (3.1415926539 * 4))
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector float e0(vector float v, float x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector float e1(vector float v, float x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector float e7(vector float v, float x)
+{
+  return vec_insert (x, v, 7);
+}
+
+vector float e8(vector float v, float x)
+{
+  return vec_insert (x, v, 8);
+}
+
+/* Test for vector residing in memory.  */
+vector float me0(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector float me1(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector float me13(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 13);
+}
+
+vector float me15(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 15);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector float ei(vector float v, int i, float x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector float mei(vector float *vp, int i, float x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector float dv = { CONST0, CONST1, CONST2, CONST3 };
+  float d;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e1 (dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = e7 (dv, CONST2);
+  if (dv [3] != CONST2)
+    abort ();
+
+  dv = e8 (dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me0 (&dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me1 (&dv, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = me13 (&dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = me15 (&dv, CONST1);
+  if (dv [3] != CONST1)
+    abort ();
+
+  dv = ei (dv, 0, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 2, CONST1);
+  if (dv [2] != CONST1)
+    abort ();
+
+  dv = ei (dv, 11, CONST0);
+  if (dv [3] != CONST0)
+    abort ();
+
+  dv = ei (dv, 17, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 15, CONST1);
+  if (dv [3] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 6, CONST0);
+  if (dv [2] != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-15c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15c.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,151 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(3.1415926539)
+#define CONST1		(3.1415926539 * 2)
+#define CONST2		(3.1415926539 * 3)
+#define CONST3		(3.1415926539 * 4)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector double e0(vector double v, double x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector double e1(vector double v, double x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector double e2(vector double v, double x)
+{
+  return vec_insert (x, v, 2);
+}
+
+vector double e3(vector double v, double x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector double me0(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector double me1(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector double me2(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 2);
+}
+
+vector double me3(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector double ei(vector double v, int i, double x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector double mei(vector double *vp, int i, double x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector double dv;
+  double d;
+  dv[0] = CONST0;
+  dv[1] = CONST1;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e1 (dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = e2 (dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = e3 (dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = me0 (&dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me1 (&dv, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = me2 (&dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me3 (&dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = ei (dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = ei (dv, 2, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 3, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 2, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 3, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-16b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,165 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned char c0 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned char c9 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 9);
+}
+
+unsigned char c21 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned char c30 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned char mc0 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned char mc9 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 9);
+}
+
+unsigned char mc21 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned char mc30 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned char ci (vector unsigned char v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned char mci (vector unsigned char *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector unsigned char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  unsigned char c;
+
+  c = c0 (cv);
+  if (c != CONST0)
+    abort ();
+
+  c = c9 (cv);
+  if (c != CONST9)
+    abort ();
+
+  c = c21 (cv);
+  if (c != CONST5)
+    abort ();
+
+  c = c30 (cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = mc0 (&cv);
+  if (c != CONST0)
+    abort ();
+
+  c = mc9 (&cv);
+  if (c != CONST9)
+    abort ();
+
+  c = mc21 (&cv);
+  if (c != CONST5)
+    abort ();
+
+  c = mc30 (&cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = ci (cv, 8);
+  if (c != CONST8)
+    abort ();
+
+  c = ci (cv, 13);
+  if (c != CONSTD)
+    abort ();
+
+  c = ci (cv, 23);
+  if (c != CONST7)
+    abort ();
+
+  c = ci (cv, 31);
+  if (c != CONSTF)
+    abort ();
+
+  c = mci (&cv, 5);
+  if (c != CONST5)
+    abort ();
+
+  c = mci (&cv, 12);
+  if (c != CONSTC)
+    abort ();
+
+  c = mci (&cv, 25);
+  if (c != CONST9)
+    abort ();
+
+  c = mci (&cv, 16);
+  if (c != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/dfp/dfp.exp
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/dfp/dfp.exp	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/dfp/dfp.exp	(.../branches/gcc-7-branch)
@@ -16,8 +16,11 @@
 # along with GCC; see the file COPYING3.  If not see
 # <http://www.gnu.org/licenses/>.
 
-# Exit immediately if this isn't a PowerPC target.
-if { ![istarget powerpc*-*-*] && ![istarget rs6000-*-*] } then {
+# Exit immediately if this isn't a PowerPC target, also exit if we
+# are on Darwin which doesn't support decimal float.
+if { (![istarget powerpc*-*-*] && ![istarget rs6000-*-*])
+    || [istarget "powerpc*-*-darwin*"]
+} then {
   return
 }
 
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-sshort-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-sshort-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-sshort-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,29 @@
+/* Test to verify that the vec_extract from a vector of
+   signed shorts remains signed.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(signed short ss) {
+  int sse;
+
+  vector signed short v = vec_splats(ss);
+  sse = vec_extract(v,0);
+
+  if (sse != ss)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (0xf600);
+  test1 (0x7600);
+  test1 (0x0600);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2.h
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,253 @@
+#include <stdlib.h>
+#include <stddef.h>
+#include <altivec.h>
+
+#ifndef RTYPE
+#define RTYPE TYPE
+#endif
+
+#ifdef DO_TRACE
+#include <stdio.h>
+
+#define TRACE(STRING, NUM)						\
+do									\
+  {									\
+    fprintf (stderr, "%s: %2d\n", STRING, (int) NUM);			\
+    fflush (stderr);							\
+  }									\
+while (0)
+
+#ifndef FAIL_FORMAT
+#define FAIL_FORMAT "%ld"
+#define FAIL_CAST(X) ((long)(X))
+#endif
+
+#define FAIL(EXP, GOT)							 \
+do									 \
+  {									 \
+    fprintf (stderr, "Expected: " FAIL_FORMAT ", got " FAIL_FORMAT "\n", \
+	     FAIL_CAST (EXP), FAIL_CAST (GOT));				 \
+    fflush (stderr);							 \
+    abort ();								 \
+  }									 \
+while (0)
+
+#else
+#define TRACE(STRING, NUM)
+#define FAIL(EXP, GOT) abort ()
+#endif
+
+static void
+check (RTYPE, RTYPE) __attribute__((__noinline__));
+
+static vector TYPE
+deoptimize (vector TYPE) __attribute__((__noinline__));
+
+static vector TYPE
+*deoptimize_ptr (vector TYPE *)	__attribute__((__noinline__));
+
+static void
+check (RTYPE expected, RTYPE got)
+{
+  if (expected != got)
+    FAIL (expected, got);
+}
+
+static vector TYPE
+deoptimize (vector TYPE a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector TYPE *
+deoptimize_ptr (vector TYPE *p)
+{
+  __asm__ (" # %0" : "+r" (p));
+  return p;
+}
+
+
+RTYPE
+get_auto_0 (vector TYPE a)
+{
+  TRACE ("get_auto_", 0);
+  return (RTYPE) vec_extract (a, 0);
+}
+
+RTYPE
+get_auto_1 (vector TYPE a)
+{
+  TRACE ("get_auto_", 1);
+  return (RTYPE) vec_extract (a, 1);
+}
+
+#if ELEMENTS >= 4
+RTYPE
+get_auto_2 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 2);
+}
+
+RTYPE
+get_auto_3 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 3);
+}
+
+#if ELEMENTS >= 8
+RTYPE
+get_auto_4 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 4);
+}
+
+RTYPE
+get_auto_5 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 5);
+}
+
+RTYPE
+get_auto_6 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 6);
+}
+
+RTYPE
+get_auto_7 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 7);
+}
+
+#if ELEMENTS >= 16
+RTYPE
+get_auto_8 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 8);
+}
+
+RTYPE
+get_auto_9 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 9);
+}
+
+RTYPE
+get_auto_10 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 10);
+}
+
+RTYPE
+get_auto_11 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 11);
+}
+
+RTYPE
+get_auto_12 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 12);
+}
+
+RTYPE
+get_auto_13 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 13);
+}
+
+RTYPE
+get_auto_14 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 14);
+}
+
+RTYPE
+get_auto_15 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 15);
+}
+
+#endif
+#endif
+#endif
+
+
+/* Tests for the normal case of vec_extract where the vector is in a register
+   and returning the result in a register as a return value.  */
+#ifdef DISABLE_INLINE_OF_GET_AUTO_N
+__attribute__ ((__noinline__))
+#else
+/* gcc issues warning: always_inline function might not be inlinable
+
+   __attribute__ ((__always_inline__))
+*/
+#endif
+RTYPE
+get_auto_n (vector TYPE a, ssize_t n)
+{
+  return (RTYPE) vec_extract (a, n);
+}
+
+typedef RTYPE (*auto_func_type) (vector TYPE);
+
+static auto_func_type get_auto_const[] = {
+  get_auto_0,
+  get_auto_1,
+#if ELEMENTS >= 4
+  get_auto_2,
+  get_auto_3,
+#if ELEMENTS >= 8
+  get_auto_4,
+  get_auto_5,
+  get_auto_6,
+  get_auto_7,
+#if ELEMENTS >= 16
+  get_auto_8,
+  get_auto_9,
+  get_auto_10,
+  get_auto_11,
+  get_auto_12,
+  get_auto_13,
+  get_auto_14,
+  get_auto_15,
+#endif
+#endif
+#endif
+};
+
+extern void do_auto (vector TYPE a) __attribute__((__noinline__));
+
+void
+do_auto (vector TYPE a)
+{
+  size_t i;
+
+  for (i = 1; i < 40; i += 3)
+    {
+      TRACE ("do_auto, i: ", i);
+      TRACE ("  get_auto_const[i] returns: ",
+	     (*get_auto_const [i % ELEMENTS]) (a));
+      TRACE ("  get_auto_n returns", get_auto_n (a, i));
+      check (get_auto_n (a, i), (*get_auto_const [i % ELEMENTS]) (a));
+    }
+}
+
+
+
+/* Main program to test all of the possibilities.  */
+int
+main (void)
+{
+  size_t i;
+  vector TYPE x = INITIAL;
+  vector TYPE *p, *p2, a, y;
+  vector TYPE z[2];
+
+  a = deoptimize (x);
+
+  do_auto (a);
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-17a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned short s3 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+unsigned short s7 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 7);
+}
+
+unsigned short s21 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned short s30 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned short ms3 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+unsigned short ms7 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 7);
+}
+
+unsigned short ms21 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned short ms30 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned short ci (vector unsigned short v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned short mci (vector unsigned short *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+int main (int argc, unsigned short *argv[]) {
+  vector unsigned short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  unsigned short s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s7 (sv);
+  if (s != CONST7)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST5)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms7 (&sv);
+  if (s != CONST7)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST5)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST7)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-15d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15d.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15d.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,151 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(3.1415926539)
+#define CONST1		(3.1415926539 * 2)
+#define CONST2		(3.1415926539 * 3)
+#define CONST3		(3.1415926539 * 4)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector double e0(vector double v, double x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector double e1(vector double v, double x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector double e2(vector double v, double x)
+{
+  return vec_insert (x, v, 2);
+}
+
+vector double e3(vector double v, double x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector double me0(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector double me1(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector double me2(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 2);
+}
+
+vector double me3(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector double ei(vector double v, int i, double x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector double mei(vector double *vp, int i, double x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector double dv;
+  double d;
+  dv[0] = CONST0;
+  dv[1] = CONST1;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e1 (dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = e2 (dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = e3 (dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = me0 (&dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me1 (&dv, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = me2 (&dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me3 (&dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = ei (dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = ei (dv, 2, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 3, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 2, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 3, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-7.h
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-7.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-7.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,18 @@
+
+/* This test code is included into vsx-7-be.c.
+ * this is meant to supplement code in altivec-7.h.  */
+
+#include <altivec.h>
+
+
+vector float *vecfloat;
+vector double *vecdouble;
+
+int main2 ()
+{
+
+  *vecdouble++ = vec_unpackl(vecfloat[0]);
+  *vecdouble++ = vec_unpackh(vecfloat[0]);
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-16c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16c.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,180 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <stdio.h>
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned char c0 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector unsigned char c9 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 9);
+}
+
+vector unsigned char c21 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector unsigned char c30 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned char mc0 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector unsigned char mc9 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 9);
+}
+
+vector unsigned char mc21 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector unsigned char mc30 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned char ci (vector unsigned char v, int i, unsigned char x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned char mci (vector unsigned char *vp, int i, unsigned char x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector unsigned char cv = { CONST0, CONST1, CONST2, CONST3,
+			      CONST4, CONST5, CONST6, CONST7,
+			      CONST8, CONST9, CONSTA, CONSTB,
+			      CONSTC, CONSTD, CONSTE, CONSTF };
+  printf ("A\n");
+  cv = c0 (cv, CONST3);
+  if (cv [0] != CONST3)
+    abort ();
+
+  printf ("B\n");
+  cv = c9 (cv, CONST2);
+  if (cv [9] != CONST2)
+    abort ();
+
+  printf ("C\n");
+  cv = c21 (cv, CONSTF);
+  if (cv [5] != CONSTF)
+    abort ();
+
+  printf ("D\n");
+  cv = c30 (cv, CONST3);
+  if (cv [14] != CONST3)
+    abort ();
+
+  printf ("E\n");
+  cv = mc0 (&cv, CONST4);
+  if (cv [0] != CONST4)
+    abort ();
+
+  printf ("F\n");
+  cv = mc9 (&cv, CONST3);
+  if (cv [9] != CONST3)
+    abort ();
+
+  printf ("G\n");
+  cv = mc21 (&cv, CONST1);
+  if (cv [5] != CONST1)
+    abort ();
+
+  printf ("H\n");
+  cv = mc30 (&cv, CONSTC);
+  if (cv [14] != CONSTC)
+    abort ();
+
+  printf ("I\n");
+  cv = ci (cv, 8, CONSTD);
+  if (cv [8] != CONSTD)
+    abort ();
+
+  printf ("J\n");
+  cv = ci (cv, 13, CONST5);
+  if (cv [13] != CONST5)
+    abort ();
+
+  printf ("K\n");
+  cv = ci (cv, 23, CONST6);
+  if (cv [7] != CONST6)
+    abort ();
+
+  printf ("L\n");
+  cv = ci (cv, 31, CONST7);
+  if (cv [15] != CONST7)
+    abort ();
+
+  printf ("M\n");
+  cv = mci (&cv, 5, CONST8);
+  if (cv [5] != CONST8)
+    abort ();
+
+  printf ("N\n");
+  cv = mci (&cv, 12, CONST9);
+  if (cv [12] != CONST9)
+    abort ();
+
+  printf ("O\n");
+  cv = mci (&cv, 25, CONSTA);
+  if (cv [9] != CONSTA)
+    abort ();
+
+  printf ("P\n");
+  cv = mci (&cv, 16, CONSTB);
+  if (cv [0] != CONSTB)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-ulong-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-ulong-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-ulong-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,27 @@
+/* Test to verify that the vec_extract from a vector of
+   unsigned longs remains unsigned.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(unsigned long long int ul) {
+
+  vector unsigned long long int v = vec_splats(ul);
+
+  if (vec_extract (v, 0) < ul)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (0xf600000000000000LL);
+  test1 (0x7600000000000000LL);
+  test1 (0x0600000000000000LL);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-17b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned short s3 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+unsigned short s7 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 7);
+}
+
+unsigned short s21 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned short s30 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned short ms3 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+unsigned short ms7 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 7);
+}
+
+unsigned short ms21 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned short ms30 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned short ci (vector unsigned short v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned short mci (vector unsigned short *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+int main (int argc, unsigned short *argv[]) {
+  vector unsigned short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  unsigned short s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s7 (sv);
+  if (s != CONST7)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST5)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms7 (&sv);
+  if (s != CONST7)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST5)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST7)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-18a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Unsigned Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned int s3 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+unsigned int s1 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 1);
+}
+
+unsigned int s21 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned int s30 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned int ms3 (vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+unsigned int ms1(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 1);
+}
+
+unsigned int ms21(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned int ms30(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned int ci (vector unsigned int v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned int mci(vector unsigned int *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+unsigned int main (int argc, unsigned char *argv[]) {
+  vector unsigned int sv = { CONST0, CONST1, CONST2, CONST3 };
+  unsigned int s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s1 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms1 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST3)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-16d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16d.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16d.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,163 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned char c0 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector unsigned char c9 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 9);
+}
+
+vector unsigned char c21 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector unsigned char c30 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned char mc0 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector unsigned char mc9 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 9);
+}
+
+vector unsigned char mc21 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector unsigned char mc30 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned char ci (vector unsigned char v, int i, unsigned char x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned char mci (vector unsigned char *vp, int i, unsigned char x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector unsigned char cv = { CONST0, CONST1, CONST2, CONST3,
+			      CONST4, CONST5, CONST6, CONST7,
+			      CONST8, CONST9, CONSTA, CONSTB,
+			      CONSTC, CONSTD, CONSTE, CONSTF };
+  cv = c0 (cv, CONST3);
+  if (cv [0] != CONST3)
+    abort ();
+
+  cv = c9 (cv, CONST2);
+  if (cv [9] != CONST2)
+    abort ();
+
+  cv = c21 (cv, CONSTF);
+  if (cv [5] != CONSTF)
+    abort ();
+
+  cv = c30 (cv, CONST3);
+  if (cv [14] != CONST3)
+    abort ();
+
+  cv = mc0 (&cv, CONST4);
+  if (cv [0] != CONST4)
+    abort ();
+
+  cv = mc9 (&cv, CONST3);
+  if (cv [9] != CONST3)
+    abort ();
+
+  cv = mc21 (&cv, CONST1);
+  if (cv [5] != CONST1)
+    abort ();
+
+  cv = mc30 (&cv, CONSTC);
+  if (cv [14] != CONSTC)
+    abort ();
+
+  cv = ci (cv, 8, CONSTD);
+  if (cv [8] != CONSTD)
+    abort ();
+
+  cv = ci (cv, 13, CONST5);
+  if (cv [13] != CONST5)
+    abort ();
+
+  cv = ci (cv, 23, CONST6);
+  if (cv [7] != CONST6)
+    abort ();
+
+  cv = ci (cv, 31, CONST7);
+  if (cv [15] != CONST7)
+    abort ();
+
+  cv = mci (&cv, 5, CONST8);
+  if (cv [5] != CONST8)
+    abort ();
+
+  cv = mci (&cv, 12, CONST9);
+  if (cv [12] != CONST9)
+    abort ();
+
+  cv = mci (&cv, 25, CONSTA);
+  if (cv [9] != CONSTA)
+    abort ();
+
+  cv = mci (&cv, 16, CONSTB);
+  if (cv [0] != CONSTB)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-uchar-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-uchar-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-uchar-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,29 @@
+/* Test to verify that the vec_extract from a vector of
+   unsigned chars remains unsigned.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(unsigned char uc) {
+  int uce;
+
+  vector unsigned char v = vec_splats(uc);
+  uce = vec_extract(v,0);
+
+  if (uce != uc)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (0xf6);
+  test1 (0x76);
+  test1 (0x06);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-17c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17c.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,154 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned short s3 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector unsigned short s7 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 7);
+}
+
+vector unsigned short s21 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector unsigned short s30 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned short ms3 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector unsigned short ms7 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 7);
+}
+
+vector unsigned short ms21 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector unsigned short ms30 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned short ci (vector unsigned short v, int i, unsigned short x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned short mci (vector unsigned short *vp, int i, unsigned short x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, unsigned short *argv[]) {
+  vector unsigned short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+
+  sv = s3 (sv, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = s7 (sv, CONST2);
+  if (sv [7] != CONST2)
+    abort ();
+
+  sv = s21 (sv, CONST3);
+  if (sv [5] != CONST3)
+    abort ();
+
+  sv = s30 (sv, CONST4);
+  if (sv [6] != CONST4)
+    abort ();
+
+  sv = ms3 (&sv, CONST5);
+  if (sv [3] != CONST5)
+    abort ();
+
+  sv = ms7 (&sv, CONST6);
+  if (sv [7] != CONST6)
+    abort ();
+
+  sv = ms21 (&sv, CONST7);
+  if (sv [5] != CONST7)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [6] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST1);
+  if (sv [5] != CONST1)
+    abort ();
+
+  sv = ci (sv, 2, CONST3);
+  if (sv [2] != CONST3)
+    abort ();
+
+  sv = ci (sv, 15, CONST2);
+  if (sv [7] != CONST2)
+    abort ();
+
+  sv = ci (sv, 28, CONST5);
+  if (sv [4] != CONST5)
+    abort ();
+
+  sv = mci (&sv, 5, CONST4);
+  if (sv [5] != CONST4)
+    abort ();
+
+  sv = mci (&sv, 12, CONST6);
+  if (sv [4] != CONST6)
+    abort ();
+
+  sv = mci (&sv, 25, CONST7);
+  if (sv [1] != CONST7)
+    abort ();
+
+  sv = mci (&sv, 16, CONST4);
+  if (sv [0] != CONST4)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-sint-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-sint-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-sint-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,29 @@
+/* Test to verify that the vec_extract from a vector of
+   signed ints remains signed.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(signed int si) {
+  long long int sie;
+
+  vector signed int v = vec_splats(si);
+  sie = vec_extract(v,0);
+
+  if (sie != si)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (0xf6000000);
+  test1 (0x76000000);
+  test1 (0x06000000);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr89765-mc.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr89765-mc.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr89765-mc.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,400 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O2" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <stdlib.h>
+#include <stddef.h>
+#include <altivec.h>
+
+#include <stdio.h>
+
+static vector unsigned __int128
+deoptimize_uint128 (vector unsigned __int128  a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned long long int
+deoptimize_ulong (vector unsigned long long int a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned int
+deoptimize_uint (vector unsigned int a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned char
+deoptimize_uchar (vector unsigned char a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned short
+deoptimize_ushort (vector unsigned short a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+__attribute ((noinline))
+vector unsigned __int128
+set_auto_n_uint128 (vector unsigned __int128 a, int n, unsigned __int128 x)
+{
+  return vec_insert (x, a, n);
+}
+
+__attribute ((noinline))
+vector unsigned long long int
+set_auto_n_ulong (vector unsigned long long int a, int n,
+		  unsigned long long int x)
+{
+  return vec_insert (x, a, n);
+}
+
+__attribute ((noinline))
+vector unsigned int
+set_auto_n_uint (vector unsigned int a, int n, unsigned int x)
+{
+  return vec_insert (x, a, n);
+}
+
+__attribute ((noinline))
+vector unsigned char
+set_auto_n_uchar (vector unsigned char a, int n, unsigned char x)
+{
+  return vec_insert (x, a, n);
+}
+
+__attribute ((noinline))
+vector unsigned short
+set_auto_n_ushort (vector unsigned short a, int n, unsigned short x)
+{
+  return vec_insert (x, a, n);
+}
+
+__attribute ((noinline))
+unsigned __int128
+get_auto_n_uint128 (vector unsigned __int128 a, int n)
+{
+  return vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned long long int
+get_auto_n_ulong (vector unsigned long long int a, int n)
+{
+  return vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned int
+get_auto_n_uint (vector unsigned int a, int n)
+{
+  return vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned char
+get_auto_n_uchar (vector unsigned char a, int n)
+{
+  return vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned short
+get_auto_n_ushort (vector unsigned short a, int n)
+{
+  return vec_extract (a, n);
+}
+
+int check_uint128_element (int i, unsigned __int128 entry)
+{
+  printf ("checking uint128 entry at index %d\n", i);
+
+  return (entry == ((((unsigned __int128) 0xffeeddccbbaa9988ULL) << 64)
+		    | 0x0706050403020100ULL));
+}
+
+unsigned __int128 get_uint128_element (int i)
+{
+  return ((((unsigned __int128) 0xffeeddccbbaa9988ULL) << 64)
+	  | 0x0706050403020100ULL);
+}
+
+int check_ulong_element (int i, unsigned long long int entry)
+{
+  printf ("checking ulong entry 0x%llx at index %d\n", entry, i);
+
+  switch (i % 2)
+    {
+      case 0: return (entry == 0x9999901010ULL);
+      case 1: return (entry == 0x7777733333ULL);
+      default:
+	return 0;
+    }
+}
+
+unsigned long long int get_ulong_element (int i)
+{
+  switch (i % 2)
+    {
+    case 0: return 0x9999901010ULL;
+    case 1: return 0x7777733333ULL;
+    }
+}
+
+int check_uint_element (int i, unsigned int entry)
+{
+  printf ("checking uint entry 0x%x at index %d\n", entry, i);
+
+  switch (i % 4)
+    {
+    case 0: return (entry == 0x99999);
+    case 1: return (entry == 0x01010);
+    case 2: return (entry == 0x77777);
+    case 3: return (entry == 0x33333);
+    default:
+      return 0;
+    }
+}
+
+unsigned int get_uint_element (int i)
+{
+  switch (i % 4)
+    {
+    case 0: return 0x99999;
+    case 1: return 0x01010;
+    case 2: return 0x77777;
+    case 3: return 0x33333;
+    }
+}
+
+int check_uchar_element (int i, unsigned char entry)
+{
+  printf ("checking uchar entry 0x%x at index %d\n", entry, i);
+  switch (i % 16)
+    {
+    case 0: return (entry == 0x90);
+    case 1: return (entry == 0x80);
+    case 2: return (entry == 0x70);
+    case 3: return (entry == 0x60);
+    case 4: return (entry == 0x50);
+    case 5: return (entry == 0x40);
+    case 6: return (entry == 0x30);
+    case 7: return (entry == 0x20);
+    case 8: return (entry == 0x10);
+    case 9: return (entry == 0xf0);
+    case 10: return (entry == 0xe0);
+    case 11: return (entry == 0xd0);
+    case 12: return (entry == 0xc0);
+    case 13: return (entry == 0xb0);
+    case 14: return (entry == 0xa0);
+    case 15: return (entry == 0xff);
+    default:
+      return 0;
+    }
+}
+
+unsigned char get_uchar_element (int i)
+{
+  switch (i % 16)
+    {
+    case 0: return 0x90;
+    case 1: return 0x80;
+    case 2: return 0x70;
+    case 3: return 0x60;
+    case 4: return 0x50;
+    case 5: return 0x40;
+    case 6: return 0x30;
+    case 7: return 0x20;
+    case 8: return 0x10;
+    case 9: return 0xf0;
+    case 10: return 0xe0;
+    case 11: return 0xd0;
+    case 12: return 0xc0;
+    case 13: return 0xb0;
+    case 14: return 0xa0;
+    case 15: return 0xff;
+    }
+}
+
+int check_ushort_element (int i, unsigned short entry)
+{
+  printf ("checking ushort entry 0x%x at index %d\n", entry, i);
+  switch (i % 8)
+    {
+    case 0: return (entry == 0x9988);
+    case 1: return (entry == 0x8877);
+    case 2: return (entry == 0x7766);
+    case 3: return (entry == 0x6655);
+    case 4: return (entry == 0x5544);
+    case 5: return (entry == 0x4433);
+    case 6: return (entry == 0x3322);
+    case 7: return (entry == 0x2211);
+    default:
+      return 0;
+    }
+}
+
+unsigned short get_ushort_element (int i)
+{
+  switch (i % 8)
+    {
+    case 0: return 0x9988;
+    case 1: return 0x8877;
+    case 2: return 0x7766;
+    case 3: return 0x6655;
+    case 4: return 0x5544;
+    case 5: return 0x4433;
+    case 6: return 0x3322;
+    case 7: return 0x2211;
+    }
+}
+
+vector unsigned __int128
+init_auto_uint128 (vector unsigned __int128 a)
+{
+  int i;
+  for (i = 0; i < 32; i += 3)
+    a = set_auto_n_uint128 (a, i, get_uint128_element (i));
+  return a;
+}
+
+void do_auto_uint128 (vector unsigned __int128 a)
+{
+  int i;
+  unsigned __int128 c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uint128 (a, i);
+      if (!check_uint128_element (i, c)) abort ();
+    }
+}
+
+vector unsigned long long int
+init_auto_ulong (vector unsigned long long int a)
+{
+  int i;
+  for (i = 0; i < 32; i += 3)
+    a = set_auto_n_ulong (a, i, get_ulong_element (i));
+  return a;
+}
+
+void do_auto_ulong (vector unsigned long long int a)
+{
+  int i;
+  unsigned long long int c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_ulong (a, i);
+      if (!check_ulong_element (i, c)) abort ();
+    }
+ }
+
+vector unsigned int init_auto_uint (vector unsigned int a)
+{
+  int i;
+  for (i = 0; i < 32; i += 3)
+    a = set_auto_n_uint (a, i, get_uint_element (i));
+  return a;
+}
+
+void do_auto_uint (vector unsigned int a)
+{
+  int i;
+  unsigned int c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uint (a, i);
+      if (!check_uint_element (i, c)) abort ();
+    }
+ }
+
+vector unsigned short init_auto_ushort ( vector unsigned short a )
+{
+  int i;
+  for (i = 0; i < 32; i += 3)
+    a = set_auto_n_ushort (a, i, get_ushort_element (i));
+  return a;
+}
+
+void do_auto_ushort (vector unsigned short a)
+{
+  int i;
+  unsigned short c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_ushort (a, i);
+      if (!check_ushort_element (i, c)) abort ();
+    }
+}
+
+vector unsigned char init_auto_uchar (vector unsigned char a)
+{
+  int i;
+  for (i = 0; i < 32; i += 3)
+    a = set_auto_n_uchar (a, i, get_uchar_element (i));
+  return a;
+}
+
+void do_auto_uchar (vector unsigned char a)
+{
+  int i;
+  unsigned char c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uchar (a, i);
+      if (!check_uchar_element (i, c)) abort ();
+    }
+}
+
+int
+main (void)
+{
+  size_t i;
+
+  vector unsigned __int128 u = { 0 };
+  vector unsigned __int128 du;
+
+  vector unsigned long long int v = { 0, 0 };
+  vector unsigned long long int dv;
+
+  vector unsigned int x = { 0, 0, 0, 0 };
+  vector unsigned int dx;
+
+  vector unsigned char y = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+  vector unsigned char dy;
+
+  vector unsigned short z = { 0, 0, 0, 0, 0, 0, 0, 0 };
+  vector unsigned short dz;
+
+  du = init_auto_uint128 (u);
+  dv = init_auto_ulong (v);
+  dx = init_auto_uint (x);
+  dy = init_auto_uchar (y);
+  dz = init_auto_ushort (z);
+
+  du = deoptimize_uint128 (du);
+  dv = deoptimize_ulong (dv);
+  dx = deoptimize_uint (dx);
+  dy = deoptimize_uchar (dy);
+  dz = deoptimize_ushort (dz);
+
+  do_auto_uint128 (du);
+  do_auto_ulong (dv);
+  do_auto_uint (dx);
+  do_auto_uchar (dy);
+  do_auto_ushort (dz);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-18b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Unsigned Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned int s3 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+unsigned int s1 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 1);
+}
+
+unsigned int s21 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned int s30 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned int ms3 (vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+unsigned int ms1(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 1);
+}
+
+unsigned int ms21(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned int ms30(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned int ci (vector unsigned int v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned int mci(vector unsigned int *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+unsigned int main (int argc, unsigned char *argv[]) {
+  vector unsigned int sv = { CONST0, CONST1, CONST2, CONST3 };
+  unsigned int s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s1 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms1 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST3)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr87532-mc.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr87532-mc.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr87532-mc.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,258 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O2" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <stdlib.h>
+#include <stddef.h>
+#include <altivec.h>
+
+#include <stdio.h>
+
+static vector unsigned __int128
+deoptimize_uint128 (vector unsigned __int128  a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned long long int
+deoptimize_ulong (vector unsigned long long int a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned int
+deoptimize_uint (vector unsigned int a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned char
+deoptimize_uchar (vector unsigned char a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned short
+deoptimize_ushort (vector unsigned short a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+__attribute ((noinline)) unsigned __int128
+get_auto_n_uint128 (vector unsigned __int128 a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+__attribute ((noinline)) unsigned long long int
+get_auto_n_ulong (vector unsigned long long int a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned int get_auto_n_uint (vector unsigned int a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned char get_auto_n_uchar (vector unsigned char a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned short get_auto_n_ushort (vector unsigned short a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+
+int check_uint128_element (int i, unsigned __int128 entry)
+{
+  printf ("checking uint128 entry at index %d\n", i);
+
+  return (entry == ((((unsigned __int128) 0xffeeddccbbaa9988ULL) << 64)
+		    | 0x0706050403020100ULL));
+}
+
+int check_ulong_element (int i, unsigned long long int entry)
+{
+  printf ("checking ulong entry 0x%llx at index %d\n", entry, i);
+
+  switch (i % 2)
+    {
+      case 0: return (entry == 0x9999901010ULL);
+      case 1: return (entry == 0x7777733333ULL);
+      default:
+	return 0;
+    }
+}
+
+int check_uint_element (int i, unsigned int entry)
+{
+  printf ("checking uint entry 0x%x at index %d\n", entry, i);
+
+  switch (i % 4)
+    {
+    case 0: return (entry == 0x99999);
+    case 1: return (entry == 0x01010);
+    case 2: return (entry == 0x77777);
+    case 3: return (entry == 0x33333);
+    default:
+      return 0;
+    }
+}
+
+int check_uchar_element (int i, unsigned char entry)
+{
+  printf ("checking uchar entry 0x%x at index %d\n", entry, i);
+  switch (i % 16)
+    {
+    case 0: return (entry == 0x90);
+    case 1: return (entry == 0x80);
+    case 2: return (entry == 0x70);
+    case 3: return (entry == 0x60);
+    case 4: return (entry == 0x50);
+    case 5: return (entry == 0x40);
+    case 6: return (entry == 0x30);
+    case 7: return (entry == 0x20);
+    case 8: return (entry == 0x10);
+    case 9: return (entry == 0xf0);
+    case 10: return (entry == 0xe0);
+    case 11: return (entry == 0xd0);
+    case 12: return (entry == 0xc0);
+    case 13: return (entry == 0xb0);
+    case 14: return (entry == 0xa0);
+    case 15: return (entry == 0xff);
+    default:
+      return 0;
+    }
+}
+
+int check_ushort_element (int i, unsigned short entry)
+{
+  printf ("checking ushort entry 0x%x at index %d\n", entry, i);
+  switch (i % 8)
+    {
+    case 0: return (entry == 0x9988);
+    case 1: return (entry == 0x8877);
+    case 2: return (entry == 0x7766);
+    case 3: return (entry == 0x6655);
+    case 4: return (entry == 0x5544);
+    case 5: return (entry == 0x4433);
+    case 6: return (entry == 0x3322);
+    case 7: return (entry == 0x2211);
+    default:
+      return 0;
+    }
+}
+
+void do_auto_uint128 ( vector unsigned __int128 a )
+{
+  int i;
+  unsigned __int128 c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uint128 (a,i);
+      if (!check_uint128_element (i, c)) abort ();
+    }
+ }
+
+void do_auto_ulong ( vector unsigned long long int a )
+{
+  int i;
+  unsigned long long int c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_ulong (a,i);
+      if (!check_ulong_element (i, c)) abort ();
+    }
+ }
+
+void do_auto_uint ( vector unsigned int a )
+{
+  int i;
+  unsigned int c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uint (a,i);
+      if (!check_uint_element (i, c)) abort ();
+    }
+ }
+
+void do_auto_ushort ( vector unsigned short a )
+{
+  int i;
+  unsigned short c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_ushort (a,i);
+      if (!check_ushort_element (i, c)) abort ();
+    }
+}
+
+void do_auto_uchar ( vector unsigned char a )
+{
+  int i;
+  unsigned char c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uchar (a,i);
+      if (!check_uchar_element (i, c)) abort ();
+    }
+}
+
+int
+main (void)
+{
+  size_t i;
+
+  vector unsigned __int128 u = {
+    ((((unsigned __int128) 0xffeeddccbbaa9988ULL) << 64)
+     | 0x0706050403020100ULL) };
+  vector unsigned __int128 du;
+
+  vector unsigned long long int v = { 0x9999901010ULL, 0x7777733333ULL };
+  vector unsigned long long int dv;
+
+  vector unsigned int x = { 0x99999, 0x01010, 0x77777, 0x33333 };
+  vector unsigned int dx;
+
+  vector unsigned char y = { 0x90, 0x80, 0x70, 0x60, 0x50, 0x40, 0x30, 0x20,
+			     0x10, 0xf0, 0xe0, 0xd0, 0xc0, 0xb0, 0xa0, 0xff };
+  vector unsigned char dy;
+
+  vector unsigned short z = { 0x9988, 0x8877, 0x7766, 0x6655,
+			      0x5544, 0x4433, 0x3322, 0x2211 };
+  vector unsigned short dz;
+
+  do_auto_uint128 (u);
+  do_auto_ulong (v);
+  do_auto_uint (x);
+  do_auto_uchar (y);
+  do_auto_ushort (z);
+
+  du = deoptimize_uint128 (u);
+  dv = deoptimize_ulong (v);
+  dx = deoptimize_uint (x);
+  dy = deoptimize_uchar (y);
+  dz = deoptimize_ushort (z);
+
+  do_auto_uint128 (du);
+  do_auto_ulong (dv);
+  do_auto_uint (dx);
+  do_auto_uchar (dy);
+  do_auto_ushort (dz);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr87496-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr87496-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr87496-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,11 @@
+/* PR target/87496 */
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
+/* { dg-require-effective-target longdouble128 } */
+/* { dg-options "-O2 -mcpu=power7 -mabi=ieeelongdouble -mno-popcntd -Wno-psabi" } */
+
+int i;
+
+/* { dg-error "'-mabi=ieeelongdouble' requires full ISA 2.06 support" "PR87496" { target *-*-* } 0 } */
+/* { dg-warning "using IEEE extended precision long double" "" { target *-*-* } 0 } */
Index: gcc/testsuite/gcc.target/powerpc/ppc-fortran/ppc-fortran.exp
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/ppc-fortran/ppc-fortran.exp	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/ppc-fortran/ppc-fortran.exp	(.../branches/gcc-7-branch)
@@ -36,7 +36,7 @@
     global gfortran_test_path
     global gfortran_aux_module_flags
     if { [llength $args] != 2 } {
-	error "dg-set-target-env-var: needs one argument"
+	error "dg-compile-aux-modules: needs one argument"
 	return
     }
 
Index: gcc/testsuite/gcc.target/powerpc/darwin-bool-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/darwin-bool-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/darwin-bool-1.c	(.../branches/gcc-7-branch)
@@ -1,6 +1,8 @@
 /* Check that sizeof(bool) is 4 if we don't use special options. */
 /* Matt Austern  <austern@apple.com> */
 /* { dg-do run { target { powerpc*-*-darwin* && ilp32 } } } */
+/* We do need to suppress the ISO C doesn't support _Bool message tho.  */
+/* { dg-options "-Wno-pedantic" } */
 
 int dummy1[sizeof(_Bool) - 3];
 int dummy2[5 - sizeof(_Bool)];
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-19a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,109 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned long long int e0 (vector unsigned long long int v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned long long int e3 (vector unsigned long long int v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+unsigned long long int me0 (vector unsigned long long int *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned long long int me3 (vector unsigned long long int *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned long long int ei (vector unsigned long long int v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+unsigned long long int mei (vector unsigned long long int *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned long long int dv = { CONST0, CONST1 };
+  unsigned long long int d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-17d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17d.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17d.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,154 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned short s3 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector unsigned short s7 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 7);
+}
+
+vector unsigned short s21 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector unsigned short s30 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned short ms3 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector unsigned short ms7 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 7);
+}
+
+vector unsigned short ms21 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector unsigned short ms30 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned short ci (vector unsigned short v, int i, unsigned short x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned short mci (vector unsigned short *vp, int i, unsigned short x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, unsigned short *argv[]) {
+  vector unsigned short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+
+  sv = s3 (sv, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = s7 (sv, CONST2);
+  if (sv [7] != CONST2)
+    abort ();
+
+  sv = s21 (sv, CONST3);
+  if (sv [5] != CONST3)
+    abort ();
+
+  sv = s30 (sv, CONST4);
+  if (sv [6] != CONST4)
+    abort ();
+
+  sv = ms3 (&sv, CONST5);
+  if (sv [3] != CONST5)
+    abort ();
+
+  sv = ms7 (&sv, CONST6);
+  if (sv [7] != CONST6)
+    abort ();
+
+  sv = ms21 (&sv, CONST7);
+  if (sv [5] != CONST7)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [6] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST1);
+  if (sv [5] != CONST1)
+    abort ();
+
+  sv = ci (sv, 2, CONST3);
+  if (sv [2] != CONST3)
+    abort ();
+
+  sv = ci (sv, 15, CONST2);
+  if (sv [7] != CONST2)
+    abort ();
+
+  sv = ci (sv, 28, CONST5);
+  if (sv [4] != CONST5)
+    abort ();
+
+  sv = mci (&sv, 5, CONST4);
+  if (sv [5] != CONST4)
+    abort ();
+
+  sv = mci (&sv, 12, CONST6);
+  if (sv [4] != CONST6)
+    abort ();
+
+  sv = mci (&sv, 25, CONST7);
+  if (sv [1] != CONST7)
+    abort ();
+
+  sv = mci (&sv, 16, CONST4);
+  if (sv [0] != CONST4)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/builtins-3-p9-runnable.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/builtins-3-p9-runnable.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/builtins-3-p9-runnable.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,35 @@
+/* { dg-do run { target { powerpc64*-*-* && { lp64 && p9vector_hw } } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-mcpu=power9 -O2 -mupper-regs-di" } */
+
+#include <altivec.h> // vector
+
+void abort (void);
+
+int main() {
+   int i;
+   vector float vfr, vfexpt;
+   vector unsigned short vusha;
+
+   /* 1.0, -2.0, 0.0, 8.5, 1.5, 0.5, 1.25, -0.25 */
+   vusha = (vector unsigned short){0B011110000000000, 0B1100000000000000,
+                                   0B000000000000000, 0B0100100001000000,
+                                   0B011111000000000, 0B0011100000000000,
+                                   0B011110100000000, 0B1011010000000000};
+   
+   vfexpt = (vector float){1.0, -2.0, 0.0, 8.5};
+   vfr = vec_extract_fp_from_shorth(vusha);
+
+   for (i=0; i<4; i++) {
+      if (vfr[i] != vfexpt[i])
+         abort();
+   }
+
+   vfexpt = (vector float){1.5, 0.5, 1.25, -0.25};
+   vfr = vec_extract_fp_from_shortl(vusha);
+
+   for (i=0; i<4; i++) {
+      if (vfr[i] != vfexpt[i])
+         abort();
+   }
+}
Index: gcc/testsuite/gcc.target/powerpc/pr89424-0.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr89424-0.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr89424-0.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,76 @@
+/* { dg-do run { target { powerpc*-*-* && lp64 } } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+/* Define PR89626 after that pr is addressed.  */
+#ifdef PR89626
+#define SIGNED
+#else
+#define SIGNED signed
+#endif
+
+#define CONST0		(((__int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+__int128 ei (vector SIGNED __int128 v, int i)
+{
+  return __builtin_vec_ext_v1ti (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__int128 mei (vector SIGNED __int128 *vp, int i)
+{
+  return __builtin_vec_ext_v1ti (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector SIGNED __int128 dv = { CONST0 };
+  __int128 d;
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-18c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18c.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,148 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Unsigned Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned int s3 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector unsigned int s1 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector unsigned int s21 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector unsigned int s30 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned int ms3 (vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector unsigned int ms1(vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector unsigned int ms21(vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector unsigned int ms30(vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned int ci (vector unsigned int v, int i, unsigned int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned int mci(vector unsigned int *vp, int i, unsigned int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, unsigned char *argv[]) {
+  vector unsigned int sv = { CONST0, CONST1, CONST2, CONST3 };
+
+  sv = s3 (sv, CONST2);
+  if (sv [3] != CONST2)
+    abort ();
+
+  sv = s1 (sv, CONST2);
+  if (sv [1] != CONST2)
+    abort ();
+
+  sv = s21 (sv, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = s30 (sv, CONST1);
+  if (sv [2] != CONST1)
+    abort ();
+
+  sv = ms3 (&sv, CONST0);
+  if (sv [3] != CONST0)
+    abort ();
+
+  sv = ms1 (&sv, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = ms21 (&sv, CONST1);
+  if (sv [1] != CONST1)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [2] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = ci (sv, 2, CONST0);
+  if (sv [2] != CONST0)
+    abort ();
+
+  sv = ci (sv, 15, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = ci (sv, 28, CONST3);
+  if (sv [0] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 5, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = mci (&sv, 12, CONST2);
+  if (sv [0] != CONST2)
+    abort ();
+
+  sv = mci (&sv, 25, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 16, CONST1);
+  if (sv [0] != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-1.c	(.../branches/gcc-7-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-skip-if "not implemented for Darwin" { powerpc*-*-darwin* } } */
 /* { dg-additional-options "-mno-speculate-indirect-jumps" } */
 /* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
Index: gcc/testsuite/gcc.target/arm/pr88648-asm-syntax-unified.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/pr88648-asm-syntax-unified.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/arm/pr88648-asm-syntax-unified.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,14 @@
+/* Test for unified syntax assembly generation.  */
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_arch_v7a_ok } */
+/* { dg-add-options arm_arch_v7a } */
+/* { dg-options "-marm -march=armv7-a -masm-syntax-unified" } */
+
+void test ()
+{
+  asm("nop");
+}
+
+/* { dg-final { scan-assembler-times {\.syntax\sunified} 3 } } */
+/* { dg-final { scan-assembler-not {\.syntax\sdivided} } } */
+
Index: gcc/testsuite/gcc.target/arm/pr88167-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/pr88167-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/arm/pr88167-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb1_ok } */
+/* { dg-options "-O2 -mthumb" }  */
+
+void *retaddr;
+
+void foo (void) {
+  retaddr = __builtin_return_address (0);
+
+  /* Used for enforcing registers stacking.  */
+  asm volatile ("" : : : "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
+			 "r8", "r9", "r10", "r11", "r12");
+}
+
+/* { dg-final { scan-assembler-not "mov\tlr," } } */
Index: gcc/testsuite/gcc.target/arm/pr88167-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/pr88167-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/arm/pr88167-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,18 @@
+/* { dg-do run } */
+/* { dg-options "-O2" }  */
+/* { dg-skip-if "" { ! { arm_thumb1 } } } */
+
+int __attribute__((noclone, noinline))
+foo (int a, long long b) {
+  /* Used for enforcing registers stacking.  */
+  asm volatile ("" : : : "r0", "r1", "r2", "r3",
+			 "r8", "r9", "r10", "r11", "r12");
+  return (int) b;
+}
+
+int main ()
+{
+  if (foo (1, 0x1000000000000003LL) != 3)
+    __builtin_abort ();
+  __builtin_exit (0);
+}
Index: gcc/testsuite/gcc.target/arm/pr89222.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/pr89222.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/arm/pr89222.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,32 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void g (void);
+
+void f1 (int x)
+{
+  if (x != (int) g + 3)
+    return;
+  g();
+}
+
+void (*a2)(void);
+
+void f2 (void)
+{
+  a2 = &g + 3;
+}
+
+typedef void (*__sighandler_t)(int);
+void handler (int);
+
+void f3 (int x)
+{
+  __sighandler_t h = &handler;
+  if (h != (__sighandler_t) 2 && h != (__sighandler_t) 1)
+    h (x);
+}
+
+/* { dg-final { scan-assembler-times {add(?:s)?\tr[0-9]+, r[0-9]+, #3} 2 } } */
+/* { dg-final { scan-assembler-not {.word\tg\+3} } } */
+/* { dg-final { scan-assembler-not {.word\thandler-1} } } */
Index: gcc/testsuite/gcc.target/arm/f16_f64_conv_no_dp.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/f16_f64_conv_no_dp.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/arm/f16_f64_conv_no_dp.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_fp16_ok } */
+/* { dg-skip-if "do not override fpu" { *-*-* } { "-mfpu=*" } { "-mfpu=fpv5-sp-d16" } } */
+/* { dg-skip-if "do not disable fpu" { *-*-* } { "-mfloat-abi=soft" } { * } } */
+/* { dg-skip-if "do not override fp16-format" { *-*-* } { "-mfp16-format=*" } { "-mfp16-format=ieee" } } */
+/* { dg-options "-O1 -mfpu=fpv5-sp-d16 -mfloat-abi=hard -mfp16-format=ieee" } */
+
+__fp16 foo (double a)
+{
+  return a;
+}
+
+double bar (__fp16 a)
+{
+  return a;
+}
Index: gcc/testsuite/gcc.target/avr/pr88253.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/avr/pr88253.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/avr/pr88253.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-Os -w" } */
+ 
+static int aRead() __attribute__((always_inline));
+static int aRead() {
+    unsigned char h,l;
+    l = (*(volatile unsigned char *)(0x78)) ;
+    h = (*(volatile unsigned char *)(0x79)) ;
+    return (h<<8) | l;
+}
+ 
+int main() {
+    volatile unsigned char x;
+     x = aRead()^42;
+ }
+ /* { dg-final { scan-assembler "lds r\\d+,121" } } */
Index: gcc/testsuite/gcc.target/s390/zvector/vec-double-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/zvector/vec-double-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/s390/zvector/vec-double-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -march=z13 -mzvector" } */
+
+#include <vecintrin.h>
+
+vector double
+test (vector unsigned long long x)
+{
+  return vec_double (x);
+}
+
+/* { dg-final { scan-assembler-times "vcdlgb\t" 1 } } */
Index: gcc/testsuite/gcc.target/s390/zvector/vec-double-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/zvector/vec-double-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/s390/zvector/vec-double-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -march=z13 -mzvector" } */
+
+#include <vecintrin.h>
+
+vector double
+test (vector long long x)
+{
+  return vec_double (x);
+}
+
+/* { dg-final { scan-assembler-times "vcdgb\t" 1 } } */
Index: gcc/testsuite/gcc.target/s390/vector/vec-shift-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/vector/vec-shift-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/s390/vector/vec-shift-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,24 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -mzarch -march=z13 --save-temps" } */
+
+/* { dg-final { scan-assembler-times "veslf" 1 } } */
+
+typedef __attribute__((vector_size(16))) signed int v4si;
+
+v4si __attribute__((noinline,noclone))
+shift_left_by_scalar (v4si in, int shift_count)
+{
+  return in << (3 + shift_count);
+}
+
+int
+main ()
+{
+  v4si a = { 1, 2, 3, 4 };
+  v4si result = shift_left_by_scalar (a, 1);
+
+  if (result[1] != 32)
+    __builtin_abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/sparc/tls-ld-int64.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sparc/tls-ld-int64.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/sparc/tls-ld-int64.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,24 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" }
+/* { dg-add-options tls } */
+/* { dg-require-effective-target lp64 } */
+
+#include <stdint.h>
+
+__thread int64_t var1 __attribute__((tls_model("local-dynamic")));
+__thread int64_t var2 __attribute__((tls_model("local-dynamic")));
+
+int64_t sum (void)
+{
+  return var1 + var2;
+}
+
+void set (int64_t i)
+{
+  var1 = i;
+  var2 = i;
+}
+
+/* { dg-final { scan-assembler-times "__tls_get_addr" 2 } } */
+/* { dg-final { scan-assembler-times "ldx\t\[^\n\]*tldo_add" 2 } } */
+/* { dg-final { scan-assembler-times "stx\t\[^\n\]*tldo_add" 2 } } */
Index: gcc/testsuite/gcc.target/sparc/tls-ld-uint16.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sparc/tls-ld-uint16.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/sparc/tls-ld-uint16.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,33 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" }
+/* { dg-add-options tls } */
+
+#include <stdint.h>
+
+__thread uint16_t var1 __attribute__((tls_model("local-dynamic")));
+__thread uint16_t var2 __attribute__((tls_model("local-dynamic")));
+
+uint16_t sum (void)
+{
+  return var1 + var2;
+}
+
+uint32_t ext32_sum (void)
+{
+  return (uint32_t)var1 + (uint32_t)var2;
+}
+
+unsigned long ext_sum (void)
+{
+  return (unsigned long)var1 + (unsigned long)var2;
+}
+
+void set (uint16_t i)
+{
+  var1 = i;
+  var2 = i;
+}
+
+/* { dg-final { scan-assembler-times "__tls_get_addr" 4 } } */
+/* { dg-final { scan-assembler-times "lduh\t\[^\n\]*tldo_add" 6 } } */
+/* { dg-final { scan-assembler-times "sth\t\[^\n\]*tldo_add" 2 } } */
Index: gcc/testsuite/gcc.target/sparc/tls-ld-int32.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sparc/tls-ld-int32.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/sparc/tls-ld-int32.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,36 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" }
+/* { dg-add-options tls } */
+
+#include <stdint.h>
+
+__thread int32_t var1 __attribute__((tls_model("local-dynamic")));
+__thread int32_t var2 __attribute__((tls_model("local-dynamic")));
+
+int32_t sum (void)
+{
+  return var1 + var2;
+}
+
+#if defined(__sparcv9) || defined(__arch64__)
+long ext_sum (void)
+{
+  return (long)var1 + (long)var2;
+}
+#else
+void *addr (void)
+{
+  return &var1;
+}
+#endif
+
+void set (int32_t i)
+{
+  var1 = i;
+  var2 = i;
+}
+
+/* { dg-final { scan-assembler-times "__tls_get_addr" 3 } } */
+/* { dg-final { scan-assembler-times "ld\t\[^\n\]*tldo_add" 2 } } */
+/* { dg-final { scan-assembler-times "ldsw\t\[^\n\]*tldo_add" 2 { target lp64 } } } */
+/* { dg-final { scan-assembler-times "st\t\[^\n\]*tldo_add" 2 } } */
Index: gcc/testsuite/gcc.target/sparc/tls-ld-uint8.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sparc/tls-ld-uint8.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/sparc/tls-ld-uint8.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,38 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" }
+/* { dg-add-options tls } */
+
+#include <stdint.h>
+
+__thread uint8_t var1 __attribute__((tls_model("local-dynamic")));
+__thread uint8_t var2 __attribute__((tls_model("local-dynamic")));
+
+uint8_t sum (void)
+{
+  return var1 + var2;
+}
+
+uint16_t ext16_sum (void)
+{
+  return (uint16_t)var1 + (uint16_t)var2;
+}
+
+uint32_t ext32_sum (void)
+{
+  return (uint32_t)var1 + (uint32_t)var2;
+}
+
+unsigned long ext_sum (void)
+{
+  return (unsigned long)var1 + (unsigned long)var2;
+}
+
+void set (uint8_t i)
+{
+  var1 = i;
+  var2 = i;
+}
+
+/* { dg-final { scan-assembler-times "__tls_get_addr" 5 } } */
+/* { dg-final { scan-assembler-times "ldub\t\[^\n\]*tldo_add" 8 } } */
+/* { dg-final { scan-assembler-times "stb\t\[^\n\]*tldo_add" 2 } } */
Index: gcc/testsuite/gcc.target/sparc/tls-ld-int8.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sparc/tls-ld-int8.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/sparc/tls-ld-int8.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,39 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" }
+/* { dg-add-options tls } */
+
+#include <stdint.h>
+
+__thread int8_t var1 __attribute__((tls_model("local-dynamic")));
+__thread int8_t var2 __attribute__((tls_model("local-dynamic")));
+
+int8_t sum (void)
+{
+  return var1 + var2;
+}
+
+int16_t ext16_sum (void)
+{
+  return (int16_t)var1 + (int16_t)var2;
+}
+
+int32_t ext32_sum (void)
+{
+  return (int32_t)var1 + (int32_t)var2;
+}
+
+long ext_sum (void)
+{
+  return (long)var1 + (long)var2;
+}
+
+void set (int8_t i)
+{
+  var1 = i;
+  var2 = i;
+}
+
+/* { dg-final { scan-assembler-times "__tls_get_addr" 5 } } */
+/* { dg-final { scan-assembler-times "ldub\t\[^\n\]*tldo_add" 2 } } */
+/* { dg-final { scan-assembler-times "ldsb\t\[^\n\]*tldo_add" 6 } } */
+/* { dg-final { scan-assembler-times "stb\t\[^\n\]*tldo_add" 2 } } */
Index: gcc/testsuite/gcc.target/sparc/tls-ld-int16.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sparc/tls-ld-int16.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/sparc/tls-ld-int16.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,34 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" }
+/* { dg-add-options tls } */
+
+#include <stdint.h>
+
+__thread int16_t var1 __attribute__((tls_model("local-dynamic")));
+__thread int16_t var2 __attribute__((tls_model("local-dynamic")));
+
+int16_t sum (void)
+{
+  return var1 + var2;
+}
+
+int32_t ext32_sum (void)
+{
+  return (int32_t)var1 + (int32_t)var2;
+}
+
+long ext_sum (void)
+{
+  return (long)var1 + (long)var2;
+}
+
+void set (int16_t i)
+{
+  var1 = i;
+  var2 = i;
+}
+
+/* { dg-final { scan-assembler-times "__tls_get_addr" 4 } } */
+/* { dg-final { scan-assembler-times "lduh\t\[^\n\]*tldo_add" 2 } } */
+/* { dg-final { scan-assembler-times "ldsh\t\[^\n\]*tldo_add" 4 } } */
+/* { dg-final { scan-assembler-times "sth\t\[^\n\]*tldo_add" 2 } } */
Index: gcc/testsuite/gcc.target/sparc/tls-ld-uint32.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sparc/tls-ld-uint32.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/sparc/tls-ld-uint32.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,36 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" }
+/* { dg-add-options tls } */
+
+#include <stdint.h>
+
+__thread uint32_t var1 __attribute__((tls_model("local-dynamic")));
+__thread uint32_t var2 __attribute__((tls_model("local-dynamic")));
+
+uint32_t sum (void)
+{
+  return var1 + var2;
+}
+
+#if defined(__sparcv9) || defined(__arch64__)
+unsigned long ext_sum (void)
+{
+  return (unsigned long)var1 + (unsigned long)var2;
+}
+#else
+void *addr (void)
+{
+  return &var1;
+}
+#endif
+
+void set (int32_t i)
+{
+  var1 = i;
+  var2 = i;
+}
+
+/* { dg-final { scan-assembler-times "__tls_get_addr" 3 } } */
+/* { dg-final { scan-assembler-times "ld\t\[^\n\]*tldo_add" 2 } } */
+/* { dg-final { scan-assembler-times "lduw\t\[^\n\]*tldo_add" 2 { target lp64 } } } */
+/* { dg-final { scan-assembler-times "st\t\[^\n\]*tldo_add" 2 } } */
Index: gcc/testsuite/gcc.target/sparc/struct-ret-check-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sparc/struct-ret-check-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/sparc/struct-ret-check-1.c	(.../branches/gcc-7-branch)
@@ -7,7 +7,7 @@
 
 /* Origin: Carlos O'Donell <carlos@codesourcery.com> */
 /* { dg-do run { target sparc*-*-solaris* sparc*-*-linux* sparc*-*-*bsd* } } */
-/* { dg-options "-mstd-struct-return" } */
+/* { dg-options "-mstd-struct-return -fno-pie" } */
 /* { dg-require-effective-target ilp32 } */
 #include <stdio.h>
 #include <stdlib.h>
Index: gcc/testsuite/gcc.target/sparc/20161111-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sparc/20161111-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/sparc/20161111-1.c	(.../branches/gcc-7-branch)
@@ -14,4 +14,4 @@
   return retval;
 }
 
-/* { dg-final { scan-assembler-not "and\t%" } } */
+/* { dg-final { scan-assembler-not "and\t%" { xfail *-*-* } } } */
Index: gcc/testsuite/gcc.target/aarch64/pr90075.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/pr90075.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/pr90075.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-O1" } */
+
+typedef struct {
+  float one, two;
+} twofloats;
+
+float
+bug (twofloats tf)
+{
+  float f1, f2;
+  union {
+    twofloats tfloats;
+    float arr[2];
+  } utfloats;
+
+  utfloats.tfloats = tf;
+  f1 = utfloats.arr[1];
+  f2 = __builtin_copysignf (0, f1);
+  return f2;
+}
Index: gcc/testsuite/gcc.target/i386/pr52146.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr52146.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr52146.c	(.../branches/gcc-7-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -mx32" } */
 
 void
Index: gcc/testsuite/gcc.target/i386/pr89523-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-4.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-4.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,36 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -march=haswell" } */
+/* { dg-final { scan-assembler-not "\tvgather" } } */
+/* { dg-final { scan-assembler "addr32 vgather" } } */
+
+typedef double __v2df __attribute__ ((__vector_size__ (16)));
+typedef int __v4si __attribute__ ((__vector_size__ (16)));
+typedef long long __v2di __attribute__ ((__vector_size__ (16)));
+
+typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));
+typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));
+
+extern __inline __m128d
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm_i32gather_pd (double const *__base, __m128i __index, const int __scale)
+{
+  __v2df __zero = { 0.0, 0.0 };
+  __v2df __mask = __builtin_ia32_cmpeqpd (__zero, __zero);
+  __v2df x = x;
+
+  return (__m128d) __builtin_ia32_gathersiv2df (x,
+						__base,
+						(__v4si)__index,
+						__mask,
+						__scale);
+}
+
+__m128d x;
+__m128i idx;
+
+void extern
+avx2_test (void)
+{
+  x = _mm_i32gather_pd ((void *) 0, idx, 1);
+}
Index: gcc/testsuite/gcc.target/i386/pr66819-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr66819-4.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr66819-4.c	(.../branches/gcc-7-branch)
@@ -1,6 +1,6 @@
 /* { dg-do compile { target ia32 } } */
 /* { dg-options "-O2 -mregparm=3" } */
-/* { dg-final { scan-assembler-not "call" } } */
+/* { dg-final { scan-assembler-not {call[ \t]+_?bar} } } */
 
 #include <stdarg.h>
 
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -12,10 +13,12 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler-times {jmp[ \t]*\.?LIND} 2 } } */
+/* { dg-final { scan-assembler-times {call[ \t]*\.?LIND} 2 } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
Index: gcc/testsuite/gcc.target/i386/pr32219-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr32219-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr32219-1.c	(.../branches/gcc-7-branch)
@@ -12,7 +12,11 @@
   return xxx;
 }
 
-/* { dg-final { scan-assembler "movl\[ \t\]xxx\\(%rip\\), %eax" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler-not "xxx@GOTPCREL" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %eax" { target ia32 } } } */
-/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %eax" { target ia32 } } } */
+/* { dg-final { scan-assembler {movl[ \t]_?xxx\(%rip\),[ \t]%eax} { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler-not "_?xxx@GOTPCREL" { target { ! ia32 } } } } */
+
+/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %eax" { target { ia32 && { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler-not "movl\[ \t\]_?xxx@GOT\\(%\[^,\]*\\), %eax" { target { ia32 && { ! *-*-darwin* } } } } } */
+
+/* For Darwin, we default to PIC - but that's needed for Darwin's PIE.  */
+/* { dg-final { scan-assembler {movl[ \t]_xxx-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-1.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk" } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,9 +12,11 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/pr52857-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr52857-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr52857-1.c	(.../branches/gcc-7-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-g -O -mx32 -maddress-mode=long" } */
 
 extern void get_BID128 (int *);
Index: gcc/testsuite/gcc.target/i386/pr52698.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr52698.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr52698.c	(.../branches/gcc-7-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -mx32 -maddress-mode=long" } */
 
 extern void abort (void);
Index: gcc/testsuite/gcc.target/i386/ret-thunk-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-1.c	(.../branches/gcc-7-branch)
@@ -6,8 +6,8 @@
 {
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-10.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-10.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-10.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mno-indirect-branch-register -mfunction-return=thunk-inline -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mno-indirect-branch-register -mfunction-return=thunk-inline -mindirect-branch=thunk " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*bar) (void);
 
@@ -10,11 +11,11 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-times {\tpause} 2 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 2 } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "_?__x86_indirect_thunk_(r|e)ax:" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/pr55049-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr55049-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr55049-1.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile { target { ! ia32 } } } */
 /* { dg-require-effective-target fpic } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -fPIC -mx32" } */
 
 extern void __morestack_fail (const char *msg);
Index: gcc/testsuite/gcc.target/i386/pr54157.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr54157.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr54157.c	(.../branches/gcc-7-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -mx32 -maddress-mode=long -ftree-vectorize" } */
 
 struct s2{
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -12,9 +13,11 @@
   dispatch[offset](offset);
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/pr59874-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr59874-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr59874-3.c	(.../branches/gcc-7-branch)
@@ -1,7 +1,8 @@
 /* PR target/59874 */
 /* { dg-do compile } */
 /* { dg-options "-O2 -mpopcnt -masm=att" } */
-/* { dg-final { scan-assembler "popcntw" } } */
+/* { dg-final { scan-assembler "\tpopcntw" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "\tpopcnt" { target *-*-darwin* } } } */
 
 unsigned int
 foo (unsigned short x)
Index: gcc/testsuite/gcc.target/i386/ret-thunk-25.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-25.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-25.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* PR target/r84530 */
 /* { dg-do compile { target ia32 } } */
+/* { dg-skip-if "ABI differs for return complex value" { *-*-darwin* } } */
 /* { dg-options "-O2 -mfunction-return=thunk -fcheck-pointer-bounds -mmpx -fno-pic" } */
 
 struct s { _Complex unsigned short x; };
Index: gcc/testsuite/gcc.target/i386/pr91704.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr91704.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr91704.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,14 @@
+/* PR target/91704 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -funsigned-char -mavx2 -mavx512f -masm=att" } */
+/* { dg-final { scan-assembler-times "\tvpcmpgtb\t%ymm" 1 } } */
+/* { dg-final { scan-assembler-not "\tvpsubusb\t" } } */
+/* { dg-final { scan-assembler-not "\tvpcmpeqb\t" } } */
+
+#include <x86intrin.h>
+
+__m256i
+foo (__m256i x, __m256i y)
+{
+  return _mm256_cmpgt_epi8 (x, y);
+}
Index: gcc/testsuite/gcc.target/i386/ret-thunk-9.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-9.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-9.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mno-indirect-branch-register -mfunction-return=thunk -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mno-indirect-branch-register -mfunction-return=thunk -mindirect-branch=thunk " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*bar) (void);
 
@@ -10,12 +11,14 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "__x86_return_thunk:" } } */
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?bar" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk" } } */
+/* { dg-final { scan-assembler {jmp[ \t]+\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]+\.?LIND} } } */
+/* { dg-final { scan-assembler "_?__x86_return_thunk:" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_bar} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_bar\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler-times {\tpause} 2 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 2 } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/pr63538.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr63538.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr63538.c	(.../branches/gcc-7-branch)
@@ -9,5 +9,5 @@
 {
   return str;
 }
-
-/* { dg-final { scan-assembler "movabs" } } */
+/* See PR90698 re. Darwin xfail.  */
+/* { dg-final { scan-assembler "movabs" { xfail { *-*-darwin* } } } } */
Index: gcc/testsuite/gcc.target/i386/pr49866.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr49866.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr49866.c	(.../branches/gcc-7-branch)
@@ -1,6 +1,7 @@
 /* PR target/49866 */
-/* { dg-do assemble } */
-/* { dg-options "-O2 -mcmodel=large" { target lp64 } } */
+/* { dg-do assemble { target lp64 } } */
+/* { dg-xfail-if "PR90698" { *-*-darwin* } } */
+/* { dg-options "-O2 -mcmodel=large"  } */
 
 void fn (void *, int, int);
 int fn2 (void);
Index: gcc/testsuite/gcc.target/i386/pr67985-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr67985-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr67985-2.c	(.../branches/gcc-7-branch)
@@ -10,4 +10,4 @@
 
 /* { dg-final { scan-assembler-not "mulss" } } */
 /* { dg-final { scan-assembler-not "movl\[ \t\].*, %eax" } } */
-/* { dg-final { scan-assembler "call\[ \t\]__mulsf3" } } */
+/* { dg-final { scan-assembler "call\[ \t\]_?__mulsf3" } } */
Index: gcc/testsuite/gcc.target/i386/pr89523-5.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-5.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-5.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,39 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512pf" } */
+/* { dg-final { scan-assembler "\tvgather" } } */
+/* { dg-final { scan-assembler-not "addr32 vgather" } } */
+
+typedef int __v8si __attribute__ ((__vector_size__ (32)));
+typedef long long __m256i __attribute__ ((__vector_size__ (32),
+					  __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_prefetch_i32gather_pd (__m256i __index, void const *__addr,
+			      int __scale, int __hint)
+{
+  __builtin_ia32_gatherpfdpd ((__mmask8) 0xFF, (__v8si) __index, __addr,
+			      __scale, __hint);
+}
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_mask_prefetch_i32gather_pd (__m256i __index, __mmask8 __mask,
+				   void const *__addr, int __scale, int __hint)
+{
+  __builtin_ia32_gatherpfdpd (__mask, (__v8si) __index, __addr, __scale,
+			      __hint);
+}
+
+volatile __m256i idx;
+volatile __mmask8 m8;
+void *base;
+
+void extern
+avx512pf_test (void)
+{
+  _mm512_prefetch_i32gather_pd (idx, base, 8, 3);
+  _mm512_mask_prefetch_i32gather_pd (idx, m8, base, 8, 3);
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -12,10 +13,12 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler-times {jmp[ \t]*\.?LIND} 2 } } */
+/* { dg-final { scan-assembler-times {call[ \t]*\.?LIND} 2 } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
Index: gcc/testsuite/gcc.target/i386/pr32219-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr32219-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr32219-2.c	(.../branches/gcc-7-branch)
@@ -12,6 +12,13 @@
 }
 
 /* { dg-final { scan-assembler-not "movl\[ \t\]xxx\\(%rip\\), %" { target { ! ia32 } } } } */
+/* For Darwin m64 we are always PIC, but common symbols are indirected, which happens to
+   match the general "ELF" case.  */
 /* { dg-final { scan-assembler "xxx@GOTPCREL" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %" { target ia32 } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %" { target ia32 } } } */
+
+/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %" { target { ia32 && { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %" { target { ia32 && { ! *-*-darwin* } } } } } */
+
+/* Darwin m32 defaults to PIC but common symbols need to be indirected.  */
+/* { dg-final { scan-assembler {movl[ \t][Ll]_xxx\$non_lazy_ptr-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
+
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-2.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,9 +12,11 @@
   dispatch[offset](offset);
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/pr52857-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr52857-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr52857-2.c	(.../branches/gcc-7-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-g -O -mx32 -maddress-mode=long" } */
 
 void uw_init_context_1 (void *);
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-register-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-register-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-register-1.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mindirect-branch=thunk -mindirect-branch-register -fno-pic" } */
+/* { dg-options "-O2 -mindirect-branch=thunk -mindirect-branch-register " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,12 +12,12 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler "mov\[ \t\](%eax|%rax), \\((%esp|%rsp)\\)" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler-not "push(?:l|q)\[ \t\]*_?dispatch"  } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk\n" } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk_bnd\n" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk\n" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk_bnd\n" } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-2.c	(.../branches/gcc-7-branch)
@@ -6,8 +6,8 @@
 {
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_return_thunk" } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-11.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-11.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-11.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mno-indirect-branch-register -mno-indirect-branch-register -mno-indirect-branch-register -mfunction-return=thunk-extern -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mno-indirect-branch-register -mno-indirect-branch-register -mno-indirect-branch-register -mfunction-return=thunk-extern -mindirect-branch=thunk " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*bar) (void);
 
@@ -10,11 +11,11 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "_?__x86_indirect_thunk_(r|e)ax:" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/pr39013-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr39013-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr39013-1.c	(.../branches/gcc-7-branch)
@@ -12,5 +12,9 @@
   return foo () + bar ();
 }
 
-/* { dg-final { scan-assembler "foo@PLT" } } */
-/* { dg-final { scan-assembler "bar@PLT" } } */
+/* { dg-final { scan-assembler "foo@PLT" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "bar@PLT" { target { ! *-*-darwin* } } } } */
+
+/* Darwin's dynamic linker does PIE without indirection.  */
+/* { dg-final { scan-assembler {call[ \t]_foo} { target *-*-darwin* } } } */
+/* { dg-final { scan-assembler {call[ \t]_bar} { target *-*-darwin* } } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -14,9 +15,11 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler-times {jmp[ \t]*\.?LIND} 2 } } */
+/* { dg-final { scan-assembler-times {call[ \t]*\.?LIND} 2 } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
Index: gcc/testsuite/gcc.target/i386/pr90547.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr90547.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr90547.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,21 @@
+/* PR target/90547 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void
+foo ()
+{
+  void *g[] = {&&a, &&b};
+
+  for (unsigned c = 0x1F;; c >>= 1)
+    {
+      unsigned d = (long)("a"+1);
+      long e = 8;
+
+      while (e)
+        {
+          a: goto *g[c&d];
+          b: e--;
+        }
+    }
+}
Index: gcc/testsuite/gcc.target/i386/pr91131.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr91131.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr91131.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+struct Reg_T {
+    unsigned int a : 3;
+    unsigned int b : 1;
+    unsigned int c : 4;
+};
+
+volatile struct Reg_T Reg_A;
+
+int
+main ()
+{
+  Reg_A = (struct Reg_T){ .a = 0, .b = 0, .c = 0 };
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times "mov\[^\r\n\]*Reg_A" 1 } } */
Index: gcc/testsuite/gcc.target/i386/pr89523-6.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-6.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-6.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,38 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512pf" } */
+/* { dg-final { scan-assembler-not "\tvgather" } } */
+/* { dg-final { scan-assembler "addr32 vgather" } } */
+
+typedef int __v8si __attribute__ ((__vector_size__ (32)));
+typedef long long __m256i __attribute__ ((__vector_size__ (32),
+					  __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_prefetch_i32gather_pd (__m256i __index, void const *__addr,
+			      int __scale, int __hint)
+{
+  __builtin_ia32_gatherpfdpd ((__mmask8) 0xFF, (__v8si) __index, __addr,
+			      __scale, __hint);
+}
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_mask_prefetch_i32gather_pd (__m256i __index, __mmask8 __mask,
+				   void const *__addr, int __scale, int __hint)
+{
+  __builtin_ia32_gatherpfdpd (__mask, (__v8si) __index, __addr, __scale,
+			      __hint);
+}
+
+volatile __m256i idx;
+volatile __mmask8 m8;
+
+void extern
+avx512pf_test (void)
+{
+  _mm512_prefetch_i32gather_pd (idx, (void *) 0, 8, 3);
+  _mm512_mask_prefetch_i32gather_pd (idx, m8, (void *) 0, 8, 3);
+}
Index: gcc/testsuite/gcc.target/i386/pr32219-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr32219-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr32219-3.c	(.../branches/gcc-7-branch)
@@ -12,7 +12,16 @@
   return xxx;
 }
 
-/* { dg-final { scan-assembler "movl\[ \t\]xxx\\(%rip\\), %eax" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler-not "xxx@GOTPCREL" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %eax" { target ia32 } } } */
-/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %eax" { target ia32 } } } */
+/* { dg-final { scan-assembler {movl[ \t]xxx\(%rip\),[ \t]%eax} { target { { ! ia32 } && { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler-not "xxx@GOTPCREL" { target { { ! ia32 } && { ! *-*-darwin* } } } } } */
+
+/* For Darwin m64, code is always PIC and we need to indirect through the GOT to allow
+   weak symbols to be interposed.  The dynamic loader knows how to apply PIE to this.  */
+/* { dg-final { scan-assembler {movq[ \t]_xxx@GOTPCREL\(%rip\),[ \t]%rax} { target { { ! ia32 } && *-*-darwin* } } } } */
+
+/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %eax" { target { ia32 && { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %eax" { target { ia32 && { ! *-*-darwin* } } } } } */
+
+/* For Darwin, we need PIC to allow PIE, but also we must indirect weak symbols so that
+   they can be indirected.  Again, dyld knows how to deal with this. */
+/* { dg-final { scan-assembler {movl[ \t][Ll]_xxx\$non_lazy_ptr-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-3.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mno-indirect-branch-register -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mno-indirect-branch-register -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk" } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -12,9 +13,11 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/pr53698.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr53698.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr53698.c	(.../branches/gcc-7-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O -mx32 -maddress-mode=long -fno-tree-dominator-opts" } */
 
 extern char foo[];
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-register-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-register-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-register-2.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mindirect-branch=thunk-inline -mindirect-branch-register -fno-pic" } */
+/* { dg-options "-O2 -mindirect-branch=thunk-inline -mindirect-branch-register " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,10 +12,10 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler "mov\[ \t\](%eax|%rax), \\((%esp|%rsp)\\)" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler-not "push(?:l|q)\[ \t\]*_?dispatch"  } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-3.c	(.../branches/gcc-7-branch)
@@ -6,7 +6,7 @@
 {
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-12.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-12.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-12.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mno-indirect-branch-register -mno-indirect-branch-register -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mno-indirect-branch-register -mno-indirect-branch-register -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*bar) (void);
 
@@ -10,11 +11,11 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "_?__x86_indirect_thunk_(r|e)ax:" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/pr88938.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr88938.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr88938.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,5 @@
+/* PR target/88938 */
+/* { dg-do compile } */
+/* { dg-options "-Og -fno-tree-ccp -fno-tree-fre -mtbm" } */
+
+#include "tbm-bextri-1.c"
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fjump-tables" } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 void func0 (void);
 void func1 (void);
@@ -36,7 +37,7 @@
 }
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not "call\[ \t\]*\.?LIND" } } */
Index: gcc/testsuite/gcc.target/i386/pr39013-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr39013-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr39013-2.c	(.../branches/gcc-7-branch)
@@ -12,5 +12,9 @@
   return foo () + bar ();
 }
 
-/* { dg-final { scan-assembler "foo@PLT" } } */
-/* { dg-final { scan-assembler "bar@PLT" } } */
+/* { dg-final { scan-assembler "foo@PLT" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "bar@PLT" { target { ! *-*-darwin* } } } } */
+
+/* Darwin's dynamic linker does PIE without indirection.  */
+/* { dg-final { scan-assembler {call[ \t]_foo} { target *-*-darwin* } } } */
+/* { dg-final { scan-assembler {call[ \t]_bar} { target *-*-darwin* } } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -13,9 +14,11 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler-times {jmp[ \t]*\.?LIND} 2 } } */
+/* { dg-final { scan-assembler-times {call[ \t]*\.?LIND} 2 } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
Index: gcc/testsuite/gcc.target/i386/fuse-caller-save-rec.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/fuse-caller-save-rec.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/fuse-caller-save-rec.c	(.../branches/gcc-7-branch)
@@ -18,14 +18,12 @@
   return y + bar (y);
 }
 
-/* For !nonpic && ia32 xfails, see PR64895.  */
-
 /* Check that no registers are saved/restored. */
-/* { dg-final { scan-assembler-not "push" { xfail { { ! nonpic } && ia32 } } } } */
-/* { dg-final { scan-assembler-not "pop" { xfail { { ! nonpic } && ia32 } } } } */
+/* { dg-final { scan-assembler-not "push" } } */
+/* { dg-final { scan-assembler-not "pop" } } */
 
 /* Check that addition uses dx. */
-/* { dg-final { scan-assembler-times "addl\t%\[re\]?dx, %\[re\]?ax" 1 { xfail { { ! nonpic } && ia32 } } } } */
+/* { dg-final { scan-assembler-times "addl\t%\[re\]?dx, %\[re\]?ax" 1 } } */
 
 /* Verify that bar is self-recursive.  */
 /* { dg-final { scan-assembler-times "call\t_?bar" 2 } } */
Index: gcc/testsuite/gcc.target/i386/fuse-caller-save-xmm.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/fuse-caller-save-xmm.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/fuse-caller-save-xmm.c	(.../branches/gcc-7-branch)
@@ -15,14 +15,20 @@
   return y + bar (y);
 }
 
-/* For !nonpic && ia32 xfails, see PR64895.  */
-
 /* Check presence of all insns on xmm registers.  These checks are expected to
    pass with both -fipa-ra and -fno-ipa-ra.  */
-/* { dg-final { scan-assembler-times "addpd\t\\.?LC0.*, %xmm0" 1 } } */
-/* { dg-final { scan-assembler-times "addpd\t%xmm1, %xmm0" 1 { xfail { { ! nonpic } && ia32 } } } } */
-/* { dg-final { scan-assembler-times "movapd\t%xmm0, %xmm1" 1 { xfail { { ! nonpic } && ia32 } } } } */
 
+/* Darwin local constant symbol is "lC0", ELF targets ".LC0" */
+/* { dg-final { scan-assembler-times {addpd\t\.?[Ll]C0.*, %xmm0} 1 { target { { ! ia32 } || nonpic } } } } */
+/* { dg-final { scan-assembler-times {movapd\t\.?[Ll]C0.*, %xmm1} 1 { target { ia32 && { ! nonpic } } } } } */
+
+/* We happen to get this for both cases, but in different positions.  */
+/* { dg-final { scan-assembler-times "addpd\t%xmm1, %xmm0" 1 } } */
+
+/* { dg-final { scan-assembler-times "movapd\t%xmm0, %xmm1" 1 { target { { ! ia32 } || nonpic } } } } */
+/* { dg-final { scan-assembler-times "movapd\t%xmm0, %xmm2" 1 { target { ia32 && { ! nonpic } } } } } */
+/* { dg-final { scan-assembler-times "addpd\t%xmm2, %xmm0" 1 { target { ia32 && { ! nonpic } } } } } */
+
 /* Check absence of save/restore of xmm1 register.  */
 /* { dg-final { scan-assembler-not "movaps\t%xmm1, \\(%\[re\]?sp\\)" } } */
 /* { dg-final { scan-assembler-not "movapd\t\\(%\[re\]?sp\\), %xmm1" } } */
Index: gcc/testsuite/gcc.target/i386/pr77881.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr77881.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr77881.c	(.../branches/gcc-7-branch)
@@ -8,5 +8,5 @@
     if (a < 0 || b)
           baz ();
 }
-/* { dg-final { scan-assembler "js\[ \t\]\.L" } } */
-/* { dg-final { scan-assembler "jne\[ \t\]\.L" } } */
+/* { dg-final { scan-assembler "js\[ \t\]\.?L" } } */
+/* { dg-final { scan-assembler "jne\[ \t\]\.?L" } } */
Index: gcc/testsuite/gcc.target/i386/pr87853.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr87853.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr87853.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,20 @@
+/* PR target/87853 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -funsigned-char -msse2 -mno-sse3 -masm=att" } */
+/* { dg-final { scan-assembler-times "\tpcmpgtb\t%xmm" 2 } } */
+/* { dg-final { scan-assembler-not "\tpsubusb\t" } } */
+/* { dg-final { scan-assembler-not "\tpcmpeqb\t" } } */
+
+#include <x86intrin.h>
+
+__m128i
+foo (__m128i x, __m128i y)
+{
+  return _mm_cmpgt_epi8 (x, y);
+}
+
+__m128i
+bar (__m128i x, __m128i y)
+{
+  return _mm_cmplt_epi8 (x, y);
+}
Index: gcc/testsuite/gcc.target/i386/pr89523-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-7.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-7.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,42 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512f" } */
+/* { dg-final { scan-assembler "\tvscatter" } } */
+/* { dg-final { scan-assembler-not "addr32 vscatter" } } */
+
+typedef int __v8si __attribute__ ((__vector_size__ (32)));
+typedef double __v8df __attribute__ ((__vector_size__ (64)));
+typedef long long __m256i __attribute__ ((__vector_size__ (32),
+					  __may_alias__));
+typedef double __m512d __attribute__ ((__vector_size__ (64), __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_i32scatter_pd (void *__addr, __m256i __index, __m512d __v1,
+		      int __scale)
+{
+  __builtin_ia32_scattersiv8df (__addr, (__mmask8) 0xFF,
+				(__v8si) __index, (__v8df) __v1, __scale);
+}
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_mask_i32scatter_pd (void *__addr, __mmask8 __mask,
+			   __m256i __index, __m512d __v1, int __scale)
+{
+  __builtin_ia32_scattersiv8df (__addr, __mask, (__v8si) __index,
+				(__v8df) __v1, __scale);
+}
+
+volatile __m512d src;
+volatile __m256i idx;
+volatile __mmask8 m8;
+double *addr;
+
+void extern
+avx512f_test (void)
+{
+  _mm512_i32scatter_pd (addr, idx, src, 8);
+  _mm512_mask_i32scatter_pd (addr, m8, idx, src, 8);
+}
Index: gcc/testsuite/gcc.target/i386/pr32219-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr32219-4.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr32219-4.c	(.../branches/gcc-7-branch)
@@ -13,6 +13,12 @@
 }
 
 /* { dg-final { scan-assembler-not "movl\[ \t\]xxx\\(%rip\\), %" { target { ! ia32 } } } } */
+/* Darwin is always PIC for PIE so no change, weak symbols need to be indirect and this
+   happens to match the ELF case.  */
 /* { dg-final { scan-assembler "xxx@GOTPCREL" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %" { target ia32 } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %" { target ia32 } } } */
+
+/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %" { target { ia32 && { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %" { target { ia32 && { ! *-*-darwin* } } } } } */
+
+/* Darwin m32 equivalent (indirect and PIC).  */
+/* { dg-final { scan-assembler {movl[ \t][Ll]_xxx\$non_lazy_ptr-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-4.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-4.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mno-indirect-branch-register -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mno-indirect-branch-register -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -12,9 +13,11 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-register-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-register-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-register-3.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mindirect-branch=thunk-extern -mindirect-branch-register -fno-pic" } */
+/* { dg-options "-O2 -mindirect-branch=thunk-extern -mindirect-branch-register " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,9 +12,9 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not "push(?:l|q)\[ \t\]*_?dispatch"  } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
 /* { dg-final { scan-assembler-not {\t(pause|pause|nop)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-4.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-4.c	(.../branches/gcc-7-branch)
@@ -6,7 +6,7 @@
 {
 }
 
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/pr88416.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr88416.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr88416.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,5 @@
+/* PR rtl-optimization/88416 */
+/* { dg-do compile } */
+/* { dg-options "-O1 -fvar-tracking-assignments -fno-forward-propagate --param max-cse-insns=1" } */
+
+#include "writeeflags-1.c"
Index: gcc/testsuite/gcc.target/i386/ret-thunk-13.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-13.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-13.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*bar) (void);
 extern int foo (void) __attribute__ ((function_return("thunk")));
@@ -11,11 +12,11 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-times {\tpause} 2 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 2 } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 3 } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 3 } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_indirect_thunk" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler-times {jmp[ \t]*\.?LIND} 3 } } */
+/* { dg-final { scan-assembler-times {call[ \t]*\.?LIND} 3 } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/avx512vl-pr87214-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512vl-pr87214-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512vl-pr87214-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,39 @@
+/* PR target/87214 */
+/* { dg-do run { target { avx512vl } } } */
+/* { dg-options "-O3 -mavx512vl -mtune=skylake-avx512" } */
+
+#define AVX512VL
+#define AVX512F_LEN 512
+#define AVX512F_LEN_HALF 256
+#include "avx512f-check.h"
+
+struct s { unsigned long a, b, c; };
+
+void __attribute__ ((noinline, noclone))
+foo (struct s *restrict s1, struct s *restrict s2, int n)
+{
+  for (int i = 0; i < n; ++i)
+    {
+      s1[i].b = s2[i].b;
+      s1[i].c = s2[i].c;
+      s2[i].c = 0;
+    }
+}
+                            
+#define N 12
+
+static void
+avx512f_test (void)
+{
+  struct s s1[N], s2[N];
+  for (unsigned int j = 0; j < N; ++j)
+    {
+      s2[j].a = j * 5;
+      s2[j].b = j * 5 + 2;
+      s2[j].c = j * 5 + 4;
+    }
+  foo (s1, s2, N);
+  for (unsigned int j = 0; j < N; ++j)
+  if (s1[j].b != j * 5 + 2)
+    __builtin_abort ();
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -14,8 +15,10 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/pr52876.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr52876.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr52876.c	(.../branches/gcc-7-branch)
@@ -1,4 +1,5 @@
 /* { dg-do run { target { x32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -mx32 -maddress-mode=long" } */
 
 extern void abort (void);
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,8 +12,10 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.LIND} } } */
Index: gcc/testsuite/gcc.target/i386/pr89523-8.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-8.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-8.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,41 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512f" } */
+/* { dg-final { scan-assembler "\tvscatter" } } */
+/* { dg-final { scan-assembler-not "addr32 vscatter" } } */
+
+typedef long long __v8di __attribute__ ((__vector_size__ (64)));
+typedef double __v8df __attribute__ ((__vector_size__ (64)));
+typedef long long __m512i __attribute__ ((__vector_size__ (64), __may_alias__));
+typedef double __m512d __attribute__ ((__vector_size__ (64), __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_i64scatter_pd (void *__addr, __m512i __index, __m512d __v1,
+		      int __scale)
+{
+  __builtin_ia32_scatterdiv8df (__addr, (__mmask8) 0xFF,
+				(__v8di) __index, (__v8df) __v1, __scale);
+}
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_mask_i64scatter_pd (void *__addr, __mmask8 __mask,
+			   __m512i __index, __m512d __v1, int __scale)
+{
+  __builtin_ia32_scatterdiv8df (__addr, __mask, (__v8di) __index,
+				(__v8df) __v1, __scale);
+}
+
+volatile __m512d src;
+volatile __m512i idx;
+volatile __mmask8 m8;
+double *addr;
+
+void extern
+avx512f_test (void)
+{
+  _mm512_i64scatter_pd (addr, idx, src, 8);
+  _mm512_mask_i64scatter_pd (addr, m8, idx, src, 8);
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fjump-tables" } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 void func0 (void);
 void func1 (void);
@@ -37,8 +38,8 @@
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
Index: gcc/testsuite/gcc.target/i386/pr32219-5.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr32219-5.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr32219-5.c	(.../branches/gcc-7-branch)
@@ -11,7 +11,11 @@
   return xxx;
 }
 
-/* { dg-final { scan-assembler "movl\[ \t\]xxx\\(%rip\\), %eax" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "movl\[ \t\]_?xxx\\(%rip\\), %eax" { target { ! ia32 } } } } */
 /* { dg-final { scan-assembler-not "xxx@GOTPCREL" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %eax" { target ia32 } } } */
-/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %eax" { target ia32 } } } */
+
+/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %eax" { target { ia32 && { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %eax" { target { ia32 && { ! *-*-darwin* } } } } } */
+
+/* For Darwin m32, we need PIC (the default) to allow PIE.  */
+/* { dg-final { scan-assembler {movl[ \t]_xxx-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
Index: gcc/testsuite/gcc.target/i386/pr89523-1a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-1a.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-1a.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,24 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-maddress-mode=short -mx32 -Ofast -funroll-loops -march=haswell" } */
+/* { dg-final { scan-assembler-not "\tvgather" } } */
+/* { dg-final { scan-assembler "addr32 vgather" } } */
+
+void foo (void);
+
+extern float *ncost;
+
+float
+bar (int type, int num)
+{
+  int i;
+  float cost;
+
+  cost = 0;
+  for (i = 0; i < num; i++)
+    if (type)
+      cost += ncost[i];
+    else
+      foo ();
+  return (cost);
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-1.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile { target { ! x32 } } } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fcheck-pointer-bounds -mmpx -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fcheck-pointer-bounds -mmpx" } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 void (*dispatch) (char *);
 char buf[10];
@@ -11,8 +12,8 @@
 }
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "bnd jmp\[ \t\]*__x86_indirect_thunk_bnd_rax" { target lp64 } } } */
-/* { dg-final { scan-assembler "bnd call\[ \t\]*__x86_indirect_thunk_bnd_eax" { target ia32 } } } */
+/* { dg-final { scan-assembler "bnd jmp\[ \t\]*_?__x86_indirect_thunk_bnd_rax" { target lp64 } } } */
+/* { dg-final { scan-assembler "bnd call\[ \t\]*_?__x86_indirect_thunk_bnd_eax" { target ia32 } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "bnd call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "bnd ret" } } */
Index: gcc/testsuite/gcc.target/i386/pr89945.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89945.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89945.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,21 @@
+/* PR target/89945 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void
+foo ()
+{
+  void *g[] = {&&a, &&b};
+
+  for (unsigned c = 0x1F;; c >>= 1)
+    {
+      unsigned d = (long)"a";
+      long e = 8;
+
+      while (e)
+        {
+          a: goto *g[c&d];
+          b: e--;
+        }
+    }
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-register-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-register-4.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-register-4.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mindirect-branch=keep -fno-pic" } */
+/* { dg-options "-O2 -mindirect-branch=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*func_p) (void);
 
Index: gcc/testsuite/gcc.target/i386/ret-thunk-5.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-5.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-5.c	(.../branches/gcc-7-branch)
@@ -8,8 +8,8 @@
 {
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/pr55093.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr55093.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr55093.c	(.../branches/gcc-7-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -mx32 -maddress-mode=long" } */
 /* { dg-skip-if "different ABI" { x86_64-*-mingw* } } */
 
Index: gcc/testsuite/gcc.target/i386/ret-thunk-14.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-14.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-14.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*bar) (void);
 
@@ -13,9 +14,11 @@
 
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?bar" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_return_thunk" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_bar} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_bar\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/avx512vl-pr87214-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512vl-pr87214-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512vl-pr87214-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,123 @@
+/* PR target/87214 */
+/* { dg-do run { target { avx512vl } } } */
+/* { dg-options "-O2 -mavx512vl" } */
+
+#define AVX512VL
+#define AVX512F_LEN 512
+#define AVX512F_LEN_HALF 256
+#include "avx512f-check.h"
+
+typedef long long int v4di __attribute__((vector_size (4 * sizeof (long long int))));
+typedef double v4df __attribute__((vector_size (4 * sizeof (double))));
+typedef long long int v8di __attribute__((vector_size (8 * sizeof (long long int))));
+typedef double v8df __attribute__((vector_size (8 * sizeof (double))));
+typedef int v8si __attribute__((vector_size (8 * sizeof (int))));
+typedef float v8sf __attribute__((vector_size (8 * sizeof (float))));
+typedef int v16si __attribute__((vector_size (16 * sizeof (int))));
+typedef float v16sf __attribute__((vector_size (16 * sizeof (float))));
+
+__attribute__((noinline, noclone)) void
+f1 (v4di *p)
+{
+  p[0] = __builtin_shuffle (p[1], p[2], (v4di) { 2, 3, 5, 6 });
+}
+
+__attribute__((noinline, noclone)) void
+f2 (v4df *p)
+{
+  p[0] = __builtin_shuffle (p[1], p[2], (v4di) { 1, 2, 6, 7 });
+}
+
+__attribute__((noinline, noclone)) void
+f3 (v8di *p)
+{
+  p[0] = __builtin_shuffle (p[1], p[2], (v8di) { 2, 3, 5, 6, 8, 9, 11, 12 });
+}
+
+__attribute__((noinline, noclone)) void
+f4 (v8df *p)
+{
+  p[0] = __builtin_shuffle (p[1], p[2], (v8di) { 1, 2, 6, 7, 9, 10, 12, 13 });
+}
+
+__attribute__((noinline, noclone)) void
+f5 (v8si *p)
+{
+  p[0] = __builtin_shuffle (p[1], p[2], (v8si) { 2, 3, 4, 5, 9, 10, 11, 12 });
+}
+
+__attribute__((noinline, noclone)) void
+f6 (v8sf *p)
+{
+  p[0] = __builtin_shuffle (p[1], p[2], (v8si) { 1, 2, 3, 4, 12, 13, 14, 15 });
+}
+
+__attribute__((noinline, noclone)) void
+f7 (v16si *p)
+{
+  p[0] = __builtin_shuffle (p[1], p[2], (v16si) { 0, 1, 2, 3, 1, 2, 3, 4, 16, 17, 18, 19, 25, 26, 27, 28 });
+}
+
+__attribute__((noinline, noclone)) void
+f8 (v16sf *p)
+{
+  p[0] = __builtin_shuffle (p[1], p[2], (v16si) { 1, 2, 3, 4, 4, 5, 6, 7, 17, 18, 19, 20, 18, 19, 20, 21 });
+}
+
+static void
+avx512f_test (void)
+{
+  v4di a[3] = { { 0, 0, 0, 0 }, { 10, 11, 12, 13 }, { 14, 15, 16, 17 } };
+  f1 (a);
+  if (a[0][0] != 12 || a[0][1] != 13 || a[0][2] != 15 || a[0][3] != 16)
+    __builtin_abort ();
+  v4df b[3] = { { 0.0, 0.0, 0.0, 0.0 }, { 10.0, 11.0, 12.0, 13.0 }, { 14.0, 15.0, 16.0, 17.0 } };
+  f2 (b);
+  if (b[0][0] != 11.0 || b[0][1] != 12.0 || b[0][2] != 16.0 || b[0][3] != 17.0)
+    __builtin_abort ();
+  v8di c[3] = { { 0, 0, 0, 0, 0, 0, 0, 0 }, { 10, 11, 12, 13, 14, 15, 16, 17 }, { 18, 19, 20, 21, 22, 23, 24, 25 } };
+  f3 (c);
+  if (c[0][0] != 12 || c[0][1] != 13 || c[0][2] != 15 || c[0][3] != 16
+      || c[0][4] != 18 || c[0][5] != 19 || c[0][6] != 21 || c[0][7] != 22)
+    __builtin_abort ();
+  v8df d[3] = { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
+		{ 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0 },
+		{ 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0 } };
+  f4 (d);
+  if (d[0][0] != 11.0 || d[0][1] != 12.0 || d[0][2] != 16.0 || d[0][3] != 17.0
+      || d[0][4] != 19.0 || d[0][5] != 20.0 || d[0][6] != 22.0 || d[0][7] != 23.0)
+    __builtin_abort ();
+  v8si e[3] = { { 0, 0, 0, 0, 0, 0, 0, 0 }, { 10, 11, 12, 13, 14, 15, 16, 17 }, { 18, 19, 20, 21, 22, 23, 24, 25 } };
+  f5 (e);
+  if (e[0][0] != 12 || e[0][1] != 13 || e[0][2] != 14 || e[0][3] != 15
+      || e[0][4] != 19 || e[0][5] != 20 || e[0][6] != 21 || e[0][7] != 22)
+    __builtin_abort ();
+  v8sf f[3] = { { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f },
+		{ 10.0f, 11.0f, 12.0f, 13.0f, 14.0f, 15.0f, 16.0f, 17.0f },
+		{ 18.0f, 19.0f, 20.0f, 21.0f, 22.0f, 23.0f, 24.0f, 25.0f } };
+  f6 (f);
+  if (f[0][0] != 11.0f || f[0][1] != 12.0f || f[0][2] != 13.0f || f[0][3] != 14.0f
+      || f[0][4] != 22.0f || f[0][5] != 23.0f || f[0][6] != 24.0f || f[0][7] != 25.0f)
+    __builtin_abort ();
+  v16si g[3] = { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+		 { 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25 },
+		 { 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41 } };
+  f7 (g);
+  if (g[0][0] != 10 || g[0][1] != 11 || g[0][2] != 12 || g[0][3] != 13
+      || g[0][4] != 11 || g[0][5] != 12 || g[0][6] != 13 || g[0][7] != 14
+      || g[0][8] != 26 || g[0][9] != 27 || g[0][10] != 28 || g[0][11] != 29
+      || g[0][12] != 35 || g[0][13] != 36 || g[0][14] != 37 || g[0][15] != 38)
+    __builtin_abort ();
+  v16sf h[3] = { { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f,
+		   0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f },
+		 { 10.0f, 11.0f, 12.0f, 13.0f, 14.0f, 15.0f, 16.0f, 17.0f,
+		   18.0f, 19.0f, 20.0f, 21.0f, 22.0f, 23.0f, 24.0f, 25.0f },
+		 { 26.0f, 27.0f, 28.0f, 29.0f, 30.0f, 31.0f, 32.0f, 33.0f,
+		   34.0f, 35.0f, 36.0f, 37.0f, 38.0f, 39.0f, 40.0f, 41.0f } };
+  f8 (h);
+  if (h[0][0] != 11.0f || h[0][1] != 12.0f || h[0][2] != 13.0f || h[0][3] != 14.0f
+      || h[0][4] != 14.0f || h[0][5] != 15.0f || h[0][6] != 16.0f || h[0][7] != 17.0f
+      || h[0][8] != 27.0f || h[0][9] != 28.0f || h[0][10] != 29.0f || h[0][11] != 30.0f
+      || h[0][12] != 28.0f || h[0][13] != 29.0f || h[0][14] != 30.0f || h[0][15] != 31.0f)
+    __builtin_abort ();
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -13,8 +14,10 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/pr66470.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr66470.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr66470.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* PR target/66470 */
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -mx32 -maddress-mode=long" } */
 /* { dg-require-effective-target tls } */
 
Index: gcc/testsuite/gcc.target/i386/pr59929.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr59929.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr59929.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,5 @@
 /* { dg-do run } */
-/* { dg-options "-O0 -mno-accumulate-outgoing-args" } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O0 -mno-accumulate-outgoing-args -mx32 -maddress-mode=short" { target x32 } } */
 
 void
Index: gcc/testsuite/gcc.target/i386/pr86334.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr86334.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr86334.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,21 @@
+/* PR rtl-optimization/86334 */
+/* { dg-do run { target ia32 } } */
+/* { dg-options "-O -march=i386 -mtune=athlon -minline-all-stringops -minline-stringops-dynamically -mmemcpy-strategy=libcall:-1:align -Wno-psabi" } */
+
+typedef int V __attribute__ ((vector_size (64)));
+
+static inline V
+foo (V g)
+{
+  g[0] = 4;
+  return g;
+}
+
+int
+main ()
+{
+  V x = foo ((V) { });
+  if (x[0] != 4 || x[1] || x[2] || x[3] || x[4] || x[5] || x[6] || x[7])
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,8 +12,10 @@
   dispatch[offset](offset);
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/call-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/call-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/call-1.c	(.../branches/gcc-7-branch)
@@ -11,7 +11,7 @@
 
 void set_eax(int val)
 {
-  __asm__ __volatile__ ("mov %0, %%eax" : : "m" (val));
+  __asm__ __volatile__ ("mov %0, %%eax" : : "m" (val) : "eax");
 }
 
 void foo(int val)
Index: gcc/testsuite/gcc.target/i386/pr89523-9.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-9.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-9.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,30 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512f" } */
+/* { dg-final { scan-assembler-not "\tvscatter" } } */
+/* { dg-final { scan-assembler "addr32 vscatter" } } */
+
+typedef int __v8si __attribute__ ((__vector_size__ (32)));
+typedef double __v8df __attribute__ ((__vector_size__ (64)));
+typedef long long __m256i __attribute__ ((__vector_size__ (32),
+					  __may_alias__));
+typedef double __m512d __attribute__ ((__vector_size__ (64), __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_i32scatter_pd (void *__addr, __m256i __index, __m512d __v1,
+		      int __scale)
+{
+  __builtin_ia32_scattersiv8df (__addr, (__mmask8) 0xFF,
+				(__v8si) __index, (__v8df) __v1, __scale);
+}
+
+volatile __m512d src;
+volatile __m256i idx;
+
+void extern
+avx512f_test (void)
+{
+  _mm512_i32scatter_pd ((void *) 0, idx, src, 8);
+}
Index: gcc/testsuite/gcc.target/i386/pr32219-6.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr32219-6.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr32219-6.c	(.../branches/gcc-7-branch)
@@ -11,7 +11,14 @@
   return xxx;
 }
 
-/* { dg-final { scan-assembler-not "movl\[ \t\]xxx\\(%rip\\), %" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "xxx@GOTPCREL" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %" { target ia32 } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %" { target ia32 } } } */
+/* { dg-final { scan-assembler-not "movl\[ \t\]xxx\\(%rip\\), %" { target { { ! ia32 } && { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler "xxx@GOTPCREL" { target { { ! ia32 } && { ! *-*-darwin* } } } } } */
+
+/* Darwin m64 is always PIC, and the dynamic linker doesn't need an indirection.  */
+/* { dg-final { scan-assembler {movl[ \t]_xxx\(%rip\),[ \t]%eax} { target { { ! ia32 } && *-*-darwin* } } } } */
+
+/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %" { target { ia32 && { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %" { target { ia32 && { ! *-*-darwin* } } } } } */
+
+/* Darwin m32 defaults to PIC, so no change.  */
+/* { dg-final { scan-assembler {movl[ \t]_xxx-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
Index: gcc/testsuite/gcc.target/i386/pr89523-1b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-1b.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-1b.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,7 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-maddress-mode=long -mx32 -Ofast -funroll-loops -march=haswell" } */
+/* { dg-final { scan-assembler-not "\tvgather" } } */
+/* { dg-final { scan-assembler "addr32 vgather" } } */
+
+#include "pr89523-1a.c"
Index: gcc/testsuite/gcc.target/i386/pr22076.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr22076.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr22076.c	(.../branches/gcc-7-branch)
@@ -1,6 +1,8 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -fomit-frame-pointer -flax-vector-conversions -mmmx" } */
-/* { dg-options "-O2 -fomit-frame-pointer -flax-vector-conversions -mmmx -mno-vect8-ret-in-mem" { target *-*-vxworks* } } */
+/* { dg-additional-options "-mno-vect8-ret-in-mem" { target *-*-vxworks* } } */
+/* { dg-additional-options "-fno-common" { target *-*-darwin* } } */
+/* { dg-additional-options "-mdynamic-no-pic" { target { ia32 && *-*-darwin* } } } */
 
 #include <mmintrin.h>
 
Index: gcc/testsuite/gcc.target/i386/ret-thunk-22.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-22.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-22.c	(.../branches/gcc-7-branch)
@@ -6,10 +6,12 @@
 struct s gs = { 100 + 200i };
 struct s __attribute__((noinline)) foo (void) { return gs; }
 
-/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 } } */
-/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk_ecx" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk_ecx" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {call[ \t]*___x86.get_pc_thunk.cx} { target { *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {jmp[ \t]*___x86_return_thunk} { target { *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/pr88948.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr88948.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr88948.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,5 @@
+/* PR rtl-optimization/88948 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fgcse-sm -msse3 -mfpmath=387" } */
+
+#include "../../gcc.c-torture/execute/stdarg-3.c"
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-2.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile { target { ! x32 } } } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fcheck-pointer-bounds -mmpx -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fcheck-pointer-bounds -mmpx" } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 void (*dispatch) (char *);
 char buf[10];
@@ -12,8 +13,8 @@
 }
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "bnd call\[ \t\]*__x86_indirect_thunk_bnd_(r|e)ax" } } */
-/* { dg-final { scan-assembler "bnd call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "bnd call\[ \t\]*_?__x86_indirect_thunk_bnd_(r|e)ax" } } */
+/* { dg-final { scan-assembler "bnd call\[ \t\]*\.?LIND" } } */
 /* { dg-final { scan-assembler "bnd ret" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-6.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-6.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-6.c	(.../branches/gcc-7-branch)
@@ -7,8 +7,8 @@
 {
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_return_thunk" } } */
Index: gcc/testsuite/gcc.target/i386/pr24414.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr24414.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr24414.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do run } */
 /* { dg-options "-O2" } */
+/* { dg-skip-if "asm insert mismatches ABI for Darwin" { *-*-darwin* } } */
 int test;
 
 int
Index: gcc/testsuite/gcc.target/i386/pr88418.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr88418.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr88418.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,15 @@
+/* PR target/88418 */
+/* { dg-do compile } */
+/* { dg-options "-O1 -fpack-struct -msse4.1 -mno-avx" } */
+
+typedef long long v2di __attribute__ ((__vector_size__ (16)));
+
+union df {
+  v2di se[2];
+};
+
+void
+qg (union df *jz, union df *pl)
+{
+  jz->se[0] = jz->se[0] == pl->se[0];
+}
Index: gcc/testsuite/gcc.target/i386/ret-thunk-15.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-15.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-15.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mno-indirect-branch-register -mno-indirect-branch-register -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=keep -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mno-indirect-branch-register -mno-indirect-branch-register -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*bar) (void);
 
@@ -11,11 +12,13 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?bar" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_bar} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_bar\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/fuse-caller-save.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/fuse-caller-save.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/fuse-caller-save.c	(.../branches/gcc-7-branch)
@@ -16,11 +16,9 @@
   return y + bar (y);
 }
 
-/* For !nonpic && ia32 xfails, see PR64895.  */
-
 /* Check that no registers are saved/restored. */
-/* { dg-final { scan-assembler-not "push" { xfail { { ! nonpic } && ia32 } } } } */
-/* { dg-final { scan-assembler-not "pop" { xfail { { ! nonpic } && ia32 } } } } */
+/* { dg-final { scan-assembler-not "push" } } */
+/* { dg-final { scan-assembler-not "pop" } } */
 
 /* PR61605.  If the first argument register and the return register differ, then
    bar leaves the first argument register intact.  That means in foo that the
@@ -31,4 +29,4 @@
 /* { dg-final { scan-assembler-not "movl" { target { ! ia32 } } } } */
 
 /* Check that addition uses di (in case of no copy) or dx (in case of copy). */
-/* { dg-final { scan-assembler-times "addl\t%\[re\]?d\[ix\], %\[re\]?ax" 1 { xfail { { ! nonpic } && ia32 } } } } */
+/* { dg-final { scan-assembler-times "addl\t%\[re\]?d\[ix\], %\[re\]?ax" 1 } } */
Index: gcc/testsuite/gcc.target/i386/pr89523-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,37 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -march=haswell" } */
+/* { dg-final { scan-assembler "\tvgather" } } */
+/* { dg-final { scan-assembler-not "addr32 vgather" } } */
+
+typedef double __v2df __attribute__ ((__vector_size__ (16)));
+typedef int __v4si __attribute__ ((__vector_size__ (16)));
+typedef long long __v2di __attribute__ ((__vector_size__ (16)));
+
+typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));
+typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));
+
+extern __inline __m128d
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm_i32gather_pd (double const *__base, __m128i __index, const int __scale)
+{
+  __v2df __zero = { 0.0, 0.0 };
+  __v2df __mask = __builtin_ia32_cmpeqpd (__zero, __zero);
+  __v2df x = x;
+
+  return (__m128d) __builtin_ia32_gathersiv2df (x,
+						__base,
+						(__v4si)__index,
+						__mask,
+						__scale);
+}
+
+__m128d x;
+double *base;
+__m128i idx;
+
+void extern
+avx2_test (void)
+{
+  x = _mm_i32gather_pd (base, idx, 1);
+}
Index: gcc/testsuite/gcc.target/i386/pr86952.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr86952.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr86952.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mindirect-branch=thunk" } */
+
+int global;
+
+int
+foo (int x)
+{
+  switch (x & 7)
+    {
+      case 0: ; return 1722;
+      case 1: global += 1; return 1060;
+      case 2: ; return 1990;
+      case 3: ; return 1242;
+      case 4: ; return 1466;
+      case 5: ; return 894;
+      case 6: ; return 570;
+      case 7: ; return 572;
+      default: return 0;
+    }
+}
+
+/* { dg-final { scan-assembler-not "jmp\[ \t\]\\*" } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,10 +12,12 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-7.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-7.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 void func0 (void);
 void func1 (void);
@@ -37,7 +38,9 @@
 }
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {leaq[ \t]*L[0-9]+\(%rip\)} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {addl[ \t]*L[0-9]+-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/fpprec-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/fpprec-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/fpprec-1.c	(.../branches/gcc-7-branch)
@@ -11,6 +11,9 @@
 	0x1.0000000000001p-1, 0x1.fffffffffffffp-2,
 	0x1.0000000000001p+0, 0x1.fffffffffffffp-1,
 	0x1.8000000000001p+0, 0x1.7ffffffffffffp+0,
+	-0x1.0000000000001p-1, -0x1.fffffffffffffp-2,
+	-0x1.0000000000001p+0, -0x1.fffffffffffffp-1,
+	-0x1.8000000000001p+0, -0x1.7ffffffffffffp+0,
 	-0.0, 0.0, -0.5, 0.5, -1.0, 1.0, -1.5, 1.5, -2.0, 2.0,
 	-2.5, 2.5 };
 #define NUM (sizeof(x)/sizeof(double))
@@ -19,6 +22,7 @@
 	-0x1.fffffffffffffp+1023, 0x1.fffffffffffffp+1023,
 	-0.0, 0.0,
 	1.0, 0.0, 1.0, 1.0, 2.0, 1.0,
+	-1.0, -0.0, -1.0, -1.0, -2.0, -1.0,
 	-0.0, 0.0, -1.0, 1.0, -1.0, 1.0, -2.0, 2.0, -2.0, 2.0,
 	-3.0, 3.0 };
 
@@ -26,6 +30,7 @@
         -0x1.fffffffffffffp+1023, 0x1.fffffffffffffp+1023,
         -0.0, 0.0,
         1.0, 0.0, 1.0, 1.0, 2.0, 1.0,
+        -1.0, -0.0, -1.0, -1.0, -2.0, -1.0,
         -0.0, 0.0, -0.0, 0.0, -1.0, 1.0, -2.0, 2.0, -2.0, 2.0,
         -2.0, 2.0 };
 
@@ -33,6 +38,7 @@
         -0x1.fffffffffffffp+1023, 0x1.fffffffffffffp+1023,
         -1.0, 0.0,
         0.0, 0.0, 1.0, 0.0, 1.0, 1.0,
+        -1.0, -1.0, -2.0, -1.0, -2.0, -2.0,
         -0.0, 0.0, -1.0, 0.0, -1.0, 1.0, -2.0, 1.0, -2.0, 2.0,
         -3.0, 2.0 };
 
@@ -40,6 +46,7 @@
         -0x1.fffffffffffffp+1023, 0x1.fffffffffffffp+1023,
         -0.0, 1.0,
         1.0, 1.0, 2.0, 1.0, 2.0, 2.0,
+        -0.0, -0.0, -1.0, -0.0, -1.0, -1.0,
         -0.0, 0.0, -0.0, 1.0, -1.0, 1.0, -1.0, 2.0, -2.0, 2.0,
         -2.0, 3.0 };
 
@@ -47,6 +54,7 @@
         -0x1.fffffffffffffp+1023, 0x1.fffffffffffffp+1023,
         -0.0, 0.0,
         0.0, 0.0, 1.0, 0.0, 1.0, 1.0,
+        -0.0, -0.0, -1.0, -0.0, -1.0, -1.0,
         -0.0, 0.0, -0.0, 0.0, -1.0, 1.0, -1.0, 1.0, -2.0, 2.0,
         -2.0, 2.0 };
 
Index: gcc/testsuite/gcc.target/i386/avx512bw-pr91150.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512bw-pr91150.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512bw-pr91150.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,37 @@
+/* PR target/91150 */
+/* { dg-do run } */
+/* { dg-options "-O2 -mavx512bw" } */
+/* { dg-require-effective-target avx512bw } */
+
+#include "avx512bw-check.h"
+
+typedef unsigned char V __attribute__((vector_size (64)));
+
+__attribute__((noinline, noclone)) void
+foo (V *x, V *y, V *z)
+{
+  *x = __builtin_shuffle (*y, *z, (V) { 0, 1, 2, 3, 4, 5, 6, 7, 8,
+					9, 10, 11, 12, 13, 14, 15,
+					80, 81, 82, 83, 84, 85, 86, 87,
+					88, 89, 90, 91, 92, 93, 94, 95,
+					96, 97, 98, 99, 100, 101, 102, 103,
+					104, 105, 106, 107, 108, 109, 110, 111,
+				        112, 113, 114, 115, 116, 117, 118, 119,
+					120, 121, 122, 123, 124, 125, 126, 127 });
+}
+
+static void
+avx512bw_test (void)
+{
+  union U { unsigned char a[64]; V v; } a, b, c;
+  int i;
+  for (i = 0; i < 64; i++)
+    {
+      b.a[i] = i + 1;
+      c.a[i] = i + 65;
+    }
+  foo (&a.v, &b.v, &c.v);
+  for (i = 0; i < 64; i++)
+    if (a.a[i] != (i < 16 ? i + 1 : i + 65))
+      __builtin_abort ();
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -12,8 +13,10 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/call-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/call-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/call-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+/* PR optimization/11304 */
+/* Originator: <manuel.serrano@sophia.inria.fr> */
+/* { dg-do run } */
+/* { dg-options "-O -fomit-frame-pointer" } */
+
+/* Verify that %eax is always restored after a call.  */
+
+__attribute__((noinline, noclone)) void set_eax(int val);
+__attribute__((noinline, noclone)) void foo(int val);
+__attribute__((noinline, noclone)) int bar(int x);
+
+#include "call-1.c"
Index: gcc/testsuite/gcc.target/i386/memset-strategy-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/memset-strategy-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/memset-strategy-1.c	(.../branches/gcc-7-branch)
@@ -1,6 +1,9 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -march=atom -mmemset-strategy=libcall:-1:align" } */
-/* { dg-final { scan-assembler-times "memset" 2  } } */
+/* On ELF platforms, one hit comes from the .file directive.  */
+/* { dg-final { scan-assembler-times "memset" 2 { target { ! *-*-darwin* } } } } */
+/* But not on Darwin, which doesn't have a .file directive by default.  */
+/* { dg-final { scan-assembler-times "_memset" 1 { target *-*-darwin* } } } */
 
 char a[2048];
 void t (void)
@@ -7,4 +10,3 @@
 {
   __builtin_memset (a, 1, 2048);
 }
-
Index: gcc/testsuite/gcc.target/i386/pr61599-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr61599-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr61599-1.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* PR target/61599 */
 /* { dg-do run { target lp64 } } */
+/* { dg-skip-if "PR90698" { *-*-darwin* } } */
 /* { dg-additional-sources pr61599-2.c } */
 /* { dg-options "-mcmodel=medium -fdata-sections" } */
 
Index: gcc/testsuite/gcc.target/i386/pr32219-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr32219-7.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr32219-7.c	(.../branches/gcc-7-branch)
@@ -12,7 +12,15 @@
   return xxx;
 }
 
-/* { dg-final { scan-assembler "movl\[ \t\]xxx\\(%rip\\), %eax" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler-not "xxx@GOTPCREL" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %eax" { target ia32 } } } */
-/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %eax" { target ia32 } } } */
+/* { dg-final { scan-assembler "movl\[ \t\]xxx\\(%rip\\), %eax" { target { { ! ia32 } && { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler-not "xxx@GOTPCREL" { target { { ! ia32 } && { ! *-*-darwin* } } } } } */
+
+/* For Darwin m64, code is always PIC but we need to indirect through the GOT to allow
+   weak symbols to be interposed.  The dynamic loader knows how to apply PIE to this.  */
+/* { dg-final { scan-assembler {movq[ \t]_xxx@GOTPCREL\(%rip\),[ \t]%rax} { target { { ! ia32 } && *-*-darwin* } } } } */
+
+/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %eax" { target { ia32 && { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %eax" { target { ia32 && { ! *-*-darwin* } } } } } */
+
+/* Darwin m32 equivalent (indirect and PIC).  */
+/* { dg-final { scan-assembler {movl[ \t][Ll]_xxx\$non_lazy_ptr-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fjump-tables" } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 void func0 (void);
 void func1 (void);
@@ -36,8 +37,10 @@
 }
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler {leaq[ \t]*L[0-9]+\(%rip\)} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {addl[ \t]*L[0-9]+-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-23.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-23.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-23.c	(.../branches/gcc-7-branch)
@@ -6,10 +6,12 @@
 struct s gs = { 100 + 200i };
 struct s __attribute__((noinline)) foo (void) { return gs; }
 
-/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 } } */
-/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk_ecx" } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk_ecx" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {call[ \t]*___x86.get_pc_thunk.cx} { target { *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {jmp[ \t]*___x86_return_thunk} { target { *-*-darwin* } } } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler-not {\tpause} } } */
 /* { dg-final { scan-assembler-not {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-7.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-7.c	(.../branches/gcc-7-branch)
@@ -7,7 +7,7 @@
 {
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-16.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-16.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-16.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mfunction-return=thunk-inline -mindirect-branch=thunk-extern -fno-pic" } */
+/* { dg-options "-O2 -mfunction-return=thunk-inline -mindirect-branch=thunk-extern " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*bar) (void);
 
@@ -11,8 +12,8 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
-/* { dg-final { scan-assembler-not "__x86_return_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/pr55116-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr55116-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr55116-1.c	(.../branches/gcc-7-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -mx32 -maddress-mode=long" } */
 
 int glob_int_arr[100];
Index: gcc/testsuite/gcc.target/i386/memcpy-strategy-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/memcpy-strategy-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/memcpy-strategy-3.c	(.../branches/gcc-7-branch)
@@ -1,6 +1,9 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -march=atom -mmemcpy-strategy=vector_loop:2000:align,libcall:-1:align" } */
-/* { dg-final { scan-assembler-times "memcpy" 2  } } */
+/* On ELF platforms, one hit comes from the .file directive.  */
+/* { dg-final { scan-assembler-times "memcpy" 2 { target { ! *-*-darwin* } } } } */
+/* But not on Darwin, which doesn't have a .file directive by default.  */
+/* { dg-final { scan-assembler-times "_memcpy" 1  { target *-*-darwin* } } } */
 
 char a[2048];
 char b[2048];
Index: gcc/testsuite/gcc.target/i386/pr89523-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-3.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,36 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -march=haswell" } */
+/* { dg-final { scan-assembler "\tvgather" } } */
+/* { dg-final { scan-assembler-not "addr32 vgather" } } */
+
+typedef double __v2df __attribute__ ((__vector_size__ (16)));
+typedef int __v4si __attribute__ ((__vector_size__ (16)));
+typedef long long __v2di __attribute__ ((__vector_size__ (16)));
+
+typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));
+typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));
+
+extern __inline __m128d
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm_i64gather_pd (double const *__base, __m128i __index, const int __scale)
+{
+  __v2df __zero = { 0.0, 0.0 };
+  __v2df __mask = __builtin_ia32_cmpeqpd (__zero, __zero);
+
+  return (__m128d) __builtin_ia32_gatherdiv2df (__zero,
+						__base,
+						(__v2di)__index,
+						__mask,
+						__scale);
+}
+
+__m128d x;
+double *base;
+__m128i idx;
+
+void extern
+avx2_test (void)
+{
+  x = _mm_i64gather_pd (base, idx, 1);
+}
Index: gcc/testsuite/gcc.target/i386/pr66819-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr66819-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr66819-3.c	(.../branches/gcc-7-branch)
@@ -1,6 +1,6 @@
 /* { dg-do compile { target ia32 } } */
 /* { dg-options "-O2 -mregparm=3" } */
-/* { dg-final { scan-assembler-not "call" } } */
+/* { dg-final { scan-assembler-not {call[ \t]+_?bar} } } */
 
 void (*bar)(int, int);
 
Index: gcc/testsuite/gcc.target/i386/pr88906.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr88906.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr88906.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,21 @@
+/* PR target/88906 */
+/* { dg-do run { target ia32 } } */
+/* { dg-options "-O -march=i386 -mtune=k6 -minline-all-stringops -minline-stringops-dynamically -mmemcpy-strategy=libcall:-1:align -Wno-psabi" } */
+
+typedef unsigned V __attribute__ ((vector_size (16)));
+
+static inline V
+foo (V v)
+{
+  __builtin_sub_overflow (0, 0, &v[0]);
+  return v;
+}
+
+int
+main ()
+{
+  V v = foo ((V) { ~0 });
+  if (v[0] || v[1] || v[2] || v[3])
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,10 +12,12 @@
   dispatch[offset](offset);
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-8.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-8.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-8.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mfunction-return=keep -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mfunction-return=keep -mindirect-branch=thunk " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 void func0 (void);
 void func1 (void);
@@ -36,7 +37,7 @@
     }
 }
 
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/pr70738-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr70738-7.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr70738-7.c	(.../branches/gcc-7-branch)
@@ -1,4 +1,4 @@
-/* { dg-do compile { target ia32 } } */
+/* { dg-do compile { target { ia32 && { ! *-*-darwin* } } } } */
 /* { dg-options "-msse2 -mgeneral-regs-only" } */
 
 extern float a, b, c;
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -12,7 +13,8 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
Index: gcc/testsuite/gcc.target/i386/pr55597.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr55597.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr55597.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile { target { ! ia32 } } } */
 /* { dg-require-effective-target fpic } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -fPIC -mx32 -maddress-mode=long" } */
 
 struct initial_sp
Index: gcc/testsuite/gcc.target/i386/pr64317.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr64317.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr64317.c	(.../branches/gcc-7-branch)
@@ -2,9 +2,14 @@
 /* { dg-require-effective-target ia32 } */
 /* { dg-require-effective-target pie } */
 /* { dg-options "-O2 -fpie" } */
-/* { dg-final { scan-assembler "addl\[ \\t\]+\[$\]_GLOBAL_OFFSET_TABLE_, %ebx" } } */
-/* { dg-final { scan-assembler "movl\[ \\t\]+c@GOTOFF\[(\]%ebx\[)\]" } } */
-/* { dg-final { scan-assembler-not "movl\[ \\t\]+\[0-9]+\[(\]%esp\[)\], %ebx" } } */
+/* { dg-final { scan-assembler "addl\[ \\t\]+\[$\]_GLOBAL_OFFSET_TABLE_, %ebx" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "movl\[ \\t\]+c@GOTOFF\[(\]%ebx\[)\]" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler-not "movl\[ \\t\]+\[0-9]+\[(\]%esp\[)\], %ebx" { target { ! *-*-darwin* } } } } */
+
+/* Check PIC access to c and t1 on Darwin (PIC is default, needed for PIE).  */
+/* { dg-final { scan-assembler {_c-L1\$pb\(%} { target *-*-darwin* } } } */
+/* { dg-final { scan-assembler {_t1.[0-9]+-L1\$pb\(%} { target *-*-darwin* } } } */
+
 long c = 1;
 
 int bar();
Index: gcc/testsuite/gcc.target/i386/pr32219-8.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr32219-8.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr32219-8.c	(.../branches/gcc-7-branch)
@@ -13,6 +13,12 @@
 }
 
 /* { dg-final { scan-assembler-not "movl\[ \t\]xxx\\(%rip\\), %" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "xxx@GOTPCREL" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %" { target ia32 } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %" { target ia32 } } } */
+/* Darwin is always PIC so no change, weak symbols needs to be indirect and this
+   happens to match the ELF case.  */
+/* { dg-final { scan-assembler "_?xxx@GOTPCREL" { target { ! ia32 } } } } */
+
+/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %" { target { ia32 && { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %" { target { ia32 && { ! *-*-darwin* } } } } } */
+
+/* Darwin m32 default to PIC but needs indirection for the weak symbol.  */
+/* { dg-final { scan-assembler {movl[ \t][Ll]_xxx\$non_lazy_ptr-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -14,9 +15,11 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-24.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-24.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-24.c	(.../branches/gcc-7-branch)
@@ -6,10 +6,12 @@
 struct s gs = { 100 + 200i };
 struct s __attribute__((noinline)) foo (void) { return gs; }
 
-/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 } } */
-/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk_ecx" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_return_thunk_ecx" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {call[ \t]*___x86.get_pc_thunk.cx} { target { *-*-darwin* } } } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*___x86_return_thunk} { target { *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/pr88470.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr88470.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr88470.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,16 @@
+/* PR rtl-optimization/88470 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -maccumulate-outgoing-args -ftrapv -fno-ivopts -fno-reorder-blocks-and-partition" } */
+
+void
+foo (long x, long *y)
+{
+  long *a = y - 64, i;
+  for (i = 0; i < x; i++)
+    {
+      long v = y[i];
+      *a++ = v;
+    }
+  register void **c __asm__ ("di");
+  goto **c;
+}
Index: gcc/testsuite/gcc.target/i386/ret-thunk-8.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-8.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-8.c	(.../branches/gcc-7-branch)
@@ -8,7 +8,7 @@
 {
 }
 
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/pr55116-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr55116-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr55116-2.c	(.../branches/gcc-7-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -mx32 -maddress-mode=long" } */
 
 typedef struct rtx_def *rtx;
Index: gcc/testsuite/gcc.target/x86_64/abi/avx512f/abi-avx512f.exp
===================================================================
--- a/src/gcc/testsuite/gcc.target/x86_64/abi/avx512f/abi-avx512f.exp	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/x86_64/abi/avx512f/abi-avx512f.exp	(.../branches/gcc-7-branch)
@@ -37,7 +37,6 @@
 foreach src [lsort [glob -nocomplain $srcdir/$subdir/test_*.c]] {
     if {[runtest_file_p $runtests $src]} {
 	if { ([istarget *-*-darwin*]) } then {
-	    # FIXME: Darwin isn't tested.
 	    c-torture-execute [list $src \
 				    $srcdir/$subdir/asm-support-darwin.s] \
 				    $additional_flags
Index: gcc/testsuite/gcc.target/x86_64/abi/avx512f/asm-support-darwin.s
===================================================================
--- a/src/gcc/testsuite/gcc.target/x86_64/abi/avx512f/asm-support-darwin.s	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/x86_64/abi/avx512f/asm-support-darwin.s	(.../branches/gcc-7-branch)
@@ -0,0 +1,93 @@
+	.text
+	.p2align 4,,15
+	.globl _snapshot
+_snapshot:
+LFB3:
+	movq	%rax, _rax(%rip)
+	movq	%rbx, _rbx(%rip)
+	movq	%rcx, _rcx(%rip)
+	movq	%rdx, _rdx(%rip)
+	movq	%rdi, _rdi(%rip)
+	movq	%rsi, _rsi(%rip)
+	movq	%rbp, _rbp(%rip)
+	movq	%rsp, _rsp(%rip)
+	movq	%r8, _r8(%rip)
+	movq	%r9, _r9(%rip)
+	movq	%r10, _r10(%rip)
+	movq	%r11, _r11(%rip)
+	movq	%r12, _r12(%rip)
+	movq	%r13, _r13(%rip)
+	movq	%r14, _r14(%rip)
+	movq	%r15, _r15(%rip)
+	vmovdqu32 %zmm0, _zmm_regs+0(%rip)
+	vmovdqu32 %zmm1, _zmm_regs+64(%rip)
+	vmovdqu32 %zmm2, _zmm_regs+128(%rip)
+	vmovdqu32 %zmm3, _zmm_regs+192(%rip)
+	vmovdqu32 %zmm4, _zmm_regs+256(%rip)
+	vmovdqu32 %zmm5, _zmm_regs+320(%rip)
+	vmovdqu32 %zmm6, _zmm_regs+384(%rip)
+	vmovdqu32 %zmm7, _zmm_regs+448(%rip)
+	vmovdqu32 %zmm8, _zmm_regs+512(%rip)
+	vmovdqu32 %zmm9, _zmm_regs+576(%rip)
+	vmovdqu32 %zmm10, _zmm_regs+640(%rip)
+	vmovdqu32 %zmm11, _zmm_regs+704(%rip)
+	vmovdqu32 %zmm12, _zmm_regs+768(%rip)
+	vmovdqu32 %zmm13, _zmm_regs+832(%rip)
+	vmovdqu32 %zmm14, _zmm_regs+896(%rip)
+	vmovdqu32 %zmm15, _zmm_regs+960(%rip)
+	vmovdqu32 %zmm16, _zmm_regs+1024(%rip)
+	vmovdqu32 %zmm17, _zmm_regs+1088(%rip)
+	vmovdqu32 %zmm18, _zmm_regs+1152(%rip)
+	vmovdqu32 %zmm19, _zmm_regs+1216(%rip)
+	vmovdqu32 %zmm20, _zmm_regs+1280(%rip)
+	vmovdqu32 %zmm21, _zmm_regs+1344(%rip)
+	vmovdqu32 %zmm22, _zmm_regs+1408(%rip)
+	vmovdqu32 %zmm23, _zmm_regs+1472(%rip)
+	vmovdqu32 %zmm24, _zmm_regs+1536(%rip)
+	vmovdqu32 %zmm25, _zmm_regs+1600(%rip)
+	vmovdqu32 %zmm26, _zmm_regs+1664(%rip)
+	vmovdqu32 %zmm27, _zmm_regs+1728(%rip)
+	vmovdqu32 %zmm28, _zmm_regs+1792(%rip)
+	vmovdqu32 %zmm29, _zmm_regs+1856(%rip)
+	vmovdqu32 %zmm30, _zmm_regs+1920(%rip)
+	vmovdqu32 %zmm31, _zmm_regs+1984(%rip)
+	jmp	*_callthis(%rip)
+LFE3:
+
+	.p2align 4,,15
+	.globl _snapshot_ret
+_snapshot_ret:
+	movq	%rdi, _rdi(%rip)
+	subq	$8, %rsp
+	call	*_callthis(%rip)
+	addq	$8, %rsp
+	movq	%rax, _rax(%rip)
+	movq	%rdx, _rdx(%rip)
+	vmovdqu32	%zmm0, _zmm_regs+0(%rip)
+	vmovdqu32	%zmm1, _zmm_regs+64(%rip)
+	fstpt	_x87_regs(%rip)
+	fstpt	_x87_regs+16(%rip)
+	fldt	_x87_regs+16(%rip)
+	fldt	_x87_regs(%rip)
+	ret
+
+	.comm	_callthis,8,8
+	.comm	_rax,8,8
+	.comm	_rbx,8,8
+	.comm	_rcx,8,8
+	.comm	_rdx,8,8
+	.comm	_rsi,8,8
+	.comm	_rdi,8,8
+	.comm	_rsp,8,8
+	.comm	_rbp,8,8
+	.comm	_r8,8,8
+	.comm	_r9,8,8
+	.comm	_r10,8,8
+	.comm	_r11,8,8
+	.comm	_r12,8,8
+	.comm	_r13,8,8
+	.comm	_r14,8,8
+	.comm	_r15,8,8
+	.comm	_zmm_regs,2048,64
+	.comm	_x87_regs,128,32
+	.comm   _volatile_var,8,8
Index: gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support-darwin.s
===================================================================
--- a/src/gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support-darwin.s	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support-darwin.s	(.../branches/gcc-7-branch)
@@ -0,0 +1,77 @@
+	.file	"asm-support-darwin.s"
+	.text
+	.p2align 4,,15
+	.globl _snapshot
+_snapshot:
+LFB3:
+	movq	%rax, _rax(%rip)
+	movq	%rbx, _rbx(%rip)
+	movq	%rcx, _rcx(%rip)
+	movq	%rdx, _rdx(%rip)
+	movq	%rdi, _rdi(%rip)
+	movq	%rsi, _rsi(%rip)
+	movq	%rbp, _rbp(%rip)
+	movq	%rsp, _rsp(%rip)
+	movq	%r8, _r8(%rip)
+	movq	%r9, _r9(%rip)
+	movq	%r10, _r10(%rip)
+	movq	%r11, _r11(%rip)
+	movq	%r12, _r12(%rip)
+	movq	%r13, _r13(%rip)
+	movq	%r14, _r14(%rip)
+	movq	%r15, _r15(%rip)
+	vmovdqu	%ymm0, _ymm_regs+0(%rip)
+	vmovdqu	%ymm1, _ymm_regs+32(%rip)
+	vmovdqu	%ymm2, _ymm_regs+64(%rip)
+	vmovdqu	%ymm3, _ymm_regs+96(%rip)
+	vmovdqu	%ymm4, _ymm_regs+128(%rip)
+	vmovdqu	%ymm5, _ymm_regs+160(%rip)
+	vmovdqu	%ymm6, _ymm_regs+192(%rip)
+	vmovdqu	%ymm7, _ymm_regs+224(%rip)
+	vmovdqu	%ymm8, _ymm_regs+256(%rip)
+	vmovdqu	%ymm9, _ymm_regs+288(%rip)
+	vmovdqu	%ymm10, _ymm_regs+320(%rip)
+	vmovdqu	%ymm11, _ymm_regs+352(%rip)
+	vmovdqu	%ymm12, _ymm_regs+384(%rip)
+	vmovdqu	%ymm13, _ymm_regs+416(%rip)
+	vmovdqu	%ymm14, _ymm_regs+448(%rip)
+	vmovdqu	%ymm15, _ymm_regs+480(%rip)
+	jmp	*_callthis(%rip)
+LFE3:
+	.p2align 4,,15
+	.globl _snapshot_ret
+_snapshot_ret:
+	movq	%rdi, _rdi(%rip)
+	subq	$8, %rsp
+	call	*_callthis(%rip)
+	addq	$8, %rsp
+	movq	%rax, _rax(%rip)
+	movq	%rdx, _rdx(%rip)
+	vmovdqu	%ymm0, _ymm_regs+0(%rip)
+	vmovdqu	%ymm1, _ymm_regs+32(%rip)
+	fstpt	_x87_regs(%rip)
+	fstpt	_x87_regs+16(%rip)
+	fldt	_x87_regs+16(%rip)
+	fldt	_x87_regs(%rip)
+	ret
+
+	.comm	_callthis,8,3
+	.comm	_rax,8,3
+	.comm	_rbx,8,3
+	.comm	_rcx,8,3
+	.comm	_rdx,8,3
+	.comm	_rsi,8,3
+	.comm	_rdi,8,3
+	.comm	_rsp,8,3
+	.comm	_rbp,8,3
+	.comm	_r8,8,3
+	.comm	_r9,8,3
+	.comm	_r10,8,3
+	.comm	_r11,8,3
+	.comm	_r12,8,3
+	.comm	_r13,8,3
+	.comm	_r14,8,3
+	.comm	_r15,8,3
+	.comm	_ymm_regs,512,5
+	.comm	_x87_regs,128,5
+	.comm   _volatile_var,8,3
Index: gcc/testsuite/lib/target-supports.exp
===================================================================
--- a/src/gcc/testsuite/lib/target-supports.exp	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/lib/target-supports.exp	(.../branches/gcc-7-branch)
@@ -2365,6 +2365,22 @@
     }]
 }
 
+# Return 1 if we're generating code for big-endian memory order.
+
+proc check_effective_target_be { } {
+    return [check_no_compiler_messages be object {
+	int dummy[__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ ? 1 : -1];
+    }]
+}
+
+# Return 1 if we're generating code for little-endian memory order.
+
+proc check_effective_target_le { } {
+    return [check_no_compiler_messages le object {
+	int dummy[__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ ? 1 : -1];
+    }]
+}
+
 # Return 1 if we're generating 32-bit code using default options, 0
 # otherwise.
 
@@ -4548,13 +4564,13 @@
 	     || [istarget powerpc*-*-aix5.2*] } {
 	    return 0
 	}
+	# Darwin doesn't run on power8, so far.
+	if { [istarget *-*-darwin*] } {
+	    return 0
+	}
 	return [check_no_compiler_messages powerpc_p8vector_ok object {
 	    int main (void) {
-#ifdef __MACH__
-		asm volatile ("xxlorc vs0,vs0,vs0");
-#else
 		asm volatile ("xxlorc 0,0,0");
-#endif
 		return 0;
 	    }
 	} "-mpower8-vector"]
@@ -4575,6 +4591,10 @@
 	     || [istarget powerpc*-*-aix5.2*] } {
 	    return 0
 	}
+	# Darwin doesn't run on power9, so far.
+	if { [istarget *-*-darwin*] } {
+	    return 0
+	}
 	return [check_no_compiler_messages powerpc_p9vector_ok object {
 	    int main (void) {
 		long e = -1;
@@ -4625,6 +4645,10 @@
 	     || [istarget powerpc*-*-aix5.2*] } {
 	    return 0
 	}
+	# Darwin doesn't have VSX, so no soft support for float128.
+	if { [istarget *-*-darwin*] } {
+	    return 0
+	}
 	return [check_no_compiler_messages powerpc_float128_sw_ok object {
 		volatile __float128 x = 1.0q;
 		volatile __float128 y = 2.0q;
@@ -4651,6 +4675,10 @@
 	     || [istarget powerpc*-*-aix5.2*] } {
 	    return 0
 	}
+	# Darwin doesn't run on any machine with float128 h/w so far.
+	if { [istarget *-*-darwin*] } {
+	    return 0
+	}
 	return [check_no_compiler_messages powerpc_float128_hw_ok object {
 		volatile __float128 x = 1.0q;
 		volatile __float128 y = 2.0q;
@@ -4677,13 +4705,14 @@
 	     || [istarget powerpc*-*-aix6*] } {
 	    return 0
 	}
+	# Darwin doesn't have VSX, even if it's used with an assembler
+	#which recognises the insns.
+	if { [istarget *-*-darwin*] } {
+	    return 0
+	}
 	return [check_no_compiler_messages powerpc_vsx_ok object {
 	    int main (void) {
-#ifdef __MACH__
-		asm volatile ("xxlor vs0,vs0,vs0");
-#else
 		asm volatile ("xxlor 0,0,0");
-#endif
 		return 0;
 	    }
 	} "-mvsx"]
Index: gcc/testsuite/gfortran.dg/pr85798.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr85798.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr85798.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,14 @@
+! { dg-do compile }
+program p
+   type t
+      integer, allocatable :: a(:)
+   end type
+   type u
+      real x
+      type(t) y
+   end type
+   type(t) :: z
+   type(u) :: q
+   data z%a(1) / 789 /     ! { dg-error "Allocatable component" }
+   data q%y%a(1) / 789 /   ! { dg-error "Allocatable component" }
+end
Index: gcc/testsuite/gfortran.dg/pr89077.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr89077.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr89077.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,11 @@
+! { dg-do run }
+!
+! PR fortran/89077 - ICE using * as len specifier for character parameter
+
+program test
+  implicit none
+  integer :: i
+  character(*), parameter :: s = 'abcdef'
+  character(*), parameter :: t = transfer ([(s(i:i), i=1,len(s))], s)
+  if (len (t) /= len (s) .or. t /= s) stop 1
+end
Index: gcc/testsuite/gfortran.dg/dec_structure_15.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/dec_structure_15.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/dec_structure_15.f90	(.../branches/gcc-7-branch)
@@ -1,4 +1,4 @@
-! { dg-do "compile" }
+! { dg-do compile }
 ! { dg-options "" }
 !
 ! PR fortran/77584
Index: gcc/testsuite/gfortran.dg/c_funptr_1_mod.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/c_funptr_1_mod.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/c_funptr_1_mod.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,16 @@
+! { dg-do  run }
+! { dg-additional-sources c_funptr_1.f90 }
+! Additional module to go with c_funptr_1.f90
+module win32_types
+  use, intrinsic :: iso_c_binding, only: C_INT,C_FUNPTR
+  implicit none
+  private
+
+  public WNDCLASSEX_T
+  type, bind(C) :: WNDCLASSEX_T
+     integer(C_INT) :: cbSize
+     type(C_FUNPTR) :: lpfnWndProc
+
+  end type WNDCLASSEX_T
+
+end module win32_types
Index: gcc/testsuite/gfortran.dg/gomp/pr89651.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/gomp/pr89651.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/gomp/pr89651.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,21 @@
+! PR fortran/89651
+! { dg-do compile }
+! { dg-additional-options "-Wuninitialized" }
+
+program pr89651
+  integer :: n
+  real, allocatable :: t(:)
+  n = 10
+  allocate (t(n), source = 0.0)
+!$omp parallel firstprivate(t)
+  print *, sum (t) ! { dg-bogus "lbound' may be used uninitialized in this function" }
+                   ! { dg-bogus "ubound' may be used uninitialized in this function" "" { target *-*-* } .-1 }
+                   ! { dg-bogus "offset' may be used uninitialized in this function" "" { target *-*-* } .-2 }
+!$omp end parallel
+!$omp parallel private(t)
+  t = 0.0
+  print *, sum (t) ! { dg-bogus "lbound' may be used uninitialized in this function" }
+                   ! { dg-bogus "ubound' may be used uninitialized in this function" "" { target *-*-* } .-1 }
+                   ! { dg-bogus "offset' may be used uninitialized in this function" "" { target *-*-* } .-2 }
+!$omp end parallel
+end program pr89651
Index: gcc/testsuite/gfortran.dg/gomp/pr89621.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/gomp/pr89621.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/gomp/pr89621.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,18 @@
+! PR middle-end/89621
+! { dg-do compile }
+
+subroutine sub(str)
+  character(*), intent(in) :: str
+end subroutine sub
+
+program pr89621
+  implicit none
+  integer i
+  character(len=:), allocatable :: str
+  str = "test"
+  !$omp parallel do
+  do i = 1, 10
+    call sub(str)
+  enddo
+  !$omp end parallel do
+end program pr89621
Index: gcc/testsuite/gfortran.dg/gomp/pr88377.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/gomp/pr88377.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/gomp/pr88377.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,15 @@
+! PR fortran/88377
+! { dg-do compile }
+
+program pr88377
+  call s(3)
+contains
+  subroutine s(n)
+    integer :: n
+    character(n), allocatable :: x
+    x = 'abc'
+    !$omp task
+    print *, x, (x == 'abc')
+    !$omp end task
+  end
+end
Index: gcc/testsuite/gfortran.dg/gomp/schedule-modifiers-1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/gomp/schedule-modifiers-1.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/gomp/schedule-modifiers-1.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,63 @@
+! { dg-do compile }
+! { dg-options "-fopenmp" }
+
+subroutine foo
+  integer :: i
+  !$omp do simd schedule (simd, simd: static, 5)
+  do i = 0, 64
+  end do
+  !$omp do simd schedule (monotonic, simd: static)
+  do i = 0, 64
+  end do
+  !$omp do simd schedule (simd , monotonic : static, 6)
+  do i = 0, 64
+  end do
+  !$omp do schedule (monotonic, monotonic : static, 7)
+  do i = 0, 64
+  end do
+  !$omp do schedule (nonmonotonic, nonmonotonic : dynamic)
+  do i = 0, 64
+  end do
+  !$omp do simd schedule (nonmonotonic , simd : dynamic, 3)
+  do i = 0, 64
+  end do
+  !$omp do simd schedule (nonmonotonic,simd:guided,4)
+  do i = 0, 64
+  end do
+  !$omp do schedule (monotonic: static, 2)
+  do i = 0, 64
+  end do
+  !$omp do schedule (monotonic : static)
+  do i = 0, 64
+  end do
+  !$omp do schedule (monotonic : dynamic)
+  do i = 0, 64
+  end do
+  !$omp do schedule (monotonic : dynamic, 3)
+  do i = 0, 64
+  end do
+  !$omp do schedule (monotonic : guided)
+  do i = 0, 64
+  end do
+  !$omp do schedule (monotonic : guided, 7)
+  do i = 0, 64
+  end do
+  !$omp do schedule (monotonic : runtime)
+  do i = 0, 64
+  end do
+  !$omp do schedule (monotonic : auto)
+  do i = 0, 64
+  end do
+  !$omp do schedule (nonmonotonic : dynamic)
+  do i = 0, 64
+  end do
+  !$omp do schedule (nonmonotonic : dynamic, 3)
+  do i = 0, 64
+  end do
+  !$omp do schedule (nonmonotonic : guided)
+  do i = 0, 64
+  end do
+  !$omp do schedule (nonmonotonic : guided, 7)
+  do i = 0, 64
+  end do
+end subroutine foo
Index: gcc/testsuite/gfortran.dg/gomp/schedule-modifiers-2.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/gomp/schedule-modifiers-2.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/gomp/schedule-modifiers-2.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,44 @@
+! { dg-do compile }
+! { dg-options "-fopenmp" }
+
+subroutine foo
+  integer :: i
+  !$omp do schedule (nonmonotonic: static, 2)	! { dg-error "NONMONOTONIC modifier specified for STATIC schedule kind" }
+  do i = 0, 64
+  end do
+  !$omp do schedule (nonmonotonic : static)	! { dg-error "NONMONOTONIC modifier specified for STATIC schedule kind" }
+  do i = 0, 64
+  end do
+  !$omp do schedule (nonmonotonic : runtime)	! { dg-error "NONMONOTONIC modifier specified for RUNTIME schedule kind" }
+  do i = 0, 64
+  end do
+  !$omp do schedule (nonmonotonic : auto)	! { dg-error "NONMONOTONIC modifier specified for AUTO schedule kind" }
+  do i = 0, 64
+  end do
+  !$omp do schedule (nonmonotonic : dynamic) ordered	! { dg-error "NONMONOTONIC schedule modifier specified with ORDERED clause" }
+  do i = 0, 64
+    !$omp ordered
+    !$omp end ordered
+  end do
+  !$omp do ordered schedule(nonmonotonic : dynamic, 5)	! { dg-error "NONMONOTONIC schedule modifier specified with ORDERED clause" }
+  do i = 0, 64
+    !$omp ordered
+    !$omp end ordered
+  end do
+  !$omp do schedule (nonmonotonic : guided) ordered(1)	! { dg-error "NONMONOTONIC schedule modifier specified with ORDERED clause" }
+  do i = 0, 64
+    !$omp ordered depend(sink: i - 1)
+    !$omp ordered depend(source)
+  end do
+  !$omp do ordered(1) schedule(nonmonotonic : guided, 2)	! { dg-error "NONMONOTONIC schedule modifier specified with ORDERED clause" }
+  do i = 0, 64
+    !$omp ordered depend(source)
+    !$ordered depend(sink: i - 1)
+  end do
+  !$omp do schedule (nonmonotonic , monotonic : dynamic)	! { dg-error "Both MONOTONIC and NONMONOTONIC schedule modifiers specified" }
+  do i = 0, 64
+  end do
+  !$omp do schedule (monotonic,nonmonotonic:dynamic)	! { dg-error "Both MONOTONIC and NONMONOTONIC schedule modifiers specified" }
+  do i = 0, 64
+  end do
+end subroutine foo
Index: gcc/testsuite/gfortran.dg/warn_undefined_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/warn_undefined_1.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/warn_undefined_1.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,28 @@
+! { dg-do compile }
+! { dg-options "-O2 -Wuninitialized" }
+! PR 67679 - this used to cause an undefined warning for
+! variables generated by the compiler.
+
+subroutine s(h, Gmin, r)
+
+   implicit none
+   real, intent(in) ::  Gmin(3), h(3)
+   integer, intent(inout) :: r
+
+   integer :: x_min(3), x_max(3), k, iStat
+   logical, dimension(:), allocatable :: check
+
+   do k = 1,1
+      x_min(k) = int(Gmin(k)*h(k))
+      x_max(k) = int(Gmin(k)*h(k))
+   end do
+
+   allocate(check(x_min(1):x_max(1)),stat=iStat)
+
+   check(:) = .false.
+
+   do k = x_min(1),x_max(1)
+            r = r + 1
+   end do
+
+end
Index: gcc/testsuite/gfortran.dg/pr88169_2.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr88169_2.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr88169_2.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,31 @@
+! { dg-do run }
+module foo_nml
+   implicit none
+   real :: x = -1
+   namelist /foo/ x
+end module
+!
+! Yes, implicit typing of local variable 'x'.
+!
+program main
+   use foo_nml, only: bar => foo
+   integer fd
+   x = 42
+   open(newunit=fd, file='tmp.dat', status='replace')
+   write(fd,nml=bar)
+   close(fd)
+   open(newunit=fd, file='tmp.dat', status='old')
+   read(fd,nml=bar)
+   close(fd)
+   call bah
+   if (x /= 42) stop 1
+end program
+
+subroutine bah
+   use foo_nml
+   integer fd
+   open(newunit=fd, file='tmp.dat', status='old')
+   read(fd,nml=foo)
+   if (x /= -1) stop 2
+   close(fd, status='delete')
+end subroutine bah
Index: gcc/testsuite/gfortran.dg/pr35031.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr35031.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr35031.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,10 @@
+! { dg-do compile }
+elemental subroutine sub2(x)
+   integer, intent(in) :: x
+   entry sub2_c(x) bind(c)    ! { dg-error "prohibited in an elemental" }
+end subroutine sub2
+
+elemental function func2(x)
+   integer, intent(in) :: x
+   entry func2_c(x) bind(c)   ! { dg-error "prohibited in an elemental" }
+end function func2
Index: gcc/testsuite/gfortran.dg/char_result_mod_19.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/char_result_mod_19.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/char_result_mod_19.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,18 @@
+! { dg-do  run }
+! { dg-additional-sources char_result_19.f90 }
+!
+! Module for char_result_19.f90
+! Tests fix for PR86248
+!
+module test_module
+  implicit none
+  public :: func_1
+  private
+  character(len=*),dimension(0:2),parameter :: darray = (/"el0 ","el11","el2 "/)
+contains
+  function func_1 (func_1_input) result(f)
+    integer, intent(in) :: func_1_input
+    character(len = len_trim (darray(func_1_input))) :: f
+    f = darray(func_1_input)
+  end function func_1
+end module test_module
Index: gcc/testsuite/gfortran.dg/c_funptr_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/c_funptr_1.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/c_funptr_1.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,38 @@
+! { dg-do preprocess }
+! { dg-additional-options "-cpp" }
+! PR 57048 - this used not to compile. Original test case by Angelo
+! Graziosi.  Only works if compiled c_funptr_1_mod.f90, hence the
+! do-nothing directive above.
+module procs
+  
+  implicit none
+  private
+
+  public WndProc
+
+contains
+  function WndProc()
+    integer :: WndProc
+    
+    WndProc = 0
+  end function WndProc
+end module procs
+
+function WinMain()
+  use, intrinsic :: iso_c_binding, only: C_INT,c_sizeof,c_funloc
+  use win32_types
+  use procs
+  implicit none
+
+  integer :: WinMain
+
+  type(WNDCLASSEX_T) :: WndClass
+
+  WndClass%cbSize = int(c_sizeof(Wndclass),C_INT)
+  WndClass%lpfnWndProc = c_funloc(WndProc)
+
+  WinMain = 0
+end function WinMain
+
+program main
+end 
Index: gcc/testsuite/gfortran.dg/c_ptr_tests_19.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/c_ptr_tests_19.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/c_ptr_tests_19.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,36 @@
+! { dg-do run }
+
+! PR 71544 - this failed with some optimization options due to a
+! pointer not being marked as escaping.
+
+module store_cptr
+    use, intrinsic :: iso_c_binding
+    implicit none
+    public
+    type(c_ptr), save :: cptr
+end module store_cptr
+
+subroutine init()
+    use, intrinsic :: iso_c_binding
+    implicit none
+    integer(c_int), pointer :: a
+    allocate(a)
+    call save_cptr(c_loc(a))
+    a = 100
+end subroutine init
+
+subroutine save_cptr(cptr_in)
+    use store_cptr
+    implicit none
+    type(c_ptr), intent(in) :: cptr_in
+    cptr = cptr_in
+end subroutine save_cptr
+
+program init_fails
+    use store_cptr
+    implicit none
+    integer(c_int), pointer :: val
+    call init()
+    call c_f_pointer(cptr,val)
+    if (val /= 100) stop 1
+end program init_fails
Index: gcc/testsuite/gfortran.dg/public_private_module_10.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/public_private_module_10.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/public_private_module_10.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! PR 87734 - this used to issue spurious errors.
+
+module m_vstring
+  implicit none
+
+  public :: vstring_length
+
+contains
+
+  subroutine vstring_cast()
+    character ( len = vstring_length() ) :: char_string
+  end subroutine
+
+  pure integer function vstring_length ()
+  end function
+
+end module
Index: gcc/testsuite/gfortran.dg/proc_ptr_51.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/proc_ptr_51.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/proc_ptr_51.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,38 @@
+! { dg-do run }
+!
+! Test the fix for PR90786.
+!
+! Contributed by Andrew benson  <abensonca@gmail.com>
+!
+module f
+procedure(c), pointer :: c_
+
+ type :: s
+   integer :: i = 42
+ end type s
+ class(s), pointer :: res, tgt
+
+contains
+
+ function c()
+   implicit none
+   class(s), pointer ::  c
+   c => tgt
+   return
+ end function c
+
+ subroutine fs()
+   implicit none
+   c_ => c  ! This used to ICE
+   return
+ end subroutine fs
+
+end module f
+
+  use f
+  allocate (tgt, source = s(99))
+  call fs()
+  res => c_()
+  if (res%i .ne. 99) stop 1
+  deallocate (tgt)
+end
Index: gcc/testsuite/gfortran.dg/dependency_53.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/dependency_53.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/dependency_53.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,25 @@
+! { dg-do run }
+! PR fortran/66089 - used to ICE and, after that ICE was fixed,
+! gave wrong results.
+  type :: t
+    integer :: c
+  end type t
+
+  class(t), dimension(:), allocatable :: b,c
+
+  allocate (b(5), source=t(7))
+  allocate(c(5), source=t(13))
+  c = plus(c(1), b)
+  if (any(c%c /= 20)) stop 1
+  c = t(13)
+  c = plus(b, c(1))
+  if (any(c%c /= 20)) stop 2
+contains
+
+  elemental function plus(lhs, rhs)
+    class(t), intent(in) :: lhs, rhs
+    type(t)             :: plus
+    plus%c = lhs%c + rhs%c
+  end function plus
+
+end
Index: gcc/testsuite/gfortran.dg/debug/pr35154-stabs.f
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/debug/pr35154-stabs.f	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/debug/pr35154-stabs.f	(.../branches/gcc-7-branch)
@@ -1,7 +1,7 @@
 C     Test program for common block debugging.  G. Helffrich 11 July 2004.
 C { dg-do compile }
 C { dg-skip-if "No stabs" { aarch64*-*-* mmix-*-* alpha*-*-* hppa*64*-*-* ia64-*-* *-*-vxworks* } { "*" } { "" } }
-C { dg-skip-if "No stabs" {*-*-* } { "*" } { "-gstabs" } }
+C { dg-skip-if "No stabs" { *-*-* } { "*" } { "-gstabs" } }
       common i,j
       common /label/l,m
       i = 1
Index: gcc/testsuite/gfortran.dg/binding_label_tests_30.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/binding_label_tests_30.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/binding_label_tests_30.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! Make sure this error is flagged.
+subroutine foo() ! { dg-error "is already being used as a SUBROUTINE" }
+end subroutine foo
+
+subroutine bar() bind(C,name="foo") ! { dg-error "is already being used as a SUBROUTINE" }
+end subroutine bar
Index: gcc/testsuite/gfortran.dg/warn_unused_dummy_argument_5.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/warn_unused_dummy_argument_5.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/warn_unused_dummy_argument_5.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,16 @@
+! { dg-do compile }
+! { dg-additional-options "-Wunused-dummy-argument" }
+! PR 91557 - this used to generate a bogus warning
+! Test case by Gerhard Steinmetz
+program p
+   integer :: a, b
+   a = 1
+   call g
+contains
+   subroutine g
+      integer :: x, y
+      call h (x, y)
+      if ( a > 0 )   y = y - 1
+      b = y - x + 1
+   end
+end
Index: gcc/testsuite/gfortran.dg/pr88155.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr88155.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr88155.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,9 @@
+! { dg-do compile }
+program p
+   type t
+      integer :: a
+   end type
+   type(t) :: x
+   data x /t()1/     ! { dg-error "No initializer for component" }
+   print *, x
+end
Index: gcc/testsuite/gfortran.dg/associate_44.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/associate_44.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/associate_44.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,23 @@
+! { dg-do compile }
+!
+! Test the fix for PR56386
+!
+! Contributed by Vladimir Fuka  <vladimir.fuka@gmail.com>
+!
+subroutine  CustomSolidBodies
+   implicit none
+
+    type inner
+      real :: elev
+    end type
+
+    type :: outer
+      type(inner),dimension(0) :: PrPoints
+    end type
+
+    type(outer) :: SB
+
+    associate (Prter=>SB%PrPoints)
+       PrTer%elev=0                  ! ICE here
+    end associate
+end subroutine  CustomSolidBodies
Index: gcc/testsuite/gfortran.dg/warn_conversion_10.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/warn_conversion_10.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/warn_conversion_10.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! { dg-options "-fno-range-check -Wconversion" }
+! PR 88298 - this used to warn unnecessarily.  Original test case by
+! Harald Anlauf.
+subroutine bug (j, js)
+  integer    :: j, js(3,2)
+  js(:,:) = cshift (js(:,:), shift=j, dim=1)
+end subroutine bug
Index: gcc/testsuite/gfortran.dg/pr91686.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr91686.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr91686.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,16 @@
+! { dg-do run }
+!
+! Test the fix for PR91686
+!
+! Contributed by  <urbanjost@comcast.net>
+!
+program shuf
+  implicit none
+  character(len=:),allocatable :: pageout(:)
+  integer                      :: i
+  pageout=[character(len=20) :: 'a','bbbbbbb','ccccc']
+  pageout=pageout([3,2,1])
+  if (trim( pageout(1)) .ne. 'ccccc') stop 1
+  if (trim( pageout(2)) .ne. 'bbbbbbb') stop 2
+  if (trim( pageout(3)) .ne. 'a') stop 3
+end program shuf
Index: gcc/testsuite/gfortran.dg/pr85797.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr85797.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr85797.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,31 @@
+! { dg-do compile }
+! PR fortran/83515 - ICE: Invalid expression in gfc_element_size 
+! PR fortran/85797 - ICE in gfc_element_size, at fortran/target-memory.c:126
+! PR fortran/89904 - ICE in gfortran starting with r270045
+
+recursive subroutine a
+  c = transfer (a, b)           ! { dg-error "'SOURCE' argument of 'TRANSFER'" }
+end
+
+recursive subroutine d
+  c = transfer (b, d)           ! { dg-error "'MOLD' argument of 'TRANSFER'" }
+end
+
+subroutine f
+  use, intrinsic :: iso_c_binding
+  integer(c_intptr_t) :: b, c
+  procedure(), pointer :: a
+  c = transfer (a, b)
+  c = transfer (transfer (b, a), b)
+end
+
+module m
+contains
+  function f () result (z)
+    class(*), pointer :: z
+  end function f
+  recursive subroutine s (q)
+    procedure(f) :: q
+    call s (q)
+  end subroutine s
+end
Index: gcc/testsuite/gfortran.dg/dec_structure_14.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/dec_structure_14.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/dec_structure_14.f90	(.../branches/gcc-7-branch)
@@ -1,4 +1,4 @@
-  ! { dg-do "compile" }
+  ! { dg-do compile }
   ! { dg-options "-fdec-structure" }
   !
   ! Test that structures inside a common block do not require the
Index: gcc/testsuite/gfortran.dg/pr90344.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr90344.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr90344.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,25 @@
+! { dg-do compile }
+! { dg-additional-options "-ffrontend-optimize" }
+! PR 90344 - this used to ICE.
+! Test case by Urban Jost.
+module M_xterm
+contains
+   elemental function func1(ch) result(res)
+      character,intent(in) :: ch
+      logical              :: res
+      res=.true.
+   end function func1
+   elemental function func2(ch) result(res)
+      character,intent(in) :: ch
+      logical              :: res
+      res=.false.
+   end function func2
+   pure function s2a(string)  RESULT (array)
+      character(len=*),intent(in) :: string
+      character(len=1)            :: array(len(string))
+      forall(i=1:len(string)) array(i) = string(i:i)
+   end function s2a
+   subroutine sub1()
+      write(*,*)all(func1(s2a('ABCDEFG')).or.func2(s2a('ABCDEFG')))
+   end subroutine sub1
+end module M_xterm
Index: gcc/testsuite/gfortran.dg/coarray_data_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/coarray_data_1.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/coarray_data_1.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,11 @@
+! { dg-do  run }
+! { dg-options "-fcoarray=lib -lcaf_single " }
+! PR 71066 - this used to ICE
+program p
+   real :: a(2,2)[*]
+   integer :: b(2,2)[*]
+   data a /4*0.0/
+   data b /1234, 2345, 3456, 4567/
+   if (any (a /= 0.0)) stop 1
+   if (any (b /= reshape([1234, 2345, 3456, 4567],[2,2]))) stop 2
+end
Index: gcc/testsuite/gfortran.dg/pr88169_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr88169_1.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr88169_1.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,21 @@
+! { dg-do run }
+module foo_nml
+   implicit none
+   real :: x = -1
+   namelist /foo/ x
+end module
+
+program main
+   use foo_nml, only: bar => foo, x
+   implicit none
+   integer fd
+   x = 42
+   open(newunit=fd, file='tmp.dat', status='replace')
+   write(fd,nml=bar)
+   close(fd)
+   open(newunit=fd, file='tmp.dat', status='old')
+   read(fd,nml=bar)
+   if (x /= 42) stop 1
+   close(fd)
+end program
+! { dg-final { cleanup-modules "foo_nml" } }
Index: gcc/testsuite/gfortran.dg/pr83246.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr83246.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr83246.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,9 @@
+! PR fortran/83246
+! { dg-do link }
+   program dusty_corner 
+   write(*,*)'BLOCK TESTS' 
+   MAKEDATAP: block
+   integer,parameter :: scratch(*)=[1,2,3]
+   write(*,*)scratch
+   endblock MAKEDATAP
+   end program dusty_corner
Index: gcc/testsuite/gfortran.dg/pr89253.f
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr89253.f	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr89253.f	(.../branches/gcc-7-branch)
@@ -0,0 +1,19 @@
+! { dg-do compile }
+! { dg-additional-options "-fsplit-loops -fno-tree-dominator-opts -std=legacy -w" }
+      program jr
+      integer :: w5, pg, zh
+      w5 = 0
+      write (w5)
+      assign 0002 to w5
+      do pg = 1, 3
+         if (pg .eq. 1) then
+            do zh = 1, pg
+            end do
+         else
+            goto w5
+ 0001       zh = 0
+ 0002       zh = 0
+            assign 0001 to w5
+         endif
+      end do
+      end
Index: gcc/testsuite/gfortran.dg/coarray_allocate_11.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/coarray_allocate_11.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/coarray_allocate_11.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,15 @@
+! { dg-do compile }
+! { dg-additional-options -fcoarray=single }
+program p
+   integer, allocatable :: z[:,:]
+   integer :: i
+   allocate (z[1:,*]) ! { dg-error "Bad array specification in ALLOCATE statement" }
+   allocate (z[:2,*]) ! { dg-error "Bad array specification in ALLOCATE statement" }
+   allocate (z[2:1,*]) ! { dg-error "Upper cobound is less than lower cobound" }
+   allocate (z[:0,*]) ! { dg-error "Bad array specification in ALLOCATE statement" }
+   allocate (z[0,*]) ! { dg-error "Upper cobound is less than lower cobound" }
+   allocate (z[1,*]) ! This is OK
+   allocate (z[1:1,*]) ! This is OK
+   allocate (z[i:i,*]) ! This is OK
+   allocate (z[i:i-1,*]) ! { dg-error "Upper cobound is less than lower cobound" }
+end
Index: gcc/testsuite/gfortran.dg/pr51434.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr51434.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr51434.f90	(.../branches/gcc-7-branch)
@@ -6,7 +6,7 @@
    character(len=1), parameter :: s(n) = 'a'
    type :: a
       integer :: m = n
-      character(len=1):: t(n) = transfer('abcde             ', s)
+      character(len=1):: t(n) = transfer('abcde', s)
    end type a
 end module foo
 
Index: gcc/testsuite/gfortran.dg/pr88269.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr88269.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr88269.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,6 @@
+! { dg-do compile }
+! PR fortran/88269
+program p
+   write (end=1e1) ! { dg-error "tag not allowed" }
+end
+
Index: gcc/testsuite/gfortran.dg/ieee/ieee.exp
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/ieee/ieee.exp	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/ieee/ieee.exp	(.../branches/gcc-7-branch)
@@ -22,15 +22,15 @@
 load_lib gfortran-dg.exp
 load_lib target-supports.exp
 
-# Initialize `dg'.
-dg-init
-
-# Flags specified in each test
+# If a testcase doesn't have special options, use these.
 global DEFAULT_FFLAGS
 if ![info exists DEFAULT_FFLAGS] then {
-    set DEFAULT_FFLAGS ""
+    set DEFAULT_FFLAGS " -pedantic-errors"
 }
 
+# Initialize `dg'.
+dg-init
+
 # Flags for finding the IEEE modules
 if [info exists TOOL_OPTIONS] {
    set specpath [get_multilibs ${TOOL_OPTIONS}]
Index: gcc/testsuite/gfortran.dg/null_10.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/null_10.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/null_10.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! PR 71860 - this used to ICE
+! Original test case by Gerhard Steinmetz
+program p
+   class(*), pointer :: z
+   z => null(z)
+end
Index: gcc/testsuite/gfortran.dg/binding_label_tests_33.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/binding_label_tests_33.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/binding_label_tests_33.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,39 @@
+! { dg-do run }
+! PR 79485 - used to crash because the wrong routine was called.
+module fmod1
+
+  contains
+
+  subroutine foo(i)
+    implicit none
+
+    integer, intent(inout) :: i
+
+    i=i+1
+
+  end subroutine foo
+
+end module fmod1
+
+module fmod2
+  use iso_c_binding
+  use fmod1, only : foo_first => foo
+
+  contains
+
+  subroutine foo(i) bind(c)
+    implicit none
+
+    integer, intent(inout) :: i
+
+    i=i+2
+    call foo_first(i)
+
+  end subroutine foo
+
+end module fmod2
+
+  use fmod2
+  
+  call foo(i)
+end
Index: gcc/testsuite/gfortran.dg/charlen_17.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/charlen_17.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/charlen_17.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,14 @@
+! { dg-do compile }
+! PR 87673 - used to cause errors about non-pure functions.
+
+module x
+  implicit none
+contains
+  pure function foo() result(res)
+    character(len=:), allocatable :: res
+    allocate (character(bar()) :: res)
+  end function foo
+  pure integer function bar()
+    bar = 1
+  end function bar
+end module x
Index: gcc/testsuite/gfortran.dg/char_result_19.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/char_result_19.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/char_result_19.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,24 @@
+! { dg-do preprocess }
+! { dg-additional-options "-cpp" }
+!
+! Test the fix for PR86248
+!
+! Contributed by Bill Long  <longb@cray.com>
+!
+program test
+  use test_module
+  implicit none
+  integer :: i
+  character(:), allocatable :: chr
+  do i = 0, 2
+    chr = func_1 (i)
+    select case (i)
+      case (0)
+        if (chr .ne. 'el0') stop i
+      case (1)
+        if (chr .ne. 'el11') stop i
+      case (2)
+        if (chr .ne. 'el2') stop i
+    end select
+  end do
+end program test
Index: gcc/testsuite/gfortran.dg/coarray_lock_7.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/coarray_lock_7.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/coarray_lock_7.f90	(.../branches/gcc-7-branch)
@@ -35,8 +35,8 @@
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_lock \\(caf_token.., 0, 0, 0B, 0B, 0B, 0\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_unlock \\(caf_token.., 0, 0, 0B, 0B, 0\\);" 1 "original" } }
 
-! { dg-final { scan-tree-dump-times "_gfortran_caf_lock \\(caf_token.., \\(3 - \\(integer\\(kind=4\\)\\) parm...dim\\\[0\\\].lbound\\) \\+ \\(integer\\(kind=4\\)\\) MAX_EXPR <\\(parm...dim\\\[0\\\].ubound - parm...dim\\\[0\\\].lbound\\) \\+ 1, 0> \\* \\(3 - \\(integer\\(kind=4\\)\\) parm...dim\\\[1\\\].lbound\\), 0, 0B, &ii, 0B, 0\\);|_gfortran_caf_lock \\(caf_token.1, \\(3 - parm...dim\\\[0\\\].lbound\\) \\+ MAX_EXPR <\\(parm...dim\\\[0\\\].ubound - parm...dim\\\[0\\\].lbound\\) \\+ 1, 0> \\* \\(3 - parm...dim\\\[1\\\].lbound\\), 0, 0B, &ii, 0B, 0\\);" 1 "original" } }
-! { dg-final { scan-tree-dump-times "_gfortran_caf_unlock \\(caf_token.., \\(2 - \\(integer\\(kind=4\\)\\) parm...dim\\\[0\\\].lbound\\) \\+ \\(integer\\(kind=4\\)\\) MAX_EXPR <\\(parm...dim\\\[0\\\].ubound - parm...dim\\\[0\\\].lbound\\) \\+ 1, 0> \\* \\(3 - \\(integer\\(kind=4\\)\\) parm...dim\\\[1\\\].lbound\\), 0, &ii, 0B, 0\\);|_gfortran_caf_unlock \\(caf_token.., \\(2 - parm...dim\\\[0\\\].lbound\\) \\+ MAX_EXPR <\\(parm...dim\\\[0\\\].ubound - parm...dim\\\[0\\\].lbound\\) \\+ 1, 0> \\* \\(3 - parm...dim\\\[1\\\].lbound\\), 0, &ii, 0B, 0\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "_gfortran_caf_lock \\(caf_token.., \\(3 - \\(integer\\(kind=4\\)\\) parm....dim\\\[0\\\].lbound\\) \\+ \\(integer\\(kind=4\\)\\) MAX_EXPR <\\(parm....dim\\\[0\\\].ubound - parm....dim\\\[0\\\].lbound\\) \\+ 1, 0> \\* \\(3 - \\(integer\\(kind=4\\)\\) parm....dim\\\[1\\\].lbound\\), 0, 0B, &ii, 0B, 0\\);|_gfortran_caf_lock \\(caf_token.1, \\(3 - parm....dim\\\[0\\\].lbound\\) \\+ MAX_EXPR <\\(parm....dim\\\[0\\\].ubound - parm....dim\\\[0\\\].lbound\\) \\+ 1, 0> \\* \\(3 - parm....dim\\\[1\\\].lbound\\), 0, 0B, &ii, 0B, 0\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "_gfortran_caf_unlock \\(caf_token.., \\(2 - \\(integer\\(kind=4\\)\\) parm....dim\\\[0\\\].lbound\\) \\+ \\(integer\\(kind=4\\)\\) MAX_EXPR <\\(parm....dim\\\[0\\\].ubound - parm....dim\\\[0\\\].lbound\\) \\+ 1, 0> \\* \\(3 - \\(integer\\(kind=4\\)\\) parm....dim\\\[1\\\].lbound\\), 0, &ii, 0B, 0\\);|_gfortran_caf_unlock \\(caf_token.., \\(2 - parm....dim\\\[0\\\].lbound\\) \\+ MAX_EXPR <\\(parm....dim\\\[0\\\].ubound - parm....dim\\\[0\\\].lbound\\) \\+ 1, 0> \\* \\(3 - parm....dim\\\[1\\\].lbound\\), 0, &ii, 0B, 0\\);" 1 "original" } }
 
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_lock \\(three.token, 0, 5 - \\(integer\\(kind=4\\)\\) three.dim\\\[0\\\].lbound, &acquired.\[0-9\]+, 0B, 0B, 0\\);|_gfortran_caf_lock \\(three.token, 0, 5 - three.dim\\\[0\\\].lbound, &acquired.\[0-9\]+, 0B, 0B, 0\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_unlock \\(three.token, 0, 8 - \\(integer\\(kind=4\\)\\) three.dim\\\[0\\\].lbound, &ii, 0B, 0\\);|_gfortran_caf_unlock \\(three.token, 0, 8 - three.dim\\\[0\\\].lbound, &ii, 0B, 0\\);" 1 "original" } }
Index: gcc/testsuite/gfortran.dg/pr88206.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr88206.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr88206.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/88206
+program p
+   integer, parameter :: z(4) = [1,2,3,4]
+   integer :: k = 2
+   print *, [real(z(k))]
+end
+
Index: gcc/testsuite/gfortran.dg/pointer_init_2.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pointer_init_2.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pointer_init_2.f90	(.../branches/gcc-7-branch)
@@ -18,7 +18,7 @@
   integer, pointer :: dp0 => 13  ! { dg-error "Error in pointer initialization" }
   integer, pointer :: dp1 => r   ! { dg-error "Different types in pointer assignment" }
   integer, pointer :: dp2 => v   ! { dg-error "Different ranks in pointer assignment" }
-  integer, pointer :: dp3 => i   ! { dg-error "is neither TARGET nor POINTER" }
+  integer, pointer :: dp3 => i   ! { dg-error "Pointer assignment target in initialization expression does not have the TARGET attribute" }
   integer, pointer :: dp4 => j   ! { dg-error "must have the SAVE attribute" }
   integer, pointer :: dp5 => a   ! { dg-error "must not be ALLOCATABLE" }
 
@@ -35,7 +35,7 @@
   end type t3
 
   type t4
-    integer, pointer :: dpc3 => i   ! { dg-error "Pointer assignment target is neither TARGET nor POINTER" }
+    integer, pointer :: dpc3 => i   ! { dg-error "Pointer assignment target in initialization expression does not have the TARGET attribute" }
   end type t4
 
   type t5
Index: gcc/testsuite/gfortran.dg/deferred_character_32.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/deferred_character_32.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/deferred_character_32.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,13 @@
+! { dg-do run }
+!
+! Test the fix for PR88117.
+!
+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>
+!
+program p
+   character(:), pointer :: z(:)
+   allocate (z, source  = ['abcd', 'bcde'])
+   z = (z) ! gimplifier choked here.
+   if (any (z .ne. ['abcd', 'bcde'])) stop 1
+   deallocate (z)
+end
Index: gcc/testsuite/gfortran.dg/class_66.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/class_66.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/class_66.f90	(.../branches/gcc-7-branch)
@@ -1,4 +1,4 @@
-! { dg- do run }
+! { dg-do run }
 !
 ! Test the fix for PR78641 in which an ICE occured on assignment
 ! of a class array constructor to a derived type array.
Index: gcc/testsuite/gfortran.dg/dg.exp
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/dg.exp	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/dg.exp	(.../branches/gcc-7-branch)
@@ -36,7 +36,7 @@
     global gfortran_test_path
     global gfortran_aux_module_flags
     if { [llength $args] != 2 } {
-	error "dg-set-target-env-var: needs one argument"
+	error "dg-compile-aux-modules: needs one argument"
 	return
     }
 
Index: gcc/testsuite/gfortran.dg/pointer_init_6.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pointer_init_6.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pointer_init_6.f90	(.../branches/gcc-7-branch)
@@ -13,7 +13,7 @@
  integer, target :: i
  type(t), target :: x
  integer, pointer :: p1 => i
- integer, pointer :: p2 => p1   ! { dg-error "must have the TARGET attribute" }
+ integer, pointer :: p2 => p1   ! { dg-error "Pointer assignment target in initialization expression does not have the TARGET attribute at" }
  integer, pointer :: p3 => x%p  ! { dg-error "must have the TARGET attribute" }
  integer, pointer :: p4 => x%i
  integer, pointer :: p5 => u    ! { dg-error "has no IMPLICIT type" }
Index: gcc/testsuite/gfortran.dg/pr88228.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr88228.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr88228.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! { dg-options "-fdec" }
+! PR fortran/88228
+program p
+   integer :: n = .not. 1
+   integer :: j = .true. .or. 1
+end
+
Index: gcc/testsuite/gfortran.dg/pr78259.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr78259.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr78259.f90	(.../branches/gcc-7-branch)
@@ -1,4 +1,4 @@
-! { dg-do "compile" }
+! { dg-do compile }
 ! { dg-options "-fdec-structure" }
 !
 ! PR fortran/78259
Index: gcc/testsuite/gfortran.dg/pr69455_2.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr69455_2.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr69455_2.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,13 @@
+! { dg-do run }
+program foo
+   block
+      use, intrinsic :: ISO_FORTRAN_ENV, only: wp => REAL32, ik => INT32
+      if (ik /= 4) stop 1
+      if (wp /= 4) stop 2
+   end block
+   block
+      use, intrinsic :: ISO_FORTRAN_ENV, only: wp => REAL64, ik => INT64
+      if (ik /= 8) stop 3
+      if (wp /= 8) stop 4
+   end block
+end program foo
Index: gcc/testsuite/gfortran.dg/finalize_28.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/finalize_28.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/finalize_28.f90	(.../branches/gcc-7-branch)
@@ -21,4 +21,4 @@
     integer, intent(out) :: edges(:,:)
   end subroutine coo_dump_edges
 end module coo_graphs
-! { dg-final { scan-tree-dump-times "__builtin_free" 6 "original" } }
+! { dg-final { scan-tree-dump-times "__builtin_free" 5 "original" } }
Index: gcc/testsuite/gfortran.dg/pr70870_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr70870_1.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr70870_1.f90	(.../branches/gcc-7-branch)
@@ -1,4 +1,5 @@
 ! { dg-do compile }
+! { dg-options "-std=gnu" }
 ! PR fortran/70870
 ! Contributed by Vittorio Zecca <zeccav at gmail dot com >
       type t
Index: gcc/testsuite/gfortran.dg/altreturn_9_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/altreturn_9_1.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/altreturn_9_1.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! { dg-options "-std=gnu" }
+! See altreturn_9_0.f90
+subroutine sub(i, *, j)
+  if (i == 10 .and. j == 20) return 1
+  return
+end subroutine sub
Index: gcc/testsuite/gfortran.dg/power_7.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/power_7.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/power_7.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,27 @@
+! { dg-do run }
+! { dg-additional-options "-fdump-tree-original" }
+! PR 85544 - this used to ICE.
+program p
+   integer, parameter :: na = -3, ne = 10
+   integer :: i, a(na:ne), b(na:ne)
+   integer :: v
+   a = [(i, i=na, ne)]
+   b = [2**a]
+   if (any (b /= [0,0,0,1,2,4,8,16,32,64,128,256,512,1024])) stop 1
+   b = [1**a]
+   if (any (b /= 1)) stop 2
+   b = [(-1)**a]
+   if (any (b /= [-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1]) )stop 3
+   b = [8**a]
+   if (any (b /= [0,0,0,1,8,64,512,4096,32768,262144,2097152,16777216,&
+        134217728,1073741824])) stop 4
+   b = [4**a]
+   if (any (b /= [0,0,0,1,4,16,64,256,1024,4096,16384,65536,262144,1048576])) stop 5
+   
+   v = 1
+   do i=1,6
+      v = v * 16
+      if (v /= 16**i) stop 6 
+   end do
+ end program p
+! { dg-final { scan-tree-dump-not "_gfortran_pow" "original" } }
Index: gcc/testsuite/gfortran.dg/binding_label_tests_32.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/binding_label_tests_32.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/binding_label_tests_32.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,35 @@
+! { dg-do run }
+! PR 77746 - this used to crash during execution.
+! Original test case by Vladimir Fuka.
+module first
+  private
+  public execute
+  
+  interface execute
+    module procedure random_name
+  end interface
+  
+contains
+
+  subroutine random_name()
+  end subroutine
+end module
+
+module test
+  use first
+
+  implicit none
+
+contains
+
+  subroutine p_execute(i)  bind(C, name="random_name")
+    integer :: i
+
+    call execute()
+  end subroutine
+  
+end module
+
+  use test
+  call p_execute(1)
+end
Index: gcc/testsuite/gfortran.dg/array_function_5.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/array_function_5.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/array_function_5.f90	(.../branches/gcc-7-branch)
@@ -1,4 +1,4 @@
-! {  dg-do run }
+! { dg-do run }
 ! PR41278 internal compiler error related to matmul and transpose
 ! Test case prepared by Jerry DeLisle  <jvdelisle@gcc.gnu.org>
 ! Original test case by Chris <cmklaij@hetnet.nl>
Index: gcc/testsuite/gfortran.dg/pr81849.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr81849.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr81849.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,16 @@
+! { dg-do run }
+! PR fortran/81849
+program p
+   implicit none
+   integer  :: n=3
+   if (any(g() /= f())) stop 1
+   contains
+      function g()
+         real g(n)
+         g = 7
+      end function g
+      function f() result(r)
+         real r(n)
+         r = 7
+      end function f
+end program
Index: gcc/testsuite/gfortran.dg/dec_structure_12.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/dec_structure_12.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/dec_structure_12.f90	(.../branches/gcc-7-branch)
@@ -1,4 +1,4 @@
-! { dg-do "compile" }
+! { dg-do compile }
 ! { dg-options "-fdec-structure" }
 !
 ! Test a regression where multiple anonymous structures failed to
Index: gcc/testsuite/gfortran.dg/select_type_46.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/select_type_46.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/select_type_46.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,21 @@
+! { dg-do compile }
+!
+! Tests the fix for PR82077
+!
+! Contributed by Damian Rouson  <damian@sourceryinstitute.org>
+!
+    type parent
+    end type parent
+    type, extends(parent) :: child
+    end type
+    class(parent), allocatable :: foo(:,:)
+    allocate(child::foo(1,1))
+    select type(foo)
+      class is (child)
+        call gfortran7_ICE(foo(1,:))  ! ICEd here.
+    end select
+contains
+    subroutine gfortran7_ICE(bar)
+      class(child) bar(:)
+    end subroutine
+end
Index: gcc/testsuite/gfortran.dg/ptr_func_assign_5.f08
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/ptr_func_assign_5.f08	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/ptr_func_assign_5.f08	(.../branches/gcc-7-branch)
@@ -0,0 +1,45 @@
+! { dg-do run }
+!
+! Test the fix for PR77703, in which calls of the pointer function
+! caused an ICE in 'gfc_trans_auto_character_variable'.
+!
+! Contributed by Gerhard Steinmetz  <gerhard.steinmetz.fortran@t-online.de>
+!
+module m
+   implicit none
+   private
+   integer, parameter, public :: n = 2
+   integer, parameter :: ell = 6
+
+   character(len=n*ell), target, public :: s
+
+   public :: t
+contains
+   function t( idx ) result( substr )
+      integer, intent(in) :: idx
+      character(len=ell), pointer  :: substr
+
+      if ( (idx < 0).or.(idx > n) ) then
+         error stop
+      end if
+      substr => s((idx-1)*ell+1:idx*ell)
+   end function t
+end module m
+
+program p
+   use m, only : s, t, n
+   integer :: i
+
+   ! Define 's'
+   s = "123456789012"
+
+   ! Then perform operations involving 't'
+   if (t(1) .ne. "123456") stop 1
+   if (t(2) .ne. "789012") stop 2
+
+   ! Do the pointer function assignments
+   t(1) = "Hello "
+   if (s .ne. "Hello 789012") Stop 3
+   t(2) = "World!"
+   if (s .ne. "Hello World!") Stop 4
+end program p
Index: gcc/testsuite/gfortran.dg/pr88902.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr88902.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr88902.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,6 @@
+! PR fortran/88902
+! { dg-do compile }
+! { dg-require-effective-target lto }
+! { dg-options "-flto --param ggc-min-heapsize=0" }
+
+include 'pr50069_2.f90'
Index: gcc/testsuite/gfortran.dg/alloc_comp_assign_16.f03
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/alloc_comp_assign_16.f03	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/alloc_comp_assign_16.f03	(.../branches/gcc-7-branch)
@@ -0,0 +1,37 @@
+! { dg-do run }
+!
+! Test the fix for PR88393 in which a segfault occurred as indicated.
+!
+! Contributed by Janus Weil  <janus@gcc.gnu.org>
+!
+module m
+   implicit none
+   type :: t
+      character(len=:), allocatable :: cs
+   contains
+      procedure :: ass
+      generic :: assignment(=) => ass
+   end type
+contains
+   subroutine ass(a, b)
+      class(t), intent(inout) :: a
+      class(t), intent(in)    :: b
+      a%cs = b%cs
+      print *, "ass"
+   end subroutine
+end module
+
+program p
+   use m
+   implicit none
+   type :: t2
+      type(t) :: c
+   end type
+   type(t2), dimension(1:2) :: arr
+   arr(1)%c%cs = "abcd"
+   arr(2)%c = arr(1)%c  ! Segfault here.
+   print *, "done", arr(2)%c%cs, arr(2)%c%cs
+! Make sure with valgrind that there are no memory leaks.
+   deallocate (arr(1)%c%cs)
+   deallocate (arr(2)%c%cs)
+end
Index: gcc/testsuite/gfortran.dg/pr88205.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr88205.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr88205.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,14 @@
+! { dg-do compile }
+! PR fortran/88205
+subroutine s1
+   real, parameter :: status = 0
+   open (newunit=n, status=status)        ! { dg-error "STATUS requires" }
+end
+subroutine s2
+   complex, parameter :: status = 0
+   open (newunit=n, status=status)        ! { dg-error "STATUS requires" }
+end
+program p
+  logical, parameter :: status = .false.
+  open (newunit=a, status=status)         ! { dg-error "STATUS requires" }
+end
Index: gcc/testsuite/gfortran.dg/interface_abstract_5.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/interface_abstract_5.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/interface_abstract_5.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,32 @@
+! { dg-do compile }
+!
+! PR 71861: [7/8/9 Regression] [F03] ICE in write_symbol(): bad module symbol
+!
+! Contributed by Gerhard Steinmetz <gerhard.steinmetz.fortran@t-online.de>
+
+module m1
+   intrinsic abs
+   abstract interface
+      function abs(x)    ! { dg-error "ABSTRACT attribute conflicts with INTRINSIC attribute" }
+         real :: abs, x
+      end
+   end interface
+end
+
+module m2
+   abstract interface
+      function abs(x)
+         real :: abs, x
+      end
+   end interface
+   intrinsic abs    ! { dg-error "ABSTRACT attribute conflicts with INTRINSIC attribute" }
+end
+
+module m3
+   abstract interface
+      function f(x)
+         real :: f, x
+      end
+   end interface
+   intrinsic f    ! { dg-error "ABSTRACT attribute conflicts with INTRINSIC attribute" }
+end
Index: gcc/testsuite/gfortran.dg/pr58968.f
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr58968.f	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr58968.f	(.../branches/gcc-7-branch)
@@ -1,5 +1,5 @@
 C PR rtl-optimization/58968.f
-C { dg-do compile { target powerpc*-*-*} }
+C { dg-do compile { target powerpc*-*-* } }
 C { dg-options "-mcpu=power7 -O3 -w -ffast-math  -funroll-loops" }
       SUBROUTINE MAKTABS(IW,SOME,LBOX1,LBOX2,LBOX3,NSPACE,NA,NB,
      *            LBST,X,
Index: gcc/testsuite/gfortran.dg/extends_11.f03
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/extends_11.f03	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/extends_11.f03	(.../branches/gcc-7-branch)
@@ -37,4 +37,4 @@
   recruit%service%education%person%ss = 9
 end
 
-! { dg-final { scan-tree-dump-times " +recruit\\.service\\.education\\.person\\.ss =" 8 "original"} }
+! { dg-final { scan-tree-dump-times " +recruit\\.service\\.education\\.person\\.ss =" 8 "original" } }
Index: gcc/testsuite/gfortran.dg/coarray/caf.exp
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/coarray/caf.exp	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/coarray/caf.exp	(.../branches/gcc-7-branch)
@@ -51,11 +51,21 @@
     global gfortran_test_path
     global gfortran_aux_module_flags
     if { [llength $args] != 2 } {
-	error "dg-set-target-env-var: needs one argument"
+	error "dg-compile-aux-modules: needs one argument"
 	return
     }
+
+    set level [info level]
+    if { [info procs dg-save-unknown] != [list] } {
+	rename dg-save-unknown dg-save-unknown-level-$level
+    }
+
     dg-test $gfortran_test_path/[lindex $args 1] "" $gfortran_aux_module_flags
-    # cleanup-modules isn't intentionally invoked here.
+    # cleanup-modules is intentionally not invoked here.
+
+    if { [info procs dg-save-unknown-level-$level] != [list] } {
+	rename dg-save-unknown-level-$level dg-save-unknown
+    }
 }
 
 # Add -latomic only where supported.  Assume built-in support elsewhere.
Index: gcc/testsuite/gfortran.dg/coarray/event_3.f08
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/coarray/event_3.f08	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/coarray/event_3.f08	(.../branches/gcc-7-branch)
@@ -3,9 +3,9 @@
 ! Check PR fortran/70696 is fixed.
 
 program global_event
-  use iso_fortran_env , only : event_type
+  use iso_fortran_env, only : event_type
   implicit none
-  type(event_type) :: x[*]
+  type(event_type), save :: x[*]
   
   call exchange
   contains
Index: gcc/testsuite/gfortran.dg/lto/20091028-1_0.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/lto/20091028-1_0.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/lto/20091028-1_0.f90	(.../branches/gcc-7-branch)
@@ -1,5 +1,5 @@
 ! { dg-lto-do link }
-! { dg-extra-ld-options "-r -nostdlib -finline-functions" }
+! { dg-extra-ld-options "-r -nostdlib -finline-functions -Wno-lto-type-mismatch" }
 
 SUBROUTINE int_gen_ti_header_char( hdrbuf, hdrbufsize, itypesize, &
                               DataHandle, Element, VarName, Data, code )
Index: gcc/testsuite/gfortran.dg/lto/20091028-2_0.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/lto/20091028-2_0.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/lto/20091028-2_0.f90	(.../branches/gcc-7-branch)
@@ -1,5 +1,5 @@
 ! { dg-lto-do link }
-! { dg-extra-ld-options "-r -nostdlib -finline-functions" }
+! { dg-extra-ld-options "-r -nostdlib -finline-functions -Wno-lto-type-mismatch" }
 
 SUBROUTINE int_gen_ti_header_char( hdrbuf, hdrbufsize, itypesize, &
                               DataHandle, Element, VarName, Data, code )
Index: gcc/testsuite/gfortran.dg/lto/pr87689_0.f
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/lto/pr87689_0.f	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/lto/pr87689_0.f	(.../branches/gcc-7-branch)
@@ -0,0 +1,13 @@
+! { dg-lto-run }
+! PR 87689 - this used to fail for POWER, plus it used to
+! give warnings about mismatches with LTO.
+! Original test case by Judical Grasset.
+      program main
+        implicit none
+        character :: c
+        character(len=20) :: res, doesntwork_p8
+        external doesntwork_p8
+        c = 'o'
+        res = doesntwork_p8(c,1,2,3,4,5,6)
+        if (res /= 'foo') stop 3
+      end program main
Index: gcc/testsuite/gfortran.dg/lto/pr89084_0.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/lto/pr89084_0.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/lto/pr89084_0.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,24 @@
+! PR fortran/89084
+! { dg-lto-do link }
+! { dg-lto-options {{ -O0 -flto }} }
+
+integer function foo ()
+  write (*,*) 'foo'
+  block
+    integer, parameter :: idxs(3) = (/ 1, 2, 3 /)
+    integer :: i
+    foo = 0
+    do i = 1, size(idxs)
+      foo = foo + idxs(i)
+    enddo
+  end block
+end function foo
+program pr89084
+  integer :: i
+  interface
+    integer function foo ()
+    end function
+  end interface
+  i = foo ()
+  if (i.ne.6) stop 1
+end
Index: gcc/testsuite/gfortran.dg/lto/pr87689_1.f
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/lto/pr87689_1.f	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/lto/pr87689_1.f	(.../branches/gcc-7-branch)
@@ -0,0 +1,11 @@
+      function doesntwork_p8(c,a1,a2,a3,a4,a5,a6)
+        implicit none
+        character(len=20) :: doesntwork_p8
+        character :: c
+        integer :: a1,a2,a3,a4,a5,a6
+        if (a1 /= 1 .or. a2 /= 2 .or. a3 /= 3 .or. a4 /= 4 .or. a5 /= 5
+     &       .or. a6 /= 6) stop 1
+       if (c /= 'o ') stop 2
+       doesntwork_p8 = 'foo'
+       return
+       end
Index: gcc/testsuite/gfortran.dg/pr88169_3.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr88169_3.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr88169_3.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,15 @@
+! { dg-do compile }
+! { dg-options "-std=f95" }
+module foo_nml
+   implicit none
+   real :: x = -1
+   namelist /foo/ x
+end module
+
+program main
+   use foo_nml, only: bar => foo, x
+   implicit none
+   real a
+   namelist /bar/a  ! { dg-error "already is USE associated" }
+end program
+! { dg-final { cleanup-modules "foo_nml" } }
Index: gcc/testsuite/gfortran.dg/finalize_34.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/finalize_34.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/finalize_34.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,25 @@
+! { dg-do compile }
+! { dg-additional-options "-fdump-tree-original" }
+! PR 87352 - this used to cause an excessive number of deallocations.
+module testmodule
+  implicit none
+  public
+
+  type :: evtlist_type
+     real,  allocatable, dimension(:) :: p1
+     real,  allocatable, dimension(:) :: p2
+     real,  allocatable, dimension(:) :: p3
+     real,  allocatable, dimension(:) :: p4
+  end type evtlist_type
+
+  type :: evtlistlist_type
+     type(evtlist_type)  :: evtlist(1:1)
+  end type evtlistlist_type
+
+end module testmodule 
+
+program main
+  use testmodule
+  type(evtlist_type), dimension(10) :: a
+end program main
+! { dg-final  { scan-tree-dump-times "__builtin_free" 8 "original" } }
Index: gcc/testsuite/gfortran.dg/no_arg_check_2.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/no_arg_check_2.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/no_arg_check_2.f90	(.../branches/gcc-7-branch)
@@ -139,7 +139,7 @@
 ! { dg-final { scan-tree-dump-times "sub_scalar .\\(struct t1 .\\) array_class_t1_alloc._data.data" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_scalar .\\(struct t1 .\\) \\(array_class_t1_ptr._data.dat" 1 "original" } }
 
-! { dg-final { scan-tree-dump-times "sub_array_assumed \\(D" 3 "original" } }
+! { dg-final { scan-tree-dump-times "sub_array_assumed \\(D" 4 "original" } }
 ! { dg-final { scan-tree-dump-times " = _gfortran_internal_pack \\(&parm" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(&array_int\\)" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(real\\(kind=4\\).0:. . restrict\\) array_real_alloc.data" 1 "original" } }
@@ -148,5 +148,5 @@
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) parm" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t2.0:. . restrict\\) array_t2_alloc.data\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. . restrict\\) array_class_t1_alloc._data.data\\);" 1 "original" } }
-! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) array_class_t1_ptr._data.data\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) array_class_t1_ptr._data.data\\);" 0 "original" } }
 
Index: gcc/testsuite/gfortran.dg/pr69455_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr69455_1.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr69455_1.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,14 @@
+! { dg-do run }
+program foo
+   block
+      use, intrinsic :: iso_c_binding, only: wp => c_float, ik => c_int
+      if (ik /= 4) stop 1
+      if (wp /= 4) stop 2
+   end block
+   block
+      use, intrinsic :: iso_c_binding, only: wp => c_double, ik => c_int64_t
+      if (ik /= 8) stop 3
+      if (wp /= 8) stop 4
+   end block
+end program foo
+
Index: gcc/testsuite/gfortran.dg/pointer_init_9.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pointer_init_9.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pointer_init_9.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! PR 71237 - this used to ICE.
+module data_mod
+  implicit none
+
+  type data_t
+    integer :: i
+  end type
+
+  type(data_t), pointer :: data
+  integer, pointer :: idata => data%i ! { dg-error "Pointer assignment target in initialization expression does not have the TARGET attribute" }
+
+end module
Index: gcc/testsuite/gfortran.dg/pr68318_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr68318_1.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr68318_1.f90	(.../branches/gcc-7-branch)
@@ -1,5 +1,5 @@
 ! { dg-do compile }
-! { dg-options "-O0"
+! { dg-options "-O0" }
 ! PR fortran/68318
 ! Original code submitted by Gerhard Steinmetz
 ! <gerhard dot steinmetz dot fortran at t-online dot de>
Index: gcc/testsuite/gfortran.dg/pr77583.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr77583.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr77583.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,10 @@
+! { dg-do compile }
+!
+! PR fortran/77583 - ICE in pp_quoted_string, at pretty-print.c:966
+! Contributed by Gerhard Steinmetz <gerhard.steinmetz.fortran@t-online.de>
+
+pure subroutine sub(s)
+contains
+   pure subroutine s  ! { dg-error "conflicts with DUMMY argument" }
+   end
+end
Index: gcc/testsuite/gfortran.dg/pr88249.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr88249.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr88249.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,7 @@
+! { dg-do compile }
+program p
+   backspace (err=1) ! { dg-error "UNIT number missing" }
+   endfile (err=1)   ! { dg-error "UNIT number missing" }
+   flush (err=1)     ! { dg-error "UNIT number missing" }
+   rewind (err=1)    ! { dg-error "UNIT number missing" }
+end
Index: gcc/testsuite/gfortran.dg/blockdata_11.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/blockdata_11.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/blockdata_11.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,33 @@
+! { dg-do run }
+! PR 84394 - this used to complain about private procedures in
+! BLOCK data.
+module mod1
+   implicit none
+   type :: type1
+      integer :: i1
+   end type type1
+end module
+
+module mod2
+   implicit none
+   contains
+      subroutine sub1
+         integer vals
+         common /block1/ vals(5)
+         if (any(vals /= [1, 2, 3, 4, 5])) stop 1
+      end subroutine
+end module
+
+block data blkdat
+  use mod1
+  integer vals
+  common /block1/ vals(5)
+  data vals/1, 2, 3, 4, 5/
+end block data blkdat
+
+program main
+  use mod2, only: sub1
+  implicit none
+  call sub1
+end program
+
Index: gcc/testsuite/gfortran.dg/altreturn_9_0.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/altreturn_9_0.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/altreturn_9_0.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,10 @@
+! { dg-do  run }
+! { dg-options -std=gnu }
+! { dg-additional-sources altreturn_9_1.f90 }
+! PR 89496 - wrong type for alternate return was generated
+
+program main
+  call sub(10, *10, 20)
+  stop 1
+10 continue
+end program main
Index: gcc/testsuite/gfortran.dg/submodule_30.f08
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/submodule_30.f08	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/submodule_30.f08	(.../branches/gcc-7-branch)
@@ -0,0 +1,42 @@
+! { dg-do run }
+!
+! Test the fix for PR82550 in which the reference to 'p' in 'foo'
+! was not being correctly handled.
+!
+! Contributed by Reinhold Bader  <Bader@lrz.de>
+!
+module m_subm_18_pos
+  implicit none
+  integer :: i = 0
+  interface
+    module subroutine foo(fun_ptr)
+      procedure(p), pointer, intent(out) :: fun_ptr
+    end subroutine
+  end interface
+contains
+  subroutine p()
+    i = 1
+  end subroutine p
+end module m_subm_18_pos
+submodule (m_subm_18_pos) subm_18_pos
+    implicit none
+contains
+    module subroutine foo(fun_ptr)
+      procedure(p), pointer, intent(out) :: fun_ptr
+      fun_ptr => p
+    end subroutine
+end submodule
+program p_18_pos
+  use m_subm_18_pos
+  implicit none
+  procedure(), pointer :: x
+  call foo(x)
+  call x()
+  if (i == 1) then
+     write(*,*) 'OK'
+  else
+     write(*,*) 'FAIL'
+     STOP 1
+  end if
+end program p_18_pos
+
Index: gcc/testsuite/gfortran.dg/binding_label_tests_31.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/binding_label_tests_31.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/binding_label_tests_31.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,19 @@
+! { dg-do compile }
+! PR fortran/66695 - this used to ICE.
+! Original test case by Vladimir Fuka.
+module mod
+  implicit none
+contains
+    integer function F()
+    end function
+end module
+    
+module mod_C
+  use mod
+  implicit none
+contains
+  subroutine s()  bind(C, name="f")
+    integer :: x
+      x = F()
+  end subroutine
+end module
Index: gcc/testsuite/gfortran.dg/pr88138.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr88138.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr88138.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,9 @@
+! { dg-do compile }
+program p
+   type t
+      character :: c = 'c'
+   end type
+   type(t), parameter :: x  = 1.e1  ! { dg-error "Incompatible initialization between a" }s
+   print *, 'a' // x%c
+end
+! { dg-prune-output "has no IMPLICIT type" }
Index: gcc/testsuite/gfortran.dg/select_type_45.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/select_type_45.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/select_type_45.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,22 @@
+! { dg-do compile }
+!
+! Tests the fix for PR80260
+!
+! Contributed by Damian Rouson  <damian@sourceryinstitute.org>
+!
+    type foo
+    end type foo
+    type, extends(foo) :: bar
+    end type
+contains
+    subroutine f(x)
+      class(foo) x(:,:)
+      select type(x)
+        class is (bar)
+          call g(x(1,:))   ! ICEd here.
+      end select
+    end subroutine
+    subroutine g(y)
+      class(bar) y(:)
+    end subroutine
+end
Index: gcc/testsuite/gfortran.dg/assumed_type_2.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/assumed_type_2.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/assumed_type_2.f90	(.../branches/gcc-7-branch)
@@ -157,7 +157,7 @@
 ! { dg-final { scan-tree-dump-times "sub_scalar .\\(struct t1 .\\) array_class_t1_alloc._data.data" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_scalar .\\(struct t1 .\\) \\(array_class_t1_ptr._data.dat" 1 "original" } }
 
-! { dg-final { scan-tree-dump-times "sub_array_assumed \\(D" 3 "original" } }
+! { dg-final { scan-tree-dump-times "sub_array_assumed \\(D" 4 "original" } }
 ! { dg-final { scan-tree-dump-times " = _gfortran_internal_pack \\(&parm" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(&array_int\\)" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(real\\(kind=4\\).0:. . restrict\\) array_real_alloc.data" 1 "original" } }
@@ -166,7 +166,7 @@
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) parm" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t2.0:. . restrict\\) array_t2_alloc.data\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. . restrict\\) array_class_t1_alloc._data.data\\);" 1 "original" } }
-! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) array_class_t1_ptr._data.data\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) array_class_t1_ptr._data.data\\);" 0 "original" } }
 
 ! { dg-final { scan-tree-dump-times "sub_array_shape \\(&array_real_alloc," 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_shape \\(&array_char_ptr," 1 "original" } }
Index: gcc/testsuite/gfortran.dg/pr89084.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr89084.f90	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr89084.f90	(.../branches/gcc-7-branch)
@@ -0,0 +1,23 @@
+! PR fortran/89084
+! { dg-do run }
+
+integer function foo ()
+  write (*,*) 'foo'
+  block
+    integer, parameter :: idxs(3) = (/ 1, 2, 3 /)
+    integer :: i
+    foo = 0
+    do i = 1, size(idxs)
+      foo = foo + idxs(i)
+    enddo
+  end block
+end function foo
+program pr89084
+  integer :: i
+  interface
+    integer function foo ()
+    end function
+  end interface
+  i = foo ()
+  if (i.ne.6) stop 1
+end
Index: gcc/testsuite/gcc.c-torture/execute/20190820-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/20190820-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/20190820-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,111 @@
+/* PR rtl-optimization/91347 */
+/* Reported by John David Anglin <danglin@gcc.gnu.org> */
+
+typedef unsigned short __u16;
+typedef __signed__ int __s32;
+typedef unsigned int __u32;
+typedef __signed__ long long __s64;
+typedef unsigned long long __u64;
+typedef __u16 u16;
+typedef __s32 s32;
+typedef __u32 u32;
+typedef __u64 u64;
+typedef _Bool bool;
+typedef s32 int32_t;
+typedef u32 uint32_t;
+typedef u64 uint64_t;
+
+char hex_asc_upper[16];
+u16 decpair[100];
+
+static __attribute__((noinline, noclone)) void
+put_dec_full4 (char *buf, unsigned r)
+{
+ unsigned q;
+ q = (r * 0x147b) >> 19;
+ *((u16 *)buf) = decpair[r - 100*q];
+ buf += 2;
+ *((u16 *)buf) = decpair[q];
+}
+
+static __attribute__((noinline, noclone)) unsigned
+put_dec_helper4 (char *buf, unsigned x)
+{
+  uint32_t q = (x * (uint64_t)0x346DC5D7) >> 43;
+  put_dec_full4(buf, x - q * 10000);
+  return q;
+}
+
+static __attribute__((noinline, noclone)) char *
+put_dec (char *buf, unsigned long long n)
+{
+ uint32_t d3, d2, d1, q, h;
+ d1 = ((uint32_t)n >> 16);
+ h = (n >> 32);
+ d2 = (h ) & 0xffff;
+ d3 = (h >> 16);
+ q = 656 * d3 + 7296 * d2 + 5536 * d1 + ((uint32_t)n & 0xffff);
+ q = put_dec_helper4(buf, q);
+ q += 7671 * d3 + 9496 * d2 + 6 * d1;
+ q = put_dec_helper4(buf+4, q);
+ q += 4749 * d3 + 42 * d2;
+ q = put_dec_helper4(buf+8, q);
+ return buf;
+}
+
+struct printf_spec {
+ unsigned int type:8;
+ signed int field_width:24;
+ unsigned int flags:8;
+ unsigned int base:8;
+ signed int precision:16;
+} __attribute__((__packed__));
+
+static __attribute__((noinline, noclone)) char *
+number (char *buf, char *end, unsigned long long num, struct printf_spec spec)
+{
+
+ char tmp[3 * sizeof(num)] __attribute__((__aligned__(2)));
+ char sign;
+ char locase;
+ int need_pfx = ((spec.flags & 64) && spec.base != 10);
+ int i;
+ bool is_zero = num == 0LL;
+ int field_width = spec.field_width;
+ int precision = spec.precision;
+
+ i = 0;
+ if (num < spec.base)
+  tmp[i++] = hex_asc_upper[num] | locase;
+ else if (spec.base != 10) {
+  int mask = spec.base - 1;
+  int shift = 3;
+  if (spec.base == 16)
+   shift = 4;
+  else
+    __builtin_abort ();
+  do {
+   tmp[i++] = (hex_asc_upper[((unsigned char)num) & mask] | locase);
+   num >>= shift;
+  } while (num);
+ } else {
+  i = put_dec(tmp, num) - tmp;
+ }
+ return buf;
+}
+
+static __attribute__((noinline, noclone)) char *
+pointer_string (char *buf, char *end, const void *ptr, struct printf_spec spec)
+{
+ spec.base = 16;
+ spec.flags = 0;
+ return number(buf, end, 100, spec);
+}
+
+int
+main (void)
+{
+  struct printf_spec spec;
+  char *s = pointer_string (0, 0, 0, spec);
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/20191023-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/20191023-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/20191023-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,73 @@
+/* PR tree-optimization/92131 */
+/* Testcase by Armin Rigo <arigo@tunes.org> */
+
+long b, c, d, e, f, i;
+char g, h, j, k;
+int *aa;
+
+static void error (void) __attribute__((noipa));
+static void error (void) { __builtin_abort(); }
+
+static void see_me_here (void) __attribute__((noipa));
+static void see_me_here (void) {}
+
+static void aaa (void) __attribute__((noipa));
+static void aaa (void) {}
+
+static void a (void) __attribute__((noipa));
+static void a (void) {
+  long am, ao;
+  if (aa == 0) {
+    aaa();
+    if (j)
+      goto ay;
+  }
+  return;
+ay:
+  aaa();
+  if (k) {
+    aaa();
+    goto az;
+  }
+  return;
+az:
+  if (i)
+    if (g)
+      if (h)
+        if (e)
+          goto bd;
+  return;
+bd:
+  am = 0;
+  while (am < e) {
+    switch (c) {
+    case 8:
+      goto bh;
+    case 4:
+      return;
+    }
+  bh:
+    if (am >= 0)
+      b = -am;
+    ao = am + b;
+    f = ao & 7;
+    if (f == 0)
+      see_me_here();
+    if (ao >= 0)
+      am++;
+    else
+      error();
+  }
+}
+
+int main (void)
+{
+    j++;
+    k++;
+    i++;
+    g++;
+    h++;
+    e = 1;
+    a();
+    return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr91137.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr91137.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr91137.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,34 @@
+long long a;
+unsigned b;
+int c[70];
+int d[70][70];
+int e;
+
+__attribute__ ((noinline)) void f(long long *g, int p2) {
+  *g = p2;
+}
+
+__attribute__ ((noinline)) void fn2() {
+  for (int j = 0; j < 70; j++) {
+    for (int i = 0; i < 70; i++) {
+      if (b)
+        c[i] = 0;
+      for (int l = 0; l < 70; l++)
+        d[i][1] = d[l][i];
+    }
+    for (int k = 0; k < 70; k++)
+      e = c[0];
+  }
+}
+
+int main() {
+  b = 5;
+  for (int j = 0; j < 70; ++j)
+    c[j] = 2075593088;
+  fn2();
+  f(&a, e);
+  if (a)
+    __builtin_abort();
+  return 0;
+}
+
Index: gcc/testsuite/gcc.c-torture/execute/pr90949.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr90949.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr90949.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,42 @@
+void __attribute__ ((noipa, noinline)) my_puts (const char *str) { }
+
+void __attribute__ ((noipa, noinline)) my_free (void *p) { }
+
+
+struct Node
+{
+  struct Node *child;
+};
+
+struct Node space[2] = { };
+
+struct Node * __attribute__ ((noipa, noinline)) my_malloc (int bytes)
+{
+  return &space[0];
+}
+
+void
+walk (struct Node *module, int cleanup)
+{
+  if (module == 0)
+    {
+      return;
+    }
+  if (!cleanup)
+    {
+      my_puts ("No cleanup");
+    }
+  walk (module->child, cleanup);
+  if (cleanup)
+    {
+      my_free (module);
+    }
+}
+
+int
+main ()
+{
+  struct Node *node = my_malloc (sizeof (struct Node));
+  node->child = 0;
+  walk (node, 1);
+}
Index: gcc/testsuite/gcc.c-torture/execute/builtins/builtins.exp
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/builtins/builtins.exp	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/builtins/builtins.exp	(.../branches/gcc-7-branch)
@@ -37,7 +37,7 @@
 torture-init
 set-torture-options $C_TORTURE_OPTIONS {{}} $LTO_TORTURE_OPTIONS
 
-set additional_flags "-fno-tree-loop-distribute-patterns -fno-tracer"
+set additional_flags "-fno-tree-loop-distribute-patterns -fno-tracer -fno-ipa-ra"
 if [istarget "powerpc-*-darwin*"] {
    lappend additional_flags "-Wl,-multiply_defined,suppress"
 }
Index: gcc/testsuite/gcc.c-torture/execute/pr89195.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr89195.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr89195.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,22 @@
+/* PR rtl-optimization/89195 */
+/* { dg-require-effective-target int32plus } */
+
+struct S { unsigned i : 24; };
+
+volatile unsigned char x;
+
+__attribute__((noipa)) int
+foo (struct S d) 
+{
+  return d.i & x;
+}
+
+int
+main ()
+{
+  struct S d = { 0x123456 };
+  x = 0x75;
+  if (foo (d) != (0x56 & 0x75))
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr88739.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr88739.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr88739.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,59 @@
+/* PR tree-optimization/88739 */
+#if __SIZEOF_SHORT__ == 2 &&  __SIZEOF_INT__ == 4 && __CHAR_BIT__ == 8
+struct A
+{
+  unsigned int a, b, c;
+  unsigned int d : 30;
+  unsigned int e : 2;
+};
+
+union U
+{
+  struct A f;
+  unsigned int g[4];
+  unsigned short h[8];
+  unsigned char i[16];
+};
+volatile union U v = { .f.d = 0x4089 };
+
+__attribute__((noipa)) void
+bar (int x)
+{
+  static int i;
+  switch (i++)
+    {
+    case 0: if (x != v.f.d) __builtin_abort (); break;
+    case 1: if (x != v.f.e) __builtin_abort (); break;
+    case 2: if (x != v.g[3]) __builtin_abort (); break;
+    case 3: if (x != v.h[6]) __builtin_abort (); break;
+    case 4: if (x != v.h[7]) __builtin_abort (); break;
+    default: __builtin_abort (); break;
+    }
+}
+
+void
+foo (unsigned int x)
+{
+  union U u;
+  u.f.d = x >> 2;
+  u.f.e = 0;
+  bar (u.f.d);
+  bar (u.f.e);
+  bar (u.g[3]);
+  bar (u.h[6]);
+  bar (u.h[7]);
+}
+
+int
+main ()
+{
+  foo (0x10224);
+  return 0;
+}
+#else
+int
+main ()
+{
+  return 0;
+}
+#endif
Index: gcc/testsuite/gcc.c-torture/compile/pr87647.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr87647.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr87647.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,15 @@
+/* PR middle-end/87647 */
+
+struct A {};
+struct A *const b = &(struct A) {};
+struct B { char *s; struct A *t; };
+void bar (struct B *);
+
+void
+foo (void)
+{
+  struct B a[] = { "", b, "", b, "", b, "", b, "", b, "", b, "", b, "", b,
+		   "", b, "", b, "", b, "", b, "", b, "", b, "", b, "", b,
+		   "", b };
+  bar (a);
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr89703-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr89703-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr89703-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,13 @@
+/* PR tree-optimization/89703 */
+
+typedef __SIZE_TYPE__ size_t;
+extern void *memcpy (void *, const void *, size_t);
+extern char *strlen (const char *);
+extern char c[2];
+
+void
+foo (char **q)
+{
+  memcpy (c, "a", 2);
+  q[0] = strlen (c);
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr82564.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr82564.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr82564.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,15 @@
+/* PR middle-end/82564 */
+/* { dg-require-effective-target alloca } */
+
+int
+main ()
+{
+  int t = 8, i;
+  typedef struct { char v[t]; } B; 
+  B a, b;
+  B __attribute__ ((noinline)) f () { return b; }
+  for (i = 0; i < 8; i++)
+    b.v[i] = i;
+  a = f ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr89998-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr89998-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr89998-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,4 @@
+/* PR tree-optimization/89998 */
+/* { dg-additional-options "-fno-printf-return-value" } */
+
+#include "pr89998-1.c"
Index: gcc/testsuite/gcc.c-torture/compile/pr90139.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr90139.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr90139.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,20 @@
+/* PR middle-end/90139 */
+
+typedef float __attribute__((vector_size (sizeof (float)))) V;
+void bar (int, V *);
+int l;
+
+void
+foo (void)
+{
+  V n, b, o;
+  while (1)
+    switch (l)
+      {
+      case 0:
+	o = n;
+	n = b;
+	b = o;
+	bar (1, &o);
+      }
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr72802.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr72802.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr72802.c	(.../branches/gcc-7-branch)
@@ -1,3 +1,4 @@
+/* { dg-skip-if "see PR trail" { *-*-darwin* } } */
 static a[];
 static b, h, m, n, o, p, q, t, u, v, t5, t6, t16, t17, t18, t25;
 c;
Index: gcc/testsuite/gcc.c-torture/compile/pr89663-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr89663-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr89663-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,81 @@
+/* PR middle-end/89663 */
+
+int irint ();
+long lrint ();
+long long llrint ();
+int iround ();
+long lround ();
+long long llround ();
+int iceil ();
+long lceil ();
+long long llceil ();
+int ifloor ();
+long lfloor ();
+long long llfloor ();
+int irintf ();
+long lrintf ();
+long long llrintf ();
+int iroundf ();
+long lroundf ();
+long long llroundf ();
+int iceilf ();
+long lceilf ();
+long long llceilf ();
+int ifloorf ();
+long lfloorf ();
+long long llfloorf ();
+int irintl ();
+long lrintl ();
+long long llrintl ();
+int iroundl ();
+long lroundl ();
+long long llroundl ();
+int iceill ();
+long lceill ();
+long long llceill ();
+int ifloorl ();
+long lfloorl ();
+long long llfloorl ();
+
+void
+foo (long long *p)
+{
+  int n = 0;
+#define T(f) p[n++] = f (1);
+  T (irint)
+  T (lrint)
+  T (llrint)
+  T (iround)
+  T (lround)
+  T (llround)
+  T (iceil)
+  T (lceil)
+  T (llceil)
+  T (ifloor)
+  T (lfloor)
+  T (llfloor)
+  T (irintf)
+  T (lrintf)
+  T (llrintf)
+  T (iroundf)
+  T (lroundf)
+  T (llroundf)
+  T (iceilf)
+  T (lceilf)
+  T (llceilf)
+  T (ifloorf)
+  T (lfloorf)
+  T (llfloorf)
+  T (irintl)
+  T (lrintl)
+  T (llrintl)
+  T (iroundl)
+  T (lroundl)
+  T (llroundl)
+  T (iceill)
+  T (lceill)
+  T (llceill)
+  T (ifloorl)
+  T (lfloorl)
+  T (llfloorl)
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr71109.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr71109.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr71109.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,31 @@
+/* PR tree-optimization/71109 */
+
+struct S { int g, h; signed char i; int j; signed char k; int l[4]; } a, c;
+struct T { signed char g; } e;
+int *b, d;
+static void foo ();
+
+void
+bar (void)
+{
+  while (d)
+    {
+      int k;
+      struct T f[3];
+      foo (bar, a);
+      for (k = 0;; k++)
+	f[k] = e;
+    }
+}
+
+static inline void
+foo (int x, struct S y, struct T z)
+{
+  for (z.g = 2; z.g; z.g--)
+    {
+      c = a = y;
+      *b |= 6;
+      if (y.g)
+	break;
+    }
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr89703-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr89703-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr89703-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,13 @@
+/* PR tree-optimization/89703 */
+
+typedef __SIZE_TYPE__ size_t;
+extern char *strlen (const char *);
+extern char *strnlen (const char *, size_t);
+extern char c[2];
+
+void
+foo (char **q)
+{
+  q[0] = strlen (c);
+  q[1] = strnlen (c, 2);
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr89998-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr89998-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr89998-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,42 @@
+/* PR tree-optimization/89998 */
+
+unsigned int sprintf (char *str, const char *fmt, ...);
+unsigned int snprintf (char *str, __SIZE_TYPE__ len, const char *fmt, ...);
+
+int
+f1 (char *s)
+{
+  return sprintf (s, "foo");
+}
+
+int
+f2 (char *s)
+{
+  return sprintf (s, "%d", 123);
+}
+
+int
+f3 (int *p, char *s)
+{
+  const char *t = "bar";
+  return sprintf (s, "%s", t);
+}
+
+int
+f4 (char *s)
+{
+  return snprintf (s, 8, "foo");
+}
+
+int
+f5 (char *s)
+{
+  return snprintf (s, 8, "%d", 123);
+}
+
+int
+f6 (int *p, char *s)
+{
+  const char *t = "bar";
+  return snprintf (s, 8, "%s", t);
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr89412.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr89412.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr89412.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,16 @@
+/* PR middle-end/89412 */
+
+struct S { double a, b; } d;
+int e;
+double f;
+
+void
+foo ()
+{
+  _Complex double h;
+  while (e)
+    {
+      f = h;
+      *(struct S *) &h = d;
+    }
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr89663-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr89663-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr89663-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,82 @@
+/* PR middle-end/89663 */
+
+int irint (double);
+long lrint (double);
+long long llrint (double);
+int iround (double);
+long lround (double);
+long long llround (double);
+int iceil (double);
+long lceil (double);
+long long llceil (double);
+int ifloor (double);
+long lfloor (double);
+long long llfloor (double);
+int irintf (float);
+long lrintf (float);
+long long llrintf (float);
+int iroundf (float);
+long lroundf (float);
+long long llroundf (float);
+int iceilf (float);
+long lceilf (float);
+long long llceilf (float);
+int ifloorf (float);
+long lfloorf (float);
+long long llfloorf (float);
+int irintl (long double);
+long lrintl (long double);
+long long llrintl (long double);
+int iroundl (long double);
+long lroundl (long double);
+long long llroundl (long double);
+int iceill (long double);
+long lceill (long double);
+long long llceill (long double);
+int ifloorl (long double);
+long lfloorl (long double);
+long long llfloorl (long double);
+
+void
+foo (long long *p)
+{
+  int (*fn) (int);
+  int n = 0;
+#define T(f) fn = (int (*) (int)) f; p[n++] = fn (1);
+  T (irint)
+  T (lrint)
+  T (llrint)
+  T (iround)
+  T (lround)
+  T (llround)
+  T (iceil)
+  T (lceil)
+  T (llceil)
+  T (ifloor)
+  T (lfloor)
+  T (llfloor)
+  T (irintf)
+  T (lrintf)
+  T (llrintf)
+  T (iroundf)
+  T (lroundf)
+  T (llroundf)
+  T (iceilf)
+  T (lceilf)
+  T (llceilf)
+  T (ifloorf)
+  T (lfloorf)
+  T (llfloorf)
+  T (irintl)
+  T (lrintl)
+  T (llrintl)
+  T (iroundl)
+  T (lroundl)
+  T (llroundl)
+  T (iceill)
+  T (lceill)
+  T (llceill)
+  T (ifloorl)
+  T (lfloorl)
+  T (llfloorl)
+}
Index: gcc/testsuite/gnat.dg/opt73.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt73.adb	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gnat.dg/opt73.adb	(.../branches/gcc-7-branch)
@@ -0,0 +1,34 @@
+-- { dg-do run }
+-- { dg-options "-O" }
+
+procedure Opt73 is
+
+   type Terminal_Set_Indexed_By_Non_Terminal is
+     array (Natural range <>, Natural  range <>) of Boolean with Pack;
+
+   type Terminal_Set_Per_Non_Terminal
+     (Last_Terminal     : Natural;
+      Last_Non_Terminal : Natural) is
+   record
+      Map : Terminal_Set_Indexed_By_Non_Terminal
+        (1 .. Last_Non_Terminal, 0 .. Last_Terminal);
+   end record;
+
+   Follow : Terminal_Set_Per_Non_Terminal (5, 4);
+   Expect : Terminal_Set_Per_Non_Terminal :=
+     (5, 4, (1 => (2 => True, others => False),
+             others => (others => False)));
+
+   procedure Get_Follow (Value : out Terminal_Set_Per_Non_Terminal) is
+   begin
+      Value.Map := (others => (others => False));
+      Value.Map (1, 2) := True;
+      Value.Map (2, 0) := Value.Map (2, 0) or Value.Map (1, 0);
+   end;
+
+begin
+   Get_Follow (Follow);
+   if Follow /= Expect then
+      raise Program_Error;
+   end if;
+end;
Index: gcc/testsuite/gnat.dg/opt75.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt75.adb	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gnat.dg/opt75.adb	(.../branches/gcc-7-branch)
@@ -0,0 +1,9 @@
+-- { dg-do run }
+-- { dg-options "-O3" }
+
+with Opt75_Pkg; use Opt75_Pkg;
+
+procedure Opt75 is
+begin
+  null;
+end;
Index: gcc/testsuite/gnat.dg/opt76.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt76.adb	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gnat.dg/opt76.adb	(.../branches/gcc-7-branch)
@@ -0,0 +1,36 @@
+-- { dg-do run }
+-- { dg-options "-O2 -gnatp -fno-omit-frame-pointer" }
+
+procedure Opt76 is
+
+   type Integer_Access is access Integer;
+   type Registry_Array is array (Natural range <>) of Integer_Access;
+
+   procedure Nested (Input, Parser : Integer; A, B : Boolean) is
+
+      Index : Registry_Array (1 .. 1024);
+      Not_B : constant Boolean := not B;
+
+      procedure Inner (Input : Integer) is
+      begin
+         if Input /= 1 then
+            raise Program_Error;
+         end if;
+
+         if Parser = 128 and then A and then Not_B then
+            Inner (Input);
+            Index (Index'First) := null;
+         end if;
+      end;
+
+   begin
+      Inner (Input);
+   end;
+
+   Input : Integer := 1 with Volatile;
+   Parser : Integer := 2 with Volatile;
+      
+begin
+   Nested (Input, Parser, False, True);
+   Nested (Input, Parser, True, False);
+end;
Index: gcc/testsuite/gnat.dg/opt79.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt79.adb	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gnat.dg/opt79.adb	(.../branches/gcc-7-branch)
@@ -0,0 +1,28 @@
+-- { dg-do compile }
+-- { dg-options "-O" }
+
+package body Opt79 is
+
+  function F (I : Integer) return Arr is
+    A : Arr;
+
+    procedure Nested is
+
+      procedure Inner is
+      begin
+        A (1) := 0;
+      end;
+
+    begin
+       Inner;
+    end;
+
+  begin
+    Nested;
+    for J in A'Range loop
+      A (J) := I;
+    end loop;
+    return A;
+  end;
+
+end Opt79;
Index: gcc/testsuite/gnat.dg/opt79.ads
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt79.ads	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gnat.dg/opt79.ads	(.../branches/gcc-7-branch)
@@ -0,0 +1,7 @@
+package Opt79 is
+
+  type Arr is array (1 .. 8) of Integer;
+
+  function F (I : Integer) return Arr;
+
+end Opt79;
Index: gcc/testsuite/gnat.dg/opt75_pkg.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt75_pkg.adb	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gnat.dg/opt75_pkg.adb	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+package body Opt75_Pkg is
+
+  overriding procedure Adjust (Object : in out T) is
+  begin
+    if Object.Ref /= Empty_Rec'Access then
+      System.Atomic_Counters.Increment (Object.Ref.Counter);
+    end if;
+  end;
+
+  A : constant Arr := (others => (others => Empty));
+
+end Opt75_Pkg;
Index: gcc/testsuite/gnat.dg/opt75_pkg.ads
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt75_pkg.ads	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gnat.dg/opt75_pkg.ads	(.../branches/gcc-7-branch)
@@ -0,0 +1,27 @@
+pragma Restrictions (No_Abort_Statements);
+pragma Restrictions (Max_Asynchronous_Select_Nesting => 0);
+
+with Ada.Finalization;
+with System.Atomic_Counters;
+
+package Opt75_Pkg is
+
+  type Rec is record
+    Counter : System.Atomic_Counters.Atomic_Counter;
+  end record;
+
+  type Rec_Ptr is access all Rec;
+
+  Empty_Rec : aliased Rec;
+
+  type T is new Ada.Finalization.Controlled with record
+    Ref : Rec_Ptr := Empty_Rec'Access;
+  end record;
+
+  overriding procedure Adjust (Object : in out T);
+
+  Empty : constant T := (Ada.Finalization.Controlled with Ref => Empty_Rec'Access);
+
+  type Arr is array (Integer range 1 .. 8, Integer range 1 .. 4) of T;
+
+end Opt75_Pkg;
Index: gcc/testsuite/gnat.dg/array34.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/array34.adb	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gnat.dg/array34.adb	(.../branches/gcc-7-branch)
@@ -0,0 +1,22 @@
+--  { dg-do run }
+
+procedure Array34 is
+
+  type Arr is array (1 .. 6) of Short_Short_Integer;
+  for Arr'Alignment use 4;
+
+  type Rec is record
+    A : Arr;
+    B: Short_Integer;
+  end record;
+  pragma Pack (Rec);
+
+  R : Rec;
+
+begin
+  R.B := 31415;
+  R.A := (others => 0);
+  if R.B /= 31415 then
+    raise Program_Error;
+  end if;
+end;
Index: gcc/testsuite/gcc.dg/darwin-minversion-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/darwin-minversion-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/darwin-minversion-2.c	(.../branches/gcc-7-branch)
@@ -1,6 +1,6 @@
 /* Basic test for -mmacosx-version-min switch on Darwin.  */
 /* { dg-options "-mmacosx-version-min=10.1 -mmacosx-version-min=10.5" } */
-/* { dg-do run { target *-*-darwin* } } */
+/* { dg-do compile { target *-*-darwin* } } */
 
 int
 main ()
Index: gcc/testsuite/gcc.dg/asm-qual-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/asm-qual-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/asm-qual-1.c	(.../branches/gcc-7-branch)
@@ -1,4 +1,4 @@
-/* Test that qualifiers other than volatile are ignored on asm.  */
+/* Test that qualifiers other than volatile are disallowed on asm.  */
 /* Origin: Joseph Myers <joseph@codesourcery.com> */
 /* { dg-do compile } */
 /* { dg-options "-std=gnu99" } */
@@ -7,6 +7,8 @@
 f (void)
 {
   asm volatile ("");
-  asm const (""); /* { dg-warning "const qualifier ignored on asm" } */
-  asm restrict (""); /* { dg-warning "restrict qualifier ignored on asm" } */
+
+  asm const (""); /* { dg-warning {'const' is not an asm qualifier} } */
+
+  asm restrict (""); /* { dg-warning {'restrict' is not an asm qualifier} } */
 }
Index: gcc/testsuite/gcc.dg/pubtypes-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pubtypes-4.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pubtypes-4.c	(.../branches/gcc-7-branch)
@@ -2,7 +2,7 @@
 /* { dg-options "-O0 -gdwarf-2 -dA" } */
 /* { dg-skip-if "Unmatchable assembly" { mmix-*-* } { "*" } { "" } } */
 /* { dg-final { scan-assembler "__debug_pubtypes" } } */
-/* { dg-final { scan-assembler "long+\[ \t\]+0x172+\[ \t\]+\[#;]+\[ \t\]+Pub Info Length" } } */
+/* { dg-final { scan-assembler "long+\[ \t\]+0x165+\[ \t\]+\[#;]+\[ \t\]+Pub Info Length" } } */
 /* { dg-final { scan-assembler "used_struct\\\\0\"+\[ \t\]+\[#;]+\[ \t\]+external name" } } */
 /* { dg-final { scan-assembler-not "unused_struct\\\\0\"+\[ \t\]+\[#;]+\[ \t\]+external name" } } */
 /* { dg-final { scan-assembler "\"list_name_type\\\\0\"+\[ \t\]+\[#;]+\[ \t\]+external name" } } */
Index: gcc/testsuite/gcc.dg/pr89734.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr89734.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr89734.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+/* PR c/89734 */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+typedef const int CI;
+typedef _Atomic int AI;
+
+CI foo (void);
+const int foo (void);
+
+AI baz (void);
+_Atomic int baz (void);
Index: gcc/testsuite/gcc.dg/pr90756.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr90756.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr90756.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,26 @@
+/* PR rtl-optimization/90756 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wno-psabi" } */
+/* { dg-additional-options "-mno-sse" { target ia32 } } */
+
+typedef float B __attribute__((vector_size(4 * sizeof (float))));
+typedef unsigned long long C __attribute__((vector_size(4 * sizeof (long long))));
+typedef short D __attribute__((vector_size(4 * sizeof (short))));
+B z;
+void foo (C);
+C bar (D);
+B baz ();
+D qux (B);
+
+void
+quux (int x)
+{
+  B n = z, b = z;
+  while (1)
+    switch (x)
+      {
+      case 0: n = baz (); /* FALLTHRU */
+      case 1: { B o = n; n = b; b = o; } /* FALLTHRU */
+      case 2: { D u = qux (b); C v = bar (u); foo (v); }
+      }
+}
Index: gcc/testsuite/gcc.dg/pr88870.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr88870.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr88870.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,23 @@
+/* PR rtl-optimization/88870 */
+/* { dg-do compile } */
+/* { dg-options "-O1 -fexceptions -fnon-call-exceptions -ftrapv -fno-tree-dominator-opts" } */
+
+int a, b;
+
+void
+foo (int *x)
+{
+  int c = 0;
+  {
+    int d;
+    x = &c;
+    for (;;)
+      {
+        x = &d;
+        b = 0;
+        d = c + 1;
+        b = c = 1;
+        ++a;
+      }
+  }
+}
Index: gcc/testsuite/gcc.dg/darwin-weakimport-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/darwin-weakimport-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/darwin-weakimport-3.c	(.../branches/gcc-7-branch)
@@ -1,5 +1,20 @@
 /* { dg-do compile { target *-*-darwin* } } */
-/* { dg-options "-fno-asynchronous-unwind-tables" } */
+
+/* Here we want to test if "foo" gets placed into a coalesced
+   section (it should not).
+
+   However, for i386, and PIC code we have a "get_pc thunk" that
+   is (correctly) placed in a coalesced section when using an older
+   linker - also unwind tables are emitted into coalesced.
+
+   With modern linkers this is moot, since even weak symbols
+   are emitted into the regular sections.
+
+   To avoid the unwind tables -fno-asynchronous-unwind-tables.
+   To ensure that we emit code for an older linker -mtarget-linker
+   To avoid the get_pc thunk optimise at least O1.  */
+
+/* { dg-options "-fno-asynchronous-unwind-tables -O1 -mtarget-linker 85.2" } */
 /* { dg-require-weak "" } */
 
 /* { dg-final { scan-assembler-not "coalesced" } } */
Index: gcc/testsuite/gcc.dg/gomp/pr85594.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/gomp/pr85594.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr85594.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,5 @@
+/* PR middle-end/85594 */
+/* { dg-do compile } */
+/* { dg-additional-options "-fwrapv" } */
+
+#include "pr81768-2.c"
Index: gcc/testsuite/gcc.dg/gomp/pr89796.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/gomp/pr89796.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr89796.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,23 @@
+/* PR c++/89796 */
+/* { dg-do compile } */
+/* { dg-additional-options "-Wunused-value" } */
+
+int
+f1 (int *p)
+{
+  int r;
+  #pragma omp atomic capture		/* { dg-bogus "value computed is not used" } */
+  { r = *p; (*p)++; }
+  return r;
+}
+
+int
+f2 (int *p)
+{
+  int s
+    = ({ int r;
+	 #pragma omp atomic capture	/* { dg-bogus "value computed is not used" } */
+	 { r = *p; (*p)++; }
+	 r; });
+  return s;
+}
Index: gcc/testsuite/gcc.dg/gomp/pr89104.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/gomp/pr89104.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr89104.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,11 @@
+/* PR c++/66676 */
+/* PR ipa/89104 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fopenmp-simd" } */
+
+#pragma omp declare simd uniform (x) aligned (x)
+int
+foo (int *x, int y)
+{
+  return x[y];
+}
Index: gcc/testsuite/gcc.dg/gomp/pr89246-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/gomp/pr89246-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr89246-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,13 @@
+/* PR middle-end/89246 */
+/* { dg-do compile { target int128 } } */
+/* { dg-options "-O0 -fno-openmp -fno-openmp-simd" } */
+
+#pragma omp declare simd
+extern int foo (__int128 x);
+
+#pragma omp declare simd
+int
+bar (int x)
+{
+  return x + foo (0);
+}
Index: gcc/testsuite/gcc.dg/gomp/pr88553.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/gomp/pr88553.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr88553.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,5 @@
+/* PR middle-end/88553 */
+/* { dg-do compile } */
+/* { dg-additional-options "-O1 -ftree-loop-vectorize -fwrapv" } */
+
+#include "pr81768-2.c"
Index: gcc/testsuite/gcc.dg/gomp/cancel-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/gomp/cancel-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/gomp/cancel-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+
+struct S { int s; } s;
+
+void
+foo (void)
+{
+  #pragma omp parallel
+  {
+    #pragma omp cancel parallel if (s)	/* { dg-error "used struct type value where scalar is required" } */
+  }
+}
Index: gcc/testsuite/gcc.dg/gomp/pr88107.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/gomp/pr88107.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr88107.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,35 @@
+/* PR tree-optimization/88107 */
+/* { dg-do compile { target fgraphite } } */
+/* { dg-require-effective-target vect_simd_clones } */
+/* { dg-options "-O2 -fexceptions -floop-nest-optimize -fnon-call-exceptions -fopenmp-simd -ftree-parallelize-loops=2" } */
+
+#define N 1024
+int a[N], b[N];
+long int c[N];
+unsigned char d[N];
+
+#pragma omp declare simd notinbranch
+__attribute__((noinline)) static int
+foo (long int a, int b, int c)
+{
+  return a + b + c;
+}
+
+#pragma omp declare simd notinbranch
+__attribute__((noinline)) static long int
+bar (int a, int b, long int c)
+{
+  return a + b + c;
+}
+
+void
+baz (void)
+{
+  int i;
+  #pragma omp simd
+  for (i = 0; i < N; i++)
+    a[i] = foo (c[i], a[i], b[i]) + 6;
+  #pragma omp simd
+  for (i = 0; i < N; i++)
+    c[i] = bar (a[i], b[i], c[i]) * 2;
+}
Index: gcc/testsuite/gcc.dg/gomp/pr87895-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/gomp/pr87895-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr87895-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,19 @@
+/* PR tree-optimization/87895 */
+/* { dg-do compile } */
+/* { dg-additional-options "-O0" } */
+
+#pragma omp declare simd
+int
+foo (int x)
+{
+  if (x == 0)
+    return 0;
+}
+
+#pragma omp declare simd
+int
+bar (int *x, int y)
+{
+  if ((y == 0) ? (*x = 0) : *x)
+    return 0;
+}
Index: gcc/testsuite/gcc.dg/gomp/pr78884.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/gomp/pr78884.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr78884.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,16 @@
+/* PR middle-end/78884 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fopenmp" } */
+
+void bar (int *);
+
+void
+foo (int n)
+{
+#pragma omp simd
+  for (int i = 0; i < 1024; i++)
+    {
+      int vla[n];
+      bar (vla);
+    }
+}
Index: gcc/testsuite/gcc.dg/gomp/pr87895-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/gomp/pr87895-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr87895-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,5 @@
+/* PR tree-optimization/87895 */
+/* { dg-do compile } */
+/* { dg-additional-options "-O1" } */
+
+#include "pr87895-1.c"
Index: gcc/testsuite/gcc.dg/gomp/pr88415.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/gomp/pr88415.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr88415.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-fexceptions -fnon-call-exceptions -fopenmp -fsignaling-nans -funsafe-math-optimizations -fno-associative-math" } */
+
+void
+lx (_Complex int *yn)
+{
+  int mj;
+
+#pragma omp for
+  for (mj = 0; mj < 1; ++mj)
+    yn[mj] += 1;
+}
Index: gcc/testsuite/gcc.dg/gomp/pr87887-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/gomp/pr87887-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr87887-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,26 @@
+/* PR middle-end/87887 */
+/* { dg-do compile } */
+/* { dg-require-effective-target vect_simd_clones } */
+/* { dg-additional-options "-w" } */
+
+struct S { int n; };
+#pragma omp declare simd
+struct S
+foo (int x)
+{
+  return (struct S) { x };
+}
+
+#pragma omp declare simd
+int
+bar (struct S x)
+{
+  return x.n;
+}
+
+#pragma omp declare simd uniform (x)
+int
+baz (int w, struct S x, int y)
+{
+  return w + x.n + y;
+}
Index: gcc/testsuite/gcc.dg/gomp/pr88105.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/gomp/pr88105.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr88105.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,30 @@
+/* { dg-do compile } */
+/* { dg-options "-fopenmp -O -fexceptions -fnon-call-exceptions -fno-tree-fre" } */
+
+int
+s0 (void)
+{
+  int g6, oh = 0;
+  int *a6 = &g6;
+
+  (void) a6;
+
+#pragma omp parallel for
+  for (g6 = 0; g6 < 1; ++g6)
+    {
+      int zk;
+
+      for (zk = 0; zk < 1; ++zk)
+        {
+          oh += zk / (zk + 1);
+
+          for (;;)
+            {
+            }
+        }
+
+      a6 = &zk;
+    }
+
+  return oh;
+}
Index: gcc/testsuite/gcc.dg/gomp/pr87895-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/gomp/pr87895-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr87895-3.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,18 @@
+/* PR tree-optimization/87895 */
+/* { dg-do compile } */
+/* { dg-additional-options "-O2" } */
+
+#pragma omp declare simd
+int foo (int x) __attribute__((noreturn));
+
+#pragma omp declare simd
+int
+bar (int x, int y)
+{
+  if (y == 1)
+    foo (x + 2);
+  if (y == 10)
+    foo (x + 6);
+  if (y != 25)
+    return 4;
+}
Index: gcc/testsuite/gcc.dg/gomp/pr89246-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/gomp/pr89246-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr89246-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,19 @@
+/* PR middle-end/89246 */
+/* { dg-do link { target { int128 && vect_simd_clones } } } */
+/* { dg-options "-O2 -fopenmp-simd -w" } */
+/* { dg-additional-sources "pr89246-2.c" } */
+
+#pragma omp declare simd
+int foo (__int128 x)
+{
+  return x;
+}
+
+#pragma omp declare simd
+extern int bar (int x);
+
+int
+main ()
+{
+  return foo (0) + bar (0);
+}
Index: gcc/testsuite/gcc.dg/gomp/pr87887-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/gomp/pr87887-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr87887-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,25 @@
+/* PR middle-end/87887 */
+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */
+/* { dg-require-effective-target vect_simd_clones } */
+
+struct S { int n; };
+#pragma omp declare simd
+struct S
+foo (int x)		/* { dg-warning "unsupported return type 'struct S' for simd" } */
+{
+  return (struct S) { x };
+}
+
+#pragma omp declare simd
+int
+bar (struct S x)	/* { dg-warning "unsupported argument type 'struct S' for simd" } */
+{
+  return x.n;
+}
+
+#pragma omp declare simd uniform (x)
+int
+baz (int w, struct S x, int y)
+{
+  return w + x.n + y;
+}
Index: gcc/testsuite/gcc.dg/pr88594.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr88594.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr88594.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,16 @@
+/* PR target/88594 */
+/* { dg-do compile { target int128 } } */
+/* { dg-options "-O2 -fno-tree-dominator-opts -fno-tree-forwprop -fno-tree-vrp" } */
+
+__int128
+foo (__int128 x, __int128 *y)
+{
+  int a;
+  __int128 z, r;
+  for (a = 0; a < 17; ++a)
+    ;
+  z = x / a;
+  r = x % a;
+  *y = z;
+  return r;
+}
Index: gcc/testsuite/gcc.dg/tsan/pr90208-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/tsan/pr90208-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/tsan/pr90208-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,20 @@
+/* PR tree-optimization/90208 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fexceptions -fsanitize=thread" } */
+
+void *b[5];
+void foo (void);
+
+void
+bar (int d)
+{
+  while (d)
+    foo ();
+}
+
+void
+baz (void)
+{
+  bar (2);
+  __builtin_setjmp (b);
+}
Index: gcc/testsuite/gcc.dg/tsan/pr88030.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/tsan/pr88030.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/tsan/pr88030.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-fsanitize=thread -fnon-call-exceptions -fexceptions" } */
+
+typedef __complex__ float Value;
+typedef struct {
+  Value a[16 / sizeof (Value)];
+} A;
+
+A sum(A a,A b)
+{
+  a.a[0]+=b.a[0];
+  a.a[1]+=b.a[1];
+  return a;
+}
Index: gcc/testsuite/gcc.dg/pr89037.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr89037.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr89037.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,24 @@
+/* { dg-do run { target int128 } } */
+/* { dg-options "" } */
+
+struct s
+{
+  __int128 y : 66;
+};
+typedef struct s T;
+T a[] = { 1, 10000, 0x12345, 0xff000001, 1ULL << 63, (__int128) 1 << 64,
+	  ((__int128) 1 << 64) | 1 };
+
+int
+main (void)
+{
+  if (a[0].y != 1
+      || a[1].y != 10000
+      || a[2].y != 0x12345
+      || a[3].y != 0xff000001
+      || a[4].y != (1ULL << 63)
+      || a[5].y != ((__int128) 1 << 64)
+      || a[6].y != (((__int128) 1 << 64) | 1))
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr89342.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr89342.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr89342.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,11 @@
+/* PR other/89342 */
+/* { dg-do compile } */
+/* { dg-options "-O0" } */
+
+__attribute__((optimize("Ofast")))
+void foo (void)
+{
+  __attribute__((optimize("no-inline")))
+  void bar (void) {}
+  bar ();
+}
Index: gcc/testsuite/gcc.dg/pr89521-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr89521-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr89521-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,13 @@
+/* PR c/89521 */
+/* { dg-do compile } */
+/* { dg-options "-Ofast -w" } */
+
+#define A(name) __typeof (__builtin_##name (0)) name (); long name##1 () { return name (1); }
+#define B(name) A(name) A(name##f) A(name##l)
+B (ceil)
+B (floor)
+B (round)
+B (trunc)
+B (nearbyint)
+B (rint)
+B (logb)
Index: gcc/testsuite/gcc.dg/cpp/usr/include/stdio.h
===================================================================
--- a/src/gcc/testsuite/gcc.dg/cpp/usr/include/stdio.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/cpp/usr/include/stdio.h	(.../branches/gcc-7-branch)
@@ -1,4 +0,0 @@
-/* Used by gcc.dg/cpp/isysroot-1.c to test isysroot.  */
-void foo()
-{
-}
Index: gcc/testsuite/gcc.dg/cpp/usr/include/example.h
===================================================================
--- a/src/gcc/testsuite/gcc.dg/cpp/usr/include/example.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/cpp/usr/include/example.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,4 @@
+/* Used by gcc.dg/cpp/isysroot-1.c to test isysroot.  */
+void foo()
+{
+}
Index: gcc/testsuite/gcc.dg/cpp/isysroot-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/cpp/isysroot-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/cpp/isysroot-1.c	(.../branches/gcc-7-branch)
@@ -1,10 +1,17 @@
 /* { dg-options "-isysroot ${srcdir}/gcc.dg/cpp" } */
 /* { dg-do compile  { target *-*-darwin* } } */
 
-#include <stdio.h>
+/* For the test to succeed there needs to be some header that is to be found
+   in the 'expected' place i.e. <sysroot>/usr/include/.  It's important that
+   it is not the name of a header for which fixincludes have been applied,
+   since such headers will be found in the gcc include-fixed dir and, in
+   general, reference additional headers.  The dummy sysroot will prevent the
+   additional headers from being found, resulting in a failed test.  So use
+   a header name we don't expect to see. */
+#include <example.h>
 int main()
 {
-  /* Special stdio.h supplies function foo.  */
+  /* Special example.h supplies function foo.  */
   void (*x)(void) = foo;
   return 0;
 }
Index: gcc/testsuite/gcc.dg/pr90760.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr90760.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr90760.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,9 @@
+/* PR c/90760 */
+/* { dg-do compile } */
+/* { dg-require-alias "" } */
+/* { dg-require-named-sections "" } */
+
+void bar (void) {}
+void foo (void) __attribute__ ((alias ("bar")));	/* { dg-error "section of alias 'foo' must match section of its target" } */
+void foo (void) __attribute__ ((section ("baz")));
+void qux (void) __attribute__ ((alias ("bar"), section ("baz")));	/* { dg-error "section of alias 'qux' must match section of its target" } */
Index: gcc/testsuite/gcc.dg/darwin-minversion-link.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/darwin-minversion-link.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/darwin-minversion-link.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,26 @@
+/* Test that we can handle leading-zeros on mmacosx-version-min for invocations
+   including linking (so that spec processing works).  To make sure that any
+   necessary target libs are present we make this specific to the target version
+   being built.  */
+/* { dg-do link { target *-*-darwin* } } */
+/* { dg-additional-options "-mmacosx-version-min=010.04.11 -DCHECK=1049" { target *-*-darwin8* } } */
+/* { dg-additional-options "-mmacosx-version-min=010.05.08 -DCHECK=1058" { target *-*-darwin9* } } */
+/* { dg-additional-options "-mmacosx-version-min=010.06.08 -DCHECK=1068" { target *-*-darwin10* } } */
+/* { dg-additional-options "-mmacosx-version-min=010.07.05 -DCHECK=1075" { target *-*-darwin11* } } */
+/* { dg-additional-options "-mmacosx-version-min=010.08.05 -DCHECK=1085" { target *-*-darwin12* } } */
+/* { dg-additional-options "-mmacosx-version-min=010.09.05 -DCHECK=1095" { target *-*-darwin13* } } */
+/* { dg-additional-options "-mmacosx-version-min=010.010.03 -DCHECK=101003" { target *-*-darwin14* } } */
+/* { dg-additional-options "-mmacosx-version-min=010.011.06 -DCHECK=101106" { target *-*-darwin15* } } */
+/* { dg-additional-options "-mmacosx-version-min=010.012.06 -DCHECK=101206" { target *-*-darwin16* } } */
+/* { dg-additional-options "-mmacosx-version-min=010.013.06 -DCHECK=101306" { target *-*-darwin17* } } */
+/* This next test covers 10.18 and (currently unreleased) 10.19 for now. */  
+/* { dg-additional-options "-mmacosx-version-min=010.014.05 -DCHECK=101405" { target *-*-darwin1[89]* } } */
+
+int
+main ()
+{
+#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ != CHECK
+  fail me;
+#endif
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/debug/pr89704.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/debug/pr89704.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/debug/pr89704.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,14 @@
+/* PR debug/89704 */
+/* { dg-do compile } */
+
+typedef __INTPTR_TYPE__ intptr_t;
+
+int
+foo (void)
+{
+  lab1:;
+  lab2:;
+  static int i = (intptr_t) &&lab1 - (intptr_t) &&lab2;
+  static int j = (intptr_t) &&lab1 - (intptr_t) &&lab2;
+  return i;
+}
Index: gcc/testsuite/gcc.dg/debug/dwarf2/pr88644.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/debug/dwarf2/pr88644.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/debug/dwarf2/pr88644.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,7 @@
+/* PR debug/88644 */
+/* { dg-do compile } */
+/* { dg-options "-gdwarf-4 -dA -gpubnames" } */
+
+char array[1];
+
+/* { dg-final { scan-assembler-not {\msizetype} } } */
Index: gcc/testsuite/gcc.dg/asm-qual-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/asm-qual-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/asm-qual-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,46 @@
+/* Test that qualifiers on asm are allowed in any order.  */
+/* { dg-do compile } */
+/* { dg-options "-std=gnu99" } */
+
+void
+f (void)
+{
+  asm volatile goto ("" :::: lab);
+  asm volatile inline ("" :::);
+  asm inline volatile ("" :::);
+  asm inline goto ("" :::: lab);
+  asm goto volatile ("" :::: lab);
+  asm goto inline ("" :::: lab);
+
+  asm volatile inline goto ("" :::: lab);
+  asm volatile goto inline ("" :::: lab);
+  asm inline volatile goto ("" :::: lab);
+  asm inline goto volatile ("" :::: lab);
+  asm goto volatile inline ("" :::: lab);
+  asm goto inline volatile ("" :::: lab);
+
+  /* Duplicates are not allowed.  */
+  asm goto volatile volatile ("" :::: lab);  /* { dg-error "" } */
+  asm volatile goto volatile ("" :::: lab);  /* { dg-error "" } */
+  asm volatile volatile goto ("" :::: lab);  /* { dg-error "" } */
+  asm goto goto volatile ("" :::: lab);  /* { dg-error "" } */
+  asm goto volatile goto ("" :::: lab);  /* { dg-error "" } */
+  asm volatile goto goto ("" :::: lab);  /* { dg-error "" } */
+
+  asm inline volatile volatile ("" :::);  /* { dg-error "" } */
+  asm volatile inline volatile ("" :::);  /* { dg-error "" } */
+  asm volatile volatile inline ("" :::);  /* { dg-error "" } */
+  asm inline inline volatile ("" :::);  /* { dg-error "" } */
+  asm inline volatile inline ("" :::);  /* { dg-error "" } */
+  asm volatile inline inline ("" :::);  /* { dg-error "" } */
+
+  asm goto inline inline ("" :::: lab);  /* { dg-error "" } */
+  asm inline goto inline ("" :::: lab);  /* { dg-error "" } */
+  asm inline inline goto ("" :::: lab);  /* { dg-error "" } */
+  asm goto goto inline ("" :::: lab);  /* { dg-error "" } */
+  asm goto inline goto ("" :::: lab);  /* { dg-error "" } */
+  asm inline goto goto ("" :::: lab);  /* { dg-error "" } */
+
+lab:
+  ;
+}
Index: gcc/testsuite/gcc.dg/pr89314.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr89314.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr89314.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,13 @@
+/* PR tree-optimization/89314 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+extern __SIZE_TYPE__ strlen (const float *);
+void bar (void);
+
+void
+foo (float *s)
+{
+  if (strlen (s) > 0)
+    bar ();
+}
Index: gcc/testsuite/gcc.dg/asan/pr81923.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/asan/pr81923.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/asan/pr81923.c	(.../branches/gcc-7-branch)
@@ -1,8 +1,11 @@
 /* PR sanitizer/81923 */
 /* { dg-do link } */
 
-int foobar __asm (__USER_LABEL_PREFIX__ "barbaz") = 34;
+#define STR1(X) #X
+#define STR2(X) STR1(X)
 
+int foobar __asm (STR2(__USER_LABEL_PREFIX__) "barbaz") = 34;
+
 int
 main ()
 {
Index: gcc/testsuite/gcc.dg/graphite/pr84552.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/graphite/pr84552.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/graphite/pr84552.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -floop-nest-optimize -fno-tree-copy-prop -fno-tree-fre -fno-tree-loop-ivcanon" } */
+
+int cx;
+
+int
+e6 (int pj, int xe)
+{
+  for (cx = 0; cx < 2; ++cx)
+    while (xe < 1)
+      {
+	for (cx = 0; cx < 2; ++cx)
+	  pj *= 2;
+
+	if (cx != 0)
+	  goto o3;
+
+	++xe;
+      }
+
+o3:
+  return pj;
+}
Index: gcc/testsuite/gcc.dg/pr89521-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr89521-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr89521-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,42 @@
+/* PR c/89521 */
+/* { dg-do compile } */
+/* { dg-options "-Ofast -w" } */
+
+#define A(name) __typeof (__builtin_##name (0)) name (); \
+  float name##1 () { return name (1); } \
+  double name##2 () { return name (1); }
+#define B(name) A(name) A(name##l)
+B (cosh)
+B (exp)
+B (exp10)
+B (exp2)
+B (expm1)
+B (gamma)
+B (j0)
+B (j1)
+B (lgamma)
+B (pow10)
+B (sinh)
+B (tgamma)
+B (y0)
+B (y1)
+B (acos)
+B (acosh)
+B (asin)
+B (asinh)
+B (atan)
+B (atanh)
+B (cbrt)
+B (cos)
+B (erf)
+B (erfc)
+B (log)
+B (log10)
+B (log2)
+B (log1p)
+B (sin)
+B (tan)
+B (tanh)
+B (sqrt)
+B (fabs)
+B (logb)
Index: gcc/testsuite/gcc.dg/pr88074-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr88074-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr88074-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,17 @@
+/* PR middle-end/88074 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-optimized" } */
+/* { dg-add-options float128 } */
+/* { dg-require-effective-target float128 } */
+/* { dg-final { scan-tree-dump-not "link_error " "optimized" } } */
+
+extern void link_error (void);
+int
+main ()
+{
+  if (((__FLT128_MAX__ * 0.5 + __FLT128_MAX__ * 0.5i)
+       / (__FLT128_MAX__ * 0.25 + __FLT128_MAX__ * 0.25i))
+      != (_Complex _Float128) 2)
+    link_error ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/nested-func-12.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/nested-func-12.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/nested-func-12.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,48 @@
+/* PR target/88620 */
+/* { dg-do run } */
+/* { dg-options "-Ofast --param ipa-cp-eval-threshold=0 -fno-guess-branch-probability -fno-inline-small-functions" } */
+/* { dg-require-effective-target alloca } */
+
+void
+foo (int n)
+{
+  struct S { int a[n]; };
+
+  struct S
+  fn (void)
+  {
+    struct S s;
+    s.a[0] = 42;
+    return s;
+  }
+
+  auto struct S
+  fn2 (void)
+  {
+    return fn ();
+  }
+
+  struct S x;
+  fn ();
+  fn2 ();
+  x = fn ();
+
+  if (x.a[0] != 42)
+    __builtin_abort ();
+
+  if (fn ().a[0] != 42)
+    __builtin_abort ();
+
+  __typeof__ (fn ()) *p = &x;
+  if (p->a[0] != 42)
+    __builtin_abort ();
+
+  if (fn2 ().a[0] != 42)
+    __builtin_abort ();
+}
+
+int
+main (void)
+{
+  foo (1);
+}
Index: gcc/testsuite/gcc.dg/inline-40.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/inline-40.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/inline-40.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,49 @@
+/* Test inline functions declared in inner scopes.  Bugs 88720 and 88726.  */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+void
+inline_1 (void)
+{
+}
+
+void
+inline_2 (void)
+{
+}
+
+static void
+inline_static_1 (void)
+{
+}
+
+static void
+inline_static_2 (void)
+{
+}
+
+static void inline_static_3 (void);
+static void inline_static_4 (void);
+
+static void
+test (void)
+{
+  inline void inline_1 (void);
+  extern inline void inline_2 (void);
+  inline void inline_3 (void);
+  extern inline void inline_4 (void);
+  inline void inline_static_1 (void);
+  extern inline void inline_static_2 (void);
+  inline void inline_static_3 (void);
+  extern inline void inline_static_4 (void);
+}
+
+void
+inline_3 (void)
+{
+}
+
+void
+inline_4 (void)
+{
+}
Index: gcc/testsuite/gcc.dg/pr89354.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr89354.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr89354.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,22 @@
+/* PR rtl-optimization/89354 */
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+/* { dg-additional-options "-msse2" { target sse2_runtime } } */
+
+static unsigned long long q = 0;
+
+__attribute__((noinline, noclone)) static void
+foo (void)
+{
+  q = (q & ~0x1ffffffffULL) | 0x100000000ULL;
+}
+
+int
+main ()
+{
+  __asm volatile ("" : "+m" (q));
+  foo ();
+  if (q != 0x100000000ULL)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr88563.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr88563.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr88563.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,15 @@
+/* PR rtl-optimization/88563 */
+/* { dg-do run { target int128 } } */
+/* { dg-options "-O2 -fno-code-hoisting -fno-tree-ccp -fno-tree-dominator-opts -fno-tree-forwprop -fno-tree-fre -fno-tree-pre -fno-tree-vrp" } */
+
+int
+main ()
+{
+#if __SIZEOF_LONG_LONG__ == 8 && __SIZEOF_INT128__ == 16 && __CHAR_BIT__ == 8
+  unsigned __int128 a = 5;
+  __builtin_mul_overflow (0xffffffffffffffffULL, (unsigned long long) a, &a);
+  if (a != ((unsigned __int128)4 << 64 | 0xfffffffffffffffb))
+    __builtin_abort ();
+#endif
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pubtypes-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pubtypes-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pubtypes-2.c	(.../branches/gcc-7-branch)
@@ -2,7 +2,7 @@
 /* { dg-options "-O0 -gdwarf-2 -dA" } */
 /* { dg-skip-if "Unmatchable assembly" { mmix-*-* } { "*" } { "" } } */
 /* { dg-final { scan-assembler "__debug_pubtypes" } } */
-/* { dg-final { scan-assembler "long+\[ \t\]+0x13b+\[ \t\]+\[#;]+\[ \t\]+Pub Info Length" } } */
+/* { dg-final { scan-assembler "long+\[ \t\]+0x12e+\[ \t\]+\[#;]+\[ \t\]+Pub Info Length" } } */
 /* { dg-final { scan-assembler "used_struct\\\\0\"+\[ \t\]+\[#;]+\[ \t\]+external name" } } */
 /* { dg-final { scan-assembler-not "unused_struct\\\\0\"+\[ \t\]+\[#;]+\[ \t\]+external name" } } */
 
Index: gcc/testsuite/gcc.dg/autopar/pr91162.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/autopar/pr91162.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/autopar/pr91162.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,25 @@
+/* { dg-do compile { target int128 } } */
+/* { dg-options "-O -ftree-parallelize-loops=2 -fno-tree-dominator-opts" } */
+
+void
+zf (__int128 ct)
+{
+  __int128 *rk = &ct;
+
+  if (0)
+    {
+      int jj;
+
+t9:
+      for (jj = 0; jj < 60; ++jj)
+	{
+	}
+
+      __builtin_unreachable ();
+    }
+
+  while (*rk < 1)
+    ++*rk;
+
+  goto t9;
+}
Index: gcc/testsuite/gcc.dg/pr89278.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr89278.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr89278.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,23 @@
+/* PR tree-optimization/89278 */
+/* { dg-do compile } */
+/* { dg-options "-O1 -ftrapv -ftree-loop-distribute-patterns --param max-loop-header-insns=2" } */
+
+void
+foo (int *w, int x, int y, int z)
+{
+  while (x < y + z)
+    {
+      w[x] = 0;
+      ++x;
+    }
+}
+
+void
+bar (int *__restrict u, int *__restrict w, int x, int y, int z)
+{
+  while (x < y + z)
+    {
+      w[x] = u[x];
+      ++x;
+    }
+}
Index: gcc/testsuite/gcc.dg/asm-qual-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/asm-qual-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/asm-qual-3.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,9 @@
+/* Test that asm-qualifiers are not allowed on toplevel asm.  */
+/* { dg-do compile } */
+/* { dg-options "-std=gnu99" } */
+
+asm const ("");    /* { dg-error {expected '\(' before 'const'} } */
+asm volatile (""); /* { dg-error {expected '\(' before 'volatile'} } */
+asm restrict (""); /* { dg-error {expected '\(' before 'restrict'} } */
+asm inline ("");   /* { dg-error {expected '\(' before 'inline'} } */
+asm goto ("");     /* { dg-error {expected '\(' before 'goto'} } */
Index: gcc/testsuite/gcc.dg/pr89590.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr89590.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr89590.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,11 @@
+/* PR middle-end/89590 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wall -w" } */
+
+void free (void *);
+
+void
+foo (void)
+{
+  ((void (*)()) free) ();
+}
Index: gcc/testsuite/gcc.dg/pr87929.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr87929.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr87929.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-fexceptions -fnon-call-exceptions -fsignaling-nans" } */
+
+#define complex __complex__
+#define _Complex_I (1.0iF)
+
+extern void f2c_4d__( complex float *, complex float *);
+extern void abort (void);
+
+void f2c_4c__(void)
+{
+  complex float x,ret_val;
+  x = 1234 + 5678 * _Complex_I;
+  f2c_4d__(&ret_val,&x);
+  if ( x != ret_val ) abort();
+}
Index: gcc/testsuite/gcc.dg/pr90082.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr90082.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr90082.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,13 @@
+/* PR rtl-optimization/90082 */
+/* { dg-do compile } */
+/* { dg-options "-O1 -fnon-call-exceptions -ftrapv" } */
+
+void *buf[5];
+
+void
+foo (int a)
+{
+  if (__builtin_setjmp (buf) == 0)
+    __asm__ ("" : : "n" (a * 2));	/* { dg-error "impossible constraint in 'asm'" } */
+					/* { dg-warning "asm operand 0 probably doesn't match constraints" "" { target *-*-* } .-1 } */
+}
Index: gcc/testsuite/gcc.dg/lto/pr85248_0.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/lto/pr85248_0.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/lto/pr85248_0.c	(.../branches/gcc-7-branch)
@@ -2,8 +2,13 @@
 /* { dg-lto-do run } */
 /* { dg-lto-options { { -flto -O2 } } } */
 
-extern void test_alias (int s, int e) __asm__ (__USER_LABEL_PREFIX__ "test");
-extern void test_noreturn (int s, int e) __asm__ (__USER_LABEL_PREFIX__ "test")
+#define STR1(X) #X
+#define STR2(X) STR1(X)
+
+extern void test_alias (int s, int e) 
+  __asm__ (STR2(__USER_LABEL_PREFIX__) "test");
+extern void test_noreturn (int s, int e)
+  __asm__ (STR2(__USER_LABEL_PREFIX__)  "test")
   __attribute__ ((__noreturn__));
 
 extern inline __attribute__ ((__always_inline__, __gnu_inline__)) void
Index: gcc/testsuite/gcc.dg/pr89520-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr89520-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr89520-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,13 @@
+/* PR c/89520 */
+/* { dg-do compile } */
+/* { dg-options "-Ofast -w" } */
+
+#define A(name) __typeof (__builtin_##name (0)) name (); long name##1 () { return name (); }
+#define B(name) A(name) A(name##f) A(name##l)
+B (ceil)
+B (floor)
+B (round)
+B (trunc)
+B (nearbyint)
+B (rint)
+B (logb)
Index: gcc/testsuite/gcc.dg/torture/neon-immediate-timode.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/neon-immediate-timode.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/neon-immediate-timode.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,10 @@
+union a {
+  char b;
+  long long c;
+};
+union a d;
+int g(int, union a, union a);
+void e() {
+  union a f[2] = {-1L};
+  g(0, d, f[0]);
+}
Index: gcc/testsuite/gcc.dg/torture/pr86554-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr86554-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr86554-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,35 @@
+/* { dg-do run } */
+
+struct foo
+{
+  unsigned x;
+};
+typedef struct foo foo;
+
+static inline int zot(foo *f)
+{
+  int ret;
+
+  if (f->x > 0x7FFFFFFF)
+    ret = (int)(f->x - 0x7FFFFFFF);
+  else
+    ret = (int)f->x - 0x7FFFFFFF;
+  return ret;
+}
+
+void __attribute__((noinline,noclone)) bar(foo *f)
+{
+  int ret = zot(f);
+  volatile int x = ret;
+  if (ret < 1)
+    __builtin_abort ();
+}
+
+int main()
+{
+  foo f;
+  f.x = 0x800003f8;
+
+  bar(&f);
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr91812.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr91812.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr91812.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } { "" } } */
+/* { dg-options "-fdump-tree-optimized-blocks" } */
+
+unsigned register1;
+unsigned register2;
+
+void busy_wait_for_register (int x)
+{
+  volatile unsigned* ptr;
+  switch(x) {
+    case 0x1111:
+    ptr = &register1;
+    break;
+
+    case 0x2222:
+    ptr = &register2;
+    break;
+
+    default:
+    return;
+  }
+  while (*ptr) {}
+}
+
+/* { dg-final { scan-tree-dump "loop depth 1" "optimized" } } */
Index: gcc/testsuite/gcc.dg/torture/pr91200.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr91200.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr91200.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,32 @@
+/* { dg-do compile } */
+
+int printf (const char *, ...);
+
+char a;
+int b, c, **d;
+
+int main ()
+{
+  int f = -128, *g, *h[2] = {0, 0}, i;
+  printf("0");
+  if (a)
+    {
+      while (f > a) {
+        int *j = &i;
+        *j |= 0;
+      }
+      h[i] = &c;
+    }
+  if (h[1])
+    {
+      int **k = &g;
+      *k = &f;
+      while (i)
+        {
+          int **l[] = {&g};
+        }
+      int **m = &g;
+      *d = *m = &b;
+    }
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr68037-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr68037-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr68037-1.c	(.../branches/gcc-7-branch)
@@ -1,4 +1,5 @@
 /* { dg-do run { target i?86-*-* x86_64-*-* } } */
+/* { dg-skip-if "PR81210 sp not aligned to 16 bytes" { *-*-darwin* } } */
 /* { dg-options "-mgeneral-regs-only" } */
 
 extern void exit (int);
Index: gcc/testsuite/gcc.dg/torture/pr90278.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr90278.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr90278.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-fexceptions -fnon-call-exceptions" } */
+
+double
+hc (void)
+{
+  double dp = 0.0;
+  double ek[1];
+
+  ek[0] = 1.0 / dp < 0.0;
+
+  return ek[0];
+}
Index: gcc/testsuite/gcc.dg/torture/pr68037-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr68037-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr68037-3.c	(.../branches/gcc-7-branch)
@@ -1,4 +1,5 @@
 /* { dg-do run { target i?86-*-* x86_64-*-* } } */
+/* { dg-skip-if "PR81210 sp not aligned to 16 bytes" { *-*-darwin* } } */
 /* { dg-options "-mgeneral-regs-only" } */
 
 #include <stddef.h>
Index: gcc/testsuite/gcc.dg/torture/pr89572.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr89572.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr89572.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-finline-functions" } */
+
+int vh, it, k1;
+
+void
+vn (void)
+{
+  ++vh;
+  if (vh == 0 && it == 0)
+    k1 = -k1;
+}
+
+__attribute__ ((returns_twice)) void
+ef (int *uw)
+{
+  while (uw != (void *) 0)
+    {
+      vn ();
+      *uw = 0;
+    }
+}
+
+void
+gu (int *uw)
+{
+  ef (uw);
+}
Index: gcc/testsuite/gcc.dg/torture/pr90071.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr90071.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr90071.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,24 @@
+/* { dg-do compile } */
+
+int a;
+static int b;
+
+void
+foo ()
+{
+  int d;
+  int e = (int) (__INTPTR_TYPE__) &&f;
+  void *g = &&h;
+h: ++e;
+   if (a)
+     i: goto *g;
+   for (;;)
+     {
+       e = 0;
+       if (b)
+	 goto i;
+     }
+f:
+   goto *({ d || e < 0 || e >= 2; });
+   &e;
+}
Index: gcc/testsuite/gcc.dg/torture/pr89008.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr89008.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr89008.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,27 @@
+/* { dg-do run } */
+/* { dg-require-effective-target int32plus } */
+
+unsigned long a, c;
+unsigned b;
+int d, e;
+long f()
+{
+  unsigned long g = 0;
+  for (d = 0; d < 5; d += 2)
+    for (e = 0; e < 5; e += 3)
+      {
+	c = 4 + b;
+	g = -b - b;
+	b = 5 * (b << 24);
+      }
+  a = g;
+  return 0;
+}
+
+int main()
+{
+  f();
+  if (a)
+    __builtin_abort();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr68264.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr68264.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr68264.c	(.../branches/gcc-7-branch)
@@ -1,4 +1,5 @@
 /* { dg-do run } */
+/* { dg-skip-if "PR68356 no math-errno on darwin" { "*-*-darwin*" } } */
 /* { dg-add-options ieee } */
 /* { dg-require-effective-target fenv_exceptions } */
 
Index: gcc/testsuite/gcc.dg/torture/pr91126.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr91126.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr91126.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,28 @@
+/* { dg-do run } */
+
+struct S
+{
+  __INT32_TYPE__ a : 24;
+  __INT32_TYPE__ b : 8;
+} s;
+
+int
+main()
+{
+  s.a = 0xfefefe;
+  s.b = 0xfe;
+  unsigned char c;
+  c = ((unsigned char *)&s)[0];
+  if (c != 0xfe)
+    __builtin_abort ();
+  c = ((unsigned char *)&s)[1];
+  if (c != 0xfe)
+    __builtin_abort ();
+  c = ((unsigned char *)&s)[2];
+  if (c != 0xfe)
+    __builtin_abort ();
+  c = ((unsigned char *)&s)[3];
+  if (c != 0xfe)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr89135.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr89135.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr89135.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,35 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target indirect_jumps } */
+/* { dg-require-effective-target label_values } */
+
+typedef __INTPTR_TYPE__ intptr_t;
+intptr_t a, b, c, d;
+int foo (void) { return 0; }
+int baz (void);
+
+void
+bar (void)
+{
+  intptr_t g = (intptr_t) &&h;
+  void *i = &&j, *k = &&l;
+j:
+  if (baz ())
+    {
+      intptr_t **n = (intptr_t **) &a;
+l:
+      b = 0;
+      for (; b >= 0;)
+	goto *k;
+h:
+      **n = 0;
+      for (;;)
+	{
+	  intptr_t *o = &c;
+	  g = foo ();
+	  *o = g;
+	  if (c)
+	    goto *d;
+	}
+    }
+  goto *i;
+}
Index: gcc/testsuite/gcc.dg/torture/pr90328.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr90328.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr90328.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,24 @@
+/* { dg-do run } */
+
+void g(int*__restrict x, int*y)
+{
+  *x = *y;
+}
+
+void __attribute__((noinline,noclone)) f(int* a,int* b)
+{
+  for(int i=0;i<1024;++i)
+    g(a+i,b+i);
+}
+
+int main()
+{
+  int x[1025];
+  for (int i = 0; i < 1025; ++i)
+    x[i] = i+1;
+  f(x+1, x);
+  for (int i = 0; i < 1025; ++i)
+    if (x[i] != 1)
+      __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr89091.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr89091.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr89091.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,10 @@
+/* PR middle-end/89091 */
+/* { dg-do compile { target int128 } } */
+
+struct S { unsigned __int128 s : 65; };
+
+int
+foo (struct S *x, int y)
+{
+  return y && x->s;
+}
Index: gcc/testsuite/gcc.dg/torture/restrict-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/restrict-7.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/restrict-7.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,27 @@
+/* { dg-do run } */
+
+extern void abort (void);
+
+static inline __attribute__((always_inline)) void
+copy(int *restrict a, int *restrict b)
+{
+  *b = *a;
+  *a = 7;
+}
+
+void __attribute__((noinline))
+floppy(int mat[static 2], unsigned idxs[static 3])
+{
+  for (int i = 0; i < 3; i++)
+    copy(&mat[i%2], &mat[idxs[i]]);
+}
+
+int main()
+{
+  int mat[2] = {10, 20};
+  unsigned idxs[3] = {1, 0, 1};
+  floppy(mat, idxs);
+  if (mat[0] != 7 || mat[1] != 10)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr86554-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr86554-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr86554-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,49 @@
+/* { dg-do run } */
+/* { dg-require-effective-target int32plus } */
+
+struct s { __INT64_TYPE__ e; };
+
+static void f (struct s *ps)
+{
+  volatile __INT64_TYPE__ m = 9223372036854775807;
+  const char *str = "11E";
+  int r;
+  __INT64_TYPE__ sum;
+
+  ps->e = 0;
+
+  for (;;)
+    {
+      if (*str++ != '1')
+	break;
+      ps->e ++;
+    }
+
+  r = 1;
+  sum = m;
+
+  if (sum >= 0 && ps->e >= 0)
+    {
+      __UINT64_TYPE__ uc;
+      uc = (__UINT64_TYPE__) sum + (__UINT64_TYPE__) ps->e;
+      if (uc > 9223372036854775807)
+	r = 2;
+      else
+	sum = 17;
+    }
+  else
+    sum = sum + ps->e;
+
+  if (sum != 9223372036854775807)
+    __builtin_abort ();
+  if (r != 2)
+    __builtin_abort ();
+  ps->e = sum;
+}
+
+int main (void)
+{
+  struct s s;
+  f (&s);
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr68037-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr68037-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr68037-2.c	(.../branches/gcc-7-branch)
@@ -1,4 +1,5 @@
 /* { dg-do run { target i?86-*-* x86_64-*-* } } */
+/* { dg-skip-if "PR81210 sp not aligned to 16 bytes" { *-*-darwin* } } */
 /* { dg-options "-mgeneral-regs-only" } */
 
 extern void exit (int);
Index: gcc/testsuite/gcc.dg/torture/pr89223.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr89223.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr89223.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,10 @@
+/* { dg-do compile { target int128 } } */
+
+int a[5];
+unsigned __int128 b;
+void c()
+{
+  b = 4;
+  for (;; b--)
+    a[b] = ({ a[b + b]; });
+}
Index: gcc/testsuite/gcc.dg/torture/pr89677.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr89677.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr89677.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target int32plus } */
+
+int a, b, d;
+unsigned c;
+float e, f, g;
+void h() {
+    float *i = &g;
+    for (; c < 10; c += 3)
+      for (; d; d += 3) {
+	  a = *i;
+	  g = f + 0;
+	  f = b + *i + (b - e + 305219) + -b + 3;
+      }
+}
Index: gcc/testsuite/gcc.dg/torture/pr89505.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr89505.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr89505.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,22 @@
+/* { dg-do run } */
+
+struct S { int i; void *p; int j; };
+int a;
+int __attribute__((noinline))
+foo (struct S * __restrict p, int q)
+{
+  int *x = &p->j;
+  if (q)
+    x = &a;
+  p->j = 1;
+  *x = 2;
+  return p->j;
+}
+
+int main()
+{
+  struct S s;
+  if (foo (&s, 0) != 2)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr90020.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr90020.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr90020.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,29 @@
+/* { dg-do run } */
+/* { dg-require-weak "" } */
+/* { dg-additional-options "-Wl,-undefined,dynamic_lookup" { target *-*-darwin* } } */
+/* { dg-additional-options "-Wl,-flat_namespace" { target *-*-darwin[89]* } } */
+
+void __attribute__((noinline,noclone))
+check (int i)
+{
+  if (i == 0)
+    __builtin_exit (0);
+}
+
+int i;
+extern int x __attribute__((weak));
+
+int main(int argc, char **argv)
+{
+  if (argc)
+    {
+      check (i);
+      return x;
+    }
+  else
+    {
+      check (i);
+      return x-1;
+    }
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr89710.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr89710.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr89710.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,30 @@
+/* { dg-do compile } */
+
+void
+gm (int *);
+
+__attribute__ ((returns_twice)) void
+jg (void)
+{
+}
+
+void
+eb (void)
+{
+  int r6 = 0;
+
+  if (r6 != 0)
+    gm (&r6);
+}
+
+void
+gm (int *r6)
+{
+  jg ();
+
+  for (;;)
+    {
+      eb ();
+      *r6 = 0;
+    }
+}
Index: gcc/testsuite/gcc.dg/memcmp-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/memcmp-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/memcmp-1.c	(.../branches/gcc-7-branch)
@@ -8,9 +8,14 @@
 #include <string.h>
 #include <stdint.h>
 
-int lib_memcmp(const void *a, const void *b, size_t n) asm("memcmp");
-int lib_strncmp(const char *a, const char *b, size_t n) asm("strncmp");
+#define STR1(X) #X
+#define STR2(X) STR1(X)
 
+int lib_memcmp(const void *a, const void *b, size_t n)
+ asm(STR2(__USER_LABEL_PREFIX__) "memcmp");
+int lib_strncmp(const char *a, const char *b, size_t n)
+ asm(STR2(__USER_LABEL_PREFIX__) "strncmp");
+
 #ifndef NRAND
 #define NRAND 10000
 #endif
Index: gcc/testsuite/gcc.dg/tree-ssa/pr89872.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr89872.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr89872.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,27 @@
+/* PR c/89872 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-optimized" } */
+/* { dg-final { scan-tree-dump-times " ={v} 1;" 1 "optimized" } } */
+/* { dg-final { scan-tree-dump-times " ={v} 2;" 1 "optimized" } } */
+/* { dg-final { scan-tree-dump-times " ={v} 3;" 1 "optimized" } } */
+/* { dg-final { scan-tree-dump-times " ={v} 4;" 1 "optimized" } } */
+/* { dg-final { scan-tree-dump-times " ={v} 0;" 1 "optimized" } } */
+/* { dg-final { scan-tree-dump-times " ={v} " 10 "optimized" } } */
+
+void
+foo (void)
+{
+  (volatile int){1} + (volatile int){2};
+}
+
+void
+bar (void)
+{
+  (volatile int){3};
+}
+
+void
+baz (void)
+{
+  (volatile int){4} / (volatile int){0};
+}
Index: gcc/testsuite/gcc.dg/uninit-pr89296.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/uninit-pr89296.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/uninit-pr89296.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wuninitialized" } */
+
+int get_a_value ();
+void printk(const char *);
+void test_func()
+{
+    int loop;
+    while (!loop) {             /* { dg-warning "is used uninitialized" } */
+	loop = get_a_value();
+	printk("...");
+    }
+}
Index: gcc/testsuite/gcc.dg/inline-41.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/inline-41.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/inline-41.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,49 @@
+/* Test inline functions declared in inner scopes.  Bugs 88720 and 88726.  */
+/* { dg-do compile } */
+/* { dg-options "-fgnu89-inline" } */
+
+void
+inline_1 (void)
+{
+}
+
+void
+inline_2 (void)
+{
+}
+
+static void
+inline_static_1 (void)
+{
+}
+
+static void
+inline_static_2 (void)
+{
+}
+
+static void inline_static_3 (void);
+static void inline_static_4 (void);
+
+static void
+test (void)
+{
+  inline void inline_1 (void);
+  extern inline void inline_2 (void);
+  inline void inline_3 (void);
+  extern inline void inline_4 (void);
+  inline void inline_static_1 (void);
+  extern inline void inline_static_2 (void);
+  inline void inline_static_3 (void);
+  extern inline void inline_static_4 (void);
+}
+
+void
+inline_3 (void)
+{
+}
+
+void
+inline_4 (void)
+{
+}
Index: gcc/testsuite/gcc.dg/darwin-minversion-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/darwin-minversion-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/darwin-minversion-1.c	(.../branches/gcc-7-branch)
@@ -1,6 +1,6 @@
 /* Basic test for -mmacosx-version-min switch on Darwin.  */
 /* { dg-options "-mmacosx-version-min=10.5" } */
-/* { dg-do run { target *-*-darwin* } } */
+/* { dg-do compile { target *-*-darwin* } } */
 
 int
 main ()
Index: gcc/testsuite/gcc.dg/pubtypes-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pubtypes-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pubtypes-3.c	(.../branches/gcc-7-branch)
@@ -2,7 +2,7 @@
 /* { dg-options "-O0 -gdwarf-2 -dA" } */
 /* { dg-skip-if "Unmatchable assembly" { mmix-*-* } { "*" } { "" } } */
 /* { dg-final { scan-assembler "__debug_pubtypes" } } */
-/* { dg-final { scan-assembler "long+\[ \t\]+0x13b+\[ \t\]+\[#;]+\[ \t\]+Pub Info Length" } } */
+/* { dg-final { scan-assembler "long+\[ \t\]+0x12e+\[ \t\]+\[#;]+\[ \t\]+Pub Info Length" } } */
 /* { dg-final { scan-assembler "used_struct\\\\0\"+\[ \t\]+\[#;]+\[ \t\]+external name" } } */
 /* { dg-final { scan-assembler-not "unused_struct\\\\0\"+\[ \t\]+\[#;]+\[ \t\]+external name" } } */
 /* { dg-final { scan-assembler-not "\"list_name_type\\\\0\"+\[ \t\]+\[#;]+\[ \t\]+external name" } } */
Index: gcc/testsuite/gcc.dg/tree-prof/section-attr-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/tree-prof/section-attr-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/section-attr-1.c	(.../branches/gcc-7-branch)
@@ -13,7 +13,11 @@
 
 void foo (int path);
 
+#ifdef __APPLE__
+__attribute__ ((section ("__TEXT,__text")))
+#else
 __attribute__((section(".text")))
+#endif
 int
 main (int argc, char *argv[])
 {
@@ -43,3 +47,4 @@
 }
 
 /* { dg-final-use { scan-assembler "\.section\[\t \]*\.text\.unlikely\[\\n\\r\]+\[\t \]*\.size\[\t \]*foo\.cold\.0" { target *-*-linux* *-*-gnu* } } } */
+/* { dg-final-use { scan-assembler "\.section\[\t \]*__TEXT,__text_cold\.\*\[\\n\\r\]+_foo\.cold\.0" { target *-*-darwin* } } } */
Index: gcc/testsuite/gcc.dg/tree-prof/section-attr-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/tree-prof/section-attr-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/section-attr-2.c	(.../branches/gcc-7-branch)
@@ -28,7 +28,11 @@
 void NOINLINE
 foo (int path)
 {
+#ifdef __APPLE__
+  static int i __attribute__ ((section ("__DATA,__data")));
+#else
   static int i __attribute__((section(".data")));
+#endif
   if (path)
     {
       for (i = 0; i < SIZE; i++)
@@ -42,3 +46,4 @@
 }
 
 /* { dg-final-use { scan-assembler "\.section\[\t \]*\.text\.unlikely\[\\n\\r\]+\[\t \]*\.size\[\t \]*foo\.cold\.0" { target *-*-linux* *-*-gnu* } } } */
+/* { dg-final-use { scan-assembler "\.section\[\t \]*__TEXT,__text_cold\.\*\[\\n\\r\]+_foo\.cold\.0:" { target *-*-darwin* } } } */
Index: gcc/testsuite/gcc.dg/tree-prof/section-attr-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/tree-prof/section-attr-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/section-attr-3.c	(.../branches/gcc-7-branch)
@@ -9,7 +9,11 @@
 #define NOINLINE __attribute__((noinline)) __attribute__ ((noclone))
 
 const char *sarr[SIZE];
+#ifdef __APPLE__
+const char *buf_hot __attribute__ ((section ("__DATA,__data")));
+#else
 const char *buf_hot __attribute__ ((section (".data")));
+#endif
 const char *buf_cold;
 
 void foo (int path);
@@ -43,3 +47,4 @@
 }
 
 /* { dg-final-use { scan-assembler "\.section\[\t \]*\.text\.unlikely\[\\n\\r\]+\[\t \]*\.size\[\t \]*foo\.cold\.0" { target *-*-linux* *-*-gnu* } } } */
+/* { dg-final-use { scan-assembler "\.section\[\t \]*__TEXT,__text_cold\.\*\[\\n\\r\]+_foo\.cold\.0:" { target *-*-darwin* } } } */
Index: gcc/testsuite/gcc.dg/ipa/ipcp-5.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/ipa/ipcp-5.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipcp-5.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,45 @@
+/* Test that estimated local cloning time benefit of extern inline functions is
+   zero.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -fdump-ipa-cp -fno-early-inlining"  } */
+/* { dg-add-options bind_pic_locally } */
+
+extern int get_int (void);
+extern void use_stuff (int);
+
+int arr[10];
+
+inline void
+f (int a)
+{
+  arr[0] += a + 5;
+  arr[1] += a + 50;
+  arr[2] += a - 3;
+  arr[3] += a;
+  arr[4] += a + 21;
+  arr[5] += a + 900;
+  arr[6] += a + 2;
+  arr[7] += a + 3456;
+  arr[8] += a + 3;
+  arr[9] += a + 32;
+  use_stuff (a);
+}
+
+
+int
+entry (void)
+{
+  int i;
+  for (i = 0; i < 100; i++)
+    f (7);
+  for (i = 0; i < 100; i++)
+    f (get_int ());
+  return 0;
+}
+
+
+/* { dg-final { scan-ipa-dump "loc_time: 0" "cp" } } */
+/* { dg-final { scan-ipa-dump-not "replacing param.*with const" "cp"  } } */
+
+
Index: gcc/testsuite/gcc.dg/ipa/pr88214.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/ipa/pr88214.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/ipa/pr88214.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void i();
+  short a;
+  void b(e) char * e;
+  {
+    i();
+    b(a);
+  }
Index: gcc/testsuite/gcc.dg/pr88568.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr88568.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr88568.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,4 @@
+/* PR c/88568 */
+/* { dg-do compile } */
+/* { dg-require-dll "" } */
+__attribute__((dllimport)) struct S var;	/* { dg-bogus "storage size of .var. isn.t known" } */
Index: gcc/testsuite/gcc.dg/pr88074.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr88074.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr88074.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+#include <complex.h>
+
+int main()
+{
+  _Complex double x;
+  __real x = 3.091e+8;
+  __imag x = -4.045e+8;
+  /* This used to spend huge amounts of compile-time inside mpc.  */
+  volatile _Complex double y = ctan (x);
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr89520-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr89520-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr89520-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,42 @@
+/* PR c/89520 */
+/* { dg-do compile } */
+/* { dg-options "-Ofast -w" } */
+
+#define A(name) __typeof (__builtin_##name (0)) name (); \
+  float name##1 () { return name (); } \
+  double name##2 () { return name (); }
+#define B(name) A(name) A(name##l)
+B (cosh)
+B (exp)
+B (exp10)
+B (exp2)
+B (expm1)
+B (gamma)
+B (j0)
+B (j1)
+B (lgamma)
+B (pow10)
+B (sinh)
+B (tgamma)
+B (y0)
+B (y1)
+B (acos)
+B (acosh)
+B (asin)
+B (asinh)
+B (atan)
+B (atanh)
+B (cbrt)
+B (cos)
+B (erf)
+B (erfc)
+B (log)
+B (log10)
+B (log2)
+B (log1p)
+B (sin)
+B (tan)
+B (tanh)
+B (sqrt)
+B (fabs)
+B (logb)
Index: gcc/testsuite/gcc.dg/uninit-19.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/uninit-19.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/uninit-19.c	(.../branches/gcc-7-branch)
@@ -23,5 +23,5 @@
   fn1 (l, &d, &e, &g, &i, &h, &k, n);  /* 23.  */
 }
 
-/* { dg-warning "may be used uninitialized" "" { target { { nonpic } || { hppa*64*-*-* } } } 14 } */
-/* { dg-warning "may be used uninitialized" "" { target { ! { { nonpic } || { hppa*64*-*-* } } } } 23 } */
+/* { dg-warning "may be used uninitialized" "" { target { { nonpic } || { hppa*64*-*-* *-*-darwin* } } } 14 } */
+/* { dg-warning "may be used uninitialized" "" { target { ! { { nonpic } || { hppa*64*-*-* *-*-darwin* } } } } 23 } */
Index: gcc/testsuite/gcc.dg/pr89679.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr89679.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr89679.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,26 @@
+/* PR rtl-optimization/89679 */
+/* { dg-do run } */
+/* { dg-options "-Og -frerun-cse-after-loop -fno-tree-fre" } */
+
+unsigned short g;
+
+void
+foo (unsigned long long x)
+{
+  if (x != 0xffff)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+#if __SIZEOF_SHORT__ == 2 && __SIZEOF_INT__ == 4 && __CHAR_BIT__ == 8
+  unsigned short d = 0;
+  unsigned long long x, c = ~0;
+  c = c >> d;
+  __builtin_memset (&d, c, 2);
+  x = d + g;
+  foo (x);
+#endif
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/vect/pr88903-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr88903-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr88903-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,26 @@
+#include "tree-vect.h"
+
+int x[1024];
+
+void __attribute__((noinline))
+foo()
+{
+  for (int i = 0; i < 512; ++i)
+    {
+      x[2*i] = x[2*i] << ((i+1) & 31);
+      x[2*i+1] = x[2*i+1] << ((i+1) & 31);
+    }
+}
+
+int
+main()
+{
+  check_vect ();
+  for (int i = 0; i < 1024; ++i)
+    x[i] = i;
+  foo ();
+  for (int i = 0; i < 1024; ++i)
+    if (x[i] != i << ((i/2+1) & 31))
+      __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/vect/pr88903-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr88903-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr88903-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,28 @@
+#include "tree-vect.h"
+
+int x[1024];
+int y[1024];
+int z[1024];
+
+void __attribute__((noinline)) foo()
+{
+  for (int i = 0; i < 512; ++i)
+    {
+      x[2*i] = x[2*i] << y[2*i];
+      x[2*i+1] = x[2*i+1] << y[2*i];
+      z[2*i] = y[2*i];
+      z[2*i+1] = y[2*i+1];
+    }
+}
+
+int main()
+{
+  check_vect ();
+  for (int i = 0; i < 1024; ++i)
+    x[i] = i, y[i] = i % 8;
+  foo ();
+  for (int i = 0; i < 1024; ++i)
+    if (x[i] != i << ((i & ~1) % 8))
+      __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/vect/pr81740-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr81740-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr81740-1.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,22 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vect_int } */
+
+#include "tree-vect.h"
+
+int a[8][10] = { [2][5] = 4 }, c;
+
+int
+main ()
+{
+  short b;
+  int i, d;
+  check_vect ();
+  for (b = 4; b >= 0; b--)
+    for (c = 0; c <= 6; c++)
+      a[c + 1][b + 2] = a[c][b + 1];
+  for (i = 0; i < 8; i++)
+    for (d = 0; d < 10; d++)
+      if (a[i][d] != (i == 3 && d == 6) * 4)
+	__builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/vect/bb-slp-pr90006.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-pr90006.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-pr90006.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,31 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-fno-math-errno" } */
+/* { dg-additional-options "-march=x86-64" { target x86_64-*-* i?86-*-* } } */
+
+long int lrint(double x);
+
+int a, b;
+union c {
+    int d;
+};
+
+int e()
+{
+  int f, g, h;
+  long i, j, k;
+  double l, m = b = lrint(0.3127);
+  a = b >> 16 >> 8 & 255;
+  ((union c *)e)->d = a;
+  k = m;
+  h = k >> 16 >> 8 & 255;
+  ((union c *)(e + 4))->d = h;
+  j = lrint(l);
+  g = j >> 16 >> 8 & 255;
+  ((union c *)(e + 8))->d = g;
+  i = lrint(0.292);
+  f = i >> 16 >> 8 & 255;
+  ((union c *)(e + 12))->d = f;
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump "basic block vectorized" "slp2" { target { { x86_64-*-* i?86-*-* } && ilp32 } } } } */
Index: gcc/testsuite/gcc.dg/vect/pr81740-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr81740-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr81740-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,24 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vect_int } */
+
+#include "tree-vect.h"
+
+int a[8][10] = { [2][5] = 4 }, c;
+
+int
+main ()
+{
+  short b;
+  int i, d;
+  check_vect ();
+  for (b = 4; b >= 0; b--)
+    for (c = 6; c >= 0; c--)
+      a[c + 1][b + 2] = a[c][b + 1];
+  for (i = 0; i < 8; i++)
+    for (d = 0; d < 10; d++)
+      if (a[i][d] != (i == 3 && d == 6) * 4)
+	__builtin_abort ();
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump "OUTER LOOP VECTORIZED" "vect" } } */
Index: gcc/testsuite/ChangeLog
===================================================================
--- a/src/gcc/testsuite/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,2258 @@
+2019-11-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR c++/79274
+	* g++.dg/tls/pr77285-2.C: XFAIL test for Darwin.
+
+2019-11-02  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-13  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.dg/pr90760.c: Require alias support.
+
+2019-11-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-10-13  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/i386/indirect-thunk-1.c: Allow 'l' or 'L' in
+	indirection label prefix, for Darwin.
+	* gcc.target/i386/indirect-thunk-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-5.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-6.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-4.c: Likewise.
+	* gcc.target/i386/pr32219-2.c: Likewise.
+	* gcc.target/i386/pr32219-3.c: Likewise.
+	* gcc.target/i386/pr32219-4.c: Likewise.
+	* gcc.target/i386/pr32219-7.c: Likewise.
+	* gcc.target/i386/pr32219-8.c: Likewise.
+	* gcc.target/i386/ret-thunk-14.c: Likewise.
+	* gcc.target/i386/ret-thunk-15.c: Likewise.
+	* gcc.target/i386/ret-thunk-9.c: Likewise.
+
+2019-11-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-08-13  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* obj-c++.dg/stubify-1.mm: Rename symbol stub option.
+	* obj-c++.dg/stubify-2.mm: Likewise.
+	* objc.dg/stubify-1.m: Likewise.
+	* objc.dg/stubify-2.m: Likewise.
+
+2019-11-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-15  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* lib/target-supports.exp 
+	(check_effective_target_powerpc_p8vector_ok): No support for Darwin.
+	(check_effective_target_powerpc_p9vector_ok): Likewise.
+	(check_effective_target_powerpc_float128_sw_ok): Likewise.
+	(check_effective_target_powerpc_float128_hw_ok): Likewise.
+	(check_effective_target_powerpc_vsx_ok): Likewise.
+	* gcc.target/powerpc/bfp/bfp.exp: Don't try to run this for Darwin.
+	* gcc.target/powerpc/dfp/dfp.exp: Likewise.
+
+2019-10-29  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.c-torture/compile/pr72802.c: Skip for Darwin.
+
+2019-10-29  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/86248
+	* gfortran.dg/char_result_19.f90 : New test.
+	* gfortran.dg/char_result_mod_19.f90 : Module for the new test.
+
+2019-10-26  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/darwin.h (ASM_OUTPUT_MAX_SKIP_ALIGN):Guard
+	against out of range max skip or log values.
+
+2019-10-25  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backport from mainline
+	2019-05-08  Mihail Ionescu  <mihail.ionescu@arm.com>
+	   Richard Earnshaw  <rearnsha@arm.com>
+	PR target/88167
+	* gcc.target/arm/pr88167-1.c: New test.
+	* gcc.target/arm/pr88167-2.c: New test.
+
+2019-10-24  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-10-17  Richard Biener  <rguenther@suse.de>
+
+	PR debug/91887
+	* g++.dg/debug/dwarf2/pr91887.C: New testcase.
+
+	2019-09-19  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91812
+	* gcc.dg/torture/pr91812.c: New testcase.
+
+2019-10-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/20191023-1.c: New test.
+
+2019-10-18  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/69455
+	* gfortran.dg/pr69455_1.f90: New test.
+	* gfortran.dg/pr69455_2.f90: Ditto.
+
+2019-10-17  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	Backport from mainline
+	2019-10-15  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/92093
+	* gcc.target/powerpc/pr91275.c: Fix type and endian issues.
+
+2019-10-07  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	Backport from mainline
+	2019-10-01  Bill Schmidt  <wschmdit@linux.ibm.com>
+
+	PR target/91275
+	* gcc.target/powerpc/pr91275.c: New.
+
+2019-09-28  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/82920
+	* gcc.target/i386/indirect-thunk-bnd-1.c: Adjust scan-asms for Darwin,
+	do not use -fno-pic on Darwin.
+	* gcc.target/i386/indirect-thunk-bnd-2.c: Likewise.
+	* gcc.target/i386/ret-thunk-25.c: Skip for Darwin, which has a
+	different ABI for returning this category of complex value.
+
+2019-09-28  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-14  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/82920
+	* gcc.target/i386/pr52146.c: Require effective target x32.
+	* gcc.target/i386/pr52698.c: Likewise.
+	* gcc.target/i386/pr52857-1.c: Likewise.
+	* gcc.target/i386/pr52857-2.c: Likewise.
+	* gcc.target/i386/pr52876.c: Likewise.
+	* gcc.target/i386/pr53698.c: Likewise.
+	* gcc.target/i386/pr54157.c: Likewise.
+	* gcc.target/i386/pr55049-1.c: Likewise.
+	* gcc.target/i386/pr55093.c: Likewise.
+	* gcc.target/i386/pr55116-1.c: Likewise.
+	* gcc.target/i386/pr55116-2.c: Likewise.
+	* gcc.target/i386/pr55597.c: Likewise.
+	* gcc.target/i386/pr59929.c: Likewise.
+	* gcc.target/i386/pr66470.c: Likewise.
+
+2019-09-28  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-12  Iain Sandoe  <iain@sandoe.co.uk>
+	    Dominique d'Humieres  <dominiq@gcc.gnu.org>
+
+	PR target/82920
+	* gcc.target/i386/indirect-thunk-1.c: Adjust scan-asms for Darwin,
+	do not use -fno-pic on Darwin.
+	* gcc.target/i386/indirect-thunk-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-7.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-5.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-6.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-7.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-8.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-7.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-7.c: Likewise.
+	* gcc.target/i386/indirect-thunk-register-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-register-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-register-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-register-4.c: Likewise.
+	* gcc.target/i386/ret-thunk-1.c: Likewise.
+	* gcc.target/i386/ret-thunk-10.c: Likewise.
+	* gcc.target/i386/ret-thunk-11.c: Likewise.
+	* gcc.target/i386/ret-thunk-12.c: Likewise.
+	* gcc.target/i386/ret-thunk-13.c: Likewise.
+	* gcc.target/i386/ret-thunk-14.c: Likewise.
+	* gcc.target/i386/ret-thunk-15.c: Likewise.
+	* gcc.target/i386/ret-thunk-16.c: Likewise.
+	* gcc.target/i386/ret-thunk-2.c: Likewise.
+	* gcc.target/i386/ret-thunk-22.c: Likewise.
+	* gcc.target/i386/ret-thunk-23.c: Likewise.
+	* gcc.target/i386/ret-thunk-24.c: Likewise.
+	* gcc.target/i386/ret-thunk-3.c: Likewise.
+	* gcc.target/i386/ret-thunk-4.c: Likewise.
+	* gcc.target/i386/ret-thunk-5.c: Likewise.
+	* gcc.target/i386/ret-thunk-6.c: Likewise.
+	* gcc.target/i386/ret-thunk-7.c: Likewise.
+	* gcc.target/i386/ret-thunk-8.c: Likewise.
+	* gcc.target/i386/ret-thunk-9.c: Likewise.
+
+2019-09-17  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-13  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* g++.dg/pr71694.C: Use non-PIC codegen for Darwin m32.
+
+2019-09-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.dg/cpp/isysroot-1.c: Use <example.h> as the test header.
+	* gcc.dg/cpp/usr/include/stdio.h: Rename...
+	* gcc.dg/cpp/usr/include/example.h: ... to this.
+
+2019-09-15  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91557
+	* gfortran.dg/warn_unused_dummy_argument_5.f90: New test.
+
+2019-09-15  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* obj-c++.dg/syntax-error-1.mm: Adjust line number in dg-error.
+
+2019-09-15  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-15  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR objc/90709
+	* obj-c++.dg/proto-lossage-7.mm: Use proxy headers.
+	* obj-c++.dg/strings/const-cfstring-2.mm: Likewise.
+	* obj-c++.dg/strings/const-cfstring-5.mm: Likewise
+	* obj-c++.dg/strings/const-str-12.mm: Likewise.
+	* obj-c++.dg/syntax-error-1.mm: Likewise.
+	* obj-c++.dg/torture/strings/const-cfstring-1.mm: Likewise.
+	* obj-c++.dg/torture/strings/const-str-10.mm: Likewise.
+	* obj-c++.dg/torture/strings/const-str-11.mm: Likewise.
+	* obj-c++.dg/torture/strings/const-str-9.mm: Likewise.
+	* obj-c++.dg/cxx-ivars-3.mm: Skip on later Darwin, where the 10.4 API
+	in no longer supported, also on m64 where there's no meaning to it.
+	* obj-c++.dg/isa-field-1.mm: Suppress unwanted warning, add comment why.
+	* obj-c++.dg/objc-gc-3.mm: Skip for Darwin > 16, the API use is an error
+	there.
+	* obj-c++.dg/qual-types-1.mm: Prune a spurious l64 warning.
+	* obj-c++.dg/stubify-1.mm: Tidy up after better compiler warnings.
+	* obj-c++.dg/stubify-2.mm: Likewise.
+	* obj-c++.dg/try-catch-1.mm: Likewise.
+	* obj-c++.dg/try-catch-3.mm: Likewise.
+
+	Backport from mainline.
+	2019-06-15  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR objc/90709
+	* objc.dg/encode-7-next-64bit.m: Use proxy headers.
+	* objc.dg/image-info.m: Likewise.
+	* objc.dg/method-6.m: Likewise.
+	* objc.dg/no-extra-load.m: Likewise.
+	* objc.dg/objc-foreach-4.m: Likewise.
+	* objc.dg/objc-foreach-5.m: Likewise.
+	* objc.dg/proto-lossage-7.m: Likewise.
+	* objc.dg/strings/const-cfstring-2.m: Likewise.
+	* objc.dg/strings/const-cfstring-5.m: Likewise.
+	* objc.dg/strings/const-str-12b.m: Likewise.
+	* objc.dg/symtab-1.m: Likewise.
+	* objc.dg/torture/strings/const-cfstring-1.m: Likewise.
+	* objc.dg/torture/strings/const-str-10.m: Likewise.
+	* objc.dg/torture/strings/const-str-11.m: Likewise.
+	* objc.dg/torture/strings/const-str-9.m: Likewise.
+	* objc.dg/zero-link-1.m: Likewise.
+	* objc.dg/zero-link-2.m: Likewise.
+	* objc.dg/zero-link-3.m: Likewise.
+	* objc.dg/isa-field-1.m: Suppress unwanted warning, add comment why.
+	* objc.dg/headers.m: XFAIL for Darwin14-19.
+	* objc.dg/objc-gc-4.m: Skip for Darwin > 16, the API use is an error
+	there.
+
+	Backport from mainline.
+	2019-06-15  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR objc/90709
+	* objc-obj-c++-shared/CF-CFString.h: New.
+	* objc-obj-c++-shared/F-NSArray.h: New.
+	* objc-obj-c++-shared/F-NSAutoreleasePool.h: New.
+	* objc-obj-c++-shared/F-NSObject.h: New.
+	* objc-obj-c++-shared/F-NSString.h: New.
+	* objc-obj-c++-shared/F-NSValue.h: New.
+	* objc-obj-c++-shared/GNUStep/CoreFoundation/CFArray.h: New.
+	* objc-obj-c++-shared/GNUStep/CoreFoundation/CFAvailability.h: New.
+	* objc-obj-c++-shared/GNUStep/CoreFoundation/CFBase.h: New.
+	* objc-obj-c++-shared/GNUStep/CoreFoundation/CFCharacterSet.h: New.
+	* objc-obj-c++-shared/GNUStep/CoreFoundation/CFData.h: New.
+	* objc-obj-c++-shared/GNUStep/CoreFoundation/CFDictionary.h: New.
+	* objc-obj-c++-shared/GNUStep/CoreFoundation/CFLocale.h: New.
+	* objc-obj-c++-shared/GNUStep/CoreFoundation/CFString.h: New.
+	* objc-obj-c++-shared/GNUStep/Foundation/NSArray.h: New.
+	* objc-obj-c++-shared/GNUStep/Foundation/NSAutoreleasePool.h: New.
+	* objc-obj-c++-shared/GNUStep/Foundation/NSDate.h: New.
+	* objc-obj-c++-shared/GNUStep/Foundation/NSEnumerator.h: New.
+	* objc-obj-c++-shared/GNUStep/Foundation/NSGeometry.h: New.
+	* objc-obj-c++-shared/GNUStep/Foundation/NSObjCRuntime.h: New.
+	* objc-obj-c++-shared/GNUStep/Foundation/NSObject.h: New.
+	* objc-obj-c++-shared/GNUStep/Foundation/NSRange.h: New.
+	* objc-obj-c++-shared/GNUStep/Foundation/NSString.h: New.
+	* objc-obj-c++-shared/GNUStep/Foundation/NSValue.h: New.
+	* objc-obj-c++-shared/GNUStep/Foundation/NSZone.h: New.
+	* objc-obj-c++-shared/GNUStep/GNUstepBase/GNUstep.h: New.
+	* objc-obj-c++-shared/GNUStep/GNUstepBase/GSBlocks.h: New.
+	* objc-obj-c++-shared/GNUStep/GNUstepBase/GSConfig.h: New.
+	* objc-obj-c++-shared/GNUStep/GNUstepBase/GSObjCRuntime.h: New.
+	* objc-obj-c++-shared/GNUStep/GNUstepBase/GSVersionMacros.h: New.
+	* objc-obj-c++-shared/GNUStep/GNUstepBase/NSArray+GNUstepBase.h: New.
+	* objc-obj-c++-shared/GNUStep/GNUstepBase/NSMutableString+GNUstepBase.h:
+	New.
+	* objc-obj-c++-shared/GNUStep/GNUstepBase/NSNumber+GNUstepBase.h: New.
+	* objc-obj-c++-shared/GNUStep/GNUstepBase/NSObject+GNUstepBase.h: New.
+	* objc-obj-c++-shared/GNUStep/GNUstepBase/NSString+GNUstepBase.h: New.
+
+2019-09-13  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-13  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.dg/darwin-minversion-1.c: Use compile rather than link/run.
+	* gcc.dg/darwin-minversion-2.c: Likewise.
+
+2019-09-12  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-27  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/i386/pr22076.c: Adjust options to
+	match codegen expected by the scan-asms.
+
+2019-09-12  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/91686
+	* gfortran.dg/pr91686.f90 : New test.
+
+2019-09-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/sparc/20161111-1.c: XFAIL redundant zero-extension test.
+
+2019-09-10  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-26  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/i386/pr39013-1.c: Adjust scan-asms for PIE to
+	account for PIC code on Darwin.
+	* gcc.target/i386/pr39013-2.c: Likewise.
+	* gcc.target/i386/pr64317.c: Likewise.
+
+2019-09-10  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-25  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/i386/pr59874-3.c: Use the spelling of popcnt
+	expected for Darwin.
+
+2019-09-09  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-07-25  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR gcov-profile/91087
+	* g++.dg/gcov/pr16855.C: Xfail the count lines for the DTORs and the
+	"final" line for the failure summaries.  Adjust source layout so that
+	dejagnu xfail expressions work.
+
+2019-09-09  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-11  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR testsuite/65364
+	* gcc.dg/uninit-19.c (fn1): Adjust target condition for Darwin.
+	(fn2): Likewise.
+
+2019-09-09  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/i386/pr66819-3.c: Specifically, check that there is no
+	call to "bar".
+	* gcc.target/i386/pr66819-4.c: Likewise.
+
+2019-09-09  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/i386/pr67985-2.c: Adjust label checks for
+	Darwin.
+	* gcc.target/i386/pr77881.c: Likewise.
+
+2019-09-09  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/i386/pr70738-7.c: Likewise.
+	* gcc.target/i386/pr24414.c: Likewise.
+
+2019-09-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/87853
+	* gcc.target/i386/pr87853.c: New test.
+
+	PR target/91704
+	* gcc.target/i386/pr91704.c: New test.
+
+2019-09-08  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/90698
+	* gcc.target/i386/pr49866.c: XFAIL for Darwin.
+	* gcc.target/i386/pr63538.c: Likewise.
+	* gcc.target/i386/pr61599-1.c: Skip for Darwin.
+
+2019-09-08  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR rtl-optimisation/64895
+	* gcc.target/i386/fuse-caller-save-rec.c: Remove XFAILs.
+	* gcc.target/i386/fuse-caller-save.c: Likewise.
+	* gcc.target/i386/fuse-caller-save-xmm.c: Adjust tests for
+	PIC cases, remove XFAILs.
+
+2019-09-06  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-22  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR testsuite/27221
+	* g++.dg/ext/alignof2.C: XFAIL for 32bit Darwin.
+
+2019-09-06  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-21  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR testsuite/67958
+	* gcc.target/i386/pr32219-1.c: Adjust scan-asms for Darwin, comment
+	the differences.
+	* gcc.target/i386/pr32219-2.c: Likewise.
+	* gcc.target/i386/pr32219-3.c: Likewise.
+	* gcc.target/i386/pr32219-4.c: Likewise.
+	* gcc.target/i386/pr32219-5.c: Likewise.
+	* gcc.target/i386/pr32219-6.c: Likewise.
+	* gcc.target/i386/pr32219-7.c: Likewise.
+	* gcc.target/i386/pr32219-8.c: Likewise.
+
+2019-09-06  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-21  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/63891
+	* gcc.dg/darwin-weakimport-3.c: Adjust options and explain
+	the reasons.
+
+2019-09-06  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-20  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR testsuite/58321
+	* gcc.target/i386/memcpy-strategy-3.c: Adjust count for Darwin and
+	add a comment as to the reason for the difference.
+	* gcc.target/i386/memset-strategy-1.c: Likewise.
+
+2019-09-05  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-07-13  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/powerpc/stabs-attrib-vect-darwin.c: Require stabs
+	support.
+
+2019-09-05  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/powerpc/safe-indirect-jump-1.c: Skip for Darwin.
+	* gcc.target/powerpc/safe-indirect-jump-7.c: Likewise.
+
+2019-09-05  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/powerpc/builtins-2.c: Require VSX hardware support.
+
+2019-09-05  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/powerpc/pr80125.c (foo): Use an unsigned char
+	vector explicitly for the vec_perm.
+
+2019-09-05  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/powerpc/pr71785.c: For Darwin, make test non-PIC,
+	expect the out-of-line GPR restore, and test specifically for
+	absence of branches to local labels.
+
+2019-09-05  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-22  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/powerpc/pr64205.c: Require effective target dfp.
+	* gcc.target/powerpc/pr79909.c: Likewise.
+
+2019-09-05  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-22  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/powerpc/darwin-bool-1.c: Suppress the pedantic
+	warning about _Bool.
+
+2019-09-05  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-10  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/x86_64/abi/avx512f/abi-avx512f.exp: Darwin is
+	now tested.
+	* gcc.target/x86_64/abi/avx512f/asm-support-darwin.s: New.
+
+2019-09-05  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* objc.dg/instancetype-0.m: New.
+
+2019-09-05  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-05-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90328
+	* gcc.dg/torture/pr90328.c: New testcase.
+
+	2019-02-22  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/87609
+	* gcc.dg/torture/restrict-7.c: New testcase.
+
+2019-09-04  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-13  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.dg/darwin-minversion-link.c: New test.
+
+2019-09-04  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-03-26  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	PR tree-optimization/81740
+	* gcc.dg/vect/pr81740-1.c: New testcase.
+	* gcc.dg/vect/pr81740-2.c: Likewise.
+
+2019-09-04  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-11-23  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/88149
+	* g++.dg/torture/pr88149.C: New testcase.
+
+2019-09-04  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-04-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90006
+	* gcc.dg/vect/bb-slp-pr90006.c: New testcase.
+
+	2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89698
+	* g++.dg/torture/pr89698.C: New testcase.
+
+	2019-01-18  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/88903
+	* gcc.dg/vect/pr88903-1.c: New testcase.
+	* gcc.dg/vect/pr88903-2.c: Likewise.
+
+	2018-12-11  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/88448
+	PR middle-end/88415
+	* gcc.dg/gomp/pr88415.c: New testcase.
+
+	2018-11-15  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/88030
+	* gcc.dg/tsan/pr88030.c: New testcase.
+
+	2018-11-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/87929
+	* gcc.dg/pr87929.c: New testcase.
+
+2019-09-02  Richard Biener  <rguenther@suse.de>
+
+
+	Backport from mainline
+	2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89710
+	* gcc.dg/torture/pr89710.c: New testcase.
+
+	2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89572
+	* gcc.dg/torture/pr89572.c: New testcase.
+
+	2019-02-18  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89296
+	* gcc.dg/uninit-pr89296.c: New testcase.
+
+	2019-01-31  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89135
+	* gcc.dg/torture/pr89135.c: New testcase.
+
+2019-09-02  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-07-19  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91200
+	* gcc.dg/torture/pr91200.c: New testcase.
+
+	2019-07-15  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/91162
+	* gcc.dg/autopar/pr91162.c: New testcase.
+
+	2019-07-11  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/91131
+	* gcc.target/i386/pr91131.c: New testcase.
+
+	2019-07-10  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91126
+	* gcc.dg/torture/pr91126.c: New testcase.
+
+	2019-07-10  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91126
+	* gcc.dg/torture/pr91126.c: New testcase.
+
+	2019-04-29  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90278
+	* gcc.dg/torture/pr90278.c: New testcase.
+
+	2019-04-11  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90020
+	* gcc.dg/torture/pr90020.c: New testcase.
+
+2019-09-02  Bin Cheng  <bin.linux@linux.alibaba.com>
+
+	Backport from mainline
+	2019-07-18  Bin Cheng  <bin.linux@linux.alibaba.com>
+
+	PR tree-optimization/91137
+	* gcc.c-torture/execute/pr91137.c: New test.
+
+2019-08-31  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/91481
+	* gcc.target/powerpc/darn-3.c: Fix testcase.
+
+2019-08-30  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-04-25  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/90194
+	* g++.dg/torture/pr90194.C: New testcase.
+
+	2019-04-15  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90071
+	* gcc.dg/torture/pr90071.c: New testcase.
+
+	2019-03-13  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89677
+	* gcc.dg/torture/pr89677.c: New testcase.
+
+2019-08-30  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2019-08-23  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/91481
+	* gcc.target/powerpc/darn-3.c: New testcase.
+
+2019-08-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-07-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/91150
+	* gcc.target/i386/avx512bw-pr91150.c: New test.
+
+	2019-07-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/78884
+	* gcc.dg/gomp/pr78884.c: New test.
+
+	PR rtl-optimization/90756
+	* gcc.dg/pr90756.c: New test.
+
+	2019-06-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/90954
+	* c-c++-common/gomp/pr90954.c: New test.
+
+	2019-06-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90950
+	* g++.dg/gomp/lastprivate-1.C: New test.
+
+	2019-06-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/90760
+	* gcc.dg/pr90760.c: New test.
+
+	2019-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR pch/90326
+	* g++.dg/pch/pr90326.C: New test.
+	* g++.dg/pch/pr90326.Hs: New file.
+
+	2019-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/90139
+	* gcc.c-torture/compile/pr90139.c: New test.
+
+	2019-04-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/90187
+	* g++.dg/opt/pr90187.C: New test.
+
+	PR tree-optimization/90208
+	* gcc.dg/tsan/pr90208-2.c: New test.
+
+	2019-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90108
+	* c-c++-common/pr90108.c: New test.
+
+	2019-04-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/90082
+	* gcc.dg/pr90082.c: New test.
+
+	PR tree-optimization/90090
+	* g++.dg/opt/pr90090.C: New test.
+
+	2019-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/89933
+	* c-c++-common/pr89933.c: New test.
+
+	2019-04-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/89998
+	* gcc.c-torture/compile/pr89998-1.c: New test.
+	* gcc.c-torture/compile/pr89998-2.c: New test.
+
+	2019-03-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/89869
+	* g++.dg/ubsan/vptr-14.C: New test.
+
+	PR c/89872
+	* gcc.dg/tree-ssa/pr89872.c: New test.
+
+	2019-03-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89621
+	* gfortran.dg/gomp/pr89621.f90: New test.
+
+	2019-03-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89796
+	* g++.dg/gomp/pr89796.C: New test.
+	* gcc.dg/gomp/pr89796.c: New test.
+
+	2019-03-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/60702
+	* g++.dg/tls/thread_local11.C: Remove scan-tree-dump-times directives
+	for _ZTH* calls.
+	* g++.dg/tls/thread_local11a.C: New test.
+
+	2019-03-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/60702
+	* g++.dg/tls/thread_local11.C: New test.
+	* g++.dg/tls/thread_local11.h: New test.
+	* g++.dg/tls/thread_local12a.C: New test.
+	* g++.dg/tls/thread_local12b.C: New test.
+	* g++.dg/tls/thread_local12c.C: New test.
+	* g++.dg/tls/thread_local12d.C: New test.
+	* g++.dg/tls/thread_local12e.C: New test.
+	* g++.dg/tls/thread_local12f.C: New test.
+	* g++.dg/tls/thread_local12g.C: New test.
+	* g++.dg/tls/thread_local12h.C: New test.
+	* g++.dg/tls/thread_local12i.C: New test.
+	* g++.dg/tls/thread_local12j.C: New test.
+	* g++.dg/tls/thread_local12k.C: New test.
+	* g++.dg/tls/thread_local12l.C: New test.
+
+	2019-03-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89767
+	* g++.dg/cpp1y/lambda-init18.C: New test.
+	* g++.dg/cpp1y/lambda-init19.C: New test.
+	* g++.dg/cpp1y/pr89767.C: New test.
+
+	2019-03-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/89752
+	* g++.dg/ext/asm15.C: Check for particular diagnostic wording.
+	* g++.dg/ext/asm16.C: Likewise.
+	* g++.dg/ext/asm17.C: New test.
+
+	PR target/89726
+	* gcc.target/i386/fpprec-1.c (x): Add 6 new constants.
+	(expect_round, expect_rint, expect_floor, expect_ceil, expect_trunc):
+	Add expected results for them.
+
+	PR c/89734
+	* gcc.dg/pr89734.c: New test.
+
+	2019-03-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/89704
+	* gcc.dg/debug/pr89704.c: New test.
+
+	2019-03-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/89679
+	* gcc.dg/pr89679.c: New test.
+
+	PR tree-optimization/89703
+	* gcc.c-torture/compile/pr89703-1.c: New test.
+	* gcc.c-torture/compile/pr89703-2.c: New test.
+
+	PR c++/89512
+	* g++.dg/cpp1y/var-templ61.C: New test.
+
+	2019-03-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/88588
+	* c-c++-common/gomp/pr88588.c: New test.
+
+	2019-03-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89663
+	* gcc.c-torture/compile/pr89663-1.c: New test.
+	* gcc.c-torture/compile/pr89663-2.c: New test.
+
+	2019-03-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/89651
+	* gfortran.dg/gomp/pr89651.f90: New test.
+
+	2019-03-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/88568
+	* g++.dg/other/pr88568.C: New test.
+
+	2019-03-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/82075
+	* g++.dg/cpp1z/decomp49.C: New test.
+
+	2019-03-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/87148
+	* g++.dg/ext/flexary34.C: New test.
+
+	2019-03-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89590
+	* gcc.dg/pr89590.c: New test.
+
+	2019-02-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/89521
+	* gcc.dg/pr89521-1.c: New test.
+	* gcc.dg/pr89521-2.c: New test.
+
+	PR c/89520
+	* gcc.dg/pr89520-1.c: New test.
+	* gcc.dg/pr89520-2.c: New test.
+
+	2019-02-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89403
+	* g++.dg/cpp0x/pr89403.C: New test.
+
+	PR middle-end/89412
+	* gcc.c-torture/compile/pr89412.c: New test.
+
+	2019-02-20  Jakub Jelinek  <jakub@redhat.com>
+		    David Malcolm  <dmalcolm@redhat.com>
+
+	PR middle-end/89091
+	* gcc.dg/torture/pr89091.c: New test.
+
+	2019-02-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/88074
+	PR middle-end/89415
+	* gcc.dg/pr88074-2.c: New test.
+
+	2019-02-19  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/88074
+	* gcc.dg/pr88074.c: New testcase.
+
+2019-08-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-02-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89303
+	* g++.dg/torture/pr89303.C: Move everything from std namespace to my
+	namespace.
+
+	2019-02-15  Richard Biener  <rguenther@suse.de>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/89278
+	* gcc.dg/pr89278.c: New test.
+
+	2019-02-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR other/89342
+	* gcc.dg/pr89342.c: New test.
+
+	2019-02-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/89354
+	* gcc.dg/pr89354.c: New test.
+
+	PR tree-optimization/89314
+	* gcc.dg/pr89314.c: New test.
+
+	2019-02-13  Jonathan Wakely  <jwakely@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89303
+	* g++.dg/torture/pr89303.C: New test.
+
+	2019-02-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89246
+	* gcc.dg/gomp/pr89246-1.c: New test.
+	* gcc.dg/gomp/pr89246-2.c: New test.
+
+	PR target/88861
+	* g++.dg/opt/pr89188.C: Include ../torture/pr88861.C.
+
+	2019-01-16  David Malcolm  <dmalcolm@redhat.com>
+
+	PR target/88861
+	* g++.dg/torture/pr88861.C: New test.
+
+	2019-02-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/89234
+	* g++.dg/ubsan/pr89234.C: New test.
+
+	2019-02-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89187
+	* g++.dg/opt/pr89187.C: New test.
+
+	PR rtl-optimization/11304
+	* gcc.target/i386/call-1.c (set_eax): Add "eax" clobber.
+	* gcc.target/i386/call-2.c: New test.
+
+	PR target/89188
+	* g++.dg/opt/pr89188.C: New test.
+
+	PR rtl-optimization/89195
+	* gcc.c-torture/execute/pr89195.c: New test.
+
+	PR target/89186
+	* g++.dg/ext/vector36.C: New test.
+
+	2019-02-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/87887
+	* gcc.dg/gomp/pr87887-1.c: New test.
+	* gcc.dg/gomp/pr87887-2.c: New test.
+
+	2019-02-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/83246
+	PR fortran/89084
+	* gfortran.dg/pr89084.f90: New test.
+	* gfortran.dg/lto/pr89084_0.f90: New test.
+	* gfortran.dg/pr83246.f90: New test.
+
+	PR tree-optimization/88107
+	* gcc.dg/gomp/pr88107.c: New test.
+
+	2019-01-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/66676
+	PR ipa/89104
+	* gcc.dg/gomp/pr89104.c: New test.
+
+	2019-01-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/87214
+	* gcc.target/i386/avx512vl-pr87214-1.c: New test.
+	* gcc.target/i386/avx512vl-pr87214-2.c: New test.
+
+	2019-01-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/88976
+	* c-c++-common/gomp/cancel-2.c: New test.
+	* gcc.dg/gomp/cancel-1.c: New test.
+	* g++.dg/gomp/cancel-1.C: New test.
+	* g++.dg/gomp/cancel-2.C: New test.
+	* g++.dg/gomp/cancel-3.C: New test.
+
+	2019-01-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/49429
+	PR target/49454
+	PR rtl-optimization/86334
+	PR target/88906
+	* gcc.target/i386/pr86334.c: New test.
+	* gcc.target/i386/pr88906.c: New test.
+
+	2019-01-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/88949
+	* g++.dg/gomp/pr88949.C: New test.
+
+	2019-01-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/88902
+	* gfortran.dg/pr88902.f90: New test.
+
+	2019-01-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/88870
+	* gcc.dg/pr88870.c: New test.
+
+	2019-01-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/88568
+	* gcc.dg/pr88568.c: New test.
+
+	2019-01-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/82564
+	PR target/88620
+	* gcc.dg/nested-func-12.c: New test.
+	* gcc.c-torture/compile/pr82564.c: New test.
+
+	2019-01-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/88594
+	* gcc.dg/pr88594.c: New test.
+
+	2019-01-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/88644
+	* gcc.dg/debug/dwarf2/pr88644.c: New test.
+
+	2019-01-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.dg/pubtypes-2.c: Adjust expected pubtypes length.
+	* gcc.dg/pubtypes-3.c: Likewise.
+	* gcc.dg/pubtypes-4.c: Likewise.
+
+	2018-12-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/85594
+	PR middle-end/88553
+	* gcc.dg/gomp/pr85594.c: New test.
+	* gcc.dg/gomp/pr88553.c: New test.
+
+	PR rtl-optimization/88563
+	* gcc.dg/pr88563.c: New test.
+
+	2018-12-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/88470
+	* gcc.target/i386/pr88470.c: New test.
+
+	PR rtl-optimization/88416
+	* gcc.target/i386/pr88416.c: New test.
+
+	2018-12-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/86669
+	* g++.dg/cpp0x/initlist105.C: New test.
+	* g++.dg/cpp0x/initlist106.C: New test.
+	* g++.dg/other/pr86669.C: New test.
+
+	PR fortran/88377
+	* gfortran.dg/gomp/pr88377.f90: New test.
+
+	PR c++/87506
+	* g++.dg/cpp0x/constexpr-87506.C: New test.
+
+	2018-12-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/88103
+	* g++.dg/cpp0x/rv-cond3.C: New test.
+
+	2018-12-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/71109
+	* gcc.c-torture/compile/pr71109.c: New test.
+
+	2018-11-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/85550
+	* g++.dg/debug/dwarf2/pr85550.C: New test.
+
+	2018-11-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/88181
+	* g++.dg/debug/pr88181.C: New test.
+
+	2018-11-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/87895
+	* gcc.dg/gomp/pr87895-1.c: New test.
+	* gcc.dg/gomp/pr87895-2.c: New test.
+	* gcc.dg/gomp/pr87895-3.c: New test.
+
+	2018-11-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/60994
+	* g++.dg/lookup/pr60994.C: New test.
+
+	2018-10-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/87725
+	* c-c++-common/gomp/schedule-modifiers-1.c (bar): Separate modifier
+	from kind with a colon rather than comma.
+	* gfortran.dg/gomp/schedule-modifiers-1.f90: New test.
+	* gfortran.dg/gomp/schedule-modifiers-2.f90: New test.
+
+	2018-10-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/87647
+	* gcc.c-torture/compile/pr87647.c: New test.
+
+	2018-10-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/85488
+	PR middle-end/87649
+	* c-c++-common/gomp/doacross-2.c: New test.
+	* c-c++-common/gomp/sink-3.c: Expect another error during error
+	recovery.
+
+2019-08-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/20190820-1.c: New test.
+
+2019-08-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	Paul Thomas <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90786
+	PR fortran/90813
+	* gfortran.dg/proc_ptr_51.f90: New test.
+
+2019-07-22  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-07-22  Martin Liska  <mliska@suse.cz>
+
+	PR driver/91172
+	* gcc.dg/pr91172.c: New test.
+
+2019-07-16  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	Backport from mainline
+	2019-03-05  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	PR target/89222
+	* gcc.target/arm/pr89222.c: Add new test.
+
+2019-07-15  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-07-01  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* gcc.target/s390/vector/vec-shift-2.c: New test.
+
+2019-07-12  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	PR testsuite/78529
+	* gcc.c-torture/execute/builtins/builtins.exp: Add -fno-ipa-ra.
+
+2019-06-21  Jeff Law  <law@redhat.com>
+
+	Backport fom mainline
+	2019-06-21  Jeff Law  <law@redhat.com>
+
+	PR tree-optimization/90949
+	* gcc.c-torture/execute/pr90949.c: New test.
+
+2019-06-21  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90937
+	* gfortran.dg/external_procedure_4.f90: New test.
+
+2019-06-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/90870
+	* gfortran.dg/deferred_character_33.f90: Remove failing test.
+	* gfortran.dg/deferred_character_33a.f90: Likewise.
+
+2019-06-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	Tom Trnka  <trnka@scm.com>
+
+	Backport from trunk
+	PR fortran/90744
+	* gfortran.dg/deferred_character_33.f90: New test.
+	* gfortran.dg/deferred_character_33a.f90: New test.
+
+2019-06-04  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-05-02  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* g++.dg/ext/instantiate2.C: Remove special-casing for Darwin.
+
+2019-05-28  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-04-20  Sandra Loosemore  <sandra@codesourcery.com>
+
+	* g++.dg/ipa/pr89009.C: Add dg-require-effective-target fpic.
+
+2019-05-28  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-28  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR testsuite/89441
+	* g++.dg/ipa/pr89009.C: Update symbol visibility.
+
+2019-05-28  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-11  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/89009
+	* g++.dg/ipa/pr89009.C: New test.
+
+2019-05-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt79.ad[sb]: New test.
+
+2019-05-23  Uro Bizjak  <ubizjak@gmail.com>
+
+	Backported from mainline
+	2019-05-21  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR target/90547
+	* gcc.target/i386/pr90547.c: New test.
+
+2019-05-20  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-05-07  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/89765
+	* gcc.target/powerpc/pr89765-mc.c: New test.
+	* gcc.target/powerpc/vsx-builtin-10c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-10d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-11c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-11d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-12c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-12d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-13c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-13d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-14c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-14d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-15c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-15d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-16c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-16d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-17c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-17d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-18c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-18d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-19c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-19d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-20c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-20d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-9c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-9d.c: New test.
+
+2019-05-13  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-05-06  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/89424
+	* gcc.target/powerpc/pr89424-0.c: New test.
+	* gcc.target/powerpc/vsx-builtin-13a.c: Define macro PR89424 to
+	enable testing of newly patched capability.
+	* gcc.target/powerpc/vsx-builtin-13b.c: Likewise.
+	* gcc.target/powerpc/vsx-builtin-20a.c: Likewise.
+	* gcc.target/powerpc/vsx-builtin-20b.c: Likewise.
+
+2019-05-07  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline:
+	2019-01-25  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR middle-end/89037
+	* gcc.dg/pr89037.c: New test.
+
+2019-05-05  Thomas Koenig <tkoenig@gcc.gnu.org>
+
+	PR fortran/90344
+	* gfortran.dg/pr90344.f90: New test
+
+2019-04-30  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	PR target/90075
+	* gcc.target/aarch64/pr90075.c: New test.
+
+2019-04-25  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	* gcc.target/powerpc/vsx-vector-6.p8.c: Fix failure caused by typo.
+
+2019-04-22  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-03-15  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/87532
+	* gcc.target/powerpc/pr87532-mc.c: New test.
+	* gcc.target/powerpc/pr87532.c: New test.
+	* gcc.target/powerpc/vec-extract-v16qiu-v2.h: New test.
+	* gcc.target/powerpc/vec-extract-v16qiu-v2a.c: New test.
+	* gcc.target/powerpc/vec-extract-v16qiu-v2b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-10a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-10b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-11a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-11b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-12a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-12b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-13a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-13b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-14a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-14b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-15a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-15b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-16a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-16b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-17a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-17b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-18a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-18b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-19a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-19b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-20a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-20b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-9a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-9b.c: New test.
+
+	2019-03-19  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/89736
+	* gcc.target/powerpc/pr87532-mc.c: Modify dejagnu directives to
+	restrict this test to vsx targets.
+
+2019-04-19  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	Backport from trunk
+	2018-02-07  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	* gcc.target/powerpc/vsx-vector-6-le.c: Update CPU target.
+	* gcc.target/powerpc/vsx-vector-6-le.p9.c: New.
+
+	Backport from trunk
+	2018-05-04  Carl Love  <cel@us.ibm.com>
+	* gcc.target/powerpc/vsx-vector-6.h (foo): Add test for vec_max,
+	vec_trunc.
+	* gcc.target/powerpc/vsx-vector-6-le.c (dg-final): Update xvcmpeqdp,
+	xvcmpgtdp, xvcmpgedp counts. Add xxsel counts.
+	* gcc.target/powerpc/vsx-vector-6-be.c (dg-final): Update xvcmpgtdp,
+	xvcmpgedp counts. Add xxsel counts.
+
+	Backport from trunk
+	2018-05-16  Carl Love  <cel@us.ibm.com>
+	* gcc.target/powerpc/vsx-vector-6-be.c: Remove file.
+	* gcc.target/powerpc/vsx-vector-6-be.p7.c: New test file.
+	* gcc.target/powerpc/vsx-vector-6-be.p8.c: New test file.
+	* gcc.target/powerpc/vsx-vector-6-le.c (dg-final): Update counts for
+	xvcmpeqdp., xvcmpgtdp., xvcmpgedp., xxlxor, xvrdpi.
+
+	Backport from trunk
+	2018-05-23  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* lib/target-supports.exp (check_effective_target_be): New.
+	(check_effective_target_le): New.
+
+	Backport from trunk
+	2018-06-01  Carl Love  <cel@us.ibm.com>
+
+	* gcc.target/powerpc/altivec-7-be.c: Delete file.
+	* gcc.target/powerpc/altivec-7-le.c: Delete file.
+	* gcc.target/powerpc/vsx-7-be.c: Remove file.
+
+	Backport from trunk
+	2018-06-01  Carl Love  <cel@us.ibm.com>
+
+	Commit 260294 on 2018-05-16 by Carl Love was supposed to add the
+	following files.
+
+	* gcc.target/powerpc/vsx-vector-6-be.p7.c: New test file.
+	* gcc.target/powerpc/vsx-vector-6-be.p8.c: New test file.
+
+	Backport from trunk
+	2018-06-08  Carl Love  <cel@us.ibm.com>
+
+	* gcc.target/powerpc/vsx-vector-6-be.p7.c: Rename this file to
+	vsx-vector-6.p7.c.
+	* gcc.target/powerpc/vsx-vector-6-le.p9.c: Rename this file to
+	vsx-vector-6.p9.c.
+	* gcc.target/powerpc/vsx-vector-6-be.p8.c: Move instruction counts
+	for BE system that are different then for an LE system from this file
+	into vsx-vector-6-le.c using be target qualifier.  Remove this file.
+	* gcc.target/powerpc/vsx-vector-6-le.c: Add le qualifiers as needed for
+	the various instruction counts.  Rename file to vsx-vector-6.p8.c.
+
+	Backport from trunk
+	2019-02-06  Bill Seurer  <seurer@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/vsx-vector-6.p7.c: Update instruction
+	counts and target.
+	* gcc.target/powerpc/vsx-vector-6.p8.c: Update instruction
+	counts and target.
+	* gcc.target/powerpc/vsx-vector-6.p9.c: Update instruction
+	counts and target.
+
+2019-04-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/87352
+	* gfortran.dg/finalize_28.f90: Adjust count of __builtin_free.
+	* gfortran.dg/finalize_34.f90: New test.
+
+2019-04-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/87352
+	* gfortran.dg/finalize_28.f90: Adjust count of __builtin_free.
+	* gfortran.dg/finalize_34.f90: New test.
+
+2019-04-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-03-08  Martin Liska  <mliska@suse.cz>
+
+	PR target/86952
+	* gcc.target/i386/pr86952.c: New test.
+	* gcc.target/i386/indirect-thunk-7.c: Use jump tables to match
+	scanned pattern.
+	* gcc.target/i386/indirect-thunk-inline-7.c: Likewise.
+
+2019-04-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89904
+	* gfortran.dg/pr85797.f90: Adjust testcase.
+
+2019-04-10  Matthew Malcomson  <matthew.malcomson@arm.com>
+
+	PR target/90024
+	* gcc.dg/torture/neon-immediate-timode.c: New test.
+
+2019-04-07  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR target/89945
+	* gcc.target/i386/pr89945.c: New test.
+
+2019-04-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt73.adb: New test.
+
+2019-04-02  Xiong Hu Luo <luoxhu@linux.ibm.com>
+
+	Backport from trunk r250477.
+
+	2017-07-24  Carl Love  <cel@us.ibm.com>
+
+	* gcc.target/powerpc/builtins-3-p9-runnable.c: Add new test file for
+	the new built-ins.
+
+	Backport from trunk r255555.
+
+	2017-12-11  Carl Love  <cel@us.ibm.com>
+	* gcc.target/powerpc/altivec-7.c: Renamed altivec-7.h.
+	* gcc.target/powerpc/altivec-7.h (main): Add testcases for vec_unpackl.
+	Add dg-final tests for the instructions generated.
+	* gcc.target/powerpc/altivec-7-be.c: New file to test on big endian.
+	* gcc.target/powerpc/altivec-7-le.c: New file to test on little endian.
+	* gcc.target/powerpc/altivec-13.c (foo): Add vec_sld, vec_srl,
+	 vec_sro testcases. Add dg-final tests for the instructions generated.
+	* gcc.target/powerpc/builtins-3-p8.c (test_vsi_packs_vui,
+	test_vsi_packs_vsi, test_vsi_packs_vssi, test_vsi_packs_vusi,
+	test_vsi_packsu-vssi, test_vsi_packsu-vusi, test_vsi_packsu-vsll,
+	test_vsi_packsu-vull, test_vsi_packsu-vsi, test_vsi_packsu-vui): Add
+	testcases. Add dg-final tests for new instructions.
+	* gcc.target/powerpc/p8vector-builtin-2.c (vbschar_eq, vbchar_eq,
+	vuchar_eq, vbint_eq, vsint_eq, viint_eq, vuint_eq, vbool_eq, vbint_ne,
+	vsint_ne, vuint_ne, vbool_ne, vsign_ne, vuns_ne, vbshort_ne): Add
+	tests.
+	Add dg-final instruction tests.
+	* gcc.target/powerpc/vsx-vector-6.c: Renamed vsx-vector-6.h.
+	* gcc.target/powerpc/vsx-vector-6.h (vec_andc,vec_nmsub, vec_nmadd,
+	vec_or, vec_nor, vec_andc, vec_or, vec_andc, vec_msums): Add tests.
+	Add dg-final tests for the generated instructions.
+	* gcc.target/powerpc/builtins-3.c (test_sll_vsc_vsc_vsuc,
+	test_sll_vuc_vuc, test_sll_vsi_vsi_vuc, test_sll_vui_vui_vuc,
+	test_sll_vbll_vull, test_sll_vbll_vbll_vus, test_sll_vp_vp_vuc,
+	test_sll_vssi_vssi_vuc, test_sll_vusi_vusi_vuc, test_slo_vsc_vsc_vsc,
+	test_slo_vuc_vuc_vsc, test_slo_vsi_vsi_vsc, test_slo_vsi_vsi_vuc,
+	test_slo_vui_vui_vsc, test_slo_vui_vui_vuc, test_slo_vsll_slo_vsll_vsc,
+	test_slo_vsll_slo_vsll_vuc, test_slo_vull_slo_vull_vsc,
+	test_slo_vull_slo_vull_vuc, test_slo_vp_vp_vsc, test_slo_vp_vp_vuc,
+	test_slo_vssi_vssi_vsc, test_slo_vssi_vssi_vuc, test_slo_vusi_vusi_vsc,
+	test_slo_vusi_vusi_vuc, test_slo_vusi_vusi_vuc, test_slo_vf_vf_vsc,
+	test_slo_vf_vf_vuc, test_cmpb_float): Add tests.
+
+	Backport from trunk r257253.
+
+	2018-01-31  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	* gcc.target/powerpc/altivec-13.c: Remove VSX-requiring built-ins.
+	* gcc.target/powerpc/vsx-13.c: New.
+
+	Backport from trunk r258137.
+
+	2018-03-02  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	* gcc.target/powerpc/altivec-7-be.c: Remove VSX content, allow
+	32-bit target.
+	* gcc.target/powerpc/altivec-7.h: Remove VSX content.
+	* gcc.target/powerpc/vsx-7-be.c: New test (VSX content).
+	* gcc.target/powerpc/vsx-7.h: New include (VSX content).
+	* gcc.target/powerpc/altivec-7-le.c: Add vsx-7.h include.
+
+2019-03-31  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/83515
+	PR fortran/85797
+	* gfortran.dg/pr85797.f90: New test.
+
+2019-02-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-02-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89253
+	* gfortran.dg/pr89253.f: New testcase.
+
+	2019-02-08  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89223
+	* gcc.dg/torture/pr89223.c: New testcase.
+
+	2019-01-28  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/88739
+	* gcc.c-torture/execute/pr88739.c: New test.
+
+2019-03-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-01-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/86554
+	* gcc.dg/torture/pr86554-1.c: New testcase.
+	* gcc.dg/torture/pr86554-2.c: Likewise.
+
+	2018-11-20  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/88105
+	* gcc.dg/gomp/pr88105.c: New testcase.
+
+	2018-03-08  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/84552
+	* gcc.dg/graphite/pr84552.c: New testcase.
+
+2019-03-25  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/71861
+	Backport from trunk
+	* gfortran.dg/interface_abstract_5.f90: New test case.
+
+2019-03-21  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR fortran/56408
+	* gcc.target/powerpc/ppc-fortran/ppc-fortran.exp
+	(dg-compile-aux-modules): Fix diagnostic.
+	* gfortran.dg/coarray/caf.exp (dg-compile-aux-modules): Likewise.
+	* gfortran.dg/dg.exp (dg-compile-aux-modules): Likewise.
+
+	PR fortran/56408
+	* gfortran.dg/coarray/caf.exp (dg-compile-aux-modules): Workaround
+	missing nexted dg-test call support in dejaGNU 1.4.4.
+
+	PR fortran/29383
+	* gfortran.dg/ieee/ieee.exp (DEFAULT_FFLAGS): Set the same as in
+	other '*.exp' files.
+
+2019-03-21  Matthias Klose  <doko@ubuntu.com>
+
+	Backport from mainline
+	2019-02-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89505
+	* gcc.dg/torture/pr89505.c: New testcase.
+
+2019-03-17  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/84394
+	Backport from trunk
+	* gfortran.dg/blockdata_11.f90: New test.
+
+2019-03-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2019-03-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/89523
+	* gcc.target/i386/pr89523-1a.c: New test.
+	* gcc.target/i386/pr89523-1b.c: Likewise.
+	* gcc.target/i386/pr89523-2.c: Likewise.
+	* gcc.target/i386/pr89523-3.c: Likewise.
+	* gcc.target/i386/pr89523-4.c: Likewise.
+	* gcc.target/i386/pr89523-5.c: Likewise.
+	* gcc.target/i386/pr89523-6.c: Likewise.
+	* gcc.target/i386/pr89523-7.c: Likewise.
+	* gcc.target/i386/pr89523-8.c: Likewise.
+	* gcc.target/i386/pr89523-9.c: Likewise.
+
+2019-03-16  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/66089
+	Backport from trunk
+	* gfortran.dg/dependency_53.f90: New test.
+	* gfortran.dg/assumed_type_2.f90: Adapted tree dumps.
+	* gfortran.dg/no_arg_check_2.f90: Likewise.
+
+2019-03-16 Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/66695
+	PR fortran/77746
+	PR fortran/79485
+	Backport from trunk
+	* gfortran.dg/binding_label_tests_30.f90: New test.
+	* gfortran.dg/binding_label_tests_31.f90: New test.
+	* gfortran.dg/binding_label_tests_32.f90: New test.
+	* gfortran.dg/binding_label_tests_33.f90: New test.
+
+2019-03-14  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-03-07  Martin Jambor  <mjambor@suse.cz>
+
+	PR lto/87525
+	* gcc.dg/ipa/ipcp-5.c: New test.
+
+2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-02-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84272
+	* g++.dg/opt/pr84272.C: New test.
+
+2019-03-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87673
+	Backport from trunk
+	* gfortran.dg/charlen_17.f90: New test.
+
+2019-03-13  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2019-03-08  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* gcc.target/arm/f16_f64_conv_no_dp.c: New test.
+
+	Backport from mainline
+	2019-03-11  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	* gcc.target/arm/f16_f64_conv_no_dp.c: Add arm_fp16_ok effective
+	target.
+
+2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71544
+	Backport from trunk
+	* gfortran.dg/c_ptr_tests_19.f90: New test.
+
+2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87734
+	Backport from trunk
+	* gfortran.dg/public_private_module_10.f90: New test.
+
+2019-04-10  Matthias Klose  <doko@ubuntu.com>
+
+	Backport from the gcc-8 branch
+	2019-03-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89585
+	* g++.dg/asm-qual-3.C: Adjust expected diagnostics.
+
+2019-03-07  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	Backport of r268834 from mainline to gcc-7-branch.
+	2019-01-23  Xiong Hu Luo  <luoxhu@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/crypto-builtin-1.c
+	(crypto1_be, crypto2_be, crypto3_be, crypto4_be, crypto5_be):
+	New testcases.
+
+2019-03-06  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/72714
+	Backport from trunk
+	* gfortran.dg/coarray_allocate_11.f90: New test.
+
+2019-03-03  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/77583
+	* gfortran.dg/pr77583.f90: New test.
+
+2019-03-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87689
+	Backport from trunk
+	* gfortran.dg/lto/20091028-1_0.f90: Add -Wno-lto-type-mismatch to
+	options.
+	* gfortran.dg/lto/20091028-2_0.f90: Likewise.
+	* gfortran.dg/lto/pr87689_0.f: New file.
+	* gfortran.dg/lto/pr87689_1.f: New file.
+	* gfortran.dg/altreturn_9_0.f90: New file.
+	* gfortran.dg/altreturn_9_1.f90: New file.
+
+2019-02-23  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/88117
+	* gfortran.dg/deferred_character_32.f90 : New test
+
+2019-02-23  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71066
+	Backport from trunk
+	* gfortran.dg/coarray_data_1.f90: New test.
+
+2019-02-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-14  Martin Liska  <mliska@suse.cz>
+
+	PR rtl-optimization/89242
+	* g++.dg/pr89242.C: New test.
+
+2019-02-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-11  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/89009
+	* g++.dg/ipa/pr89009.C: New test.
+
+2019-02-15  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/sparc/struct-ret-check-1.c: Add -fno-pie option.
+
+2019-02-11  Stefan Agner  <stefan@agner.ch>
+
+	Backport from mainline
+	2019-01-10  Stefan Agner  <stefan@agner.ch>
+
+	PR target/88648
+	* gcc.target/arm/pr88648-asm-syntax-unified.c: Add test to
+	check if -masm-syntax-unified gets applied properly.
+
+2019-02-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89077
+	* gfortran.dg/pr89077.f90: New test.
+
+2019-02-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71723
+	Backport from trunk
+	* gfortran.dg/pointer_init_2.f90: Adjust error messages.
+	* gfortran.dg/pointer_init_6.f90: Likewise.
+	* gfortran.dg/pointer_init_9.f90: New test.
+
+2019-02-09  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71860
+	Backport from trunk
+	* gfortran.dg/null_10.f90: New test.
+
+2019-02-06  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	2019-02-05  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+	* gcc.target/powerpc/vec-extract-slong-1.c: Require p8 execution
+	hardware.
+	* gcc.target/powerpc/vec-extract-schar-1.c: Likewise.
+	* gcc.target/powerpc/vec-extract-sint128-1.c: Likewise.
+	* gcc.target/powerpc/vec-extract-sshort-1.c: Likewise.
+	* gcc.target/powerpc/vec-extract-ulong-1.c: Likewise.
+	* gcc.target/powerpc/vec-extract-uchar-1.c: Likewise.
+	* gcc.target/powerpc/vec-extract-sint-1.c: Likewise.
+	* gcc.target/powerpc/vec-extract-uint128-1.c: Likewise.
+	* gcc.target/powerpc/vec-extract-ushort-1.c: Likewise.
+	* gcc.target/powerpc/vec-extract-uint-1.c: Likewise.
+
+	Backport from mainline.
+	2019-01-30  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+	* gcc.target/powerpc/vec-extract-schar-1.c: New test.
+	* gcc.target/powerpc/vec-extract-sint-1.c: New test.
+	* gcc.target/powerpc/vec-extract-sint128-1.c: New test.
+	* gcc.target/powerpc/vec-extract-slong-1.c: New test.
+	* gcc.target/powerpc/vec-extract-sshort-1.c: New test.
+	* gcc.target/powerpc/vec-extract-uchar-1.c: New test.
+	* gcc.target/powerpc/vec-extract-uint-1.c: New test.
+	* gcc.target/powerpc/vec-extract-uint128-1.c: New test.
+	* gcc.target/powerpc/vec-extract-ulong-1.c: New test.
+	* gcc.target/powerpc/vec-extract-ushort-1.c: New test.
+
+2019-02-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt76.adb: New test.
+
+2019-02-05  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/67679
+	Backport from trunk
+	* gfortran.dg/warn_undefined_1.f90: New test.
+	* gfortran.dg/coarray_lock_7.f90: Fix patterns in test.
+
+2019-02-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/88393
+	* gfortran.dg/alloc_comp_assign_16.f03 : New test.
+
+2019-02-02  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/88298
+	Backport from trunk
+	* gfortran.dg/warn_conversion_10.f90: New test.
+
+2019-02-02  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/57048
+	Backport from trunk
+	* gfortran.dg/c_funptr_1.f90: New file.
+	* gfortran.dg/c_funptr_1_mod.f90: New file.
+
+2019-01-30  Manfred Schwarb  <manfred99@gmx.ch>
+
+	* gfortran.dg/pr68318_1.f90: Fix a dg directive.
+
+2019-01-30  Kewen Lin  <linkw@gcc.gnu.org>
+
+	Backport from mainline
+	2019-01-20  Kewen Lin  <linkw@gcc.gnu.org>
+
+	* gcc.target/powerpc/altivec_vld_vst_addr.c: Remove, split into
+	altivec_vld_vst_addr-1.c and altivec_vld_vst_addr-2.c.
+	* gcc.target/powerpc/altivec_vld_vst_addr-1.c: New test.
+	* gcc.target/powerpc/altivec_vld_vst_addr-2.c: Ditto.
+
+	2019-01-17  Kewen Lin  <linkw@gcc.gnu.org>
+
+	* gcc.target/powerpc/altivec_vld_vst_addr.c: New test.
+
+2019-01-27  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR fortran/70696
+	* gfortran.dg/coarray/event_3.f0: Add save attribue to x.
+
+2019-01-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/56386
+	PR fortran/58906
+	PR fortran/77385
+	* gfortran.dg/associate_44.f90 : New test.
+
+	PR fortran/80260
+	* gfortran.dg/select_type_45.f90 : New test.
+
+	PR fortran/82077
+	* gfortran.dg/select_type_46.f90 : New test.
+
+2019-01-27  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt75.adb: New test.
+	* gnat.dg/opt75_pkg.ad[sb]: New helper.
+
+2019-01-27  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR target/88948
+	* gcc.target/i386/pr88948.c: New test.
+
+2019-01-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/array34.adb: New test.
+
+2019-01-26  Dominique d'Humieres  <dominiq@gcc.gnu.org>
+
+	PR fortran/85579
+	* gfortran.dg/pr51434.f90: Fix the TRANSFER argument.
+
+2019-01-26  Manfred Schwarb  <manfred99@gmx.ch>
+
+	* gfortran.dg/array_function_5.f90
+	* gfortran.dg/class_66.f90
+	* gfortran.dg/dec_structure_12.f90
+	* gfortran.dg/dec_structure_14.f90
+	* gfortran.dg/dec_structure_15.f90
+	* gfortran.dg/extends_11.f03
+	* gfortran.dg/pr58968.f
+	* gfortran.dg/pr78259.f90
+	* gfortran.dg/debug/pr35154-stabs.f
+
+2019-01-24  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR target/88998
+	* g++.dg/pr88998.c: New test.
+
+2019-01-24  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-01-23  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89008
+	* gcc.dg/torture/pr89008.c: New testcase.
+
+2019-01-22  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR target/88938
+	* gcc.target/i386/pr88938.c: New test.
+
+2019-01-16  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from mainline
+	2019-01-07  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/88720
+	PR c/88726
+	* gcc.dg/inline-40.c, gcc.dg/inline-41.c: New tests.
+
+2019-01-16  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from mainline
+	2018-12-10  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/88214
+	* gcc.dg/ipa/pr88214.c: New test.
+
+2019-01-15  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/81849
+	* gfortran.dg/pr81849.f90: New test.
+
+2019-01-13  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/88776
+	* gfortran.dg/namelist_96.f90: New test.
+
+2019-01-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/35031
+	* gfortran.dg/pr35031.f90: new test.
+
+2019-01-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/sparc/tls-ld-int8.c: New test.
+	* gcc.target/sparc/tls-ld-int16.c: Likewise.
+	* gcc.target/sparc/tls-ld-int32.c: Likewise.
+	* gcc.target/sparc/tls-ld-uint8.c: Likewise.
+	* gcc.target/sparc/tls-ld-uint16.c: Likewise.
+	* gcc.target/sparc/tls-ld-uint32.c: Likewise.
+
+2019-01-05  Dominique d'Humieres  <dominiq@gcc.gnu.org>
+
+	PR target/60563
+	* g++.dg/ext/sync-4.C: Add dg-xfail-run-if for darwin.
+
+2018-01-02  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR inline-asm/55681
+	* gcc.dg/asm-qual-1.c: Test that "const" and "restrict" are refused.
+	* gcc.dg/asm-qual-2.c: New test, test that asm-qualifiers are allowed
+	in any order, but that duplicates are not allowed.
+
+	Backport from trunk
+	2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* c-c++-common/torture/asm-inline.c: New testcase.
+	* gcc.dg/asm-qual-2.c: Test asm inline, too.
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* g++.dg/asm-qual-1.C: New testcase.
+	* g++.dg/asm-qual-2.C: New testcase.
+	* gcc.dg/asm-qual-1.c: Update.
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* g++.dg/asm-qual-3.C: New testcase.
+	* gcc.dg/asm-qual-3.c: New testcase.
+
+	And extra for the backport
+	2019-01-02  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* gcc.dg/asm-qual-1.c: Adjust.
+
+2018-12-30  Dominique d'Humieres  <dominiq@gcc.gnu.org>
+
+	PR tree-optimization/68356
+	PR target/81210
+	* gcc.dg/torture/pr68264.c: Skip on darwin.
+	* gcc.dg/torture/pr68037-1.c: Likewise.
+	* gcc.dg/torture/pr68037-2.c: Likewise.
+	* gcc.dg/torture/pr68037-3.c: Likewise.
+
+2018-12-29  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/82550
+	* gfortran.dg/submodule_30.f08 : New test.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR testsuite/67974
+	* gcc.target/x86_64/abi/avx/asm-support-darwin.s: New.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-08-16  Iain Sandoe <iain@sandoe.co.uk>
+
+	* g++.dg/torture/pr44295.C : Skip for Darwin.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-08-22  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.dg/lto/pr85248_0.c (test_alias):
+	Stringify __USER_LABEL_PREFIX__.
+	(test_noreturn): Likewise.
+
+	2018-08-16  Iain Sandoe <iain@sandoe.co.uk>
+
+	* gcc.dg/memcmp-1.c (lib_memcmp): Apply __USER_LABEL_PREFIX__.
+	(lib_strncmp): Likewise.
+
+	2018-08-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.dg/asan/pr81923.c: Stringify __USER_LABEL_PREFIX__.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-08-16  Iain Sandoe <iain@sandoe.co.uk>
+
+	PR testsuite/78544
+	* gcc.dg/tree-prof/section-attr-1.c: Add Darwin-specific section
+	attributes and matching.
+	* gcc.dg/tree-prof/section-attr-2.c: Likewise.
+	* gcc.dg/tree-prof/section-attr-3.c: Likewise.
+
+2018-12-23  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/77703
+	* gfortran.dg/ptr_func_assign_5.f08 : New test.
+
+2018-12-22  Steven G . Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85798
+	* gfortran.dg/pr85798.f90: New test.
+
+2018-12-22  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/85544
+	* gfortran.dg/power_7.f90: New test.
+
+2018-12-21  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88169
+	* gfortran.dg/pr88169_1.f90: new test.
+	* gfortran.dg/pr88169_2.f90: Ditto.
+	* gfortran.dg/pr88169_3.f90: Ditto.
+
+2018-12-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2018-12-10  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/88418
+	* gcc.target/i386/pr88418.c: New test.
+
+2018-12-17  Senthil Kumar Selvaraj  <senthilkumar.selvaraj@microchip.com>
+
+	Backport from trunk
+	2018-12-17  Senthil Kumar Selvaraj  <senthilkumar.selvaraj@microchip.com>
+
+	PR rtl-optimization/88253
+	* gcc.target/avr/pr88253.c: New test.
+
+2018-12-15  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88138
+	* gfortran.dg/pr88138.f90: new test.
+
+2018-12-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2018-12-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* gcc.target/s390/zvector/vec-double-1.c: New test.
+	* gcc.target/s390/zvector/vec-double-2.c: New test.
+
+2018-12-12  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backport from mainline
+	2018-12-07  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/87496
+	* gcc.target/powerpc/pr87496-1.c: New test.
+	* gcc.target/powerpc/pr87496-2.c: New test.
+	* gcc.target/powerpc/pr87496-3.c: New test.
+
+2018-12-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88155
+	* gfortran.dg/pr70870_1.f90: Update testcase to use -std=gnu.
+	* gfortran.dg/pr88155.f90: New test.
+
+2018-12-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88249
+	* gfortran.dg/pr88249.f90: New test.
+
+2018-12-10  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88269
+	* gfortran.dg/pr88269.f90: New test.
+
+2018-12-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88205
+	* gfortran.dg/pr88205.f90: New unit.
+
+2018-12-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88206
+	* gfortran.dg/pr88206.f90: New test.
+
+2018-12-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88228
+	* gfortran.dg/pr88228.f90: New test.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: gcc/testsuite/objc-obj-c++-shared/F-NSObject.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/F-NSObject.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/F-NSObject.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,33 @@
+/* Copyright (C) 2019 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef _OBJC_F_NSOBJECT_H_
+#define _OBJC_F_NSOBJECT_H_
+
+/* This is a workaround to PR90709 for the NeXT runtime.
+   If we're on a system version that has headers with items we can't
+   consume, then use the GNUStep header instead.
+*/
+
+#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1090
+#  import "GNUStep/Foundation/NSObject.h"
+#else 
+#  import <Foundation/NSObject.h>
+#endif
+
+#endif /* _OBJC_F_NSOBJECT_H_ */
Index: gcc/testsuite/objc-obj-c++-shared/F-NSString.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/F-NSString.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/F-NSString.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,33 @@
+/* Copyright (C) 2019 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef _OBJC_F_NSSTRING_H_
+#define _OBJC_F_NSSTRING_H_
+
+/* This is a workaround to PR90709 for the NeXT runtime.
+   If we're on a system version that has headers with items we can't
+   consume, then use the GNUStep header instead.
+*/
+
+#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1090
+#  import "GNUStep/Foundation/NSString.h"
+#else 
+#  import <Foundation/NSString.h>
+#endif
+
+#endif /* _OBJC_F_NSSTRING_H_ */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFDictionary.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFDictionary.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFDictionary.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,174 @@
+/* CFDictionary.h
+
+   Copyright (C) 2010 Free Software Foundation, Inc.
+
+   Written by: Stefan Bidigaray
+   Date: January, 2010
+
+   This file is part of the GNUstep CoreBase Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; see the file COPYING.LIB.
+   If not, see <http://www.gnu.org/licenses/> or write to the 
+   Free Software Foundation, 51 Franklin Street, Fifth Floor, 
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef __COREFOUNDATION_CFDICTIONARY_H__
+#define __COREFOUNDATION_CFDICTIONARY_H__ 1
+
+#include "CFBase.h"
+
+CF_EXTERN_C_BEGIN
+/** \ingroup CFDictionaryRef */
+typedef const struct __CFDictionary *CFDictionaryRef;
+/** \ingroup CFMutableDictionaryRef */
+typedef struct __CFDictionary *CFMutableDictionaryRef;
+
+/** \defgroup CFDictionaryRef CFDictionary Reference
+    \{
+ */
+typedef void (*CFDictionaryApplierFunction) (const void *key,
+                                             const void *value, void *context);
+
+typedef CFStringRef (*CFDictionaryCopyDescriptionCallBack) (const void *value);
+typedef Boolean (*CFDictionaryEqualCallBack) (const void *value1,
+                                              const void *value2);
+typedef CFHashCode (*CFDictionaryHashCallBack) (const void *value);
+typedef void (*CFDictionaryReleaseCallBack) (CFAllocatorRef allocator,
+                                             const void *value);
+typedef const void *(*CFDictionaryRetainCallBack) (CFAllocatorRef allocator,
+                                                   const void *value);
+
+typedef struct _CFDictionaryKeyCallBacks CFDictionaryKeyCallBacks;
+struct _CFDictionaryKeyCallBacks
+{
+  CFIndex version;
+  CFDictionaryRetainCallBack retain;
+  CFDictionaryReleaseCallBack release;
+  CFDictionaryCopyDescriptionCallBack copyDescription;
+  CFDictionaryEqualCallBack equal;
+  CFDictionaryHashCallBack hash;
+};
+
+typedef struct _CFDictionaryValueCallBacks CFDictionaryValueCallBacks;
+struct _CFDictionaryValueCallBacks
+{
+  CFIndex version;
+  CFDictionaryRetainCallBack retain;
+  CFDictionaryReleaseCallBack release;
+  CFDictionaryCopyDescriptionCallBack copyDescription;
+  CFDictionaryEqualCallBack equal;
+};
+
+CF_EXPORT const CFDictionaryKeyCallBacks kCFCopyStringDictionaryKeyCallBacks;
+CF_EXPORT const CFDictionaryKeyCallBacks kCFTypeDictionaryKeyCallBacks;
+CF_EXPORT const CFDictionaryValueCallBacks kCFTypeDictionaryValueCallBacks;
+
+/** \name Creating a dictionary
+    \{
+ */
+CF_EXPORT CFDictionaryRef
+CFDictionaryCreate (CFAllocatorRef allocator, const void **keys,
+                    const void **values, CFIndex numValues,
+                    const CFDictionaryKeyCallBacks * keyCallBacks,
+                    const CFDictionaryValueCallBacks * valueCallBacks);
+
+CF_EXPORT CFDictionaryRef
+CFDictionaryCreateCopy (CFAllocatorRef allocator, CFDictionaryRef theDict);
+/** \} */
+
+/** \name Examining a dictionary
+    \{
+ */
+CF_EXPORT Boolean
+CFDictionaryContainsKey (CFDictionaryRef theDict, const void *key);
+
+CF_EXPORT Boolean
+CFDictionaryContainsValue (CFDictionaryRef theDict, const void *value);
+
+CF_EXPORT CFIndex CFDictionaryGetCount (CFDictionaryRef theDict);
+
+CF_EXPORT CFIndex
+CFDictionaryGetCountOfKey (CFDictionaryRef theDict, const void *key);
+
+CF_EXPORT CFIndex
+CFDictionaryGetCountOfValue (CFDictionaryRef theDict, const void *value);
+
+CF_EXPORT void
+CFDictionaryGetKeysAndValues (CFDictionaryRef theDict, const void **keys,
+                              const void **values);
+
+CF_EXPORT const void *CFDictionaryGetValue (CFDictionaryRef theDict,
+                                            const void *key);
+
+CF_EXPORT Boolean
+CFDictionaryGetValueIfPresent (CFDictionaryRef theDict, const void *key,
+                               const void **value);
+/** \} */
+
+/** \name Applying a funcation to a dictionary
+    \{
+ */
+CF_EXPORT void
+CFDictionaryApplyFunction (CFDictionaryRef theDict,
+                           CFDictionaryApplierFunction applier, void *context);
+/** \} */
+
+/** \name Getting the CFDictionary type ID
+    \{
+ */
+CF_EXPORT CFTypeID CFDictionaryGetTypeID (void);
+/** \} */
+/** \} */
+
+/** \defgroup CFMutableDictionaryRef CFMutableDictionary Reference
+    \{
+ */
+/** \name Creating a Mutable Dictionary
+    \{
+ */
+CF_EXPORT CFMutableDictionaryRef
+CFDictionaryCreateMutable (CFAllocatorRef allocator, CFIndex capacity,
+                           const CFDictionaryKeyCallBacks * keyCallBacks,
+                           const CFDictionaryValueCallBacks * valueCallBacks);
+
+CF_EXPORT CFMutableDictionaryRef
+CFDictionaryCreateMutableCopy (CFAllocatorRef allocator, CFIndex capacity,
+                               CFDictionaryRef theDict);
+/** \} */
+
+/** \name Modifying a Dictionary
+    \{
+ */
+CF_EXPORT void
+CFDictionaryAddValue (CFMutableDictionaryRef theDict, const void *key,
+                      const void *value);
+
+CF_EXPORT void CFDictionaryRemoveAllValues (CFMutableDictionaryRef theDict);
+
+CF_EXPORT void
+CFDictionaryRemoveValue (CFMutableDictionaryRef theDict, const void *key);
+
+CF_EXPORT void
+CFDictionaryReplaceValue (CFMutableDictionaryRef theDict, const void *key,
+                          const void *value);
+
+CF_EXPORT void
+CFDictionarySetValue (CFMutableDictionaryRef theDict, const void *key,
+                      const void *value);
+/** \} */
+/** \} */
+
+CF_EXTERN_C_END
+#endif /* __COREFOUNDATION_CFDICTIONARY_H__ */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFString.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFString.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFString.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,593 @@
+/* CFString.h
+   
+   Copyright (C) 2010 Free Software Foundation, Inc.
+   
+   Written by: Stefan Bidigaray
+   Date: January, 2010
+   
+   This file is part of CoreBase.
+   
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.         See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; see the file COPYING.LIB.
+   If not, see <http://www.gnu.org/licenses/> or write to the 
+   Free Software Foundation, 51 Franklin Street, Fifth Floor, 
+   Boston, MA 02110-1301, USA.
+*/ 
+
+#ifndef __COREFOUNDATION_CFSTRING_H__
+#define __COREFOUNDATION_CFSTRING_H__
+
+#include "CFBase.h"
+#include "CFArray.h"
+#include "CFCharacterSet.h"
+#include "CFData.h"
+#include "CFDictionary.h"
+#include "CFLocale.h"
+
+#include <stdarg.h>
+
+CF_EXTERN_C_BEGIN
+
+/** \defgroup CFStringRef CFString Reference
+    \brief The CFString type defines opaque objects representing strings.
+
+    CFString is "toll-free bridged" to NSString.
+
+    \{
+ */
+
+/*
+ * Data Types
+ */
+typedef UInt32 CFStringEncoding;
+
+/*
+ * Constants
+ */
+typedef enum
+{
+  kCFCompareCaseInsensitive = 1,
+  kCFCompareBackwards = 4,
+  kCFCompareAnchored = 8,
+  kCFCompareNonliteral = 16,
+  kCFCompareLocalized = 32,
+  kCFCompareNumerically = 64,
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+  kCFCompareDiacriticInsensitive = 128,
+  kCFCompareWidthInsensitive = 256,
+  kCFCompareForcedOrdering = 512
+#endif
+} CFStringCompareFlags;
+
+enum CFStringBuiltInEncodings
+{
+  kCFStringEncodingMacRoman = 0,
+  kCFStringEncodingWindowsLatin1 = 0x0500,
+  kCFStringEncodingISOLatin1 = 0x0201,
+  kCFStringEncodingNextStepLatin = 0x0B01,
+  kCFStringEncodingASCII = 0x0600,
+  kCFStringEncodingUnicode = 0x0100,
+  kCFStringEncodingUTF8 = 0x08000100,
+  kCFStringEncodingNonLossyASCII = 0x0BFF,
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+  kCFStringEncodingUTF16 = 0x0100,
+  kCFStringEncodingUTF16BE = 0x10000100,
+  kCFStringEncodingUTF16LE = 0x14000100,
+  kCFStringEncodingUTF32 = 0x0c000100,
+  kCFStringEncodingUTF32BE = 0x18000100,
+  kCFStringEncodingUTF32LE = 0x1c000100
+#endif
+};
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2, GS_API_LATEST)
+# define kCFStringEncodingInvalidId (0xffffffffU)
+#endif
+
+/** \def CFSTR(x)
+    \brief Creates a constant string object.
+    
+    \note This macro will create the constant string at runtime.
+ */
+/* The 'pure' attribute tells the compiler that this function will always
+   return the same result with the same input.  If it has any skill, then
+   constant propagation passes will magically make sure that this function is
+   called as few times as possible. */
+CF_EXPORT CFStringRef
+__CFStringMakeConstantString (const char *str) GS_PURE_FUNCTION;
+//#define CFSTR(x) __CFStringMakeConstantString("" x "")
+
+#ifdef __CONSTANT_CFSTRINGS__
+#define CFSTR(x)  ((CFStringRef) __builtin___CFStringMakeConstantString ("" x ""))
+#else
+#define CFSTR(x)  __CFStringMakeConstantString("" x "")
+#endif
+
+/** \name Creating a CFString
+    \{
+ */
+CF_EXPORT CFArrayRef
+CFStringCreateArrayBySeparatingStrings (CFAllocatorRef alloc,
+  CFStringRef theString, CFStringRef separatorString);
+
+CF_EXPORT CFStringRef
+CFStringCreateByCombiningStrings (CFAllocatorRef alloc, CFArrayRef theArray,
+  CFStringRef separatorString);
+
+CF_EXPORT CFStringRef
+CFStringCreateCopy (CFAllocatorRef alloc, CFStringRef theString);
+
+CF_EXPORT CFStringRef
+CFStringCreateFromExternalRepresentation (CFAllocatorRef alloc, CFDataRef data,
+  CFStringEncoding encoding);
+
+CF_EXPORT CFStringRef
+CFStringCreateWithBytes (CFAllocatorRef alloc, const UInt8 *bytes,
+  CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation);
+
+CF_EXPORT CFStringRef
+CFStringCreateWithCharacters (CFAllocatorRef alloc, const UniChar *chars,
+  CFIndex numChars);
+
+CF_EXPORT CFStringRef
+CFStringCreateWithCharactersNoCopy (CFAllocatorRef alloc, const UniChar *chars,
+  CFIndex numChars, CFAllocatorRef contentsDeallocator);
+
+CF_EXPORT CFStringRef
+CFStringCreateWithCString (CFAllocatorRef alloc, const char *cStr,
+  CFStringEncoding encoding);
+
+CF_EXPORT CFStringRef
+CFStringCreateWithCStringNoCopy (CFAllocatorRef alloc, const char *cStr,
+  CFStringEncoding encoding, CFAllocatorRef contentsDeallocator);
+
+CF_EXPORT CFStringRef
+CFStringCreateWithFormat (CFAllocatorRef alloc, CFDictionaryRef formatOptions,
+  CFStringRef format, ...);
+
+CF_EXPORT CFStringRef
+CFStringCreateWithFormatAndArguments (CFAllocatorRef alloc,
+  CFDictionaryRef formatOptions, CFStringRef format, va_list arguments);
+
+CF_EXPORT CFStringRef
+CFStringCreateWithSubstring (CFAllocatorRef alloc, CFStringRef str,
+  CFRange range);
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+CF_EXPORT CFStringRef
+CFStringCreateWithFileSystemRepresentation (CFAllocatorRef alloc,
+  const char *buffer);
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+CF_EXPORT CFStringRef
+CFStringCreateWithBytesNoCopy (CFAllocatorRef alloc, const UInt8 *bytes,
+  CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalReprentation,
+  CFAllocatorRef contentsDeallocator);
+#endif
+/** \} */
+
+/** \name Searching CFStrings
+    \{
+ */
+CF_EXPORT CFArrayRef
+CFStringCreateArrayWithFindResults (CFAllocatorRef alloc, CFStringRef theString,
+  CFStringRef stringToFind, CFRange rangeToSearch,
+  CFStringCompareFlags compareOptions);
+
+CF_EXPORT CFRange
+CFStringFind (CFStringRef theString, CFStringRef stringToFind,
+  CFStringCompareFlags compareOptions);
+
+CF_EXPORT Boolean
+CFStringFindWithOptions (CFStringRef theString, CFStringRef stringToFind,
+  CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result);
+
+CF_EXPORT Boolean
+CFStringFindWithOptionsAndLocale (CFStringRef theString,CFStringRef stringToFind,
+  CFRange rangeToSearch, CFStringCompareFlags searchOptions,
+  CFLocaleRef locale, CFRange *result);
+
+CF_EXPORT void
+CFStringGetLineBounds (CFStringRef theString, CFRange range,
+  CFIndex *lineBeginIndex, CFIndex *lineEndIndex, CFIndex *contentsEndIndex);
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2, GS_API_LATEST)
+CF_EXPORT Boolean
+CFStringFindCharacterFromSet (CFStringRef theString, CFCharacterSetRef theSet,
+  CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result);
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+CF_EXPORT void
+CFStringGetParagraphBounds (CFStringRef string, CFRange range,
+  CFIndex *parBeginIndex, CFIndex *parEndIndex, CFIndex *contentsEndIndex);
+#endif
+/** \} */
+
+/** \name Comparing String
+    \{
+ */
+CF_EXPORT CFComparisonResult
+CFStringCompare (CFStringRef theString1, CFStringRef theString2,
+  CFStringCompareFlags compareOptions);
+
+CF_EXPORT CFComparisonResult
+CFStringCompareWithOptions (CFStringRef theString1, CFStringRef theString2,
+  CFRange rangeToCOmpare, CFStringCompareFlags compareOptions);
+
+CF_EXPORT Boolean
+CFStringHasPrefix (CFStringRef theString, CFStringRef prefix);
+
+CF_EXPORT Boolean
+CFStringHasSuffix (CFStringRef theString, CFStringRef suffix);
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+CF_EXPORT CFComparisonResult
+CFStringCompareWithOptionsAndLocale (CFStringRef theString1,
+  CFStringRef theString2, CFRange rangeToCOmpare,
+  CFStringCompareFlags compareOptions, CFLocaleRef locale);
+#endif
+/** \} */
+
+/** \name Accessing Characters
+    \{
+ */
+CF_EXPORT CFDataRef
+CFStringCreateExternalRepresentation (CFAllocatorRef alloc,
+  CFStringRef theString, CFStringEncoding encoding, UInt8 lossByte);
+
+CF_EXPORT CFIndex
+CFStringGetBytes (CFStringRef theString, CFRange range,
+  CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation,
+  UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen);
+
+CF_EXPORT UniChar
+CFStringGetCharacterAtIndex (CFStringRef theString, CFIndex idx);
+
+CF_EXPORT void
+CFStringGetCharacters (CFStringRef theString, CFRange range, UniChar *buffer);
+
+CF_EXPORT const UniChar *
+CFStringGetCharactersPtr (CFStringRef theString);
+
+CF_EXPORT Boolean
+CFStringGetCString (CFStringRef theString, char *buffer, CFIndex bufferSize,
+  CFStringEncoding encoding);
+
+CF_EXPORT const char *
+CFStringGetCStringPtr (CFStringRef theString, CFStringEncoding encoding);
+
+CF_EXPORT CFIndex
+CFStringGetLength (CFStringRef str);
+
+CF_EXPORT CFRange
+CFStringGetRangeOfComposedCharactersAtIndex (CFStringRef theString,
+  CFIndex theIndex);
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
+CF_EXPORT UTF32Char
+CFStringGetLongCharacterForSurrogatePair (UniChar surrogateHigh,
+  UniChar surrogateLow);
+
+CF_EXPORT Boolean
+CFStringGetSurrogatePairForLongCharacter (UTF32Char character,
+  UniChar *surrogates);
+
+CF_EXPORT Boolean
+CFStringIsSurrogateHighCharacter (UniChar character);
+
+CF_EXPORT Boolean
+CFStringIsSurrogateLowCharacter (UniChar character);
+#endif
+/** \} */
+
+/** \name Working with Encodings
+    \{
+ */
+CF_EXPORT CFStringRef
+CFStringConvertEncodingToIANACharSetName (CFStringEncoding encoding);
+
+CF_EXPORT unsigned long
+CFStringConvertEncodingToNSStringEncoding (CFStringEncoding encoding);
+
+UInt32
+CFStringConvertEncodingToWindowsCodepage (CFStringEncoding encoding);
+
+CF_EXPORT CFStringEncoding
+CFStringConvertIANACharSetNameToEncoding (CFStringRef theString);
+
+CF_EXPORT CFStringEncoding
+CFStringConvertNSStringEncodingToEncoding (unsigned long encoding);
+
+CF_EXPORT CFStringEncoding
+CFStringConvertWindowsCodepageToEncoding (UInt32 codepage);
+
+CF_EXPORT CFStringEncoding
+CFStringGetFastestEncoding (CFStringRef theString);
+
+CF_EXPORT const CFStringEncoding *
+CFStringGetListOfAvailableEncodings (void);
+
+CF_EXPORT CFIndex
+CFStringGetMaximumSizeForEncoding (CFIndex length, CFStringEncoding encoding);
+
+CF_EXPORT CFStringEncoding
+CFStringGetMostCompatibleMacStringEncoding (CFStringEncoding encoding);
+
+CF_EXPORT CFStringRef
+CFStringGetNameOfEncoding (CFStringEncoding encoding);
+
+CF_EXPORT CFStringEncoding
+CFStringGetSmallestEncoding (CFStringRef theString);
+
+CF_EXPORT CFStringEncoding
+CFStringGetSystemEncoding (void);
+
+CF_EXPORT Boolean
+CFStringIsEncodingAvailable (CFStringEncoding encoding);
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+CF_EXPORT Boolean
+CFStringGetFileSystemRepresentation (CFStringRef string, char *buffer,
+  CFIndex maxBufLen);
+
+CF_EXPORT CFIndex
+CFStringGetMaximumSizeOfFileSystemRepresentation (CFStringRef string);
+#endif
+/** \} */
+
+/** \name Getting Numeric Values
+    \{
+ */
+CF_EXPORT double
+CFStringGetDoubleValue (CFStringRef str);
+
+CF_EXPORT SInt32
+CFStringGetIntValue (CFStringRef str);
+/** \} */
+
+/** \name Getting String Properties
+    \{
+ */
+CF_EXPORT void
+CFShow (CFTypeRef obj);
+
+CF_EXPORT void
+CFShowStr (CFStringRef str);
+
+CF_EXPORT CFTypeID
+CFStringGetTypeID (void);
+/** \} */
+
+
+
+/** \name Pascal Strings
+    \{
+ */
+CF_EXPORT CFStringRef
+CFStringCreateWithPascalString (CFAllocatorRef alloc, ConstStr255Param pStr,
+  CFStringEncoding encoding);
+
+CF_EXPORT CFStringRef
+CFStringCreateWithPascalStringNoCopy (CFAllocatorRef alloc,
+  ConstStr255Param pStr, CFStringEncoding encoding,
+  CFAllocatorRef contentsDeallocate);
+
+CF_EXPORT Boolean
+CFStringGetPascalString (CFStringRef theString, StringPtr buffer,
+  CFIndex bufferSize, CFStringEncoding encoding);
+
+CF_EXPORT ConstStringPtr
+CFStringGetPascalStringPtr (CFStringRef theString, CFStringEncoding encoding);
+/** \} */
+/** \} */
+
+
+
+/** \defgroup CFMutableStringRef CFMutableString Reference
+ *  \{
+ */
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2, GS_API_LATEST)
+typedef enum
+{
+  kCFStringNormalizationFormD = 0,
+  kCFStringNormalizationFormKD = 1,
+  kCFStringNormalizationFormC = 2,
+  kCFStringNormalizationFormKC = 3
+} CFStringNormalizationForm;
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+CF_EXPORT const CFStringRef kCFStringTransformStripCombiningMarks;
+CF_EXPORT const CFStringRef kCFStringTransformToLatin;
+CF_EXPORT const CFStringRef kCFStringTransformFullwidthHalfwidth;
+CF_EXPORT const CFStringRef kCFStringTransformLatinKatakana;
+CF_EXPORT const CFStringRef kCFStringTransformLatinHiragana;
+CF_EXPORT const CFStringRef kCFStringTransformHiraganaKatakana;
+CF_EXPORT const CFStringRef kCFStringTransformMandarinLatin;
+CF_EXPORT const CFStringRef kCFStringTransformLatinHangul;
+CF_EXPORT const CFStringRef kCFStringTransformLatinArabic;
+CF_EXPORT const CFStringRef kCFStringTransformLatinHebrew;
+CF_EXPORT const CFStringRef kCFStringTransformLatinThai;
+CF_EXPORT const CFStringRef kCFStringTransformLatinCyrillic;
+CF_EXPORT const CFStringRef kCFStringTransformLatinGreek;
+CF_EXPORT const CFStringRef kCFStringTransformToXMLHex;
+CF_EXPORT const CFStringRef kCFStringTransformToUnicodeName;
+#endif
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+CF_EXPORT const CFStringRef kCFStringTransformStripDiacritics;
+#endif
+
+CF_EXPORT void
+CFStringAppend (CFMutableStringRef theString, CFStringRef appendedString);
+
+CF_EXPORT void
+CFStringAppendCharacters (CFMutableStringRef theString,
+  const UniChar *chars, CFIndex numChars);
+
+CF_EXPORT void
+CFStringAppendCString (CFMutableStringRef theString, const char *cStr,
+  CFStringEncoding encoding);
+
+CF_EXPORT void
+CFStringAppendFormat (CFMutableStringRef theString,
+  CFDictionaryRef formatOptions, CFStringRef format, ...);
+
+CF_EXPORT void
+CFStringAppendFormatAndArguments (CFMutableStringRef theString,
+  CFDictionaryRef formatOptions, CFStringRef format, va_list arguments);
+
+CF_EXPORT void
+CFStringAppendPascalString (CFMutableStringRef theString,
+  ConstStr255Param pStr, CFStringEncoding encoding);
+
+CF_EXPORT void
+CFStringCapitalize (CFMutableStringRef theString, CFLocaleRef locale);
+
+CF_EXPORT CFMutableStringRef
+CFStringCreateMutable (CFAllocatorRef alloc, CFIndex maxLength);
+
+CF_EXPORT CFMutableStringRef
+CFStringCreateMutableCopy (CFAllocatorRef alloc, CFIndex maxLength,
+  CFStringRef theString);
+
+CF_EXPORT CFMutableStringRef
+CFStringCreateMutableWithExternalCharactersNoCopy (CFAllocatorRef alloc,
+  UniChar *chars, CFIndex numChars, CFIndex capacity,
+  CFAllocatorRef externalCharactersAllocator);
+
+CF_EXPORT void
+CFStringDelete (CFMutableStringRef theString, CFRange range);
+
+CF_EXPORT void
+CFStringInsert (CFMutableStringRef str, CFIndex idx, CFStringRef insertedStr);
+
+CF_EXPORT void
+CFStringLowercase (CFMutableStringRef theString, CFLocaleRef locale);
+
+CF_EXPORT void
+CFStringPad (CFMutableStringRef theString, CFStringRef padString,
+  CFIndex length, CFIndex indexIntoPad);
+
+CF_EXPORT void
+CFStringReplace (CFMutableStringRef theString, CFRange range,
+  CFStringRef replacement);
+
+CF_EXPORT void
+CFStringReplaceAll (CFMutableStringRef theString, CFStringRef replacement);
+
+CF_EXPORT void
+CFStringSetExternalCharactersNoCopy (CFMutableStringRef theString,
+  UniChar *chars, CFIndex length, CFIndex capacity);
+
+CF_EXPORT void
+CFStringTrim (CFMutableStringRef theString, CFStringRef trimString);
+
+CF_EXPORT void
+CFStringTrimWhitespace (CFMutableStringRef theString);
+
+CF_EXPORT void
+CFStringUppercase (CFMutableStringRef theString, CFLocaleRef locale);
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2, GS_API_LATEST)
+CF_EXPORT CFIndex
+CFStringFindAndReplace (CFMutableStringRef theString,
+  CFStringRef stringToFind, CFStringRef replacementString,
+  CFRange rangeToSearch, CFOptionFlags compareOptions);
+
+CF_EXPORT void
+CFStringNormalize (CFMutableStringRef theString,
+  CFStringNormalizationForm theForm);
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+CF_EXPORT Boolean
+CFStringTransform (CFMutableStringRef string, CFRange *range,
+  CFStringRef transform, Boolean reverse);
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+CF_EXPORT void
+CFStringFold (CFMutableStringRef theString, CFOptionFlags theFlags,
+  CFLocaleRef theLocale);
+#endif
+/** \} */
+
+
+
+/** \ingroup CFStringRef
+    \name CFStringInlineBuffer
+    \{
+ */
+#define __kCFStringInlineBufferLength 64
+struct CFStringInlineBuffer
+{
+  UniChar buffer[__kCFStringInlineBufferLength];
+  CFStringRef theString;
+  const UniChar *directBuffer;
+  CFRange rangeToBuffer;
+  CFIndex bufferedRangeStart;
+  CFIndex bufferedRangeEnd;
+};
+typedef struct CFStringInlineBuffer CFStringInlineBuffer;
+
+CF_INLINE void
+CFStringInitInlineBuffer (CFStringRef str, CFStringInlineBuffer *buf,
+  CFRange range)
+{
+  buf->theString = str;
+  buf->rangeToBuffer = range;
+  buf->directBuffer = CFStringGetCharactersPtr (str);
+  buf->bufferedRangeStart = 0;
+  buf->bufferedRangeEnd = 0;
+}
+
+CF_INLINE UniChar
+CFStringGetCharacterFromInlineBuffer (CFStringInlineBuffer *buf, CFIndex idx)
+{
+  if (buf->directBuffer)
+    {
+      if (idx < 0 || idx >= buf->rangeToBuffer.length)
+        return 0;
+      return buf->directBuffer[idx + buf->rangeToBuffer.location];
+    }
+  else if (idx >= buf->bufferedRangeEnd || idx < buf->bufferedRangeStart)
+    {
+      CFRange range;
+      
+      if (idx < 0 || idx >= buf->rangeToBuffer.length)
+        return 0;
+      
+      /* Use 16 here so it's efficient to go backwards, too */
+      buf->bufferedRangeStart = idx - 16;
+      if (buf->bufferedRangeStart < 0)
+        buf->bufferedRangeStart = 0;
+      buf->bufferedRangeEnd =
+        buf->bufferedRangeStart + __kCFStringInlineBufferLength;
+      if (buf->bufferedRangeEnd > buf->rangeToBuffer.length)
+        buf->bufferedRangeEnd = buf->rangeToBuffer.length;
+      
+      range = CFRangeMake (buf->rangeToBuffer.location + buf->bufferedRangeStart,
+        buf->bufferedRangeEnd - buf->bufferedRangeStart);
+      
+      CFStringGetCharacters (buf->theString, range, buf->buffer);
+    }
+  
+  return buf->buffer[(idx - buf->bufferedRangeStart)];
+}
+/** \} */
+
+CF_EXTERN_C_END
+
+#endif /* __COREFOUNDATION_CFSTRING_H__ */
+
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFCharacterSet.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFCharacterSet.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFCharacterSet.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,173 @@
+/* CFCharacterSet.h
+   
+   Copyright (C) 2012 Free Software Foundation, Inc.
+   
+   Written by: Stefan Bidigaray
+   Date: January, 2012
+   
+   This file is part of the GNUstep CoreBase Library.
+   
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.         See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; see the file COPYING.LIB.
+   If not, see <http://www.gnu.org/licenses/> or write to the 
+   Free Software Foundation, 51 Franklin Street, Fifth Floor, 
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef __COREFOUNDATION_CFCHARACTERSET_H__
+#define __COREFOUNDATION_CFCHARACTERSET_H__
+
+#include "CFBase.h"
+#include "CFData.h"
+
+CF_EXTERN_C_BEGIN
+
+/** \ingroup CFCharacterSetRef */
+typedef const struct __CFCharacterSet * CFCharacterSetRef;
+/** \ingroup CFMutableCharacterSetRef */
+typedef struct __CFCharacterSet * CFMutableCharacterSetRef;
+
+/** \defgroup CFCharacterSetRef CFCharacterSet Reference
+    \{
+ */
+typedef enum
+{
+  kCFCharacterSetControl = 1,
+  kCFCharacterSetWhitespace,
+  kCFCharacterSetWhitespaceAndNewline,
+  kCFCharacterSetDecimalDigit,
+  kCFCharacterSetLetter,
+  kCFCharacterSetLowercaseLetter,
+  kCFCharacterSetUppercaseLetter,
+  kCFCharacterSetNonBase,
+  kCFCharacterSetDecomposable,
+  kCFCharacterSetAlphaNumeric,
+  kCFCharacterSetPunctuation,
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2, GS_API_LATEST)
+  kCFCharacterSetCapitalizedLetter = 13,
+#endif
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_3, GS_API_LATEST)
+  kCFCharacterSetSymbol = 14,
+#endif
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+  kCFCharacterSetNewline = 15,
+#endif
+  kCFCharacterSetIllegal = 12
+} CFCharacterSetPredefinedSet;
+
+
+
+/** \name Creating Character Sets
+    \{
+ */
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_3, GS_API_LATEST)
+CF_EXPORT CFCharacterSetRef
+CFCharacterSetCreateCopy (CFAllocatorRef alloc, CFCharacterSetRef set);
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2, GS_API_LATEST)
+CF_EXPORT CFCharacterSetRef
+CFCharacterSetCreateInvertedSet (CFAllocatorRef alloc, CFCharacterSetRef set);
+#endif
+
+CF_EXPORT CFCharacterSetRef
+CFCharacterSetCreateWithCharactersInRange (CFAllocatorRef alloc,
+  CFRange range);
+
+CF_EXPORT CFCharacterSetRef
+CFCharacterSetCreateWithCharactersInString (CFAllocatorRef alloc,
+  CFStringRef string);
+
+CF_EXPORT CFCharacterSetRef
+CFCharacterSetCreateWithBitmapRepresentation (CFAllocatorRef alloc,
+  CFDataRef data);
+/** \} */
+
+/** \name Getting Predefined Character Sets
+    \{
+ */
+CF_EXPORT CFCharacterSetRef
+CFCharacterSetGetPredefined (CFCharacterSetPredefinedSet setIdentifier);
+/** \} */
+
+/** \name Querying Character Sets
+    \{
+ */
+CF_EXPORT CFDataRef
+CFCharacterSetCreateBitmapRepresentation (CFAllocatorRef alloc,
+  CFCharacterSetRef set);
+
+CF_EXPORT Boolean
+CFCharacterSetIsCharacterMember (CFCharacterSetRef set, UniChar c);
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2, GS_API_LATEST)
+CF_EXPORT Boolean
+CFCharacterSetHasMemberInPlane (CFCharacterSetRef set, CFIndex plane);
+
+CF_EXPORT Boolean
+CFCharacterSetIsLongCharacterMember (CFCharacterSetRef set, UTF32Char c);
+
+CF_EXPORT Boolean
+CFCharacterSetIsSupersetOfSet (CFCharacterSetRef set,
+  CFCharacterSetRef otherSet);
+#endif
+/** \} */
+
+/** \name Getting the Character Set Type Identifier
+    \{
+ */
+CF_EXPORT CFTypeID
+CFCharacterSetGetTypeID (void);
+/** \} */
+/** \} */
+
+/** \defgroup CFMutableCharacterSetRef CFMutableCharacterSet Reference
+    \{
+ */
+CF_EXPORT CFMutableCharacterSetRef
+CFCharacterSetCreateMutable (CFAllocatorRef alloc);
+
+CF_EXPORT CFMutableCharacterSetRef
+CFCharacterSetCreateMutableCopy (CFAllocatorRef alloc, CFCharacterSetRef set);
+
+CF_EXPORT void
+CFCharacterSetAddCharactersInRange (CFMutableCharacterSetRef set,
+  CFRange range);
+
+CF_EXPORT void
+CFCharacterSetAddCharactersInString (CFMutableCharacterSetRef set,
+  CFStringRef string);
+
+CF_EXPORT void
+CFCharacterSetRemoveCharactersInRange (CFMutableCharacterSetRef set,
+  CFRange range);
+
+CF_EXPORT void
+CFCharacterSetRemoveCharactersInString (CFMutableCharacterSetRef set,
+  CFStringRef string);
+
+CF_EXPORT void
+CFCharacterSetIntersect (CFMutableCharacterSetRef set,
+  CFCharacterSetRef otherSet);
+
+CF_EXPORT void
+CFCharacterSetInvert (CFMutableCharacterSetRef set);
+
+CF_EXPORT void
+CFCharacterSetUnion (CFMutableCharacterSetRef set, CFCharacterSetRef otherSet);
+/** \} */
+
+CF_EXTERN_C_END
+
+#endif /* __COREFOUNDATION_CFCHARACTERSET_H__ */
+
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFData.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFData.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFData.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,114 @@
+/* CFData.h
+
+   Copyright (C) 2010 Free Software Foundation, Inc.
+
+   Written by: Stefan Bidigaray
+   Date: January, 2010
+
+   This file is part of CoreBase.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; see the file COPYING.LIB.
+   If not, see <http://www.gnu.org/licenses/> or write to the 
+   Free Software Foundation, 51 Franklin Street, Fifth Floor, 
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef __COREFOUNDATION_CFDATA_H__
+#define __COREFOUNDATION_CFDATA_H__
+
+#include "CFBase.h"
+
+CF_EXTERN_C_BEGIN
+/** \ingroup CFDataRef */
+typedef const struct __CFData *CFDataRef;
+/** \ingroup CFMutableDataRef */
+typedef struct __CFData *CFMutableDataRef;
+
+/** \defgroup CFDataRef CFData Reference
+    \{
+ */
+/** \name Creating a CFData Object
+    \{
+ */
+CF_EXPORT CFDataRef
+CFDataCreate (CFAllocatorRef allocator, const UInt8 * bytes, CFIndex length);
+
+CF_EXPORT CFDataRef
+CFDataCreateCopy (CFAllocatorRef allocator, CFDataRef theData);
+
+CF_EXPORT CFDataRef
+CFDataCreateWithBytesNoCopy (CFAllocatorRef allocator, const UInt8 * bytes,
+                             CFIndex length, CFAllocatorRef bytesDeallocator);
+/** \} */
+
+/** \name Examining a CFData Object
+    \{
+ */
+CF_EXPORT const UInt8 *CFDataGetBytePtr (CFDataRef theData);
+
+CF_EXPORT void
+CFDataGetBytes (CFDataRef theData, CFRange range, UInt8 * buffer);
+
+CF_EXPORT CFIndex CFDataGetLength (CFDataRef theData);
+/** \} */
+
+/** \name Getting the CFData Type ID
+    \{
+ */
+CF_EXPORT CFTypeID CFDataGetTypeID (void);
+/** \} */
+/** \} */
+
+/** \defgroup CFMutableDataRef CFMutableData Reference
+    \{
+ */
+/** \name Creating a Mutable Data Object
+    \{
+ */
+CF_EXPORT CFMutableDataRef
+CFDataCreateMutable (CFAllocatorRef allocator, CFIndex capacity);
+
+CF_EXPORT CFMutableDataRef
+CFDataCreateMutableCopy (CFAllocatorRef allocator, CFIndex capacity,
+                         CFDataRef theData);
+/** \} */
+
+/** \name Accessing Mutable Data
+    \{
+ */
+CF_EXPORT UInt8 *CFDataGetMutableBytePtr (CFMutableDataRef theData);
+/** \} */
+
+/** \name Modifying a Mutable Data Object
+    \{
+ */
+CF_EXPORT void
+CFDataAppendBytes (CFMutableDataRef theData, const UInt8 * bytes,
+                   CFIndex length);
+
+CF_EXPORT void CFDataDeleteBytes (CFMutableDataRef theData, CFRange range);
+
+CF_EXPORT void
+CFDataReplaceBytes (CFMutableDataRef theData, CFRange range,
+                    const UInt8 * newBytes, CFIndex newLength);
+
+CF_EXPORT void
+CFDataIncreaseLength (CFMutableDataRef theData, CFIndex extraLength);
+
+CF_EXPORT void CFDataSetLength (CFMutableDataRef theData, CFIndex length);
+/** \} */
+/** \} */
+
+CF_EXTERN_C_END
+#endif /* __COREFOUNDATION_CFDATA_H__ */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFAvailability.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFAvailability.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFAvailability.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,52 @@
+/* CFAvailability.h
+   
+   Copyright (C) 2017 Free Software Foundation, Inc.
+   
+   Written by: Stefan Bidigaray
+   Date: August, 2017
+   
+   This file is part of the GNUstep CoreBase Library.
+   
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.         See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; see the file COPYING.LIB.
+   If not, see <http://www.gnu.org/licenses/> or write to the 
+   Free Software Foundation, 51 Franklin Street, Fifth Floor, 
+   Boston, MA 02110-1301, USA.
+*/
+
+
+#ifndef __COREFOUNDATION_CFAVAILABILITY_H__
+#define __COREFOUNDATION_CFAVAILABILITY_H__
+
+/* Compiler features */
+#ifndef __has_feature
+#define __has_feature(x) 0
+#endif
+#ifndef __has_attribute
+#define __has_attribute(x) 0
+#endif
+#ifndef __has_extension
+#define __has_extension(x) __has_feature
+#endif
+
+/* CFEnum macro for type definitions */
+#if (__cplusplus && __cplusplus >= 201103L)
+#define CF_ENUM(_type, _name) _type _name; enum : _type
+#define CF_OPTIONS(_type, _name) _type _name; enum : _type
+#else
+#define CF_ENUM(_type, _name) _type _name; enum
+#define CF_OPTIONS(_type, _name) _type _name; enum
+#endif
+
+#endif /* __COREFOUNDATION_CFAVAILABILITY_H__ */
+
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFBase.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFBase.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFBase.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,464 @@
+/* CFBase.h
+   
+   Copyright (C) 2010 Free Software Foundation, Inc.
+   
+   Written by: Stefan Bidigaray
+   Date: January, 2010
+   
+   This file is part of the GNUstep CoreBase Library.
+   
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.         See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; see the file COPYING.LIB.
+   If not, see <http://www.gnu.org/licenses/> or write to the 
+   Free Software Foundation, 51 Franklin Street, Fifth Floor, 
+   Boston, MA 02110-1301, USA.
+*/
+
+
+#ifndef __COREFOUNDATION_CFBASE_H__
+#define __COREFOUNDATION_CFBASE_H__
+
+/* CoreFoundation defines __LITTLE_ENDIAN__ or __BIG_ENDIAN__ so we'll
+ * do the same here for compatibility.
+ */
+#if !defined(__LITTLE_ENDIAN__) && !defined(__BIG_ENDIAN__)
+#define __LITTLE_ENDIAN__ 1
+#endif
+
+#include "CFAvailability.h"
+#include "../GNUstepBase/GSVersionMacros.h"
+
+/*
+ * CoreFoundation types
+ */
+typedef unsigned char Boolean;
+typedef unsigned char UInt8;
+typedef signed char SInt8;
+typedef unsigned short UInt16;
+typedef signed short SInt16;
+typedef unsigned int UInt32;
+typedef signed int SInt32;
+typedef unsigned long long UInt64;
+typedef signed long long SInt64;
+typedef SInt32 OSStatus;
+
+typedef float Float32;
+typedef double Float64;
+typedef UInt16 UniChar;
+typedef UInt8 *StringPtr;
+typedef const StringPtr *ConstStringPtr;
+typedef UInt8 Str255[256];
+typedef const Str255 *ConstStr255Param;
+typedef SInt16 OSErr;
+typedef SInt16 RegionCode;
+typedef SInt16 LangCode;
+typedef SInt16 ScriptCode;
+typedef UInt32 FourCharCode;
+#ifndef OSTYPE_DECLARED
+typedef FourCharCode OSType;
+#define OSTYPE_DECLARED
+#endif
+typedef UInt8 Byte;
+typedef SInt8 SignedByte;
+
+#ifndef UTF32Char               /* UTF32Char is also defined in GSConfig.h */
+typedef UInt32 UTF32Char;
+#endif
+typedef UInt16 UTF16Char;
+typedef UInt8 UTF8Char;
+
+#if !defined(CF_EXTERN_C_BEGIN)
+#if defined(__cplusplus)
+#define CF_EXTERN_C_BEGIN extern "C" {
+#define CF_EXTERN_C_END }
+#else
+#define CF_EXTERN_C_BEGIN
+#define CF_EXTERN_C_END
+#endif
+#endif
+
+#if defined(_WIN32)
+#if defined(BUILDING_SELF)
+#if defined(__cplusplus)
+#define CF_EXPORT extern "C" __declspec(dllexport)
+#else
+#define CF_EXPORT extern __declspec(dllexport)
+#endif
+#else
+#if defined(__cplusplus)
+#define CF_EXPORT extern "C" __declspec(dllimport)
+#else
+#define CF_EXPORT extern __declspec(dllimport)
+#endif
+#endif
+#else
+#if defined(__cplusplus)
+#define CF_EXPORT extern "C"
+#else
+#define CF_EXPORT extern
+#endif
+#endif
+
+#if !defined(__bool_true_false_are_defined)
+#define true 1
+#define false 0
+#endif
+
+#ifndef TRUE
+#define TRUE  1
+#endif
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#if !defined(CF_INLINE)
+#if defined(__GNUC__) && (__GNUC__ >= 4)
+#define CF_INLINE static __inline__ __attribute__((always_inline))
+#elif defined(__GNUC__)
+#define CF_INLINE static __inline__
+#elif defined(__MWERKS__) || defined(__cplusplus)
+#define CF_INLINE static inline
+#elif defined(_MSC_VER)
+#define CF_INLINE static __inline
+#elif _WIN32
+#define CF_INLINE static __inline__
+#else
+#define CF_INLINE static inline
+#endif
+#endif
+
+#if defined(__GNUC__) || defined(__llvm__)
+#define GS_PURE_FUNCTION __attribute__((pure))
+#else
+#define GS_PURE_FUNCTION
+#endif
+
+CF_EXTERN_C_BEGIN
+/** \defgroup CFTypeRef CFType Reference
+    \{
+ */
+typedef unsigned long CFTypeID;
+typedef const void *CFTypeRef;
+/** @}
+ */
+
+/** \defgroup BaseUtils Base Utilities
+    \{
+ */
+/** An integer value to store a hash code. */
+typedef unsigned long CFHashCode;
+/** A bitfield for passing information to functions.  Can hold as many bits
+    as a word.
+ */
+typedef unsigned long CFOptionFlags;
+/** A signed integer representing an index, size, length or count. */
+typedef signed long CFIndex;
+
+/** A structure that represents a range of items in a container, such as
+    an array.
+ */
+typedef struct CFRange CFRange;
+struct CFRange
+{
+  CFIndex location;
+    /**< An integer representing the start location of the range, inclusive. */
+  CFIndex length;
+    /**< An integer representing the total number of items in the range */
+};
+
+/** Creates a CFRange structure.
+    \param location The starting location.
+    \param length The length.
+    \return An initialized CFRange structure.
+ */
+CF_INLINE CFRange
+CFRangeMake (CFIndex location, CFIndex length)
+{
+  CFRange range;
+
+  range.location = location;
+  range.length = length;
+  return range;
+}
+
+/* Returned by comparison functions */
+typedef enum
+{
+  kCFCompareLessThan = -1,
+  kCFCompareEqualTo = 0,
+  kCFCompareGreaterThan = 1
+} CFComparisonResult;
+
+/* Return when a value is not found */
+enum
+{
+  kCFNotFound = -1
+};
+
+/* Definition for standard comparison function callback. */
+typedef CFComparisonResult (*CFComparatorFunction) (const void *val1,
+                                                    const void *val2,
+                                                    void *context);
+
+/* CoreFoundation version numbers */
+/** \name Library Version Numbers
+    \{
+ */
+CF_EXPORT const double kCFCoreFoundationVersionNumber;
+#define kCFCoreFoundationVersionNumber10_0    196.40
+#define kCFCoreFoundationVersionNumber10_0_3  196.50
+#define kCFCoreFoundationVersionNumber10_1    226.00
+#define kCFCoreFoundationVersionNumber10_1_1  226.00
+#define kCFCoreFoundationVersionNumber10_1_2  227.20
+#define kCFCoreFoundationVersionNumber10_1_3  227.20
+#define kCFCoreFoundationVersionNumber10_1_4  227.30
+#define kCFCoreFoundationVersionNumber10_2    263.00
+#define kCFCoreFoundationVersionNumber10_2_1  263.10
+#define kCFCoreFoundationVersionNumber10_2_2  263.10
+#define kCFCoreFoundationVersionNumber10_2_3  263.30
+#define kCFCoreFoundationVersionNumber10_2_4  263.30
+#define kCFCoreFoundationVersionNumber10_2_5  263.50
+#define kCFCoreFoundationVersionNumber10_2_6  263.50
+#define kCFCoreFoundationVersionNumber10_2_7  263.50
+#define kCFCoreFoundationVersionNumber10_2_8  263.50
+#define kCFCoreFoundationVersionNumber10_3    299.00
+#define kCFCoreFoundationVersionNumber10_3_1  299.00
+#define kCFCoreFoundationVersionNumber10_3_2  299.00
+#define kCFCoreFoundationVersionNumber10_3_3  299.30
+#define kCFCoreFoundationVersionNumber10_3_4  299.31
+#define kCFCoreFoundationVersionNumber10_3_5  299.31
+#define kCFCoreFoundationVersionNumber10_3_6  299.32
+#define kCFCoreFoundationVersionNumber10_3_7  299.33
+#define kCFCoreFoundationVersionNumber10_3_8  299.33
+#define kCFCoreFoundationVersionNumber10_3_9  299.35
+#define kCFCoreFoundationVersionNumber10_4    368.00
+#define kCFCoreFoundationVersionNumber10_4_1  368.10
+#define kCFCoreFoundationVersionNumber10_4_2  368.11
+#define kCFCoreFoundationVersionNumber10_4_3  368.18
+#define kCFCoreFoundationVersionNumber10_4_4_Intel   368.26
+#define kCFCoreFoundationVersionNumber10_4_4_PowerPC 368.25
+#define kCFCoreFoundationVersionNumber10_4_5_Intel   368.26
+#define kCFCoreFoundationVersionNumber10_4_5_PowerPC 368.25
+#define kCFCoreFoundationVersionNumber10_4_6_Intel   368.26
+#define kCFCoreFoundationVersionNumber10_4_6_PowerPC 368.25
+#define kCFCoreFoundationVersionNumber10_4_7  368.27
+#define kCFCoreFoundationVersionNumber10_4_8  368.27
+#define kCFCoreFoundationVersionNumber10_4_9  368.28
+#define kCFCoreFoundationVersionNumber10_4_10 368.28
+#define kCFCoreFoundationVersionNumber10_4_11 368.31
+#define kCFCoreFoundationVersionNumber10_5    476.00
+#define kCFCoreFoundationVersionNumber10_5_1  476.00
+#define kCFCoreFoundationVersionNumber10_5_2  476.10
+#define kCFCoreFoundationVersionNumber10_5_3  476.13
+#define kCFCoreFoundationVersionNumber10_5_4  476.14
+#define kCFCoreFoundationVersionNumber10_5_5  476.15
+#define kCFCoreFoundationVersionNumber10_5_6  476.17
+/** \} */
+/** \} */
+
+#if __has_feature(attribute_cf_returns_retained)
+#define CF_RETURNS_RETAINED __attribute__((cf_returns_retained))
+#else
+#define CF_RETURNS_RETAINED
+#endif
+
+#if __has_feature(attribute_cf_returns_not_retained)
+#define CF_RETURNS_NOT_RETAINED __attribute__((cf_returns_not_retained))
+#else
+#define CF_RETURNS_NOT_RETAINED
+#endif
+
+/** \ingroup CFPropertyListRef
+ */
+typedef CFTypeRef CFPropertyListRef;
+
+/** \ingroup CFStringRef
+ */
+typedef const struct __CFString *CFStringRef;
+/** \ingroup CFMutableStringRef
+ */
+typedef struct __CFString *CFMutableStringRef;
+
+
+
+/** \defgroup CFAllocatorRef CFAllocator Reference
+    \brief CFAllocator is an opaque type used to allocate and deallocate
+    memory.
+    \{
+ */
+/** \brief A reference to a CFAllocator object.
+ */
+typedef const struct __CFAllocator *CFAllocatorRef;
+
+typedef void *(*CFAllocatorAllocateCallBack) (CFIndex allocSize,
+                                              CFOptionFlags hint, void *info);
+typedef void (*CFAllocatorDeallocateCallBack) (void *ptr, void *info);
+typedef void *(*CFAllocatorReallocateCallBack) (void *ptr,
+                                                CFIndex newsize,
+                                                CFOptionFlags hint, void *info);
+typedef CFIndex (*CFAllocatorPreferredSizeCallBack) (CFIndex size,
+                                                     CFOptionFlags hint,
+                                                     void *info);
+typedef const void *(*CFAllocatorRetainCallBack) (const void *info);
+typedef void (*CFAllocatorReleaseCallBack) (const void *info);
+typedef CFStringRef (*CFAllocatorCopyDescriptionCallBack) (const void *info);
+
+struct _CFAllocatorContext
+{
+  CFIndex version;
+  void *info;
+  CFAllocatorRetainCallBack retain;
+  CFAllocatorReleaseCallBack release;
+  CFAllocatorCopyDescriptionCallBack copyDescription;
+  CFAllocatorAllocateCallBack allocate;
+  CFAllocatorReallocateCallBack reallocate;
+  CFAllocatorDeallocateCallBack deallocate;
+  CFAllocatorPreferredSizeCallBack preferredSize;
+};
+typedef struct _CFAllocatorContext CFAllocatorContext;
+
+/** The default allocator and is equivalent to NULL.
+    \see CFAllocatorGetDefault()
+    \see CFAllocatorSetDefault()
+ */
+CF_EXPORT CFAllocatorRef kCFAllocatorDefault;
+/** The default system allocator is used internally by GNUstep and is the
+    default allocator if none is been defined.
+    \see CFAllocatorSetDefault()
+ */
+CF_EXPORT CFAllocatorRef kCFAllocatorSystemDefault;
+/** An allocator that uses the system's malloc, realloc and free functions.
+ */
+CF_EXPORT CFAllocatorRef kCFAllocatorMalloc;
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+/** Equivalent to kCFAllocatorSystemDefault
+ */
+CF_EXPORT CFAllocatorRef kCFAllocatorMallocZone;
+#endif
+/** The NULL allocator does perform any operations.  Can be passed as
+    a deallocator if you do not want GNUstep to deallocate the data.
+ */
+CF_EXPORT CFAllocatorRef kCFAllocatorNull;
+/** This is a special case allocator directing CFAllocatorCreate() to use
+    the given CFAllocatorContext structure to allocate the new allocator.
+ */
+CF_EXPORT CFAllocatorRef kCFAllocatorUseContext;
+
+/** Create a new CFAllocator.
+    \param allocator The allocator used to create this allocator or
+      kCFAllocatorUseContext to use the functions in \b context.
+    \param context The new allocator's context functions.
+    \return A new CFAllocator or NULL in case of failure.
+    \see CFAllocatorContext
+ */
+CF_EXPORT CFAllocatorRef
+CFAllocatorCreate (CFAllocatorRef allocator, CFAllocatorContext * context);
+
+/** Allocate new memory.
+    \param allocator The CFAllocator to use.
+    \param size The number of bytes to allocate.
+    \param hint Option flags.  Currently unused and should be 0.
+    \return Newly allocated memory of NULL in case of failure.
+    \see CFAllocatorDeallocate()
+ */
+CF_EXPORT void *CFAllocatorAllocate (CFAllocatorRef allocator, CFIndex size,
+                                     CFOptionFlags hint);
+
+/** Deallocate the memory pointed to by \b ptr.
+    \param allocator The CFAllocator to use.
+    \param ptr A pointer previously allocated by CFAllocatorAllocate().
+    \see CFAllocatorAllocate()
+ */
+CF_EXPORT void CFAllocatorDeallocate (CFAllocatorRef allocator, void *ptr);
+
+CF_EXPORT CFIndex
+CFAllocatorGetPreferredSizeForSize (CFAllocatorRef allocator, CFIndex size,
+                                    CFOptionFlags hint);
+
+CF_EXPORT void *CFAllocatorReallocate (CFAllocatorRef allocator, void *ptr,
+                                       CFIndex newsize, CFOptionFlags hint);
+
+CF_EXPORT CFAllocatorRef CFAllocatorGetDefault (void);
+
+CF_EXPORT void CFAllocatorSetDefault (CFAllocatorRef allocator);
+
+CF_EXPORT void
+CFAllocatorGetContext (CFAllocatorRef allocator, CFAllocatorContext * context);
+
+CF_EXPORT CFTypeID CFAllocatorGetTypeID (void);
+/** \} */
+
+
+
+/** \ingroup CFTypeRef
+    \{
+ */
+/* These function will be implemented in CFRuntime.c since they 
+   require runtime support. */
+CF_EXPORT CFStringRef CFCopyDescription (CFTypeRef cf);
+
+CF_EXPORT CFStringRef CFCopyTypeIDDescription (CFTypeID typeID);
+
+CF_EXPORT Boolean CFEqual (CFTypeRef cf1, CFTypeRef cf2);
+
+CF_EXPORT CFAllocatorRef CFGetAllocator (CFTypeRef cf);
+
+CF_EXPORT CFIndex CFGetRetainCount (CFTypeRef cf);
+
+CF_EXPORT CFTypeID CFGetTypeID (CFTypeRef cf);
+
+CF_EXPORT CFHashCode CFHash (CFTypeRef cf);
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+CF_EXPORT CFTypeRef CFMakeCollectable (CFTypeRef cf);
+#endif
+
+CF_EXPORT void CFRelease (CFTypeRef cf);
+
+CF_EXPORT CFTypeRef CFRetain (CFTypeRef cf);
+
+CF_EXPORT CFTypeRef CFAutorelease(CFTypeRef arg);
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_7, GS_API_LATEST)
+CF_EXPORT void *_CFBridgingRelease (CFTypeRef cf);
+CF_EXPORT CFTypeRef _CFBridgingRetain (void *obj);
+
+#if __has_feature(objc_arc)
+#define CFBridgingRetain(x) (__bridge_retained CFTypeRef)(x)
+#define CFBridgingRelease(x) (__bridge_transfer id)(x)
+#elif __OBJC__
+#define CFBridgingRetain(x) _CFBridgingRetain((void *)(x))
+#define CFBridgingRelease(x) (id)_CFBridgingRelease((x))
+#else
+#define CFBridgingRetain(x) _CFBridgingRetain((void *)(x))
+#define CFBridgingRelease(x) _CFBridgingRelease((x))
+#endif
+#endif
+/** \} */
+
+
+
+/** \defgroup CFNullRef CFNull Reference
+    \{
+ */
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2, GS_API_LATEST)
+typedef struct __CFNull *CFNullRef;
+
+CF_EXPORT CFNullRef kCFNull;
+
+CFTypeID CFNullGetTypeID (void);
+#endif
+/** \} */
+
+CF_EXTERN_C_END
+#endif /* __COREFOUNDATION_CFBASE_H__ */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFArray.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFArray.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFArray.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,191 @@
+/* CFArray.h
+   
+   Copyright (C) 2010 Free Software Foundation, Inc.
+   
+   Written by: Stefan Bidigaray
+   Date: January, 2010
+   
+   This file is part of CoreBase.
+   
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; see the file COPYING.LIB.
+   If not, see <http://www.gnu.org/licenses/> or write to the 
+   Free Software Foundation, 51 Franklin Street, Fifth Floor, 
+   Boston, MA 02110-1301, USA.
+*/
+
+
+#ifndef __COREFOUNDATION_CFARRAY_H__
+#define __COREFOUNDATION_CFARRAY_H__
+
+#include "CFBase.h"
+
+CF_EXTERN_C_BEGIN
+/** \ingroup CFArrayRef
+    \brief Reference to an immutable array object.
+ */
+typedef const struct __CFArray *CFArrayRef;
+/**
+    \ingroup CFMutableArrayRef
+    \brief Reference to a mutable array object.
+ */
+typedef struct __CFArray *CFMutableArrayRef;
+
+/** \defgroup CFArrayRef CFArray Reference
+    \brief A CFArray and its mutable type, \ref CFMutableArrayRef
+      "CFMutableArray", are simple, low overhead, ordered containers for
+      objects.
+    \details
+      <code>\#include <CoreFoundation/CFArray.h></code>
+    \{
+ */
+
+/** \name Callbacks
+    \{
+ */
+typedef void (*CFArrayApplierFunction) (const void *value, void *context);
+typedef CFStringRef (*CFArrayCopyDescriptionCallBack) (const void *value);
+typedef void (*CFArrayReleaseCallBack) (CFAllocatorRef allocator,
+                                        const void *value);
+typedef const void *(*CFArrayRetainCallBack) (CFAllocatorRef allocator,
+                                              const void *value);
+typedef Boolean (*CFArrayEqualCallBack) (const void *value1,
+                                         const void *value2);
+/** \} */
+
+/** \brief Structure with CFArray callbacks.
+ */
+typedef struct _CFArrayCallBacks CFArrayCallBacks;
+struct _CFArrayCallBacks
+{
+  CFIndex version; /**< Structure's version number.  Current version is 0. */
+  CFArrayRetainCallBack retain;
+    /**< The callback used to retain values added to the array.  If NULL,
+	 values are not retained. */
+  CFArrayReleaseCallBack release;
+  CFArrayCopyDescriptionCallBack copyDescription;
+  CFArrayEqualCallBack equal;
+};
+
+/** \name Predefined Callback Structures
+    \{
+ */
+CF_EXPORT const CFArrayCallBacks kCFTypeArrayCallBacks;
+/** \} */
+
+
+
+/** \name Creating an Array
+    \{
+ */
+CF_EXPORT CFArrayRef
+CFArrayCreate (CFAllocatorRef allocator, const void **values,
+               CFIndex numValues, const CFArrayCallBacks * callBacks);
+
+CF_EXPORT CFArrayRef
+CFArrayCreateCopy (CFAllocatorRef allocator, CFArrayRef theArray);
+/** \} */
+
+/** \name Examining an Array
+    \{
+ */
+CF_EXPORT CFIndex
+CFArrayBSearchValues (CFArrayRef theArray, CFRange range, const void *value,
+                      CFComparatorFunction comparator, void *context);
+
+CF_EXPORT Boolean
+CFArrayContainsValue (CFArrayRef theArray, CFRange range, const void *value);
+
+CF_EXPORT CFIndex CFArrayGetCount (CFArrayRef theArray);
+
+CF_EXPORT CFIndex
+CFArrayGetCountOfValue (CFArrayRef theArray, CFRange range, const void *value);
+
+CF_EXPORT CFIndex
+CFArrayGetFirstIndexOfValue (CFArrayRef theArray, CFRange range,
+                             const void *value);
+
+CF_EXPORT CFIndex
+CFArrayGetLastIndexOfValue (CFArrayRef theArray, CFRange range,
+                            const void *value);
+
+CF_EXPORT void
+CFArrayGetValues (CFArrayRef theArray, CFRange range, const void **values);
+
+CF_EXPORT const void *CFArrayGetValueAtIndex (CFArrayRef theArray, CFIndex idx);
+/** \} */
+
+/** \name Applying a Function to Elements
+    \{
+ */
+CF_EXPORT void
+CFArrayApplyFunction (CFArrayRef theArray, CFRange range,
+                      CFArrayApplierFunction applier, void *context);
+/** \} */
+
+/** \name Getting the CFArray Type ID
+    \{
+ */
+CF_EXPORT CFTypeID CFArrayGetTypeID (void);
+/** \} */
+
+/** \} */
+
+/** \defgroup CFMutableArrayRef CFMutableArray Reference
+    \details <code>\#include <CoreFoundation/CFArray.h></code>
+    \{
+ */
+CF_EXPORT void
+CFArrayAppendArray (CFMutableArrayRef theArray, CFArrayRef otherArray,
+                    CFRange otherRange);
+
+CF_EXPORT void
+CFArrayAppendValue (CFMutableArrayRef theArray, const void *value);
+
+CF_EXPORT CFMutableArrayRef
+CFArrayCreateMutable (CFAllocatorRef allocator, CFIndex capacity,
+                      const CFArrayCallBacks * callBacks);
+
+CF_EXPORT CFMutableArrayRef
+CFArrayCreateMutableCopy (CFAllocatorRef allocator, CFIndex capacity,
+                          CFArrayRef theArray);
+
+CF_EXPORT void
+CFArrayExchangeValuesAtIndices (CFMutableArrayRef theArray, CFIndex idx1,
+                                CFIndex idx2);
+
+CF_EXPORT void
+CFArrayInsertValueAtIndex (CFMutableArrayRef theArray, CFIndex idx,
+                           const void *value);
+
+CF_EXPORT void CFArrayRemoveAllValues (CFMutableArrayRef theArray);
+
+CF_EXPORT void
+CFArrayRemoveValueAtIndex (CFMutableArrayRef theArray, CFIndex idx);
+
+CF_EXPORT void
+CFArrayReplaceValues (CFMutableArrayRef theArray, CFRange range,
+                      const void **newValues, CFIndex newCount);
+
+CF_EXPORT void
+CFArraySetValueAtIndex (CFMutableArrayRef theArray, CFIndex idx,
+                        const void *value);
+
+CF_EXPORT void
+CFArraySortValues (CFMutableArrayRef theArray, CFRange range,
+                   CFComparatorFunction comparator, void *context);
+
+/** \} */
+
+CF_EXTERN_C_END
+#endif /* __COREFOUNDATION_CFARRAY_H__ */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFLocale.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFLocale.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFLocale.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,249 @@
+/* CFLocale.h
+   
+   Copyright (C) 2010 Free Software Foundation, Inc.
+   
+   Written by: Stefan Bidigaray
+   Date: March, 2011
+   
+   This file is part of the GNUstep CoreBase Library.
+   
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; see the file COPYING.LIB.
+   If not, see <http://www.gnu.org/licenses/> or write to the 
+   Free Software Foundation, 51 Franklin Street, Fifth Floor, 
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef __COREFOUNDATION_CFLOCALE__
+#define __COREFOUNDATION_CFLOCALE__ 1
+
+#include "CFBase.h"
+
+#include "CFArray.h"
+#include "CFDictionary.h"
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_3, GS_API_LATEST)
+
+CF_EXTERN_C_BEGIN
+
+/** \defgroup CFLocaleRef CFLocale Reference
+    \brief CFLocale provides basic functionality for language and/or region
+    specific operations.
+    
+    Locale-sensitive operations, such as collation, calendars and
+    capitalization, may use CFLocale objects to provide language and/or region
+    specific functionality.
+  
+    CFLocale is "toll-free bridged" to NSLocale.
+    
+    \{
+ */
+typedef const struct __CFLocale *CFLocaleRef;
+
+/** 
+ */
+enum
+{
+  kCFLocaleLanguageDirectionUnknown     = 0,
+  kCFLocaleLanguageDirectionLeftToRight = 1,
+  kCFLocaleLanguageDirectionRightToLeft = 2,
+  kCFLocaleLanguageDirectionTopToBottom = 3,
+  kCFLocaleLanguageDirectionBottomToTop = 4
+};
+typedef CFIndex CFLocaleLanguageDirection;
+
+/** \name CFLocale Property Keys
+    \{
+ */
+CF_EXPORT const CFStringRef kCFLocaleMeasurementSystem; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleDecimalSeparator; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleGroupingSeparator; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleCurrencySymbol; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleCurrencyCode; /* CFString */
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+CF_EXPORT const CFStringRef kCFLocaleIdentifier; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleLanguageCode; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleCountryCode; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleScriptCode; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleVariantCode; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleExemplarCharacterSet; /* CFCharacterSet */
+CF_EXPORT const CFStringRef kCFLocaleCalendarIdentifier; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleCalendar; /* CFCalendar */
+CF_EXPORT const CFStringRef kCFLocaleCollationIdentifier; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleUsesMetricSystem; /* CFBoolean */
+#endif
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
+CF_EXPORT const CFStringRef kCFLocaleCollatorIdentifier; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleQuotationBeginDelimiterKey; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleQuotationEndDelimiterKey; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleAlternateQuotationBeginDelimiterKey; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleAlternateQuotationEndDelimiterKey; /* CFString */
+#endif
+/** \} */
+
+/** \name CFCalendar Identifiers
+    \{
+ */
+CF_EXPORT const CFStringRef kCFGregorianCalendar;
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+CF_EXPORT const CFStringRef kCFBuddhistCalendar;
+CF_EXPORT const CFStringRef kCFChineseCalendar;
+CF_EXPORT const CFStringRef kCFHebrewCalendar;
+CF_EXPORT const CFStringRef kCFIslamicCalendar;
+CF_EXPORT const CFStringRef kCFIslamicCivilCalendar;
+CF_EXPORT const CFStringRef kCFJapaneseCalendar;
+#endif
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
+CF_EXPORT const CFStringRef kCFRepublicOfChinaCalendar;
+CF_EXPORT const CFStringRef kCFPersianCalendar;
+CF_EXPORT const CFStringRef kCFIndianCalendar;
+CF_EXPORT const CFStringRef kCFISO8601Calendar;
+#endif
+/** \} */
+
+/** CFLocale Change Notification
+ */
+CF_EXPORT const CFStringRef kCFLocaleCurrentLocaleDidChangeNotification;
+
+
+
+/** \name Creating a Locale
+    \{
+ */
+CF_EXPORT CFLocaleRef
+CFLocaleCopyCurrent (void);
+
+CF_EXPORT CFLocaleRef
+CFLocaleCreate (CFAllocatorRef allocator,
+                CFStringRef localeIdent);
+
+CF_EXPORT CFLocaleRef
+CFLocaleCreateCopy (CFAllocatorRef allocator,
+                    CFLocaleRef locale);
+
+CF_EXPORT CFLocaleRef
+CFLocaleGetSystem (void);
+/** \} */
+
+/** \name Getting System Locale Information
+    \{
+ */
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+CF_EXPORT CFArrayRef
+CFLocaleCopyAvailableLocaleIdentifiers (void);
+#endif
+/** \} */
+
+/** \name Getting ISO Information
+    \{
+ */
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+CF_EXPORT CFArrayRef
+CFLocaleCopyISOCountryCodes (void);
+
+CF_EXPORT CFArrayRef
+CFLocaleCopyISOLanguageCodes (void);
+
+CF_EXPORT CFArrayRef
+CFLocaleCopyISOCurrencyCodes (void);
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+CF_EXPORT CFArrayRef
+CFLocaleCopyCommonISOCurrencyCodes (void);
+#endif
+/** \{ */
+
+/** \name Accessing Language Information
+    \{
+ */
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+CF_EXPORT CFArrayRef
+CFLocaleCopyPreferredLanguages (void);
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
+CF_EXPORT CFLocaleLanguageDirection
+CFLocaleGetLanguageCharacterDirection (CFStringRef isoLangCode);
+
+CF_EXPORT CFLocaleLanguageDirection
+CFLocaleGetLanguageLineDirection (CFStringRef isoLangCode);
+#endif
+/** \} */
+
+/** \name Getting Information About a Locale
+    \{
+ */
+CF_EXPORT CFStringRef
+CFLocaleCopyDisplayNameForPropertyValue (CFLocaleRef displayLocale,
+                                         CFStringRef key,
+                                         CFStringRef value);
+
+CF_EXPORT CFTypeRef
+CFLocaleGetValue (CFLocaleRef locale,
+                  CFStringRef key);
+
+CF_EXPORT CFStringRef
+CFLocaleGetIdentifier (CFLocaleRef locale);
+/** \} */
+
+/** \name Getting and Creating Locale Identifiers
+    \{
+ */
+CF_EXPORT CFStringRef
+CFLocaleCreateCanonicalLocaleIdentifierFromString (CFAllocatorRef allocator,
+                                                   CFStringRef localeIdent);
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+CF_EXPORT CFStringRef
+CFLocaleCreateCanonicalLanguageIdentifierFromString (CFAllocatorRef allocator,
+                                                     CFStringRef localeIdent);
+
+CF_EXPORT CFDictionaryRef
+CFLocaleCreateComponentsFromLocaleIdentifier (CFAllocatorRef allocator,
+                                              CFStringRef localeIdent);
+
+CF_EXPORT CFStringRef
+CFLocaleCreateLocaleIdentifierFromComponents (CFAllocatorRef allocator,
+                                              CFDictionaryRef dictionary);
+#endif
+/** \} */
+
+/** \name Windows Locale Codes
+    \{
+ */
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
+CF_EXPORT CFStringRef
+CFLocaleCreateLocaleIdentifierFromWindowsLocaleCode (CFAllocatorRef allocator,
+                                                     UInt32 lcid);
+
+CF_EXPORT UInt32
+CFLocaleGetWindowsLocaleCodeFromLocaleIdentifier (CFStringRef localeIdent);
+#endif
+/** \} */
+
+/** \name Getting the CFLocale Type ID
+    \{
+ */
+CF_EXPORT CFTypeID
+CFLocaleGetTypeID (void);
+/** \} */
+
+/** \} */
+
+CF_EXTERN_C_END
+
+#endif /* OS_API_VERSION >= MAC_OS_X_VERSION_10_3 */
+
+#endif /* __COREFOUNDATION_CFLOCALE__ */
+
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSObjCRuntime.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSObjCRuntime.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSObjCRuntime.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,631 @@
+/** Interface to ObjC runtime for GNUStep
+   Copyright (C) 1995, 1997, 2000, 2002, 2003 Free Software Foundation, Inc.
+
+   Written by:  Andrew Kachites McCallum <mccallum@gnu.ai.mit.edu>
+   Date: 1995
+   Written by:  Richard Frith-Macdonald <rfm@gnu.org>
+   Date: 2002
+   
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+   
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+
+    AutogsdocSource: Additions/GSObjCRuntime.m
+
+   */ 
+
+#ifndef __GSObjCRuntime_h_GNUSTEP_BASE_INCLUDE
+#define __GSObjCRuntime_h_GNUSTEP_BASE_INCLUDE
+
+#import "GSVersionMacros.h"
+#import "GSConfig.h"
+
+#include <stdio.h>
+
+#if 1 || NeXT_RUNTIME
+ #include <objc/objc.h>
+ #include <objc/objc-class.h>
+ #include <objc/objc-runtime.h>
+ #ifndef _C_ATOM
+  #define _C_ATOM '%'
+ #endif
+ #define _F_CONST    0x01
+ #define _F_IN       0x01
+ #define _F_OUT      0x02
+ #define _F_INOUT    0x03
+ #define _F_BYCOPY   0x04
+ #define _F_ONEWAY   0x08
+ #define _C_CONST    'r'
+ #define _C_IN       'n'
+ #define _C_INOUT    'N'
+ #define _C_OUT      'o'
+ #define _C_BYCOPY   'O'
+ #define _C_ONEWAY   'V'
+#else				/* GNU Objective C Runtime */
+ #include <objc/objc.h>
+ #if defined (__GNU_LIBOBJC__)
+  #include <objc/runtime.h>
+ #else
+  #include <objc/objc-api.h>
+  #include <objc/encoding.h>
+ #endif
+#endif
+
+/*
+ * Hack for older compiler versions that don't have all defines
+ * needed in  objc-api.h
+ */
+#ifndef	_C_LNG_LNG
+#define	_C_LNG_LNG	'q'
+#endif
+#ifndef	_C_ULNG_LNG
+#define	_C_ULNG_LNG	'Q'
+#endif
+
+#if	OBJC2RUNTIME
+/* We have a real ObjC2 runtime.
+ */
+#include <objc/runtime.h>
+#else
+/* We emulate an ObjC2 runtime.
+ */
+#include <ObjectiveC2/objc/runtime.h>
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+@class	NSArray;
+@class	NSDictionary;
+@class	NSObject;
+@class	NSString;
+@class	NSValue;
+
+#ifndef YES
+#define YES		1
+#endif
+#ifndef NO
+#define NO		0
+#endif
+#ifndef nil
+#define nil		0
+#endif
+
+#if	!defined(_C_CONST)
+#define _C_CONST        'r'
+#endif
+#if	!defined(_C_IN)
+#define _C_IN           'n'
+#endif
+#if	!defined(_C_INOUT)
+#define _C_INOUT        'N'
+#endif
+#if	!defined(_C_OUT)
+#define _C_OUT          'o'
+#endif
+#if	!defined(_C_BYCOPY)
+#define _C_BYCOPY       'O'
+#endif
+#if	!defined(_C_BYREF)
+#define _C_BYREF        'R'
+#endif
+#if	!defined(_C_ONEWAY)
+#define _C_ONEWAY       'V'
+#endif
+#if	!defined(_C_GCINVISIBLE)
+#define _C_GCINVISIBLE  '!'
+#endif
+
+/*
+ * Functions for accessing instance variables directly -
+ * We can copy an ivar into arbitrary data,
+ * Get the type encoding for a named ivar,
+ * and copy a value into an ivar.
+ */
+GS_EXPORT BOOL
+GSObjCFindVariable(id obj, const char *name,
+		   const char **type, unsigned int *size, int *offset);
+
+GS_EXPORT void
+GSObjCGetVariable(id obj, int offset, unsigned int size, void *data);
+
+GS_EXPORT void
+GSObjCSetVariable(id obj, int offset, unsigned int size, const void *data);
+
+GS_EXPORT NSArray *
+GSObjCMethodNames(id obj, BOOL recurse);
+
+GS_EXPORT NSArray *
+GSObjCVariableNames(id obj, BOOL recurse);
+
+/**
+ * <p>A Behavior can be seen as a "Protocol with an implementation" or a
+ * "Class without any instance variables".  A key feature of behaviors
+ * is that they give a degree of multiple inheritance.
+ * </p>
+ * <p>Behavior methods, when added to a class, override the class's
+ * superclass methods, but not the class's methods.
+ * </p>
+ * <p>Whan a behavior class is added to a receiver class, not only are the
+ * methods defined in the behavior class added, but the methods from the
+ * behavior's class hierarchy are also added (unless already present).
+ * </p>
+ * <p>It's not the case that a class adding behaviors from another class
+ * must have "no instance vars".  The receiver class just has to have the
+ * same layout as the behavior class (optionally with some additional
+ * ivars after those of the behavior class).
+ * </p>
+ * <p>This function provides Behaviors without adding any new syntax to
+ * the Objective C language.  Simply define a class with the methods you
+ * want to add, then call this function with that class as the behavior
+ * argument.
+ * </p>
+ * <p>This function should be called in the +initialize method of the receiver.
+ * </p>
+ * <p>If you add several behaviors to a class, be aware that the order of
+ * the additions is significant.
+ * </p>
+ */
+GS_EXPORT void
+GSObjCAddClassBehavior(Class receiver, Class behavior);
+
+/**
+ * <p>An Override can be seen as a "category implemented as a separate class
+ * and manually added to the receiver class under program control, rather
+ * than automatically added by the compiler/runtime.
+ * </p>
+ * <p>Override methods, when added to a receiver class, replace the class's
+ * class's methods of the same name (or are added if the class did not define
+ * methods with that name).
+ * </p>
+ * <p>It's not the case that a class adding overrides from another class
+ * must have "no instance vars".  The receiver class just has to have the
+ * same layout as the override class (optionally with some additional
+ * ivars after those of the override class).
+ * </p>
+ * <p>This function provides overrides without adding any new syntax to
+ * the Objective C language.  Simply define a class with the methods you
+ * want to add, then call this function with that class as the override
+ * argument.
+ * </p>
+ * <p>This function should usually be called in the +initialize method
+ * of the receiver.
+ * </p>
+ * <p>If you add several overrides to a class, be aware that the order of
+ * the additions is significant.
+ * </p>
+ */
+GS_EXPORT void
+GSObjCAddClassOverride(Class receiver, Class override);
+
+/** Turn on (YES), off (NO) or test (-1) behavior debugging.
+ */
+GS_EXPORT BOOL GSObjCBehaviorDebug(int setget);
+
+GS_EXPORT NSValue *
+GSObjCMakeClass(NSString *name, NSString *superName, NSDictionary *iVars);
+
+GS_EXPORT void
+GSObjCAddClasses(NSArray *classes);
+
+/**
+ * Given a NULL terminated list of methods, add them to the class.<br />
+ * If the method already exists in a superclass, the new version overrides
+ * that one, but if the method already exists in the class itsself, the
+ * new one is quietly ignored (replace==NO) or replaced with the new
+ * version (if replace==YES).<br />
+ * To add class methods, cls should be the metaclass of the class to
+ * which the methods are being added.
+ */
+GS_EXPORT void
+GSObjCAddMethods(Class cls, Method *list, BOOL replace);
+
+/*
+ * Functions for key-value encoding ... they access values in an object
+ * either by selector or directly, but do so using NSNumber for the
+ * scalar types of data.
+ */
+GS_EXPORT id
+GSObjCGetVal(NSObject *self, const char *key, SEL sel,
+  const char *type, unsigned size, int offset);
+
+GS_EXPORT void
+GSObjCSetVal(NSObject *self, const char *key, id val, SEL sel,
+  const char *type, unsigned size, int offset);
+
+/*
+ * This section includes runtime functions
+ * to query and manipulate the ObjC runtime structures.
+ * These functions take care to not use ObjC code so
+ * that they can safely be used in +(void)load implementations
+ * where applicable.
+ */
+
+/**
+ * Deprecated ... use objc_getClassList()
+ */
+GS_EXPORT unsigned int
+GSClassList(Class *buffer, unsigned int max, BOOL clearCache);
+
+/**
+ * GSObjCClass() is deprecated ... use object_getClass()
+ */
+GS_EXPORT Class GSObjCClass(id obj);
+
+/**
+ * GSObjCSuper() is deprecated ... use class_getSuperclass()
+ */
+GS_EXPORT Class GSObjCSuper(Class cls);
+
+/**
+ * GSObjCIsInstance() is deprecated ... use object_getClass()
+ * in conjunction with class_isMetaClass()
+ */
+GS_EXPORT BOOL GSObjCIsInstance(id obj);
+
+/**
+ * GSObjCIsClass() is deprecated ... use object_getClass()
+ * in conjunction with class_isMetaClass()
+ */
+GS_EXPORT BOOL GSObjCIsClass(Class cls);
+
+/**
+ * Test to see if class inherits from another class
+ * The argument to this function must NOT be nil.
+ */
+GS_EXPORT BOOL GSObjCIsKindOf(Class cls, Class other);
+
+/**
+ * GSClassFromName() is deprecated ... use objc_lookUpClass()
+ */
+GS_EXPORT Class GSClassFromName(const char *name);
+
+/**
+ * GSNameFromClass() is deprecated ... use class_getName()
+ */
+GS_EXPORT const char *GSNameFromClass(Class cls);
+
+/**
+ * GSClassNameFromObject() is deprecated ... use object_getClass()
+ * in conjunction with class_getName()
+ */
+GS_EXPORT const char *GSClassNameFromObject(id obj);
+
+/**
+ * GSNameFromSelector() is deprecated ... use sel_getName()
+ */
+GS_EXPORT const char *GSNameFromSelector(SEL sel);
+
+/**
+ * GSSelectorFromName() is deprecated ... use sel_getUid()
+ */
+GS_EXPORT SEL
+GSSelectorFromName(const char *name);
+
+/**
+ * Return the selector for the specified name and types.<br />
+ * Returns a nul pointer if the name is nul.<br />
+ * Creates a new selector if necessary.<br />
+ * Code must NOT rely on this providing a selector with type information.
+ */
+GS_EXPORT SEL
+GSSelectorFromNameAndTypes(const char *name, const char *types);
+
+/**
+ * Return the type information from the specified selector.<br />
+ * May return a nul pointer if the selector was a nul pointer or if it
+ * was not typed (or if the runtime does not support typed selectors).<br />
+ * Code must NOT rely on this providing any type information.
+ */
+GS_EXPORT const char *
+GSTypesFromSelector(SEL sel);
+
+/**
+ * Compare only the type information ignoring qualifiers, the frame layout
+ * and register markers.  Unlike sel_types_match, this function also
+ * handles comparisons of types with and without any layout information.
+ */
+GS_EXPORT BOOL
+GSSelectorTypesMatch(const char *types1, const char *types2);
+
+/** Takes full type information and skips forward to the actual type
+ * as specified in the _C_... constants.
+ */
+GS_EXPORT const char *
+GSSkipTypeQualifierAndLayoutInfo(const char *types);
+
+/**
+ * Returns a protocol object with the corresponding name.
+ * This function searches the registered classes for any protocol
+ * with the supplied name.  If one is found, it is cached in
+ * for future requests.  If efficiency is a factor then use
+ * GSRegisterProtocol() to insert a protocol explicitly into the cache
+ * used by this function.  If no protocol is found this function returns
+ * nil.
+ */
+GS_EXPORT Protocol *
+GSProtocolFromName(const char *name);
+
+/**
+ * Registers proto in the cache used by GSProtocolFromName().
+ */
+GS_EXPORT void
+GSRegisterProtocol(Protocol *proto);
+
+/**
+ * A variant of protocol_getMethodDescription which recursively searches
+ * parent protocols if the requested selector isn't found in the given
+ * protocol.
+ *
+ * Returns a {NULL, NULL} structure if the requested selector couldn't be
+ * found.
+ */
+GS_EXPORT struct objc_method_description
+GSProtocolGetMethodDescriptionRecursive(Protocol *aProtocol, SEL aSel, BOOL isRequired, BOOL isInstance);
+
+/*
+ * Unfortunately the definition of the symbols
+ * 'Method(_t)', 'MethodList(_t)'  and 'IVar(_t)'
+ * are incompatible between the GNU and NeXT/Apple runtimes.
+ * We introduce GSMethod, GSMethodList and GSIVar to allow portability.
+ */
+typedef Method	GSMethod;
+typedef Ivar	GSIVar;
+
+/**
+ * Returns the pointer to the method structure
+ * for the selector in the specified class.
+ * Depending on searchInstanceMethods, this function searches
+ * either instance or class methods.
+ * Depending on searchSuperClassesm this function searches
+ * either the specified class only or also its superclasses.<br/>
+ * To obtain the implementation pointer IMP use returnValue->method_imp
+ * which should be safe across all runtimes.<br/>
+ * It should be safe to use this function in +load implementations.<br/>
+ * This function should currently (June 2004) be considered WIP.
+ * Please follow potential changes (Name, parameters, ...) closely until
+ * it stabilizes.
+ */
+GS_EXPORT GSMethod
+GSGetMethod(Class cls, SEL sel,
+	    BOOL searchInstanceMethods,
+	    BOOL searchSuperClasses);
+
+/**
+ * Deprecated .. does nothing.
+ */
+GS_EXPORT void
+GSFlushMethodCacheForClass (Class cls);
+
+/**
+ * Deprecated .. use class_getInstanceVariable()
+ */
+GS_EXPORT GSIVar
+GSCGetInstanceVariableDefinition(Class cls, const char *name);
+
+/**
+ * Deprecated .. use class_getInstanceVariable()
+ */
+GS_EXPORT GSIVar
+GSObjCGetInstanceVariableDefinition(Class cls, NSString *name);
+
+/**
+ * GSObjCVersion() is deprecated ... use class_getVersion()
+ */
+GS_EXPORT int GSObjCVersion(Class cls);
+
+/**
+ * Quickly return autoreleased data storage area.
+ */
+GS_EXPORT void *
+GSAutoreleasedBuffer(unsigned size);
+
+/**
+ * <p>Prints a message to fptr using the format string provided and any
+ * additional arguments.  The format string is interpreted as by
+ * the NSString formatted initialisers, and understands the '%@' syntax
+ * for printing an object.
+ * </p>
+ * <p>The data is written to the file pointer in the default CString
+ * encoding if possible, as a UTF8 string otherwise.
+ * </p>
+ * <p>This function is recommended for printing general log messages.
+ * For debug messages use NSDebugLog() and friends.  For error logging
+ * use NSLog(), and for warnings you might consider NSWarnLog().
+ * </p>
+ */
+GS_EXPORT BOOL
+GSPrintf (FILE *fptr, NSString *format, ...);
+
+
+
+GS_EXPORT NSArray *
+GSObjCAllSubclassesOfClass(Class cls);
+
+GS_EXPORT NSArray *
+GSObjCDirectSubclassesOfClass(Class cls);
+
+/** Function to change the class of the specified instance to newClass.
+ * This handles memory debugging issues in GNUstep-base and also
+ * deals with class finalisation issues in a garbage collecting
+ * environment, so you should use this function rather than attempting
+ * to swizzle class pointers directly.
+ */
+GS_EXPORT void
+GSClassSwizzle(id instance, Class newClass);
+
+#if !defined(GS_GNUSTEP_V) || (GS_GNUSTEP_V >= GS_API_ANY && GS_GNUSTEP_V < 011500)
+//GS_API_VERSION(GS_API_ANY,011500)
+
+GS_EXPORT const char *
+GSLastErrorStr(long error_id) GS_DEPRECATED_FUNC;
+
+#endif
+
+
+
+#ifndef	GS_MAX_OBJECTS_FROM_STACK
+/**
+ * The number of objects to try to get from varargs into an array on
+ * the stack ... if there are more than this, use the heap.
+ * NB. This MUST be a multiple of 2
+ */
+#define	GS_MAX_OBJECTS_FROM_STACK	128
+#endif
+
+/**
+ * <p>This is a macro designed to minimise the use of memory allocation and
+ * deallocation when you need to work with a vararg list of objects.<br />
+ * The objects are unpacked from the vararg list into two 'C' arrays and
+ * then a code fragment you specify is able to make use of them before
+ * that 'C' array is destroyed. 
+ * </p>
+ * <p>The firstObject argument is the name of the formal parameter in your
+ * method or function which precedes the ', ...' denoting variable args.
+ * </p>
+ * <p>The code argument is a piece of objective-c code to be executed to
+ * make use of the objects stored in the 'C' arrays.<br />
+ * When this code is called the unsigned integer '__count' will contain the
+ * number of objects unpacked, the pointer '__objects' will point to
+ * the first object in each pair, and the pointer '__pairs' will point
+ * to an array containing the second halves of the pairs of objects
+ * whose first halves are in '__objects'.<br />
+ * This lets you pack a list of the form 'key, value, key, value, ...'
+ * into an array of keys and an array of values.
+ * </p>
+ */
+#define GS_USEIDPAIRLIST(firstObject, code...) ({\
+  va_list	__ap; \
+  unsigned int	__max = GS_MAX_OBJECTS_FROM_STACK; \
+  unsigned int	__count = 0; \
+  id		__buf[__max]; \
+  id		*__objects = __buf; \
+  id		*__pairs = &__objects[__max/2]; \
+  id		__obj = firstObject; \
+  va_start(__ap, firstObject); \
+  while (__obj != nil && __count < __max) \
+    { \
+      if ((__count % 2) == 0) \
+	{ \
+	  __objects[__count/2] = __obj; \
+	} \
+      else \
+	{ \
+	  __pairs[__count/2] = __obj; \
+	} \
+      __obj = va_arg(__ap, id); \
+      if (++__count == __max) \
+	{ \
+	  while (__obj != nil) \
+	    { \
+	      __count++; \
+	      __obj = va_arg(__ap, id); \
+	    } \
+	} \
+    } \
+  if ((__count % 2) == 1) \
+    { \
+      __pairs[__count/2] = nil; \
+      __count++; \
+    } \
+  va_end(__ap); \
+  if (__count > __max) \
+    { \
+      unsigned int	__tmp; \
+      __objects = (id*)malloc(__count*sizeof(id)); \
+      __pairs = &__objects[__count/2]; \
+      __objects[0] = firstObject; \
+      va_start(__ap, firstObject); \
+      for (__tmp = 1; __tmp < __count; __tmp++) \
+	{ \
+	  if ((__tmp % 2) == 0) \
+	    { \
+	      __objects[__tmp/2] = va_arg(__ap, id); \
+	    } \
+	  else \
+	    { \
+	      __pairs[__tmp/2] = va_arg(__ap, id); \
+	    } \
+	} \
+      va_end(__ap); \
+    } \
+  code; \
+  if (__objects != __buf) free(__objects); \
+})
+
+/**
+ * <p>This is a macro designed to minimise the use of memory allocation and
+ * deallocation when you need to work with a vararg list of objects.<br />
+ * The objects are unpacked from the vararg list into a 'C' array and
+ * then a code fragment you specify is able to make use of them before
+ * that 'C' array is destroyed. 
+ * </p>
+ * <p>The firstObject argument is the name of the formal parameter in your
+ * method or function which precedes the ', ...' denoting variable args.
+ * </p>
+ * <p>The code argument is a piece of objective-c code to be executed to
+ * make use of the objects stored in the 'C' array.<br />
+ * When this code is called the unsigned integer '__count' will contain the
+ * number of objects unpacked, and the pointer '__objects' will point to
+ * the unpacked objects, ie. firstObject followed by the vararg arguments
+ * up to (but not including) the first nil.
+ * </p>
+ */
+#define GS_USEIDLIST(firstObject, code...) ({\
+  va_list	__ap; \
+  unsigned int	__max = GS_MAX_OBJECTS_FROM_STACK; \
+  unsigned int	__count = 0; \
+  id		__buf[__max]; \
+  id		*__objects = __buf; \
+  id		__obj = firstObject; \
+  va_start(__ap, firstObject); \
+  while (__obj != nil && __count < __max) \
+    { \
+      __objects[__count] = __obj; \
+      __obj = va_arg(__ap, id); \
+      if (++__count == __max) \
+	{ \
+	  while (__obj != nil) \
+	    { \
+	      __count++; \
+	      __obj = va_arg(__ap, id); \
+	    } \
+	} \
+    } \
+  va_end(__ap); \
+  if (__count > __max) \
+    { \
+      unsigned int	__tmp; \
+      __objects = (id*)NSZoneMalloc(NSDefaultMallocZone(),__count*sizeof(id)); \
+      va_start(__ap, firstObject); \
+      __objects[0] = firstObject; \
+      for (__tmp = 1; __tmp < __count; __tmp++) \
+	{ \
+	  __objects[__tmp] = va_arg(__ap, id); \
+	} \
+      va_end(__ap); \
+    } \
+  code; \
+  if (__objects != __buf) NSZoneFree (NSDefaultMallocZone(),__objects); \
+})
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __GSObjCRuntime_h_GNUSTEP_BASE_INCLUDE */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSArray+GNUstepBase.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSArray+GNUstepBase.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSArray+GNUstepBase.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,78 @@
+/** Declaration of extension methods for base additions
+
+   Copyright (C) 2003-2010 Free Software Foundation, Inc.
+
+   Written by:  Richard Frith-Macdonald <rfm@gnu.org>
+   and:         Adam Fedor <fedor@gnu.org>
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+
+*/
+
+#ifndef	INCLUDED_NSArray_GNUstepBase_h
+#define	INCLUDED_NSArray_GNUstepBase_h
+
+#import "../GNUstepBase/GSVersionMacros.h"
+#import "../Foundation/NSArray.h"
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+#if	OS_API_VERSION(GS_API_NONE,GS_API_LATEST)
+
+@interface NSArray (GNUstepBase)
+
+/** <p>Method for working with sorted arrays - use a binary chop
+ * to determine the insertion location for an object.  If equal objects
+ * already exist in the array, they will be located immediately before
+ * the insertion position.
+ * </p>
+ * <p>The comparator function takes two items as arguments, the first is the
+ * item to be added, the second is the item already in the array.
+ * The function should return NSOrderedAscending if the item to be
+ * added is 'less than' the item in the array, NSOrderedDescending
+ * if it is greater, and NSOrderedSame if it is equal.
+ * </p>
+ */
+- (NSUInteger) insertionPosition: (id)item
+		   usingFunction: (NSComparisonResult (*)(id, id, void *))sorter
+		         context: (void *)context;
+
+/* <p>Method for working with sorted arrays - use a binary chop
+ * to determine the insertion location for an object.  If equal objects
+ * already exist in the array, they will be located immediately before
+ * the insertion position.
+ * </p> 
+ * <p>The selector identifies a method returning NSOrderedAscending if
+ * the receiver is 'less than' the argument, and NSOrderedDescending if
+ * it is greate.
+ * </p>
+ */
+- (NSUInteger) insertionPosition: (id)item
+		   usingSelector: (SEL)comp;
+@end
+
+#endif	/* OS_API_VERSION */
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#endif	/* INCLUDED_NSArray_GNUstepBase_h */
+
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSMutableString+GNUstepBase.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSMutableString+GNUstepBase.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSMutableString+GNUstepBase.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,57 @@
+/** Declaration of extension methods for base additions
+
+   Copyright (C) 2003-2010 Free Software Foundation, Inc.
+
+   Written by:  Richard Frith-Macdonald <rfm@gnu.org>
+   and:         Adam Fedor <fedor@gnu.org>
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+
+*/
+
+#ifndef	INCLUDED_NSMutableString_GNUstepBase_h
+#define	INCLUDED_NSMutableString_GNUstepBase_h
+
+#import "GSVersionMacros.h"
+#import "../Foundation/NSString.h"
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+#if	OS_API_VERSION(GS_API_NONE,GS_API_LATEST)
+
+@interface NSMutableString (GNUstepBase)
+- (void) deleteSuffix: (NSString*)suffix;
+- (void) deletePrefix: (NSString*)prefix;
+- (NSString*) immutableProxy;
+- (void) replaceString: (NSString*)replace
+            withString: (NSString*)by;
+- (void) trimLeadSpaces;
+- (void) trimTailSpaces;
+- (void) trimSpaces;
+@end
+
+#endif	/* OS_API_VERSION */
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#endif	/* INCLUDED_NSMutableString_GNUstepBase_h */
+
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSConfig.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSConfig.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSConfig.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,462 @@
+/* Machine/OS specific configuration information for GNUstep
+
+   Please NOTE - GSConfig.h is generated by the configure script from the
+   file GSConfig.h.in - changes/fixes need to be made to the original file,
+   not to the GSConfig.h generated from it.
+
+   Copyright (C) 1998-2010 Free Software Foundation, Inc.
+
+   Written by:  Richard frith-Macdonald <richard@brainstorm.co.uk>
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+   */
+
+#ifndef	included_GSConfig_h
+#define	included_GSConfig_h
+
+/* Check the compiler to see if we are building on/for ms-windows.
+ * Whatever the compiler uses, we want a standard setting of _WIN64
+ * to indicate 64bit AND _WIN32 to indicate ms-windows.
+ * These are defined by gcc, clang, and microsoft compilers anyway.
+ */
+#if     defined(__WIN32__) \
+	|| defined(__MS_WIN32__) \
+	|| defined(__MINGW32__)
+#  if	!defined(_WIN32)
+#    define _WIN32
+#  endif
+#endif
+#if     defined(__WIN64__) \
+	|| defined(__MS_WIN64__) \
+	|| defined(__MINGW64__)
+#  if	!defined(__WIN64__)
+#    define __WIN64__
+#  endif
+#  if	!defined(_WIN32)
+#    define _WIN32
+#  endif
+#endif
+
+/* Check to see if this is a MINGW build (all we currently support)
+ */
+#if	defined(__MINGW32__) || defined(__MINGW64__)
+#  if	!defined(__MINGW__)
+#    define __MINGW__
+#  endif
+#endif
+
+// Make sure we expose the constants that we use in ObjC++ mode
+#ifndef __STDC_CONSTANT_MACROS
+#define __STDC_CONSTANT_MACROS 1
+#endif
+#ifndef __STDC_LIMIT_MACROS 
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#if !defined(NeXT_Foundation_LIBRARY)
+
+/* An alternate to GS_FAKE_MAIN which forces the user to call the
+   NSProcessInfo initialization in 'main', GS_FAKE_MAIN must also
+   be undefined. */
+#if 0
+#define GS_PASS_ARGUMENTS 0
+#endif
+
+#define GS_FAKE_MAIN	0
+#if	GS_FAKE_MAIN
+
+/*
+ * NOTE - if GS_FAKE_MAIN (above) is set to 1, this hack applies - and you
+ * must make sure that this file is included in any file that implements
+ * the 'main()' function and links with the GNUstep base libarary.
+ * You should NOT include this file in a program that does not link with
+ * the base library.
+ * This file is included automatically in NSObject.h and Foundation.h
+ *
+ * The Foundation classe NSProcessInfo need access to the argc, argv,
+ * and env variables of the main() function. The purpose of this (ugly hack)
+ * definition is to give the gstep-base library the opportunity to implement
+ * its own main function with private access to the global vars. The private
+ * main() implementation (in NSProcessInfo.m) will then call the user defined
+ * gnustep_base_user_main() function.
+ *
+ * The original hack was -
+ ** Written by:  Georg Tuparev, EMBL & Academia Naturalis,
+ **              Heidelberg, Germany
+ **              Tuparev@EMBL-Heidelberg.de
+ **
+ **  NOTE! This is very dirty and dangerous trick. I spend several hours
+ ** on thinking and man pages browsing, but couldn't find better solution.
+ ** I know that I will spend 666 years in the Computer Hell for writing
+ ** this hack, and the master devil (Bully Boy) will send me to write
+ ** Windowz software.
+ ** BTW, for writing this hack I got personal congratulations from Dennis
+ ** Ritchie and Bjarne Stroustrup sent me a bunch of flowers and asked me
+ ** to participate in the standardization committee for C-- v.6.0 as
+ ** responsible for the new Tab-Overriding-Operator and Scope-Sensitive-
+ ** Comments ... but this makes my situation even worse ;-)
+ ** - Georg
+ *
+ * On some systems, there are other relatively clean workarounds, if this
+ * applies to the system you are running on, your configuration script
+ * should have set GS_FAKE_MAIN to zero, so that this define hack will
+ * not be used.
+ */
+
+#define main gnustep_base_user_main
+
+#endif	/* GS_FAKE_MAIN */
+#endif
+
+/*
+ * Definition to specify if your processor stores words with the most
+ * significant byte first (like Motorola and SPARC, unlike Intel and VAX).
+ */
+#define GS_WORDS_BIGENDIAN	0
+
+/*
+ *	Size definitions for standard types
+ */
+#define	GS_SIZEOF_SHORT		2
+#define	GS_SIZEOF_INT		4
+#define	GS_SIZEOF_LONG		8
+#define	GS_SIZEOF_LONG_LONG	8
+#define	GS_SIZEOF_FLOAT		4
+#define	GS_SIZEOF_DOUBLE	8
+#define	GS_SIZEOF_VOIDP		8
+
+/*
+ *	Size information to be places in bits 5 and 6 of type encoding bytes
+ *	in archives (bits 0 to 4 are used for basic type info and bit 7 is
+ *	used to mark cross-references to previously encoded objects).
+ */
+#define	_GSC_S_SHT	_GSC_I16
+#define	_GSC_S_INT	_GSC_I32
+#define	_GSC_S_LNG	_GSC_I64
+#define	_GSC_S_LNG_LNG	_GSC_I64
+
+/*
+ * Type definitions for types with known sizes.
+ */
+typedef signed char gss8;
+typedef unsigned char gsu8;
+typedef signed short gss16;
+typedef unsigned short gsu16;
+typedef signed int gss32;
+typedef unsigned int gsu32;
+typedef signed long gss64;
+typedef unsigned long gsu64;
+typedef struct { gsu8 a[16]; } gss128;
+typedef struct { gsu8 a[16]; } gsu128;
+typedef float gsf32;
+typedef double gsf64;
+
+/*
+ * Integer type with same size as a pointer
+ */
+typedef	unsigned long gsuaddr;
+typedef	long gssaddr;
+typedef	gsuaddr gsaddr;
+
+/*
+ *	Do we have real 64-bit and 128-bit integers or are we just pretending.
+ */
+#define GS_HAVE_I64	1
+#define GS_HAVE_I128	0
+
+/*
+ * Ensure some standard types are defined.
+ */
+#include <inttypes.h>
+
+
+
+
+
+
+
+
+
+
+
+/*
+ * PTR Limit information replacements for buggy headers
+ */ 
+#if 0
+#undef INTPTR_MAX
+#define INTPTR_MAX 
+#undef INTPTR_MIN
+#define INTPTR_MIN 
+#undef UINTPTR_MAX
+#define UINTPTR_MAX 
+#endif
+
+
+/*
+ *	Do we have zlib for file handle compression?
+ */
+#define USE_ZLIB	1
+
+/*
+ *	Do we have the GNU Multiple-precision library for NSDecimal?
+ */
+//#define USE_GMP	1
+#define USE_GMP	0
+
+#ifdef	GS_WITH_GC
+#undef  GS_WITH_GC
+#endif
+#define	GS_WITH_GC	0
+
+/*
+ * Define to say if we use NXConstantString or NSConstantString
+ */
+#define NXConstantString	NSConstantString
+
+
+/*
+ * Wide unicode character type.
+ */
+#ifndef	UTF32Char
+#define	UTF32Char	uint32_t
+#endif
+
+/*
+ * Native character type for use in systemcalls etc.
+ */
+
+#if	defined(__MINGW__)
+#  define	GSNativeChar	uint16_t
+#else
+#  define	GSNativeChar	char
+#endif
+
+/*
+ * Types used to avoid exposing pthread header in NSLock.h
+ * NB. These types should *never* be used except to provide enough space
+ * in a class layout for the type of data actually used by the pthread
+ * implementation of the current platform.
+ */
+typedef	struct {
+  uint8_t	dummy[48];
+} gs_cond_t	__attribute__((aligned (8)));
+typedef	struct {
+  uint8_t	dummy[40];
+} gs_mutex_t	__attribute__((aligned (8)));
+
+#define	OBJC2RUNTIME 1
+#define BASE_NATIVE_OBJC_EXCEPTIONS     1
+#define GS_NONFRAGILE     0
+#define GS_MIXEDABI     0
+#define GS_USE_LIBXML 0
+#define GS_USE_GNUTLS 0
+#define GS_USE_AVAHI 0
+#define GS_USE_MDNS 0
+#define GS_USE_ICU 0
+#define GS_USE_LIBDISPATCH 0
+#define GS_USE_LIBDISPATCH_RUNLOOP 0
+#define GS_HAVE_OBJC_ROOT_CLASS_ATTR 0
+
+#ifndef __has_include
+#  define __has_include(x) 0
+#endif
+#ifndef __has_feature
+#  define __has_feature(x) 0
+#endif
+#ifndef __has_builtin
+#  define __has_builtin(x) 0
+#endif
+
+/*
+ * __has_extension has slightly different semantics from __has_feature.
+ * It evaluates to true if the feature is supported by by clang for the
+ * current compilation unit (language and -f switches), regardless of
+ * whether it is part of the language standard or just a (non-standard)
+ * extension.
+ */
+#ifndef __has_extension
+#  define __has_extension(x) __has_feature(x)
+#endif
+
+#if defined(_WIN32)
+#define BOOL WinBOOL
+#define __OBJC_BOOL 1
+#include <w32api.h>
+#ifndef _WIN32_WINNT
+#define _WIN32_WINNT Windows2000
+#endif
+#if	!defined(WINVER)
+#define WINVER Windows2000
+#elif (WINVER < Windows2000)
+#undef	WINVER
+#define WINVER Windows2000
+#endif
+
+#if defined(__WIN64__)
+#include <winsock2.h>
+#include <windows.h>
+#else
+#include <windows.h>
+#include <winsock2.h>
+#endif
+
+#undef __OBJC_BOOL
+#undef  BOOL
+#endif
+
+/* Include the blocks runtime header if it's available (It shouldn't matter
+ * that this doesn't work on compilers that don't support __has_include(),
+ * because they also don't support blocks).
+ */
+#if __has_include(<objc/block_runtime.h>)
+#  include <objc/block_runtime.h>
+#endif
+
+#ifndef _WIN32
+#include <sys/param.h> /* Hack to get rid of warning in GNU libc 2.0.3. */
+#endif
+
+/* The following group of lines maintained by the gstep-base configure */
+#define GNUSTEP_BASE_VERSION            1.26.0
+#define GNUSTEP_BASE_MAJOR_VERSION      1
+#define GNUSTEP_BASE_MINOR_VERSION      26
+#define GNUSTEP_BASE_SUBMINOR_VERSION   0
+#define GNUSTEP_BASE_GCC_VERSION        4.0.0
+
+/* Do not use the following macros!
+ */
+#define OBJC_DEP(M) \
+  ({ static BOOL beenHere = NO; if (beenHere == NO) {\
+    beenHere = YES; fprintf(stderr, "%s:%d %s", __FILE__, __LINE__, (M));}})
+
+#define OBJC_MALLOC(VAR, TYPE, NUM) \
+   (OBJC_DEP("OBJC_MALLOC is deprecated ... use malloc\n"),(VAR) = (TYPE *) malloc ((unsigned)(NUM)*sizeof(TYPE)))
+#define OBJC_VALLOC(VAR, TYPE, NUM) \
+   (OBJC_DEP("OBJC_VALLOC is deprecated\n"),(VAR) = (TYPE *) valloc ((unsigned)(NUM)*sizeof(TYPE)))
+#define OBJC_ATOMIC_MALLOC(VAR, TYPE, NUM) \
+   (OBJC_DEP("OBJC_ATOMIC_MALLOC is deprecated\n"),(VAR) = (TYPE *) malloc ((unsigned)(NUM)*sizeof(TYPE)))
+#define OBJC_REALLOC(VAR, TYPE, NUM) \
+   (OBJC_DEP("OBJC_REALLOC is deprecated ... use realloc\n"),(VAR) = (TYPE *) realloc ((VAR), (unsigned)(NUM)*sizeof(TYPE)))
+#define OBJC_CALLOC(VAR, TYPE, NUM) \
+   (OBJC_DEP("OBJC_CALLOC is deprecated ... use calloc\n"),(VAR) = (TYPE *) calloc ((unsigned)(NUM), sizeof(TYPE)))
+#define OBJC_FREE(PTR) (OBJC_DEP("OBJC_FREE is deprecated ... use free\n"), free (PTR))
+
+#ifndef MAX
+#define MAX(a,b) \
+       ({__typeof__(a) _MAX_a = (a); __typeof__(b) _MAX_b = (b);  \
+         _MAX_a > _MAX_b ? _MAX_a : _MAX_b; })
+#endif
+
+#ifndef MIN
+#define MIN(a,b) \
+       ({__typeof__(a) _MIN_a = (a); __typeof__(b) _MIN_b = (b);  \
+         _MIN_a < _MIN_b ? _MIN_a : _MIN_b; })
+#endif
+
+#ifndef ABS
+#define ABS(a) \
+       ({__typeof__(a) _ABS_a = (a); \
+         _ABS_a < 0 ? -_ABS_a : _ABS_a; })
+#endif
+
+#ifndef STRINGIFY
+#define STRINGIFY(s) XSTRINGIFY(s)
+#define XSTRINGIFY(s) #s
+#endif
+
+#ifndef OBJC_STRINGIFY
+#define OBJC_STRINGIFY(s) OBJC_XSTRINGIFY(s)
+#define OBJC_XSTRINGIFY(s) @#s
+#endif
+
+#ifndef PTR2LONG
+#define PTR2LONG(P) (((char*)(P))-(char*)0)
+#endif
+#ifndef LONG2PTR
+#define LONG2PTR(L) (((char*)0)+(L))
+#endif
+
+#if VSPRINTF_RETURNS_LENGTH
+#define VSPRINTF_LENGTH(VSPF_CALL) (VSPF_CALL)
+#else
+#define VSPRINTF_LENGTH(VSPF_CALL) strlen((VSPF_CALL))
+#endif /* VSPRINTF_RETURNS_LENGTH */
+
+#if VASPRINTF_RETURNS_LENGTH
+#define VASPRINTF_LENGTH(VASPF_CALL) (VASPF_CALL)
+#else
+#define VASPRINTF_LENGTH(VASPF_CALL) strlen((VASPF_CALL))
+#endif /* VSPRINTF_RETURNS_LENGTH */
+
+/* Evil hack to stop gcc-4.1 complaining about a dealloc method which
+ * does not call the superclass implementation.
+ */
+#define	GSNOSUPERDEALLOC	if (0) [super dealloc]
+
+#ifndef CF_EXCLUDE_CSTD_HEADERS
+#include <sys/types.h>
+#include <stdarg.h>
+#include <assert.h>
+#include <ctype.h>
+#include <errno.h>
+#include <float.h>
+#include <limits.h>
+#include <locale.h>
+#include <math.h>
+#include <setjmp.h>
+#include <signal.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <stdbool.h>
+#endif
+
+#if !__has_feature(objc_arc)
+// NetBSD > 6 defines __weak in cdefs_elf.h
+#ifdef __NetBSD__
+#undef __weak
+#endif
+#  if !defined(__weak)
+#    define __weak
+#  endif
+#  if !defined(__strong)
+#    define __strong
+#  endif
+#endif
+
+#ifndef __unsafe_unretained
+#  if !__has_feature(objc_arc)
+#    define __unsafe_unretained
+#  endif
+#endif
+#ifndef __bridge
+#  if !__has_feature(objc_arc)
+#    define __bridge
+#  endif
+#endif
+
+#if __has_builtin(__builtin_unreachable)
+#  define GS_UNREACHABLE() __builtin_unreachable()
+#else
+#  define GS_UNREACHABLE() abort()
+#endif
+
+#endif	/* included_GSConfig_h */
+
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSObject+GNUstepBase.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSObject+GNUstepBase.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSObject+GNUstepBase.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,242 @@
+/** Declaration of extension methods for base additions
+
+   Copyright (C) 2003-2010 Free Software Foundation, Inc.
+
+   Written by:  Richard Frith-Macdonald <rfm@gnu.org>
+   and:         Adam Fedor <fedor@gnu.org>
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+
+*/
+
+#ifndef	INCLUDED_NSObject_GNUstepBase_h
+#define	INCLUDED_NSObject_GNUstepBase_h
+
+#import "GSVersionMacros.h"
+#import "../Foundation/NSObject.h"
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+#if	OS_API_VERSION(GS_API_NONE,GS_API_LATEST)
+
+@class  NSHashTable;
+
+@interface NSObject (GNUstepBase)
+
+/**
+  WARNING: The -compare: method for NSObject is deprecated
+           due to subclasses declaring the same selector with 
+	   conflicting signatures.
+           Comparision of arbitrary objects is not just meaningless
+           but also dangerous as most concrete implementations
+           expect comparable objects as arguments often accessing
+	   instance variables directly.
+	   This method will be removed in a future release.
+*/
+- (NSComparisonResult) compare: (id)anObject;
+
+/** For backward compatibility only ... use class_isMetaClass() on the
+ * class of the receiver instead.
+ */
+- (BOOL) isInstance;
+
+/** DEPRECATED ... do not use.
+ * Transmutes the receiver into an immutable version of the same object
+ * and returns the result.<br />
+ * If the receiver is not a mutable object or cannot be simply transmuted,
+ * then this method either returns the receiver unchanged or,
+ * if the force flag is set to YES, returns an autoreleased copy of the
+ * receiver.<br />
+ * Mutable classes should override this default implementation.<br />
+ * This method is used in methods which are declared to return immutable
+ * objects (eg. an NSArray), but which create and build mutable ones
+ * internally.
+ */
+- (id) makeImmutableCopyOnFail: (BOOL)force;
+
+/** Transmutes the receiver into an immutable version of the same object.
+ * Returns YES if the receiver has become immutable, NO otherwise.<br />
+ * The default implementation returns NO.<br />
+ * Mutable classes which have an immutable counterpart they can efficiently
+ * change into, should override to transmute themselves and return YES.<br />
+ * Immutable classes should override this to simply return YES with no
+ * further action.<br />
+ * This method is used in methods which are declared to return immutable
+ * objects (eg. an NSArray), but which create and build mutable ones
+ * internally.
+ */
+- (BOOL) makeImmutable;
+
+/**
+ * Message sent when an implementation wants to explicitly exclude a method
+ * (but cannot due to compiler constraint), and wants to make sure it is not
+ * called by mistake.  Default implementation raises an exception at runtime.
+ */
+- (id) notImplemented: (SEL)aSel GS_NORETURN_METHOD;
+
+/**
+ * Message sent when an implementation wants to explicitly require a subclass
+ * to implement a method (but cannot at compile time since there is no
+ * <code>abstract</code> keyword in Objective-C).  Default implementation
+ * raises an exception at runtime to alert developer that he/she forgot to
+ * override a method.
+ */
+- (id) subclassResponsibility: (SEL)aSel GS_NORETURN_METHOD;
+
+/**
+ * Message sent when an implementation wants to explicitly exclude a method
+ * (but cannot due to compiler constraint) and forbid that subclasses
+ * implement it.  Default implementation raises an exception at runtime.  If a
+ * subclass <em>does</em> implement this method, however, the superclass's
+ * implementation will not be called, so this is not a perfect mechanism.
+ */
+- (id) shouldNotImplement: (SEL)aSel GS_NORETURN_METHOD;
+
+@end
+
+/** This is an informal protocol ... classes may implement the method to
+ * report how much memory is used by the instance and any objects it acts
+ * as a container for.
+ */
+@interface      NSObject(MemoryFootprint)
+/* This method returns the memory usage of the receiver, excluding any
+ * objects already present in the exclude table.<br />
+ * The argument is a hash table configured to hold non-retained pointer
+ * objects and is used to inform the receiver that its size should not
+ * be counted again if it's already in the table.<br />
+ * The NSObject implementation returns zero if the receiver is in the
+ * table, but otherwise adds itself to the table and returns its memory
+ * footprint (the sum of all of its instance variables, but not any
+ * memory pointed to by those variables).<br />
+ * Subclasses should override this method by calling the superclass
+ * implementation, and either return the result (if it was zero) or
+ * return that value plus the sizes of any memory owned by the receiver
+ * (eg found by calling the same method on objects pointed to by the
+ * receiver's instance variables).
+ */
+- (NSUInteger) sizeInBytesExcluding: (NSHashTable*)exclude;
+@end
+
+/** This is an informal protocol ... classes may implement the method and
+ * register themselves to have it called on process exit.
+ */
+@interface NSObject(GSAtExit)
+/** This method is called on exit for any class which implements it and which
+ * has called +registerAtExit to register it to be called.<br />
+ * The order in which methods for different classes is called is the reverse
+ * of the order in which the classes were registered, but it's best to assume
+ * the method can not depend on any other class being in a usable state
+ * at the point when the method is called (rather like +load).<br />
+ * Typical use would be to release memory occupied by class data structures
+ * so that memory usage analysis software will not think the memory has
+ * been leaked.
+ */
++ (void) atExit;
+@end
+
+/** Category for methods handling leaked memory cleanup on exit of process
+ * (for use when debugging memory leaks).<br />
+ * You enable this by calling the +setShouldCleanUp: method (done implicitly
+ * by gnustep-base if the GNUSTEP_SHOULD_CLEAN_UP environment variable is
+ * set to YES).<br />
+ * Your class then has two options for performing cleanup when the process
+ * ends:
+ * <p>1. Use the +leak: method to register objects which are simply to be 
+ * retained until the process ends, and then either ignored or released
+ * depending on the cleanup setting in force.  This mechanism is simple
+ * and should be sufficient for many classes.
+ * </p>
+ * <p>2. Implement a +atExit method to be run when the process ends and,
+ * within your +initialize implementation, call +shouldCleanUp to determine
+ * whether cleanup should be done, and if it returns YES then call
+ * +registerAtExit to have your +atExit method called when the process
+ * terminates.
+ * </p>
+ * <p>The order in which 'leaked' objects are released and +atExit methods
+ * are called on process exist is the reverse of the order in which they
+ * werse set up suing this API.
+ * </p>
+ */
+@interface NSObject(GSCleanup)
+
+
+/** This method simply retains its argument so that it will never be
+ * deallocated during normal operation, but keeps track of it so that
+ * it is released during process exit if cleanup is enabled.<br />
+ * Returns its argument.
+ */
++ (id) NS_RETURNS_RETAINED leak: (id)anObject;
+
+/** This method retains the object at *anAddress so that it will never be
+ * deallocated during normal operation, but keeps track of the address
+ * so that the object is released and the address is zeroed during process
+ * exit if cleanup is enabled.<br />
+ * Returns the object at *anAddress.
+ */
++ (id) NS_RETURNS_RETAINED leakAt: (id*)anAddress;
+
+/** Sets the receiver to have its +atExit method called at the point when
+ * the process terminates.<br />
+ * Returns YES on success and NO on failure (if the class does not implement
+ * the method or if it is already registered to call it).<br />
+ * Implemented as a call to +registerAtExit: with the selector for the +atExit
+ * method as its argument.
+ */
++ (BOOL) registerAtExit;
+
+/** Sets the receiver to have the specified  method called at the point when
+ * the process terminates.<br />
+ * Returns YES on success and NO on failure (if the class does not implement
+ * the method ir if it is already registered to call it).
+ */
++ (BOOL) registerAtExit: (SEL)aSelector;
+
+/** Specifies the default cleanup behavior on process exit ... the value
+ * returned by the NSObject implementation of the +shouldClanUp method.<br />
+ * Calling this method with a YES argument implicitly calls the +enableAtExit
+ * method as well.<br />
+ * The GNUstep Base library calls this method with the value obtained from
+ * the GNUSTEP_SHOULD_CLEAN_UP environment variable when NSObject is
+ * initialised.
+ */
++ (void) setShouldCleanUp: (BOOL)aFlag;
+
+/** Returns a flag indicating whether the receiver should clean up
+ * its data structures etc at process exit.<br />
+ * The NSObject implementation returns the value set by the +setShouldCleanUp:
+ * method but subclasses may override this.
+ */
++ (BOOL) shouldCleanUp;
+
+@end
+
+/* Macro to take an autoreleased object and either make it immutable or
+ * create an autoreleased copy of the original.
+ */
+#define GS_IMMUTABLE(O) ([O makeImmutable] == YES ? O : AUTORELEASE([O copy]))
+
+#endif	/* OS_API_VERSION */
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#endif	/* INCLUDED_NSObject_GNUstepBase_h */
+
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSString+GNUstepBase.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSString+GNUstepBase.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSString+GNUstepBase.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,105 @@
+/** Declaration of extension methods for base additions
+
+   Copyright (C) 2003-2010 Free Software Foundation, Inc.
+
+   Written by:  Richard Frith-Macdonald <rfm@gnu.org>
+   and:         Adam Fedor <fedor@gnu.org>
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+
+*/
+
+#ifndef	INCLUDED_NSString_GNUstepBase_h
+#define	INCLUDED_NSString_GNUstepBase_h
+
+#import "GSVersionMacros.h"
+#import "../Foundation/NSString.h"
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+#if	OS_API_VERSION(GS_API_NONE,GS_API_LATEST)
+
+/**
+ * Provides some additional (non-standard) utility methods.
+ */
+@interface NSString (GNUstepBase)
+
+/**
+ * Alternate way to invoke <code>stringWithFormat</code> if you have or wish
+ * to build an explicit <code>va_list</code> structure.
+ */
++ (id) stringWithFormat: (NSString*)format
+	      arguments: (va_list)argList NS_FORMAT_FUNCTION(1,0);
+
+/**
+ * Returns a string formed by removing the prefix string from the
+ * receiver.  Raises an exception if the prefix is not present.
+ */
+- (NSString*) stringByDeletingPrefix: (NSString*)prefix;
+
+/**
+ * Returns a string formed by removing the suffix string from the
+ * receiver.  Raises an exception if the suffix is not present.
+ */
+- (NSString*) stringByDeletingSuffix: (NSString*)suffix;
+
+/**
+ * Returns a string formed by removing leading white space from the
+ * receiver.
+ */
+- (NSString*) stringByTrimmingLeadSpaces;
+
+/**
+ * Returns a string formed by removing trailing white space from the
+ * receiver.
+ */
+- (NSString*) stringByTrimmingTailSpaces;
+
+/**
+ * Returns a string formed by removing both leading and trailing
+ * white space from the receiver.
+ */
+- (NSString*) stringByTrimmingSpaces;
+
+/**
+ * Returns a string in which any (and all) occurrences of
+ * replace in the receiver have been replaced with by.
+ * Returns the receiver if replace
+ * does not occur within the receiver.  NB. an empty string is
+ * not considered to exist within the receiver.
+ */
+- (NSString*) stringByReplacingString: (NSString*)replace
+			   withString: (NSString*)by;
+
+/**
+ * An obsolete name for -substringWithRange: ... deprecated.
+ */
+- (NSString*) substringFromRange: (NSRange)aRange;
+
+@end
+
+#endif	/* OS_API_VERSION */
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#endif	/* INCLUDED_NSString_GNUstepBase_h */
+
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSVersionMacros.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSVersionMacros.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSVersionMacros.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,460 @@
+/* GSVersionMacros.h - macros for managing API versioning and visibility
+   Copyright (C) 2006-2014 Free Software Foundation, Inc.
+
+   Written by: Richard Frith-Macdonald <rfm@gnu.org>
+   Date: Oct, October 2006
+
+   This file is part of GNUstep.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef __GNUSTEP_GSVERSIONMACROS_H_INCLUDED_
+#define __GNUSTEP_GSVERSIONMACROS_H_INCLUDED_
+
+/* By default we defined NO_GNUSTEP to 0 so that we will include extensions.
+ */
+#if	!defined(NO_GNUSTEP)
+#  define	NO_GNUSTEP	0
+#endif
+
+/* Check consistency of definitions for system compatibility.
+ */
+#if	defined(STRICT_OPENSTEP)
+#  define	GS_OPENSTEP_V	 10000
+#  undef	NO_GNUSTEP
+#  define	NO_GNUSTEP	1
+#elif	defined(STRICT_MACOS_X)
+#  define	GS_OPENSTEP_V	100600
+#  undef	NO_GNUSTEP
+#  define	NO_GNUSTEP	1
+#endif
+
+/* Define the GS_OSX_ADJUST() macro to adjust OSX style version macros
+ * to GNUstep style version macros.
+ */
+#define	GS_OSX_ADJUST(V) ((V) >= 10000 ? (V) : ((V)/100*10000 + (V)%100*10))
+
+/* Define OSX compatibility version macros if necessary.
+ */
+#if     !defined(MAC_OS_X_VERSION_10_0)
+#define	MAC_OS_X_VERSION_10_0	1000
+#define	MAC_OS_X_VERSION_10_1	1010
+#define	MAC_OS_X_VERSION_10_2	1020
+#define	MAC_OS_X_VERSION_10_3	1030
+#define	MAC_OS_X_VERSION_10_4	1040
+#define	MAC_OS_X_VERSION_10_5	1050
+#define	MAC_OS_X_VERSION_10_6	1060
+#define	MAC_OS_X_VERSION_10_7	1070
+#define	MAC_OS_X_VERSION_10_8	1080
+#define	MAC_OS_X_VERSION_10_9	1090
+#define MAC_OS_X_VERSION_10_10	1100
+#define MAC_OS_X_VERSION_10_11	1110
+#define MAC_OS_X_VERSION_10_12	1120
+#define MAC_OS_X_VERSION_10_13	1130
+#define MAC_OS_X_VERSION_10_14	1140
+#endif	/* MAC_OS_X_VERSION_10_0 */
+
+/* Allow MAC_OS_X_VERSION_MAX_ALLOWED to be used in place of GS_OPENSTEP_V
+ * if GS_OPENSTEP_V is not defined.
+ */
+#ifndef	GS_OPENSTEP_V
+#ifdef	MAC_OS_X_VERSION_MAX_ALLOWED
+#define	GS_OPENSTEP_V	GS_OSX_ADJUST(MAC_OS_X_VERSION_MAX_ALLOWED)
+#endif	/* MAC_OS_X_VERSION_MAX_ALLOWED */
+#endif	/* GS_OPENSTEP_V */
+
+/*
+ * NB. The version values below must be integers ... by convention these are
+ * made up of two digits each for major, minor and subminor version numbers
+ * (ie each is in the range 00 to 99 though a leading zero in the major
+ * number is not permitted).
+ * So for a MacOS-X 10.3.9 release the version number would be 100309
+ *
+ * You may define GS_GNUSTEP_V or GS_OPENSTEP_V to ensure that your
+ * program only 'sees' the specified varsion of the API.
+ */
+
+/**
+ * <p>Macro to check a defined GNUstep version number (GS_GNUSTEP_V) against
+ * the supplied arguments.  Returns true if no GNUstep version is specified,
+ * or if ADD &lt;= version &lt; REM, where ADD is the version
+ * number at which a feature guarded by the macro was introduced and
+ * REM is the version number at which it was removed.
+ * </p>
+ * <p>The version number arguments are six digit integers where the first
+ * two digits are the major version number, the second two are the minor
+ * version number and the last two are the subminor number (all left padded
+ * with a zero where necessary).  However, for convenience you can also
+ * use the predefined constants ...
+ * <ref type="macro" id="GS_API_NONE">GS_API_NONE</ref>,
+ * <ref type="macro" id="GS_API_LATEST">GS_API_LATEST</ref>,
+ * </p>
+ * <p>Also see <ref type="macro" id="OS_API_VERSION">OS_API_VERSION</ref>
+ * </p>
+ * <p>NB. If you are changing the API (eg adding a new feature) you need
+ * to control the visibility io the new header file code using<br />
+ * <code>#if GS_API_VERSION(ADD,GS_API_LATEST)</code><br />
+ * where <code>ADD</code> is the version number of the next minor
+ * release after the most recent one.<br />
+ * As a general principle you should <em>not</em> change the API with
+ * changing subminor version numbers ... as that tends to confuse
+ * people (though Apple has sometimes done it).
+ * </p>
+ */
+#define	GS_API_VERSION(ADD,REM) \
+  (!defined(GS_GNUSTEP_V) || (GS_GNUSTEP_V >= ADD && GS_GNUSTEP_V < REM))
+
+/**
+ * <p>Macro to check a defined OpenStep/OPENSTEP/MacOS-X version against the
+ * supplied arguments.  Returns true if no version is specified, or if
+ * ADD &lt;= version &lt; REM, where ADD is the version
+ * number at which a feature guarded by the macro was introduced and
+ * REM is the version number at which it was removed.
+ * </p>
+ * <p>The version number arguments are six digit integers where the first
+ * two digits are the major version number, the second two are the minor
+ * version number and the last two are the subminor number (all left padded
+ * with a zero where necessary).  However, for convenience you can also
+ * use any of several predefined constants ...
+ * <ref type="macro" id="GS_API_NONE">GS_API_NONE</ref>,
+ * <ref type="macro" id="GS_API_LATEST">GS_API_LATEST</ref>,
+ * <ref type="macro" id="GS_API_OSSPEC">GS_API_OSSPEC</ref>,
+ * <ref type="macro" id="GS_API_OPENSTEP">GS_API_OPENSTEP</ref>,
+ * <ref type="macro" id="GS_API_MACOSX">GS_API_MACOSX</ref>
+ * </p>
+ * <p>Also see <ref type="macro" id="GS_API_VERSION">GS_API_VERSION</ref>
+ * </p>
+ * <p>For OSX compatibility, this macro also supports the use of Apple's
+ * symbolic constants for version numbering.  Their contants are currently
+ * four digit values (two digits for the major version, one for the minor,
+ * and one for the subminor). 
+ * </p>
+ * <p>The Apple compatibility version macros are currently:
+ * <ref type="macro" id="MAC_OS_X_VERSION_10_0">MAC_OS_X_VERSION_10_0</ref>,
+ * <ref type="macro" id="MAC_OS_X_VERSION_10_1">MAC_OS_X_VERSION_10_1</ref>,
+ * <ref type="macro" id="MAC_OS_X_VERSION_10_2">MAC_OS_X_VERSION_10_2</ref>,
+ * <ref type="macro" id="MAC_OS_X_VERSION_10_3">MAC_OS_X_VERSION_10_3</ref>,
+ * <ref type="macro" id="MAC_OS_X_VERSION_10_4">MAC_OS_X_VERSION_10_4</ref>,
+ * <ref type="macro" id="MAC_OS_X_VERSION_10_5">MAC_OS_X_VERSION_10_5</ref>,
+ * <ref type="macro" id="MAC_OS_X_VERSION_10_6">MAC_OS_X_VERSION_10_6</ref>,
+ * <ref type="macro" id="MAC_OS_X_VERSION_10_7">MAC_OS_X_VERSION_10_7</ref>,
+ * <ref type="macro" id="MAC_OS_X_VERSION_10_8">MAC_OS_X_VERSION_10_8</ref>
+ * <ref type="macro" id="MAC_OS_X_VERSION_10_9">MAC_OS_X_VERSION_10_9</ref>
+ * </p>
+ */
+#define	OS_API_VERSION(ADD,REM) \
+  (!defined(GS_OPENSTEP_V) \
+  || (GS_OPENSTEP_V>=GS_OSX_ADJUST(ADD) && GS_OPENSTEP_V<GS_OSX_ADJUST(REM)))
+
+/**
+ * A constant which is the lowest possible version number (0) so that
+ * when used as the removal version (second argument of the GS_API_VERSION
+ * or OS_API_VERSION macro) represents a feature which is not present in
+ * any version.<br />
+ * eg.<br />
+ * #if <ref type="macro" id="OS_API_VERSION">OS_API_VERSION</ref>
+ * (GS_API_NONE, GS_API_NONE)<br />
+ * denotes  code not present in OpenStep/OPENSTEP/MacOS-X
+ */
+#define	GS_API_NONE	     0
+
+/**
+ * A constant to represent a feature which is still present in the latest
+ * version.  This is the highest possible version number.<br />
+ * eg.<br />
+ * #if <ref type="macro" id="OS_API_VERSION">OS_API_VERSION</ref>
+ * (GS_API_MACOSX, GS_API_LATEST)<br />
+ * denotes code present from the initial MacOS-X version onwards.
+ */
+#define	GS_API_LATEST	999999
+
+/**
+ * The version number of the initial OpenStep specification.<br />
+ * eg.<br />
+ * #if <ref type="macro" id="OS_API_VERSION">OS_API_VERSION</ref>
+ * (GS_API_OSSPEC, GS_API_LATEST)<br />
+ * denotes code present from the OpenStep specification onwards.
+ */
+#define	GS_API_OSSPEC	 10000
+
+/**
+ * The version number of the first OPENSTEP implementation.<br />
+ * eg.<br />
+ * #if <ref type="macro" id="OS_API_VERSION">OS_API_VERSION</ref>
+ * (GS_API_OPENSTEP, GS_API_LATEST)<br />
+ * denotes code present from the initial OPENSTEP version onwards.
+ */
+#define	GS_API_OPENSTEP	 40000
+
+/**
+ * The version number of the first MacOS-X implementation.<br />
+ * eg.<br />
+ * #if <ref type="macro" id="OS_API_VERSION">OS_API_VERSION</ref>
+ * (GS_API_MACOSX, GS_API_LATEST)<br />
+ * denotes code present from the initial MacOS-X version onwards.
+ */
+#define	GS_API_MACOSX	100000
+
+/* Allow OSX code comparing MAC_OS_X_VERSION_MAX_ALLOWED with a specific
+ * version to see if that version is allowed, to always have it allowed
+ * on GNUstep.
+ */
+#ifndef	MAC_OS_X_VERSION_MAX_ALLOWED
+#define	MAC_OS_X_VERSION_MAX_ALLOWED    GS_API_LATEST
+#endif  /* MAC_OS_X_VERSION_MAX_ALLOWED */
+
+
+#if	defined(GNUSTEP_BASE_INTERNAL)
+#include "GNUstepBase/GSConfig.h"
+#else
+#include "GSConfig.h"
+#endif
+
+
+#if defined(__GNUC__) && defined(__GNUC_MINOR__) && !defined(__clang__)
+#  define GS_GCC_MINREQ(maj, min) \
+  ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
+#else
+#  define GS_GCC_MINREQ(maj, min) 0
+#endif
+
+#if defined(__clang__)
+#  define GS_CLANG_MINREQ(maj, min) \
+  ((__clang_major__ << 16) + __clang_minor__ >= ((maj) << 16) + (min))
+#else
+#  define GS_CLANG_MINREQ(maj, min) 0
+#endif
+
+/* Attribute definitions for attributes which may or may not be supported
+ * depending on the compiler being used.
+ * NB we currently expect gcc to be version 4 or later.
+ *
+ * The definition should be of the form GS_XXX_CONTEXT where XXX is the
+ * name of the attribute and CONTEXT is one of FUNC, METH, or IVAR
+ * depending on where the attribute can be applied.
+ */
+
+#if defined(__clang__) || GS_GCC_MINREQ(3,1)
+#  define GS_DEPRECATED_FUNC __attribute__ ((deprecated))
+#else
+#  define GS_DEPRECATED_FUNC
+#endif
+
+#define GS_UNUSED_ARG __attribute__((unused))
+
+#define GS_UNUSED_FUNC __attribute__((unused))
+
+// FIXME ... what version of gcc?
+#if __clang__
+#  define GS_UNUSED_IVAR __attribute__((unused))
+#else
+#  define GS_UNUSED_IVAR 
+#endif
+
+
+
+#ifndef __has_feature
+#define __has_feature(x) 0
+#endif
+
+/* The following is for deciding whether private instance variables
+ * should be visible ... if we are building with a compiler which
+ * does not define __has_feature then we know we don't have non-fragile
+ * ivar support.
+ * In the header we bracket instance variable declarations in a
+ * '#if	GS_EXPOSE(classname) ... #endif' sequence, so that the variables
+ * will not be visible to code which uses the library.
+ * In the source file we define EXPOSE_classname_IVARS to be 1
+ * before including the header, so that the ivars are always available
+ * in the class source itsself
+ */
+
+#if	GS_MIXEDABI
+#  undef	GS_NONFRAGILE
+#  define	GS_NONFRAGILE	0	/* Mixed is treated as fragile */
+#else
+#  if (__has_feature(objc_nonfragile_abi))
+#    if	!GS_NONFRAGILE
+#      if	defined(GNUSTEP_BASE_INTERNAL)
+#        error "You are building gnustep-base using the objc-nonfragile-abi but your gnustep-base was not configured to use it."
+#      endif
+#    endif
+#  else
+#    if	GS_NONFRAGILE
+#      error "Your gnustep-base was configured for the objc-nonfragile-abi but you are not using it now."
+#    endif
+#  endif
+#endif
+
+#define	GS_EXPOSE(X)	(!GS_NONFRAGILE || defined(EXPOSE_##X##_IVARS))
+
+/* Static analyser macros: Provide annotations to help the analyser */
+#ifdef __clang__
+#  define GS_NORETURN_METHOD __attribute__((__noreturn__))
+#else
+#  define GS_NORETURN_METHOD
+#endif
+
+#ifndef NS_RETURNS_RETAINED
+#  if __has_feature(attribute_ns_returns_retained)
+#    define NS_RETURNS_RETAINED __attribute__((ns_returns_retained))
+#  else
+#    define NS_RETURNS_RETAINED
+#  endif
+#endif
+
+#ifndef NS_RETURNS_NOT_RETAINED
+#  if __has_feature(attribute_ns_returns_not_retained)
+#    define NS_RETURNS_NOT_RETAINED __attribute__((ns_returns_not_retained))
+#  else
+#    define NS_RETURNS_NOT_RETAINED
+#  endif
+#endif
+
+#ifndef NS_CONSUMED
+#  if __has_feature(attribute_ns_consumed)
+#    define NS_CONSUMED __attribute__((ns_consumed))
+#  else
+#    define NS_CONSUMED
+#  endif
+#endif
+
+
+#ifndef NS_CONSUMES_SELF
+#  if __has_feature(attribute_ns_consumes_self)
+#    define NS_CONSUMES_SELF __attribute__((ns_consumes_self))
+#  else
+#    define NS_CONSUMES_SELF
+#  endif
+#endif
+
+#if defined(__clang__) && defined(__OBJC__)
+static inline void gs_consumed(id NS_CONSUMED o) GS_UNUSED_FUNC;
+static inline void gs_consumed(id NS_CONSUMED GS_UNUSED_ARG o) { return; }
+#define	GS_CONSUMED(O)	gs_consumed(O);
+#else
+#define	GS_CONSUMED(O)
+#endif
+
+/* Include the appropriate header for ObjC2 blocks support if it is in use.
+ *
+ * FIXME: "OBJC2RUNTIME" is set to "1" if the runtime supports the ObjC2
+ * runtime API, which is unrelated to whether the compiler has blocks
+ * support or not.
+ */
+#if __has_feature(blocks)
+#  if	OBJC2RUNTIME
+#    if defined(__APPLE__)
+#      include <Block.h>
+#    else
+#      include <objc/blocks_runtime.h>
+#    endif
+#  else
+#    include <ObjectiveC2/blocks_runtime.h>
+#  endif
+#endif
+
+/* Attribute definition for root classes, annotates the interface declaration
+ * of the class.
+ */
+#ifndef GS_ROOT_CLASS
+#  if GS_HAVE_OBJC_ROOT_CLASS_ATTR || __has_feature(attribute_objc_root_class)
+#    define GS_ROOT_CLASS __attribute__((objc_root_class))
+#  else
+#    define GS_ROOT_CLASS
+#  endif
+#endif
+
+
+
+#if	defined(GNUSTEP_WITH_DLL)
+
+#if BUILD_libgnustep_base_DLL
+#
+# if defined(__MINGW__)
+  /* On Mingw, the compiler will export all symbols automatically, so
+   * __declspec(dllexport) is not needed.
+   */
+#  define GS_EXPORT  extern
+#  define GS_DECLARE
+# else
+#  define GS_EXPORT  __declspec(dllexport)
+#  define GS_DECLARE __declspec(dllexport)
+# endif
+#else
+#  define GS_EXPORT  extern __declspec(dllimport)
+#  define GS_DECLARE __declspec(dllimport)
+#endif
+
+#else /* GNUSTEP_WITH[OUT]_DLL */
+
+#  define GS_EXPORT extern
+#  define GS_DECLARE
+
+#endif
+
+
+/* Attribute macros compatible with Apple.
+ */
+
+#ifndef NS_FORMAT_ARGUMENT
+#if defined(__clang__) || GS_GCC_MINREQ(4,2)
+#  define NS_FORMAT_ARGUMENT(A) __attribute__((format_arg(A)))
+#else
+#  define NS_FORMAT_ARGUMENT(F,A) 
+#endif
+#endif
+
+// FIXME ... what version of gcc?
+#ifndef NS_FORMAT_FUNCTION
+#if __clang__
+#  define NS_FORMAT_FUNCTION(F,A) __attribute__((format(__NSString__, F, A)))
+#else
+#  define NS_FORMAT_FUNCTION(F,A) 
+#endif
+#endif
+
+#ifndef NS_REQUIRES_NIL_TERMINATION
+#define NS_REQUIRES_NIL_TERMINATION __attribute__((sentinel))
+#endif
+
+// FIXME ... what exact version of clang and gcc?
+#ifndef UNAVAILABLE_ATTRIBUTE
+#if defined(__clang__) || GS_GCC_MINREQ(4,0)
+#  define UNAVAILABLE_ATTRIBUTE __attribute__((unavailable))
+#else
+#  define UNAVAILABLE_ATTRIBUTE
+#endif
+#endif
+
+/* Check if compiler supports @optional in protocols
+ */
+#if defined(__clang__) || GS_GCC_MINREQ(4,6)
+#  define GS_PROTOCOLS_HAVE_OPTIONAL 1
+#else
+#  define GS_PROTOCOLS_HAVE_OPTIONAL 0
+#endif
+
+/* Check if compiler supports declared properties
+ */
+#if defined(__clang__) || GS_GCC_MINREQ(4,6)
+#  define GS_HAS_DECLARED_PROPERTIES 1
+#else
+#  define GS_HAS_DECLARED_PROPERTIES 0
+#endif
+
+#endif /* __GNUSTEP_GSVERSIONMACROS_H_INCLUDED_ */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GNUstep.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GNUstep.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GNUstep.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,418 @@
+/* GNUstep.h - macros to make easier to port gnustep apps to macos-x
+   Copyright (C) 2001 Free Software Foundation, Inc.
+
+   Written by: Nicola Pero <n.pero@mi.flashnet.it>
+   Date: March, October 2001
+   
+   This file is part of GNUstep.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+   
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/ 
+
+#ifndef __GNUSTEP_GNUSTEP_H_INCLUDED_
+#define __GNUSTEP_GNUSTEP_H_INCLUDED_
+
+/* The contents of this file are designed to be usable with either
+ * GNUstep-base or MacOS-X Foundation.
+ */
+
+#ifndef __has_feature
+#  define __has_feature(x) 0
+#endif
+
+/*
+ * __has_extension has slightly different semantics from __has_feature.
+ * It evaluates to true if the feature is supported by by clang for the
+ * current compilation unit (language and -f switches), regardless of 
+ * whether it is part of the language standard or just a (non-standard)
+ * extension.
+ */
+#ifndef __has_extension
+#  define __has_extension(x) __has_feature(x)
+#endif
+
+/*
+ * __has_attribute is the equivalent to __has_feature and __has_extension
+ * for GNU-style attributes.
+ */
+#ifndef __has_attribute
+#  define __has_attribute(x) 0
+#endif
+
+#if	__has_feature(objc_arc)
+
+#ifndef	RETAIN
+#define	RETAIN(object)		        (object)
+#endif
+#ifndef	RELEASE
+#define	RELEASE(object)		
+#endif
+#ifndef	AUTORELEASE
+#define	AUTORELEASE(object)	        (object)
+#endif
+
+#ifndef	TEST_RETAIN
+#define	TEST_RETAIN(object)	        (object)
+#endif
+#ifndef	TEST_RELEASE
+#define	TEST_RELEASE(object)
+#endif
+#ifndef	TEST_AUTORELEASE
+#define	TEST_AUTORELEASE(object)	(object)
+#endif
+
+#ifndef	ASSIGN
+#define	ASSIGN(object,value)	        object = (value)
+#endif
+#ifndef	ASSIGNCOPY
+#define	ASSIGNCOPY(object,value)	object = [(value) copy]
+#endif
+#ifndef	DESTROY
+#define	DESTROY(object) 	        object = nil
+#endif
+
+#define	IF_NO_GC(X)	
+
+#ifndef ENTER_POOL
+#define ENTER_POOL                      @autoreleasepool{do{
+#endif
+
+#ifndef LEAVE_POOL
+#define LEAVE_POOL                      }while(0);}
+#endif
+
+#ifndef DEALLOC
+#define DEALLOC
+#endif
+
+#else
+
+#ifndef	RETAIN
+/**
+ *	Basic retain operation ... calls [NSObject-retain]<br />
+ *	Deprecated ... pointless on modern processors.
+ *	Simply call the -retain method.
+ */
+#define	RETAIN(object)		[(object) retain]
+#endif
+
+#ifndef	RELEASE
+/**
+ *	Basic release operation ... calls [NSObject-release]<br />
+ *	Deprecated ... pointless on modern processors.
+ *	Simply call the -release method.
+ */
+#define	RELEASE(object)		[(object) release]
+#endif
+
+#ifndef	AUTORELEASE
+/**
+ *	Basic autorelease operation ... calls [NSObject-autorelease]<br />
+ *	Deprecated ... pointless on modern processors.
+ *	Simply call the -autorelease method.
+ */
+#define	AUTORELEASE(object)	[(object) autorelease]
+#endif
+
+#ifndef	TEST_RETAIN
+/**
+ *	Tested retain - only invoke the
+ *	objective-c method if the receiver is not nil.<br />
+ *	Deprecated ... pointless on modern processors.
+ *	Simply call the -retain method.
+ */
+#define	TEST_RETAIN(object)	({\
+id __object = (object); (__object != nil) ? [__object retain] : nil; })
+#endif
+
+#ifndef	TEST_RELEASE
+/**
+ *	Tested release - only invoke the
+ *	objective-c method if the receiver is not nil.<br />
+ *	Deprecated ... pointless on modern processors.
+ *	Simply call the -release method.
+ */
+#define	TEST_RELEASE(object)	({\
+id __object = (object); if (__object != nil) [__object release]; })
+#endif
+
+#ifndef	TEST_AUTORELEASE
+/**
+ *	Tested autorelease - only invoke the
+ *	objective-c method if the receiver is not nil.<br />
+ *	Deprecated ... pointless on modern processors.
+ *	Simply call the -autorelease method.
+ */
+#define	TEST_AUTORELEASE(object)	({\
+id __object = (object); (__object != nil) ? [__object autorelease] : nil; })
+#endif
+
+#ifndef	ASSIGN
+/**
+ *	ASSIGN(object,value) assigns the value to the object with
+ *	appropriate retain and release operations.<br />
+ *	Use this to avoid retain/release errors.
+ */
+#define	ASSIGN(object,value)	({\
+  id __object = object; \
+  object = [(value) retain]; \
+  [__object release]; \
+})
+#endif
+
+#ifndef	ASSIGNCOPY
+/**
+ *	ASSIGNCOPY(object,value) assigns a copy of the value to the object
+ *	with release of the original.<br />
+ *	Use this to avoid retain/release errors.
+ */
+#define	ASSIGNCOPY(object,value)	({\
+  id __object = object; \
+  object = [(value) copy];\
+  [__object release]; \
+})
+#endif
+
+#ifndef	DESTROY
+/**
+ *	DESTROY() is a release operation which also sets the variable to be
+ *	a nil pointer for tidiness - we can't accidentally use a DESTROYED
+ *	object later.  It also makes sure to set the variable to nil before
+ *	releasing the object - to avoid side-effects of the release trying
+ *	to reference the object being released through the variable.
+ */
+#define	DESTROY(object) 	({ \
+  id __o = object; \
+  object = nil; \
+  [__o release]; \
+})
+#endif
+
+#define	IF_NO_GC(X)	X
+
+#ifndef ENTER_POOL
+/**
+ *	ENTER_POOL creates an autorelease pool and places subsequent code
+ *	in a do/while loop (executed only once) which can be broken out of
+ *	to reach the point when the pool is drained.<br />
+ *	The block must be terminated with a corresponding LEAVE_POOL.<br />
+ *	You should not return from such a block of code (to do so could
+ *	leak an autorelease pool and give objects a longer lifetime than
+ *	they ought to have.  If you wish to leave the block of code early,
+ *	you may do so using a 'break' statement.
+ */
+#define ENTER_POOL      {NSAutoreleasePool *_lARP=[NSAutoreleasePool new];do{
+#endif
+
+#ifndef LEAVE_POOL
+/**
+ *	LEAVE_POOL terminates a block of code started with ENTER_POOL.
+ */
+#define LEAVE_POOL      }while(0);[_lARP drain];}
+#endif
+
+#ifndef DEALLOC
+/**
+ *	DEALLOC calls the superclass implementation of dealloc, unless
+ *	ARC is in use (in which case it does nothing).
+ */
+#define DEALLOC         [super dealloc];
+#endif
+#endif
+
+#ifndef	CREATE_AUTORELEASE_POOL
+/** DEPRECATED ... use ENTER_POOL and LEAVE_POOL
+ */
+#define	CREATE_AUTORELEASE_POOL(X)	\
+  NSAutoreleasePool *X = [NSAutoreleasePool new]
+#endif
+
+#ifndef RECREATE_AUTORELEASE_POOL
+/** DEPRECATED ... use ENTER_POOL and LEAVE_POOL
+ */
+#define RECREATE_AUTORELEASE_POOL(X)  \
+  DESTROY(X);\
+  X = [NSAutoreleasePool new]
+#endif
+
+
+/**
+ * <p>
+ *   This function (macro) is a GNUstep extension.
+ * </p>
+ * <p>
+ *   <code>_(@"My string to translate")</code>
+ * </p>
+ * <p>
+ *   is basically equivalent to
+ * </p>
+ * <p>
+ *   <code>NSLocalizedString(@"My string to translate", @"")</code>
+ * </p>
+ * <p>
+ * It is useful when you need to translate an application
+ * very quickly, as you just need to enclose all strings
+ * inside <code>_()</code>.  But please note that when you
+ * use this macro, you are not taking advantage of comments
+ * for the translator, so consider using
+ * <code>NSLocalizedString</code> instead when you need a
+ * comment.
+ * </p>
+ * <p>You may define GS_LOCALISATION_BUNDLE_ID to the bundle identifier
+ * of the bundle which is to provide the localisation information.<br />
+ * This can be used when compiling a single file by specifying something like
+ * '-D GS_LOCALISATION_BUNDLE_ID=$(FRAMEWORK_NAME)' in your make file.<br />
+ * If this is not defined, the localisation is provided by your application's
+ * main bundle exactly like the NSLocalizedString function.
+ * </p>
+ * <p>Alternatively you may define GS_LOCALISATION_BUNDLE to be the bundle
+ * to be used to prvide the localisation information.
+ * </p>
+ */
+# define _(X) \
+  [GS_LOCALISATION_BUNDLE localizedStringForKey: (X) value: @"" table: nil]
+
+#if	!defined(GS_LOCALISATION_BUNDLE)
+# if	defined(GS_LOCALISATION_BUNDLE_ID)
+#   define	GS_LOCALISATION_BUNDLE	[NSBundle bundleWithIdentifier: \
+  GS_LOCALISATION_BUNDLE_ID]
+# else
+#   define	GS_LOCALISATION_BUNDLE	[NSBundle mainBundle]
+# endif
+#endif
+
+
+ 
+/**
+ * <p>
+ *   This function (macro) is a GNUstep extension.
+ * </p>
+ * <p>
+ *   <code>__(@"My string to translate")</code>
+ * </p>
+ * <p>
+ *   is exactly the same as
+ * </p>
+ * <p>
+ *   <code>GSLocalizedStaticString(@"My string to translate", @"")</code>
+ * </p>
+ * <p>
+ *   It is useful when you need to translate an application very
+ *   quickly.  You would use it as follows for static strings:
+ * </p>
+ * <p>
+ *  <code>
+ *    NSString *message = __(@"Hello there");
+ *    ... more code ...
+ *    NSLog (_(messages));
+ *  </code>
+ * </p>
+ * <p>
+ *   But please note that when you use this macro, you are not
+ *   taking advantage of comments for the translator, so
+ *   consider using <code>GSLocalizedStaticString</code>
+ *   instead when you need a comment.
+ * </p>
+ */
+#define __(X) X
+
+/* The better way for a static string, with a comment - use as follows -
+ *
+ * static NSString *string = GSLocalizedStaticString (@"New Game",
+ *                                                    @"Menu Option");
+ *
+ * NSLog (_(string));
+ *
+ * If you need anything more complicated than this, please initialize
+ * the static strings manually.
+ */
+
+/**
+ * <p>
+ *   This function (macro) is a GNUstep extensions, and it is used
+ *   to localize static strings.  Here is an example of a static
+ *   string:
+ * </p>
+ * <p>
+ *   <code>
+ *     NSString *message = @"Hi there";
+ *     ... some code ...
+ *     NSLog (message);
+ *  </code>
+ * </p>
+ * <p>
+ *   This string can not be localized using the standard
+ *   openstep functions/macros.  By using this gnustep extension,
+ *   you can localize it as follows:
+ * </p>
+ * <p>
+ *   <code>
+ *     NSString *message = GSLocalizedStaticString (@"Hi there",
+ *       @"Greeting");
+ * 
+ *     ... some code ...
+ * 
+ *     NSLog (NSLocalizedString (message, @""));
+ *  </code>
+ * </p>
+ * <p>
+ *   When the tools generate the
+ *   <code>Localizable.strings</code> file from the source
+ *   code, they will ignore the <code>NSLocalizedString</code>
+ *   call while they will extract the string (and the comment)
+ *   to localize from the <code>GSLocalizedStaticString</code>
+ *   call.
+ * </p>
+ * <p>
+ *   When the code is compiled, instead, the
+ *   <code>GSLocalizedStaticString</code> call is ignored (discarded,
+ *   it is a macro which simply expands to <code>key</code>), while
+ *   the <code>NSLocalizedString</code> will actually look up the
+ *   string for translation in the <code>Localizable.strings</code>
+ *   file.
+ * </p>
+ * <p>
+ *   Please note that there is currently no macro/function to
+ *   localize static strings using different tables.  If you
+ *   need that functionality, you have either to prepare the
+ *   localization tables by hand, or to rewrite your code in
+ *   such a way as not to use static strings.
+ * </p>
+ */
+#define GSLocalizedStaticString(key, comment) key
+
+/**
+ * To be used inside a method for making sure that a range does not specify
+ * anything outside the size of an array/string.  Raises exception if range
+ * extends beyond [0,size]. Size must be an unsigned integer (NSUInteger).
+ */
+#define GS_RANGE_CHECK(RANGE, SIZE) \
+  if (RANGE.location > (NSUInteger)SIZE \
+    || RANGE.length > ((NSUInteger)SIZE - RANGE.location)) \
+    [NSException raise: NSRangeException format: @"in %s, range { %"\
+      PRIuPTR ", %" PRIuPTR " } extends beyond size (%" PRIuPTR ")", \
+      GSNameFromSelector(_cmd), RANGE.location, RANGE.length, (NSUInteger)SIZE]
+
+/** Checks whether INDEX is strictly less than OVER (within C array space).
+ * INDEX and OVER must be unsigned integers (NSUInteger).
+ */
+#define CHECK_INDEX_RANGE_ERROR(INDEX, OVER) \
+if ((NSUInteger)INDEX >= (NSUInteger)OVER) \
+  [NSException raise: NSRangeException \
+    format: @"in %s, index %" PRIuPTR " is out of range", \
+    GSNameFromSelector(_cmd), (NSUInteger)INDEX]
+
+#endif /* __GNUSTEP_GNUSTEP_H_INCLUDED_ */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSNumber+GNUstepBase.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSNumber+GNUstepBase.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSNumber+GNUstepBase.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,56 @@
+/** Declaration of extension methods for base additions
+
+   Copyright (C) 2003-2010 Free Software Foundation, Inc.
+
+   Written by:  Richard Frith-Macdonald <rfm@gnu.org>
+   and:         Adam Fedor <fedor@gnu.org>
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+
+*/
+
+#ifndef	INCLUDED_NSNumber_GNUstepBase_h
+#define	INCLUDED_NSNumber_GNUstepBase_h
+
+#import "GSVersionMacros.h"
+#import "../Foundation/NSValue.h"
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+#if	OS_API_VERSION(GS_API_NONE,GS_API_LATEST)
+
+@interface NSNumber(GNUstepBase)
+/**
+ * Parses string as a <code>double</code>, <code>int</code>, or <code>unsigned
+ * int</code> depending on what characters are present.  Uses
+ * <code>atof</code> and <code>atoi</code> which don't report errors, so be
+ * careful if the string might contain an invalid value.
+ */
++ (NSValue*) valueFromString: (NSString *)string;
+@end
+
+#endif	/* OS_API_VERSION */
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#endif	/* INCLUDED_NSNumber_GNUstepBase_h */
+
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSBlocks.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSBlocks.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSBlocks.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,145 @@
+/** Definitions for block support for GNUStep
+   Copyright (C) 2011 Free Software Foundation, Inc.
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+
+   */
+
+#ifndef __GSBlocks_h_GNUSTEP_BASE_INCLUDE
+#define __GSBlocks_h_GNUSTEP_BASE_INCLUDE
+
+/* Define the has_feature pseudo-macro for GCC. */
+#ifndef __has_feature
+#define __has_feature(x) 0
+#endif
+
+#ifndef GCC_VERSION
+#define GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)
+#endif
+
+#if __has_feature(blocks)
+
+#define BLOCK_SCOPE __block
+/**
+ * Defines a block type.  Will work whether or not the compiler natively
+ * supports blocks.
+ */
+#define DEFINE_BLOCK_TYPE(name, retTy, argTys, ...) \
+typedef retTy(^name)(argTys, ## __VA_ARGS__)
+
+#define DEFINE_BLOCK_TYPE_NO_ARGS(name, retTy) \
+typedef retTy(^name)()
+
+/**
+ * Calls a block.  Works irrespective of whether the compiler supports blocks.
+ */
+#define CALL_BLOCK(block, args, ...) block(args, ## __VA_ARGS__)
+
+/**
+ * Calls a block without arguments.
+ */
+#define CALL_BLOCK_NO_ARGS(block) block()
+#else
+
+/* Fall-back versions for when the compiler doesn't have native blocks support.
+ */
+#if (GCC_VERSION >= 3000)
+
+#define DEFINE_BLOCK_TYPE(name, retTy, argTys, ...) \
+  typedef struct {\
+    void *isa;\
+    int flags;\
+    int reserved;\
+    retTy (*invoke)(void*, argTys, ## __VA_ARGS__);\
+  } *name
+
+#define DEFINE_BLOCK_TYPE_NO_ARGS(name, retTy) \
+  typedef struct {\
+    void *isa;\
+    int flags;\
+    int reserved;\
+    retTy (*invoke)(void*);\
+  } *name
+
+#define CALL_BLOCK(block, args, ...) block->invoke(block, args, ## __VA_ARGS__)
+
+#define CALL_BLOCK_NO_ARGS(block) block->invoke(block)
+#define BLOCK_SCOPE
+
+#else /* GCC_VERSION >= 3000 */
+
+#define DEFINE_BLOCK_TYPE(name, retTy, argTys...) \
+  typedef struct {\
+    void *isa;\
+    int flags;\
+    int reserved;\
+    retTy (*invoke)(void*, argTys);\
+  } *name
+
+#define DEFINE_BLOCK_TYPE_NO_ARGS(name, retTy) \
+  typedef struct {\
+    void *isa;\
+    int flags;\
+    int reserved;\
+    retTy (*invoke)(void*);\
+  } *name
+
+
+#define CALL_BLOCK(block, args...) block->invoke(block, args)
+#define CALL_BLOCK_NO_ARGS(block) block->invoke(block)
+#define BLOCK_SCOPE
+#endif /* GCC_VERSION >= 3000 */
+
+#endif /* __has_feature(blocks) */
+
+#if __has_include(<objc/blocks_runtime.h>)
+#  include <objc/blocks_runtime.h>
+#else
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * _Block_copy and _Block_release are weakly imported, but can be assumed
+ * to be available whenever a feature using blocks is accessed
+ * by an application.
+ */
+
+/* weak attributed supported only with ELF, MINGW is COFF */
+#ifndef __MINGW32__
+
+void *_Block_copy(const void *) __attribute__((weak));
+void _Block_release(const void *) __attribute__((weak));
+
+#endif /* __MINGW32__ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#ifndef Block_copy
+#  define Block_copy(x) ((__typeof(x))_Block_copy((const void *)(x)))
+#endif
+#ifndef Block_release
+#  define Block_release(x) _Block_release((const void *)(x))
+#endif
+
+#endif /* __has_include(<objc/blocks_runtime.h>) */
+#endif /* __GSBlocks_h_GNUSTEP_BASE_INCLUDE */
+
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSGeometry.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSGeometry.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSGeometry.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,609 @@
+/* Interface for NSGeometry routines for GNUStep
+ * Copyright (C) 1995 Free Software Foundation, Inc.
+ * 
+ * Written by:  Adam Fedor <fedor@boulder.colorado.edu>
+ * Date: 1995,199
+ * 
+ * This file is part of the GNUstep Base Library.
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02111 USA.
+ */ 
+
+#ifndef __NSGeometry_h_GNUSTEP_BASE_INCLUDE
+#define __NSGeometry_h_GNUSTEP_BASE_INCLUDE
+#import	"../GNUstepBase/GSVersionMacros.h"
+
+#import <objc/objc.h>
+
+#import "NSString.h"
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+/**** Type, Constant, and Macro Definitions **********************************/
+
+#ifndef MAX
+#define MAX(a,b) \
+       ({__typeof__(a) _MAX_a = (a); __typeof__(b) _MAX_b = (b);  \
+         _MAX_a > _MAX_b ? _MAX_a : _MAX_b; })
+#define	GS_DEFINED_MAX
+#endif
+
+#ifndef MIN
+#define MIN(a,b) \
+       ({__typeof__(a) _MIN_a = (a); __typeof__(b) _MIN_b = (b);  \
+         _MIN_a < _MIN_b ? _MIN_a : _MIN_b; })
+#define	GS_DEFINED_MIN
+#endif
+
+/**
+<example>{
+  CGFloat x;
+  CGFloat y;
+}</example>
+ <p>Represents a 2-d cartesian position.</p> */
+typedef struct _NSPoint NSPoint;
+struct _NSPoint
+{
+  CGFloat x;
+  CGFloat y;
+};
+
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+/** Array of NSPoint structs. */
+typedef NSPoint *NSPointArray;
+/** Pointer to NSPoint struct. */
+typedef NSPoint *NSPointPointer;
+#endif
+
+/**
+<example>{
+  CGFloat width;
+  CGFloat height;
+}</example>
+ <p>Floating point rectangle size.</p> */
+typedef struct _NSSize NSSize;
+struct _NSSize
+{
+  CGFloat width;
+  CGFloat height;
+};
+
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+/** Array of NSSize structs. */
+typedef NSSize *NSSizeArray;
+/** Pointer to NSSize struct. */
+typedef NSSize *NSSizePointer;
+#endif
+
+/**
+<example>{
+  NSPoint origin;
+  NSSize size;
+}</example>
+
+ <p>Rectangle.</p> */
+typedef struct _NSRect NSRect;
+struct _NSRect
+{
+  NSPoint origin;
+  NSSize size;
+};
+
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+/** Array of NSRect structs. */
+typedef NSRect *NSRectArray;
+/** Pointer to NSRect struct. */
+typedef NSRect *NSRectPointer;
+#endif
+
+enum
+{
+  NSMinXEdge = 0,
+  NSMinYEdge = 1,
+  NSMaxXEdge = 2,
+  NSMaxYEdge = 3
+};
+/** Sides of a rectangle.
+<example>
+{
+  NSMinXEdge,
+  NSMinYEdge,
+  NSMaxXEdge,
+  NSMaxYEdge
+}
+</example>
+ */
+typedef NSUInteger NSRectEdge;
+
+/**
+<example>{
+  CGFloat top;
+  CGFloat left;
+  CGFloat bottom;
+  CGFloat right;
+}</example>
+
+ <p>A description of the distance between the edges of two rectangles.</p> */
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_7, GS_API_LATEST)
+typedef struct NSEdgeInsets {
+    CGFloat top;
+    CGFloat left;
+    CGFloat bottom;
+    CGFloat right;
+} NSEdgeInsets;
+#endif
+
+/** Point at 0,0 */
+static const NSPoint NSZeroPoint __attribute__((unused)) = {0.0,0.0};
+/** Zero-size rectangle at 0,0 */
+static const NSRect NSZeroRect __attribute__((unused)) = {{0.0,0.0},{0.0,0.0}};
+/** Zero size */
+static const NSSize NSZeroSize __attribute__((unused)) = {0.0,0.0};
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_7, GS_API_LATEST)
+/** Zero edge insets **/
+static const NSEdgeInsets NSEdgeInsetsZero __attribute__((unused))  = {0.0,0.0,0.0,0.0};
+#endif
+
+/**** Function Prototypes ****************************************************/
+
+/*
+ *	All but the most complex functions are declared static inline in this
+ *	header file so that they are maximally efficient.  In order to provide
+ *	true functions (for code modules that don't have this header) this
+ *	header is included in NSGeometry.m where the functions are no longer
+ *	declared inline.
+ */
+#ifdef	IN_NSGEOMETRY_M
+#define	GS_GEOM_SCOPE	extern
+#define GS_GEOM_ATTR	
+#else
+#define	GS_GEOM_SCOPE	static inline
+#define GS_GEOM_ATTR	__attribute__((unused))
+#endif
+
+/** Create Basic Structures... **/
+
+GS_GEOM_SCOPE NSPoint
+NSMakePoint(CGFloat x, CGFloat y) GS_GEOM_ATTR;
+
+/** Returns an NSPoint having x-coordinate X and y-coordinate Y. */
+GS_GEOM_SCOPE NSPoint
+NSMakePoint(CGFloat x, CGFloat y)
+{
+  NSPoint point;
+
+  point.x = x;
+  point.y = y;
+  return point;
+}
+
+GS_GEOM_SCOPE NSSize
+NSMakeSize(CGFloat w, CGFloat h) GS_GEOM_ATTR;
+
+/** Returns an NSSize having width w and height h. */
+GS_GEOM_SCOPE NSSize
+NSMakeSize(CGFloat w, CGFloat h)
+{
+  NSSize size;
+
+  size.width = w;
+  size.height = h;
+  return size;
+}
+
+GS_GEOM_SCOPE NSRect
+NSMakeRect(CGFloat x, CGFloat y, CGFloat w, CGFloat h) GS_GEOM_ATTR;
+
+/** Returns an NSRect having point of origin (x, y) and size {w, h}. */
+GS_GEOM_SCOPE NSRect
+NSMakeRect(CGFloat x, CGFloat y, CGFloat w, CGFloat h)
+{
+  NSRect rect;
+
+  rect.origin.x = x;
+  rect.origin.y = y;
+  rect.size.width = w;
+  rect.size.height = h;
+  return rect;
+}
+
+/** Constructs NSEdgeInsets. **/
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_7, GS_API_LATEST)
+GS_GEOM_SCOPE NSEdgeInsets
+NSEdgeInsetsMake(CGFloat top, CGFloat left,
+                 CGFloat bottom, CGFloat right) GS_GEOM_ATTR;
+
+GS_GEOM_SCOPE NSEdgeInsets
+NSEdgeInsetsMake(CGFloat top, CGFloat left, CGFloat bottom, CGFloat right)
+{
+  NSEdgeInsets edgeInsets;
+
+  edgeInsets.top = top;
+  edgeInsets.left = left;
+  edgeInsets.bottom = bottom;
+  edgeInsets.right = right;
+
+  return edgeInsets;
+}
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_10, GS_API_LATEST)
+/** Compares two edge insets for equality. **/
+GS_EXPORT BOOL
+NSEdgeInsetsEqual(NSEdgeInsets e1, NSEdgeInsets e2);
+#endif
+
+#endif
+
+/** Get a Rectangle's Coordinates... **/
+
+GS_GEOM_SCOPE CGFloat
+NSMaxX(NSRect aRect) GS_GEOM_ATTR;
+
+/** Returns the greatest x-coordinate value still inside aRect. */
+GS_GEOM_SCOPE CGFloat
+NSMaxX(NSRect aRect)
+{
+  return aRect.origin.x + aRect.size.width;
+}
+
+GS_GEOM_SCOPE CGFloat
+NSMaxY(NSRect aRect) GS_GEOM_ATTR;
+
+/** Returns the greatest y-coordinate value still inside aRect. */
+GS_GEOM_SCOPE CGFloat
+NSMaxY(NSRect aRect)
+{
+  return aRect.origin.y + aRect.size.height;
+}
+
+GS_GEOM_SCOPE CGFloat
+NSMidX(NSRect aRect) GS_GEOM_ATTR;
+
+/** Returns the x-coordinate of aRect's middle point. */
+GS_GEOM_SCOPE CGFloat
+NSMidX(NSRect aRect)
+{
+  return aRect.origin.x + (aRect.size.width / 2.0);
+}
+
+GS_GEOM_SCOPE CGFloat
+NSMidY(NSRect aRect) GS_GEOM_ATTR;
+
+/** Returns the y-coordinate of aRect's middle point. */
+GS_GEOM_SCOPE CGFloat
+NSMidY(NSRect aRect)
+{
+  return aRect.origin.y + (aRect.size.height / 2.0);
+}
+
+GS_GEOM_SCOPE CGFloat
+NSMinX(NSRect aRect) GS_GEOM_ATTR;
+
+/** Returns the least x-coordinate value still inside aRect. */
+GS_GEOM_SCOPE CGFloat
+NSMinX(NSRect aRect)
+{
+  return aRect.origin.x;
+}
+
+GS_GEOM_SCOPE CGFloat
+NSMinY(NSRect aRect) GS_GEOM_ATTR;
+
+/** Returns the least y-coordinate value still inside aRect. */
+GS_GEOM_SCOPE CGFloat
+NSMinY(NSRect aRect)
+{
+  return aRect.origin.y;
+}
+
+GS_GEOM_SCOPE CGFloat
+NSWidth(NSRect aRect) GS_GEOM_ATTR;
+
+/** Returns aRect's width. */
+GS_GEOM_SCOPE CGFloat
+NSWidth(NSRect aRect)
+{
+  return aRect.size.width;
+}
+
+GS_GEOM_SCOPE CGFloat
+NSHeight(NSRect aRect) GS_GEOM_ATTR;
+
+/** Returns aRect's height. */
+GS_GEOM_SCOPE CGFloat
+NSHeight(NSRect aRect)
+{
+  return aRect.size.height;
+}
+
+GS_GEOM_SCOPE BOOL
+NSIsEmptyRect(NSRect aRect) GS_GEOM_ATTR;
+
+/** Returns 'YES' iff the area of aRect is zero (i.e., iff either
+ * of aRect's width or height is negative or zero). */
+GS_GEOM_SCOPE BOOL
+NSIsEmptyRect(NSRect aRect)
+{
+  return ((NSWidth(aRect) > 0) && (NSHeight(aRect) > 0)) ? NO : YES;
+}
+
+/** Modify a Copy of a Rectangle... **/
+
+GS_GEOM_SCOPE NSRect
+NSOffsetRect(NSRect aRect, CGFloat dx, CGFloat dy) GS_GEOM_ATTR;
+
+/** Returns the rectangle obtained by translating aRect
+ * horizontally by dx and vertically by dy. */
+GS_GEOM_SCOPE NSRect
+NSOffsetRect(NSRect aRect, CGFloat dx, CGFloat dy)
+{
+  NSRect rect = aRect;
+
+  rect.origin.x += dx;
+  rect.origin.y += dy;
+  return rect;
+}
+
+GS_GEOM_SCOPE NSRect
+NSInsetRect(NSRect aRect, CGFloat dX, CGFloat dY) GS_GEOM_ATTR;
+
+/** Returns the rectangle obtained by moving each of aRect's
+ * horizontal sides inward by dy and each of aRect's vertical
+ * sides inward by dx.<br />
+ * NB. For MacOS-X compatability, this is permitted to return
+ * a rectanglew with nagative width or height, strange as that seems.
+ */
+GS_GEOM_SCOPE NSRect
+NSInsetRect(NSRect aRect, CGFloat dX, CGFloat dY)
+{
+  NSRect rect;
+
+  rect = NSOffsetRect(aRect, dX, dY);
+  rect.size.width -= (2 * dX);
+  rect.size.height -= (2 * dY);
+  return rect;
+}
+
+/** Divides aRect into two rectangles (namely slice and remainder) by
+ * "cutting" aRect---parallel to, and a distance amount from the given edge
+ * of aRect.  You may pass 0 in as either of slice or
+ * remainder to avoid obtaining either of the created rectangles. */
+GS_EXPORT void
+NSDivideRect(NSRect aRect,
+             NSRect *slice,
+             NSRect *remainder,
+             CGFloat amount,
+             NSRectEdge edge);
+
+/** Returns a rectangle obtained by expanding aRect minimally
+ * so that all four of its defining components are integers. */
+GS_EXPORT NSRect
+NSIntegralRect(NSRect aRect);
+
+/** Compute a Third Rectangle from Two Rectangles... **/
+
+GS_GEOM_SCOPE NSRect
+NSUnionRect(NSRect aRect, NSRect bRect) GS_GEOM_ATTR;
+
+/** Returns the smallest rectangle which contains both aRect
+ * and bRect (modulo a set of measure zero).  If either of aRect
+ * or bRect is an empty rectangle, then the other rectangle is
+ * returned.  If both are empty, then the empty rectangle is returned. */
+GS_GEOM_SCOPE NSRect
+NSUnionRect(NSRect aRect, NSRect bRect)
+{
+  NSRect rect;
+
+  if (NSIsEmptyRect(aRect) && NSIsEmptyRect(bRect))
+    return NSMakeRect(0.0,0.0,0.0,0.0);
+  else if (NSIsEmptyRect(aRect))
+    return bRect;
+  else if (NSIsEmptyRect(bRect))
+    return aRect;
+
+  rect = NSMakeRect(MIN(NSMinX(aRect), NSMinX(bRect)),
+                    MIN(NSMinY(aRect), NSMinY(bRect)), 0.0, 0.0);
+
+  rect = NSMakeRect(NSMinX(rect),
+                    NSMinY(rect),
+                    MAX(NSMaxX(aRect), NSMaxX(bRect)) - NSMinX(rect),
+                    MAX(NSMaxY(aRect), NSMaxY(bRect)) - NSMinY(rect));
+
+  return rect;
+}
+
+GS_GEOM_SCOPE NSRect
+NSIntersectionRect(NSRect aRect, NSRect bRect) GS_GEOM_ATTR;
+
+/** Returns the largest rectangle which lies in both aRect and
+ * bRect.  If aRect and bRect have empty intersection (or, rather,
+ * intersection of measure zero, since this includes having their
+ * intersection be only a point or a line), then the empty
+ * rectangle is returned. */
+GS_GEOM_SCOPE NSRect
+NSIntersectionRect (NSRect aRect, NSRect bRect)
+{
+  if (NSMaxX(aRect) <= NSMinX(bRect) || NSMaxX(bRect) <= NSMinX(aRect)
+    || NSMaxY(aRect) <= NSMinY(bRect) || NSMaxY(bRect) <= NSMinY(aRect)) 
+    {
+      return NSMakeRect(0.0, 0.0, 0.0, 0.0);
+    }
+  else
+    {
+      NSRect    rect;
+
+      if (NSMinX(aRect) <= NSMinX(bRect))
+        rect.origin.x = bRect.origin.x;
+      else
+        rect.origin.x = aRect.origin.x;
+
+      if (NSMinY(aRect) <= NSMinY(bRect))
+        rect.origin.y = bRect.origin.y;
+      else
+        rect.origin.y = aRect.origin.y;
+
+      if (NSMaxX(aRect) >= NSMaxX(bRect))
+        rect.size.width = NSMaxX(bRect) - rect.origin.x;
+      else
+        rect.size.width = NSMaxX(aRect) - rect.origin.x;
+
+      if (NSMaxY(aRect) >= NSMaxY(bRect))
+        rect.size.height = NSMaxY(bRect) - rect.origin.y;
+      else
+        rect.size.height = NSMaxY(aRect) - rect.origin.y;
+
+      return rect;
+    }
+}
+
+/** Test geometric relationships... **/
+
+/** Returns 'YES' iff aRect's and bRect's origin and size are the same. */
+GS_EXPORT BOOL
+NSEqualRects(NSRect aRect, NSRect bRect) GS_GEOM_ATTR;
+
+/** Returns 'YES' iff aSize's and bSize's width and height are the same. */
+GS_EXPORT BOOL
+NSEqualSizes(NSSize aSize, NSSize bSize) GS_GEOM_ATTR;
+
+/** Returns 'YES' iff aPoint's and bPoint's x- and y-coordinates
+ * are the same. */
+GS_EXPORT BOOL
+NSEqualPoints(NSPoint aPoint, NSPoint bPoint) GS_GEOM_ATTR;
+
+GS_GEOM_SCOPE BOOL
+NSMouseInRect(NSPoint aPoint, NSRect aRect, BOOL flipped) GS_GEOM_ATTR;
+
+/** Returns 'YES' iff aPoint is inside aRect. */ 
+GS_GEOM_SCOPE BOOL
+NSMouseInRect(NSPoint aPoint, NSRect aRect, BOOL flipped)
+{
+  if (flipped)
+    {
+      return ((aPoint.x >= NSMinX(aRect))
+        && (aPoint.y >= NSMinY(aRect))
+        && (aPoint.x < NSMaxX(aRect))
+        && (aPoint.y < NSMaxY(aRect))) ? YES : NO;
+    }
+  else
+    {
+      return ((aPoint.x >= NSMinX(aRect))
+        && (aPoint.y > NSMinY(aRect))
+        && (aPoint.x < NSMaxX(aRect))
+        && (aPoint.y <= NSMaxY(aRect))) ? YES : NO;
+    }
+}
+
+GS_GEOM_SCOPE BOOL
+NSPointInRect(NSPoint aPoint, NSRect aRect) GS_GEOM_ATTR;
+
+/** Just like 'NSMouseInRect(aPoint, aRect, YES)'. */
+GS_GEOM_SCOPE BOOL
+NSPointInRect(NSPoint aPoint, NSRect aRect)
+{
+  return NSMouseInRect(aPoint, aRect, YES);
+}
+
+GS_GEOM_SCOPE BOOL
+NSContainsRect(NSRect aRect, NSRect bRect) GS_GEOM_ATTR;
+
+/** Returns 'YES' iff aRect totally encloses bRect.  NOTE: For
+ * this to be the case, aRect cannot be empty, nor can any side
+ * of bRect go beyond any side of aRect. Note that this behavior
+ * is different than the original OpenStep behavior, where the sides
+ * of bRect could not touch aRect. */
+GS_GEOM_SCOPE BOOL
+NSContainsRect(NSRect aRect, NSRect bRect)
+{
+  return (!NSIsEmptyRect(bRect)
+    && (NSMinX(aRect) <= NSMinX(bRect))
+    && (NSMinY(aRect) <= NSMinY(bRect))
+    && (NSMaxX(aRect) >= NSMaxX(bRect))
+    && (NSMaxY(aRect) >= NSMaxY(bRect))) ? YES : NO;
+}
+
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+GS_GEOM_SCOPE BOOL
+NSIntersectsRect(NSRect aRect, NSRect bRect) GS_GEOM_ATTR;
+
+/** Returns YES if aRect and bRect have non-zero intersection area
+    (intersecting at a line or a point doesn't count). */
+GS_GEOM_SCOPE BOOL
+NSIntersectsRect(NSRect aRect, NSRect bRect)
+{
+  /* Note that intersecting at a line or a point doesn't count */
+  return (NSMaxX(aRect) <= NSMinX(bRect)
+    || NSMaxX(bRect) <= NSMinX(aRect)
+    || NSMaxY(aRect) <= NSMinY(bRect)
+    || NSMaxY(bRect) <= NSMinY(aRect)
+    || NSIsEmptyRect(aRect)
+    || NSIsEmptyRect(bRect)) ? NO : YES;
+}
+#endif
+
+/** Get a String Representation... **/
+
+#ifdef __OBJC__
+/** Returns an NSString of the form "{x=X; y=Y}", where
+ * X and Y are the x- and y-coordinates of aPoint, respectively. */
+GS_EXPORT NSString *
+NSStringFromPoint(NSPoint aPoint);
+
+/** Returns an NSString of the form "{x=X; y=Y; width=W; height=H}",
+ * where X, Y, W, and H are the x-coordinate, y-coordinate,
+ * width, and height of aRect, respectively. */
+GS_EXPORT NSString *
+NSStringFromRect(NSRect aRect);
+
+/** Returns an NSString of the form "{width=W; height=H}", where
+ * W and H are the width and height of aSize, respectively. */
+GS_EXPORT NSString *
+NSStringFromSize(NSSize aSize);
+
+/** Parses point from string of form "<code>{x=a; y=b}</code>". (0,0) returned
+    if parsing fails. */
+GS_EXPORT NSPoint	NSPointFromString(NSString* string);
+
+/** Parses size from string of form "<code>{width=a; height=b}</code>". Size of
+    0,0 returned if parsing fails. */
+GS_EXPORT NSSize	NSSizeFromString(NSString* string);
+
+/** Parses point from string of form "<code>{x=a; y=b; width=c;
+    height=d}</code>".  Rectangle of 0 size at origin returned if parsing
+    fails.
+*/
+GS_EXPORT NSRect	NSRectFromString(NSString* string);
+
+#endif /* __OBJC__ */
+
+#ifdef	GS_DEFINED_MAX
+#undef	GS_DEFINED_MAX
+#undef	MAX
+#endif
+
+#ifdef	GS_DEFINED_MIN
+#undef	GS_DEFINED_MIN
+#undef	MIN
+#endif
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#endif /* __NSGeometry_h_GNUSTEP_BASE_INCLUDE */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSZone.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSZone.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSZone.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,335 @@
+/** Zone memory management. -*- Mode: ObjC -*-
+   Copyright (C) 1997,1998,1999 Free Software Foundation, Inc.
+
+   Written by: Yoo C. Chung <wacko@laplace.snu.ac.kr>
+   Date: January 1997
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+
+    AutogsdocSource:	NSZone.m
+    AutogsdocSource:	NSPage.m
+
+   */
+
+#ifndef __NSZone_h_GNUSTEP_BASE_INCLUDE
+#define __NSZone_h_GNUSTEP_BASE_INCLUDE
+#import	"../GNUstepBase/GSVersionMacros.h"
+
+/**
+ * Primary structure representing an <code>NSZone</code>.  Technically it
+ * consists of a set of function pointers for zone upkeep functions plus some
+ * other things-
+<example>
+{
+  // Functions for zone.
+  void *(*malloc)(struct _NSZone *zone, size_t size);
+  void *(*realloc)(struct _NSZone *zone, void *ptr, size_t size);
+  void (*free)(struct _NSZone *zone, void *ptr);
+  void (*recycle)(struct _NSZone *zone);
+  BOOL (*check)(struct _NSZone *zone);
+  BOOL (*lookup)(struct _NSZone *zone, void *ptr);
+
+  // Zone statistics (not always maintained).
+  struct NSZoneStats (*stats)(struct _NSZone *zone);
+  
+  size_t gran;    // Zone granularity (passed in on initialization)
+  NSString *name; // Name of zone (default is 'nil')
+  NSZone *next;   // Pointer used for internal management of multiple zones.
+}</example>
+ */
+typedef struct _NSZone NSZone;
+
+#import	"NSObjCRuntime.h"
+
+@class NSString;
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+struct _NSZone
+{
+  /* Functions for zone. */
+  void *(*malloc)(struct _NSZone *zone, size_t size);
+  void *(*realloc)(struct _NSZone *zone, void *ptr, size_t size);
+  void (*free)(struct _NSZone *zone, void *ptr);
+  void (*recycle)(struct _NSZone *zone);
+  BOOL (*check)(struct _NSZone *zone);
+  BOOL (*lookup)(struct _NSZone *zone, void *ptr);
+  struct NSZoneStats (*stats)(struct _NSZone *zone);
+  
+  size_t gran; // Zone granularity
+  __unsafe_unretained NSString *name; // Name of zone (default is 'nil')
+  NSZone *next;
+};
+
+/**
+ * Creates a new zone of start bytes, which will grow and shrink by
+ * granularity bytes.  If canFree is 0, memory in zone is allocated but
+ * never freed, meaning allocation will be very fast.  The whole zone can
+ * still be freed with NSRecycleZone(), and you should still call NSZoneFree
+ * on memory in the zone that is no longer needed, since a count of allocated
+ * pointers is kept and must reach zero before freeing the zone.<br />
+ * If Garbage Collection is enabled, this function does nothing other than
+ * log a warning and return the same value as the NSDefaultMallocZone()
+ * function.
+ */
+GS_EXPORT NSZone*
+NSCreateZone (NSUInteger start, NSUInteger gran, BOOL canFree);
+
+/** Returns the default zone for memory allocation.  Memory created in this
+ * zone is the same as memory allocates using the system malloc() function.
+ */
+GS_EXPORT NSZone*
+NSDefaultMallocZone (void);
+
+/**
+ * Searches and finds the zone ptr was allocated from.  The speed depends
+ * upon the number of zones and their size.<br />
+ * If Garbage Collection is enabled, this function always returns the
+ * same as the NSDefaultMallocZone() function.
+ */
+GS_EXPORT NSZone*
+NSZoneFromPointer (void *ptr);
+
+/**
+ * Allocates and returns memory for elems items of size bytes, in the
+ * given zone.  Returns NULL if allocation of size 0 requested.  Raises
+ * <code>NSMallocException</code> if not enough free memory in zone to
+ * allocate and no more can be obtained from system, unless using the
+ * default zone, in which case NULL is returned.<br />
+ * If Garbage Collection is enabled, this function always allocates
+ * non-scanned, non-collectable memory in the NSDefaultMallocZone() and
+ * the zone argument is ignored.
+ */
+GS_EXPORT void*
+NSZoneMalloc (NSZone *zone, NSUInteger size);
+
+/**
+ * Allocates and returns cleared memory for elems items of size bytes, in the
+ * given zone.  Returns NULL if allocation of size 0 requested.  Raises
+ * <code>NSMallocException</code> if not enough free memory in zone to
+ * allocate and no more can be obtained from system, unless using the
+ * default zone, in which case NULL is returned.<br />
+ * If Garbage Collection is enabled, this function always allocates
+ * non-scanned, non-collectable memory in the NSDefaultMallocZone() and
+ * the zone argument is ignored.
+ */
+GS_EXPORT void*
+NSZoneCalloc (NSZone *zone, NSUInteger elems, NSUInteger bytes);
+
+/**
+ * Reallocates the chunk of memory in zone pointed to by ptr to a new one of
+ * size bytes.  Existing contents in ptr are copied over.  Raises an
+ * <code>NSMallocException</code> if insufficient memory is available in the
+ * zone and no more memory can be obtained from the system, unless using the
+ * default zone, in which case NULL is returned.<br />
+ * If Garbage Collection is enabled, the zone argument is ignored.
+ */
+GS_EXPORT void*
+NSZoneRealloc (NSZone *zone, void *ptr, NSUInteger size);
+
+/**
+ * Return memory for an entire zone to system.  In fact, this will not be done
+ * unless all memory in the zone has been explicitly freed (by calls to
+ * NSZoneFree()).  For "non-freeable" zones, the number of NSZoneFree() calls
+ * must simply equal the number of allocation calls.  The default zone, on the
+ * other hand, cannot be recycled.<br />
+ * If Garbage Collection is enabled, this function has not effect.
+ */
+GS_EXPORT void
+NSRecycleZone (NSZone *zone);
+
+/**
+ * Frees memory pointed to by ptr (which should have been allocated by a
+ * previous call to NSZoneMalloc(), NSZoneCalloc(), or NSZoneRealloc()) and
+ * returns it to zone.  Note, if this is a nonfreeable zone, the memory is
+ * not actually freed, but the count of number of free()s is updated.<br />
+ * If Garbage Collection is enabled, the zone argument is ignored and this
+ * function causes ptr to be deallocated immediately.
+ */
+GS_EXPORT void
+NSZoneFree (NSZone *zone, void *ptr);
+
+/**
+ * Sets name of the given zone (useful for debugging and logging).
+ */
+GS_EXPORT void
+NSSetZoneName (NSZone *zone, NSString *name);
+
+/**
+ * Returns the name of the given zone (useful for debugging and logging).
+ */
+GS_EXPORT NSString*
+NSZoneName (NSZone *zone);
+
+#if OS_API_VERSION(GS_API_NONE, GS_API_NONE)
+
+/** Deprecated ...<br />
+ * Checks integrity of a zone.  Not defined by OpenStep or OS X.
+ */
+BOOL
+NSZoneCheck (NSZone *zone);
+
+/**
+ *  <code>NSZoneStats</code> is the structure returned by the NSZoneStats()
+ *  function that summarizes the current usage of a zone.  It is similar to
+ *  the structure <em>mstats</em> in the GNU C library.  It has 5 fields of
+ *  type <code>size_t</code>-
+ *  <deflist>
+ *    <term><code>bytes_total</code></term>
+ *    <desc>
+ *    This is the total size of memory managed by the zone, in bytes.</desc>
+ *    <term><code>chunks_used</code></term>
+ *    <desc>This is the number of memory chunks in use in the zone.</desc>
+ *    <term><code>bytes_used</code></term>
+ *    <desc>This is the number of bytes in use.</desc>
+ *    <term><code>chunks_free</code></term>
+ *    <desc>This is the number of memory chunks that are not in use.</desc>
+ *    <term><code>bytes_free</code></term>
+ *    <desc>
+ *    This is the number of bytes managed by the zone that are not in use.
+ *    </desc>
+ *  </deflist>
+ */
+struct NSZoneStats
+{
+  size_t bytes_total;
+  size_t chunks_used;
+  size_t bytes_used;
+  size_t chunks_free;
+  size_t bytes_free;
+};
+
+/** Deprecated ...<br />
+ *  Obtain statistics about the zone.  Implementation emphasis is on
+ *  correctness, not speed.  Not defined by OpenStep or OS X.
+ */
+struct NSZoneStats
+NSZoneStats (NSZone *zone);
+
+/**
+ * Try to get more memory - the normal process has failed.
+ * If we can't do anything, just return a null pointer.
+ * Try to do some logging if possible.
+ */
+void*
+GSOutOfMemory(NSUInteger size, BOOL retry);
+
+/**
+ * Called during +initialize to tell the class that instances created
+ * in future should have the specified instance variable as a weak
+ * pointer for garbage collection.<br />
+ * NB. making a pointer weak does not mean that it is automatically
+ * zeroed when the object it points to is garbage collected. To get that
+ * behavior you must asign values to the pointer using the
+ * GSAssignZeroingWeakPointer() function.<br />
+ * This function has no effect if the system is
+ * not built for garbage collection.
+ */
+GS_EXPORT void
+GSMakeWeakPointer(Class theClass, const char *iVarName);
+
+/**
+ * This function must be used to assign a value to a zeroing weak pointer.<br />
+ * A zeroing weak pointer is one where, when the garbage collector collects
+ * the object pointed to, it also clears the weak pointer.<br />
+ * Assigning zero (nil) will always succeed and has the effect of telling the
+ * garbage collector that it no longer needs to track the previously assigned
+ * object.  Apart from that case, a source needs to be garbage collectable for
+ * this function to work, and using a non-garbage collectable value will
+ * cause the function to return NO.<br />
+ * If the destination object (the weak pointer watching the source object)
+ * belongs to a chunk of memory which may be collected before the source
+ * object is collected, it is important that it is finalised and the
+ * finalisation code assigns zero to the pointer.<br />
+ * If garbage collection is not in use, this function performs a simple
+ * assignment returning YES, unless destination is null in which case it
+ * returns NO.
+ */
+GS_EXPORT BOOL
+GSAssignZeroingWeakPointer(void **destination, void *source);
+
+#endif
+
+GS_EXPORT NSUInteger
+NSPageSize (void) __attribute__ ((const));
+
+GS_EXPORT NSUInteger
+NSLogPageSize (void) __attribute__ ((const));
+
+GS_EXPORT NSUInteger
+NSRoundDownToMultipleOfPageSize (NSUInteger bytes) __attribute__ ((const));
+
+GS_EXPORT NSUInteger
+NSRoundUpToMultipleOfPageSize (NSUInteger bytes) __attribute__ ((const));
+
+GS_EXPORT NSUInteger
+NSRealMemoryAvailable (void);
+
+GS_EXPORT void*
+NSAllocateMemoryPages (NSUInteger bytes);
+
+GS_EXPORT void
+NSDeallocateMemoryPages (void *ptr, NSUInteger bytes);
+
+GS_EXPORT void
+NSCopyMemoryPages (const void *src, void *dest, NSUInteger bytes);
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, OS_API_LATEST)
+
+enum {
+  NSScannedOption = (1<<0),
+  NSCollectorDisabledOption = (1<<1)
+};
+
+/** Allocate memory.  If garbage collection is not enabled this uses the
+ * default malloc zone and the options are ignored.<br />
+ * If garbage collection is enabled, the allocate memory is normally not
+ * scanned for pointers but is itsself garbage collectable.  The options
+ * argument is a bitmask in which NSScannedOption sets the memory to be
+ * scanned for pointers by the garbage collector, and
+ * NSCollectorDisabledOption causes the memory to be excempt from being
+ * garbage collected itsself.<br />
+ * In any case the memory returned is zero'ed.
+ */
+GS_EXPORT void *
+NSAllocateCollectable(NSUInteger size, NSUInteger options);
+
+/** Reallocate memory to be of a different size and/or to have different
+ * options settings.  The behavior of options is as for
+ * the NSAllocateCollectable() function.
+ */ 
+GS_EXPORT void *
+NSReallocateCollectable(void *ptr, NSUInteger size, NSUInteger options);
+
+#endif
+
+static inline id NSMakeCollectable(const void *cf) {
+#if __has_feature(objc_arc)
+    return nil;
+#else
+    return (id)cf; // Unimplemented; garbage collection is deprecated.
+#endif
+}
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#endif /* not __NSZone_h_GNUSTEP_BASE_INCLUDE */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSRange.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSRange.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSRange.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,235 @@
+/* 
+ * Copyright (C) 1995,1999 Free Software Foundation, Inc.
+ * 
+ * Written by:  Adam Fedor <fedor@boulder.colorado.edu>
+ * Date: 1995
+ * 
+ * This file is part of the GNUstep Base Library.
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02111 USA.
+ */ 
+
+#ifndef __NSRange_h_GNUSTEP_BASE_INCLUDE
+#define __NSRange_h_GNUSTEP_BASE_INCLUDE
+#import	"../GNUstepBase/GSVersionMacros.h"
+
+/**** Included Headers *******************************************************/
+
+#import	"NSObject.h"
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+@class NSException;
+@class NXConstantString;
+
+/**** Type, Constant, and Macro Definitions **********************************/
+
+#ifndef MAX
+#define MAX(a,b) \
+       ({__typeof__(a) _MAX_a = (a); __typeof__(b) _MAX_b = (b);  \
+         _MAX_a > _MAX_b ? _MAX_a : _MAX_b; })
+#define	GS_DEFINED_MAX
+#endif
+
+#ifndef MIN
+#define MIN(a,b) \
+       ({__typeof__(a) _MIN_a = (a); __typeof__(b) _MIN_b = (b);  \
+         _MIN_a < _MIN_b ? _MIN_a : _MIN_b; })
+#define	GS_DEFINED_MIN
+#endif
+
+/**
+ * <example>
+{
+  NSUInteger location;
+  NSUInteger length;
+}</example>
+ * <p>
+ *   The NSRange type is used to specify ranges of locations,
+ *   typically items in an array, characters in a string, and bytes
+ *   in a data object.
+ * </p>
+ * <p>
+ *   As 'boundary' or 'fencepost' errors are a particularly common
+ *   problem in programming, it is important that you understand
+ *   how an NSRange works.
+ * </p>
+ * <p>
+ *   An NSRange consists of a <em>location</em> and a <em>length</em>.  The
+ *   points that are considered to lie in a range are the integers from
+ *   the location to the location plus the length, so the number
+ *   of points in a range is the length of the range plus one.<br />
+ *   However, if you consider these points like the marks on a
+ *   ruler, you can only store information <strong>between</strong>
+ *   points.  So the number of items that can be stored in a range
+ *   is the length of the range.
+ * </p>
+ */
+typedef struct _NSRange NSRange;
+struct _NSRange
+{
+  NSUInteger location;
+  NSUInteger length;
+};
+
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+/** Pointer to an NSRange structure. */
+typedef NSRange *NSRangePointer;
+#endif
+
+/**** Function Prototypes ****************************************************/
+
+/*
+ *      All but the most complex functions are declared static inline in this
+ *      header file so that they are maximally efficient.  In order to provide
+ *      true functions (for code modules that don't have this header) this
+ *      header is included in NSRange.m where the functions are no longer
+ *      declared inline.
+ */
+#ifdef  IN_NSRANGE_M
+#define GS_RANGE_SCOPE   extern
+#define GS_RANGE_ATTR
+#else
+#define GS_RANGE_SCOPE   static inline
+#define GS_RANGE_ATTR    __attribute__((unused))
+#endif
+
+GS_RANGE_SCOPE NSUInteger
+NSMaxRange(NSRange range) GS_RANGE_ATTR;
+
+/** Returns top end of range (location + length). */
+GS_RANGE_SCOPE NSUInteger
+NSMaxRange(NSRange range) 
+{
+  return range.location + range.length;
+}
+
+GS_RANGE_SCOPE BOOL 
+NSLocationInRange(NSUInteger location, NSRange range) GS_RANGE_ATTR;
+
+/** Returns whether location is greater than or equal to range's location
+ *  and less than its max.
+ */
+GS_RANGE_SCOPE BOOL 
+NSLocationInRange(NSUInteger location, NSRange range) 
+{
+  return (location >= range.location) && (location < NSMaxRange(range));
+}
+
+/** Convenience method for raising an NSRangeException. */
+GS_EXPORT void _NSRangeExceptionRaise (void);
+/* NB: The implementation of _NSRangeExceptionRaise is: 
+   [NSException raise: NSRangeException
+	       format: @"Range location + length too great"]; 
+
+   _NSRangeExceptionRaise is defined in NSRange.m so that this
+   file (NSRange.h) can be included without problems in the
+   implementation of the base classes themselves. */
+
+GS_RANGE_SCOPE NSRange
+NSMakeRange(NSUInteger location, NSUInteger length) GS_RANGE_ATTR;
+
+/** Creates new range starting at location and of given length. */
+GS_RANGE_SCOPE NSRange
+NSMakeRange(NSUInteger location, NSUInteger length)
+{
+  NSRange range;
+  NSUInteger end = location + length;
+
+  if (end < location || end < length)
+    {
+      _NSRangeExceptionRaise ();
+    }
+  range.location = location;
+  range.length   = length;
+  return range;
+}
+
+GS_RANGE_SCOPE BOOL
+NSEqualRanges(NSRange range1, NSRange range2) GS_RANGE_ATTR;
+
+/** Returns whether range1 and range2 have same location and length. */
+GS_RANGE_SCOPE BOOL
+NSEqualRanges(NSRange range1, NSRange range2)
+{
+  return ((range1.location == range2.location)
+                && (range1.length == range2.length));
+}
+
+GS_RANGE_SCOPE NSRange
+NSUnionRange(NSRange range1, NSRange range2) GS_RANGE_ATTR;
+
+/** Returns range going from minimum of aRange's and bRange's locations to
+    maximum of their two max's. */
+GS_RANGE_SCOPE NSRange
+NSUnionRange(NSRange aRange, NSRange bRange)
+{
+  NSRange range;
+
+  range.location = MIN(aRange.location, bRange.location);
+  range.length   = MAX(NSMaxRange(aRange), NSMaxRange(bRange))
+                - range.location;
+  return range;
+}
+
+GS_RANGE_SCOPE NSRange
+NSIntersectionRange(NSRange range1, NSRange range2) GS_RANGE_ATTR;
+
+/** Returns range containing indices existing in both aRange and bRange.  If
+ *  the returned length is 0, the location is undefined and should be ignored.
+ */
+GS_RANGE_SCOPE NSRange
+NSIntersectionRange (NSRange aRange, NSRange bRange)
+{
+  NSRange range;
+
+  if (NSMaxRange(aRange) < bRange.location
+                || NSMaxRange(bRange) < aRange.location)
+    return NSMakeRange(0, 0);
+
+  range.location = MAX(aRange.location, bRange.location);
+  range.length   = MIN(NSMaxRange(aRange), NSMaxRange(bRange))
+                - range.location;
+  return range;
+}
+
+
+@class NSString;
+
+/** Returns string of form {location=a, length=b}. */
+GS_EXPORT NSString *NSStringFromRange(NSRange range);
+
+/** Parses range from string of form {location=a, length=b}; returns range
+    with 0 location and length if this fails. */
+GS_EXPORT NSRange NSRangeFromString(NSString *aString);
+
+#ifdef	GS_DEFINED_MAX
+#undef	GS_DEFINED_MAX
+#undef	MAX
+#endif
+
+#ifdef	GS_DEFINED_MIN
+#undef	GS_DEFINED_MIN
+#undef	MIN
+#endif
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#endif /* __NSRange_h_GNUSTEP_BASE_INCLUDE */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSValue.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSValue.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSValue.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,370 @@
+/* Interface for NSValue for GNUStep
+   Copyright (C) 1995, 1996 Free Software Foundation, Inc.
+
+   Written by:  Adam Fedor <fedor@boulder.colorado.edu>
+   Created: 1995
+   
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+   
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+   */ 
+
+#ifndef __NSValue_h_GNUSTEP_BASE_INCLUDE
+#define __NSValue_h_GNUSTEP_BASE_INCLUDE
+#import	"../GNUstepBase/GSVersionMacros.h"
+
+#import	"NSObject.h"
+#import	"NSGeometry.h"
+#import	"NSRange.h"
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+@class NSString;
+
+/**
+ * The <code>NSValue</code> class can wrap a single primitive value as an
+ * object so it can be used in the containers and other places where an object
+ * reference is needed. Once initialized, an <code>NSValue</code> is
+ * immutable, and there is no <code>NSMutableValue</code> class. You
+ * initialize it by giving it a pointer to the primitive value, and you should
+ * be careful this does not get freed until after the <code>NSValue</code> is
+ * no longer used.
+ */
+@interface NSValue : NSObject <NSCopying, NSCoding>
+
+// Allocating and Initializing 
+
+/**
+ * Create new instance with specified value (a pointer) of given type, which
+ * is a string code obtainable through the compile-time operator
+ * <code>@encode(...)</code>.  For example:
+<example>
+    NSValue *theValue = [NSValue value: &amp;n withObjCType: @encode(int)];
+</example>
+ */
++ (NSValue*) value: (const void*)value withObjCType: (const char*)type;
+
+/**
+ * Create new instance holding anObject.  This is useful if you want to add
+ * anObject to a collection such as [NSArray] but don't want it to be retained
+ * (a weak reference).
+ */
++ (NSValue*) valueWithNonretainedObject: (id)anObject;
+
+/**
+ * Convenience method to create instance holding an <code>NSPoint</code>
+ * structure.
+ */
++ (NSValue*) valueWithPoint: (NSPoint)point;
+
+/**
+ * Convenience method to create instance holding a pointer.  Same as
+ * using <code>@encode(void *)</code> in +value:withObjCType: .
+ */
++ (NSValue*) valueWithPointer: (const void*)pointer;
+
+/**
+ * Convenience method to create instance holding an <code>NSRange</code>
+ * structure.
+ */
++ (NSValue*) valueWithRange: (NSRange)range;
+
+/**
+ * Convenience method to create instance holding an <code>NSRect</code>
+ * structure.
+ */
++ (NSValue*) valueWithRect: (NSRect)rect;
+
+/**
+ * Convenience method to create instance holding an <code>NSSize</code>
+ * structure.
+ */
++ (NSValue*) valueWithSize: (NSSize)size;
+
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+/**
+ * Synonym for value:withObjCType: .
+ */
++ (NSValue*) valueWithBytes: (const void*)value objCType: (const char*)type;
+
+/** <init/>
+ * Initialize with value of type, parallel to value:withObjCType: .
+ */
+- (id) initWithBytes: (const void*)data objCType: (const char*)type;
+
+/**
+ * Compares this instance to another <code>NSValue</code>.  For equality,
+ * both contents and declared type of the two values must match.
+ */
+- (BOOL) isEqualToValue: (NSValue*)other;
+#endif	/* GS_API_MACOSX */
+
+// Accessing Data 
+
+/**
+ * Copies bytes from the pointer receiver was initialized with into buffer
+ * pointed to by value.  Number of bytes copied is determined by the type.  If
+ * type was a void * pointer or object id, the memory address itself is
+ * copied.
+ */
+- (void) getValue: (void*)value;
+
+/**
+ * Returns the string <code>@encode(...)</code> compatible type the receiver
+ * was initialized with.
+ */
+- (const char*) objCType;
+
+/**
+ * If receiver was initialized with an object ID, return it, else raises
+ * <code>NSInternalInconsistencyException</code>.
+ */
+- (id) nonretainedObjectValue;
+
+/**
+ * If receiver was initialized with a void * pointer, return it, else raises
+ * <code>NSInternalInconsistencyException</code>.
+ */
+- (void*) pointerValue;
+
+/**
+ * If receiver was initialized with an <code>NSRange</code> value, return it,
+ * else raises <code>NSInternalInconsistencyException</code>.
+ */
+- (NSRange) rangeValue;
+
+/**
+ * If receiver was initialized with an <code>NSRect</code> value, return it,
+ * else raises <code>NSInternalInconsistencyException</code>.
+ */
+- (NSRect) rectValue;
+
+/**
+ * If receiver was initialized with an <code>NSSize</code> value, return it,
+ * else raises <code>NSInternalInconsistencyException</code>.
+ */
+- (NSSize) sizeValue;
+
+/**
+ * If receiver was initialized with an <code>NSPoint</code> value, return it,
+ * else raises <code>NSInternalInconsistencyException</code>.
+ */
+- (NSPoint) pointValue;
+
+@end
+
+/**
+ * Subclass of [NSValue] offering convenience methods for initializing from
+ * and accessing as any C primitive numeric type.  On access, the value will
+ * be type-converted if necessary, using standard C conversion rules.
+ */
+@interface NSNumber : NSValue <NSCopying,NSCoding>
+
+// Allocating and Initializing
+
+/** New instance from boolean value. */
++ (NSNumber*) numberWithBool: (BOOL)value; 
+/** New instance from signed char value. */
++ (NSNumber*) numberWithChar: (signed char)value;
+/** New instance from double value. */
++ (NSNumber*) numberWithDouble: (double)value;
+/** New instance from float value. */
++ (NSNumber*) numberWithFloat: (float)value;
+/** New instance from (signed) int value. */
++ (NSNumber*) numberWithInt: (signed int)value;
+/** New instance from (signed) long value. */
++ (NSNumber*) numberWithLong: (signed long)value;
+/** New instance from (signed) long long value. */
++ (NSNumber*) numberWithLongLong: (signed long long)value;
+/** New instance from (signed) short value. */
++ (NSNumber*) numberWithShort: (signed short)value;
+/** New instance from unsigned char value. */
++ (NSNumber*) numberWithUnsignedChar: (unsigned char)value;
+/** New instance from unsigned int value. */
++ (NSNumber*) numberWithUnsignedInt: (unsigned int)value;
+/** New instance from unsigned long value. */
++ (NSNumber*) numberWithUnsignedLong: (unsigned long)value;
+/** New instance from unsigned long long value. */
++ (NSNumber*) numberWithUnsignedLongLong: (unsigned long long)value;
+/** New instance from unsigned short value. */
++ (NSNumber*) numberWithUnsignedShort: (unsigned short)value;
+
+/** Initialize from boolean value. */
+- (id) initWithBool: (BOOL)value;
+/** Initialize from signed char value. */
+- (id) initWithChar: (signed char)value;
+/** Initialize from double value. */
+- (id) initWithDouble: (double)value;
+/** Initialize from float value. */
+- (id) initWithFloat: (float)value;
+/** Initialize from (signed) int value. */
+- (id) initWithInt: (signed int)value;
+/** Initialize from (signed) long value. */
+- (id) initWithLong: (signed long)value;
+/** Initialize from (signed) long long value. */
+- (id) initWithLongLong: (signed long long)value;
+/** Initialize from (signed) short value. */
+- (id) initWithShort: (signed short)value;
+/** Initialize from unsigned char value. */
+- (id) initWithUnsignedChar: (unsigned char)value;
+/** Initialize from unsigned int value. */
+- (id) initWithUnsignedInt: (unsigned int)value;
+/** Initialize from unsigned long value. */
+- (id) initWithUnsignedLong: (unsigned long)value;
+/** Initialize from unsigned long long value. */
+- (id) initWithUnsignedLongLong: (unsigned long long)value;
+/** Initialize from unsigned short value. */
+- (id) initWithUnsignedShort: (unsigned short)value;
+
+// Accessing Data 
+
+/**
+ * Return value as a BOOL; this will in fact be a char value converted
+ * if necessary from type initialized with; if you wish to consider anything
+ * nonzero TRUE do not compare directly to YES, but use <code>'!= NO'</code>.
+ */
+- (BOOL) boolValue;
+/** Returns value as a signed char, converting if necessary. */
+- (signed char) charValue;
+/** Returns value as a double, converting if necessary. */
+- (double) doubleValue;
+/** Returns value as a float, converting if necessary. */
+- (float) floatValue;
+/** Returns value as a (signed) int, converting if necessary. */
+- (signed int) intValue;
+/** Returns value as a (signed) long, converting if necessary. */
+- (signed long) longValue;
+/** Returns value as a (signed) long long, converting if necessary. */
+- (signed long long) longLongValue;
+/** Returns value as a (signed) short, converting if necessary. */
+- (signed short) shortValue;
+/** Returns value as an unsigned char, converting if necessary. */
+- (unsigned char) unsignedCharValue;
+/** Returns value as an unsigned int, converting if necessary. */
+- (unsigned int) unsignedIntValue;
+/** Returns value as an unsigned long, converting if necessary. */
+- (unsigned long) unsignedLongValue;
+/** Returns value as an unsigned long long, converting if necessary. */
+- (unsigned long long) unsignedLongLongValue;
+/** Returns value as an unsigned short, converting if necessary. */
+- (unsigned short) unsignedShortValue;
+
+/** Returns -description . */
+- (NSString*) stringValue;
+
+/**
+ * Returns the string representation of this number using a non-localised
+ * conversion (decimal point is '.' irrespective of the locale).
+ */
+- (NSString*) description;
+
+/**
+ * <p>
+ *   Produces a string representation of the number.  For a boolean
+ *   this will be either 'true' or 'false'.  For other numbers the
+ *   format is produced using the initWithFormat:locale:... method
+ *   of NSString, and the format depends on the type of number as
+ *   follows -
+ * </p>
+ * <deflist>
+ *   <term>char</term>
+ *   <desc>%i</desc>
+ *   <term> short</term>
+ *   <desc>%hi</desc>
+ *   <term> int</term>
+ *   <desc>%i</desc>
+ *   <term> long</term>
+ *   <desc>%li</desc>
+ *   <term> long long</term>
+ *   <desc>%lli</desc>
+ *   <term> unsigned char</term>
+ *   <desc>%u</desc>
+ *   <term> unsigned short</term>
+ *   <desc>%hu</desc>
+ *   <term> unsigned int</term>
+ *   <desc>%u</desc>
+ *   <term> unsigned long</term>
+ *   <desc>%lu</desc>
+ *   <term> unsigned long long</term>
+ *   <desc>%llu</desc>
+ *   <term> float</term>
+ *   <desc>%0.7g</desc>
+ *   <term> double</term>
+ *   <desc>%0.16g</desc>
+ * </deflist>
+ */
+- (NSString*) descriptionWithLocale: (id)locale;
+
+/**
+ * Compares receiver with otherNumber, using C type conversion if necessary,
+ * and returns <code>NSOrderedAscending</code>,
+ * <code>NSOrderedDescending</code>, or <code>NSOrderedSame</code> depending
+ * on whether it is less than, greater than, or equal to otherNumber.
+ */
+- (NSComparisonResult) compare: (NSNumber*)otherNumber;
+
+/**
+ * Returns whether receiver and otherNumber represent the same numerical value.
+ */
+- (BOOL) isEqualToNumber: (NSNumber*)otherNumber;
+
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+/** Return a number intialised with NSInteger.
+ */
++ (NSNumber*) numberWithInteger: (NSInteger)value;
+/** Return a number intialised with NSUInteger.
+ */
++ (NSNumber*) numberWithUnsignedInteger: (NSUInteger)value;
+/** Initialise the receiver with NSInteger content.
+ */
+- (id) initWithInteger: (NSInteger)value;
+/** Initialise the receiver with NSUInteger content.
+ */
+- (id) initWithUnsignedInteger: (NSUInteger)value;
+/** Return the contents of the receiver as NSInteger.
+ */
+- (NSInteger) integerValue;
+/** Return the contents of the receiver as NSUInteger.
+ */
+- (NSUInteger) unsignedIntegerValue;
+#endif
+
+@end
+
+#if OS_API_VERSION(GS_API_NONE, GS_API_NONE)
+
+/** Note: Defines a method that is not in the OpenStep spec, but makes
+    subclassing easier. */
+@interface NSValue (Subclassing)
+
+/** Used by value: withObjCType: to determine the concrete subclass to alloc. */
++ (Class) valueClassWithObjCType: (const char*)type;
+
+@end
+#endif
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#if     !NO_GNUSTEP && !defined(GNUSTEP_BASE_INTERNAL)
+#import "../GNUstepBase/NSNumber+GNUstepBase.h"
+#endif
+
+#endif /* __NSValue_h_GNUSTEP_BASE_INCLUDE */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSDate.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSDate.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSDate.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,300 @@
+/* Interface for NSDate for GNUStep
+   Copyright (C) 1994, 1996, 1999 Free Software Foundation, Inc.
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+  */
+
+#ifndef __NSDate_h_GNUSTEP_BASE_INCLUDE
+#define __NSDate_h_GNUSTEP_BASE_INCLUDE
+#import	"../GNUstepBase/GSVersionMacros.h"
+
+#import	"NSObjCRuntime.h"
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+GS_EXPORT NSString * const NSSystemClockDidChangeNotification;
+
+/**
+ * Time interval difference between two dates, in seconds.
+ */
+typedef double NSTimeInterval;
+
+/**
+ * Time interval between the unix standard reference date of 1 January 1970
+ * and the OpenStep reference date of 1 January 2001<br />
+ * This number comes from:<br />
+ * (((31 years * 365 days) + 8 days for leap years) = total number of days<br />
+ * 24 hours * 60 minutes * 60 seconds)<br />
+ * This ignores leap-seconds.
+ */
+GS_EXPORT const NSTimeInterval NSTimeIntervalSince1970;
+
+#import	"NSObject.h"
+
+@class NSArray;
+@class NSCalendarDate;
+@class NSData;
+@class NSDictionary;
+@class NSString;
+@class NSTimeZone;
+@class NSTimeZoneDetail;
+
+@interface NSDate : NSObject <NSCoding,NSCopying>
+{
+}
+
+/** Returns an autoreleased instance with the current date/time.
+ */
++ (id) date;
+
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+/** Returns an autoreleased instance representing the date and time given
+ * by string. The value of string may be a 'natural' specification as
+ * specified by the preferences in the user defaults database, allowing
+ * phrases like 'last tuesday'
+ */
++ (id) dateWithNaturalLanguageString: (NSString*)string;
+
+/**
+ * <p>Returns an autoreleased instance representing the date and time given
+ * by string. The value of string may be a 'natural' specification as
+ * specified by the preferences in the user defaults database, allowing
+ * phrases like 'last tuesday'
+ * </p>
+ * The locale contains keys such as -
+ * <deflist>
+ *   <term>NSDateTimeOrdering</term>
+ *   <desc>Controls the use of ambiguous numbers. This is done as a
+ *   sequence of the letters D(ay), M(onth), Y(ear), and H(our).
+ *   YMDH means that the first number encountered is assumed to be a
+ *   year, the second a month, the third a day, and the last an hour.
+ *   </desc>
+ *   <term>NSEarlierTimeDesignations</term>
+ *   <desc>An array of strings for times in the past.<br />
+ *   Defaults are <em>ago</em>, <em>last</em>, <em>past</em>, <em>prior</em>
+ *   </desc>
+ *   <term>NSHourNameDesignations</term>
+ *   <desc>An array of arrays of strings identifying the time of day.
+ *   Each array has an hour as its first value, and one or more words
+ *   as subsequent values.<br />
+ *   Defaults are: (0, midnight), (10, morning), (12, noon, lunch),
+ *   (14, afternoon), (19, dinner).
+ *   </desc>
+ *   <term>NSLaterTimeDesignations</term>
+ *   <desc>An array of strings for times in the future.<br />
+ *   Default is <em>next</em>
+ *   </desc>
+ *   <term>NSNextDayDesignations</term>
+ *   <desc>The day after today. Default is <em>tomorrow.</em>
+ *   </desc>
+ *   <term>NSNextNextDayDesignations</term>
+ *   <desc>The day after tomorrow. Default is <em>nextday.</em>
+ *   </desc>
+ *   <term>NSPriorDayDesignations</term>
+ *   <desc>The day before today. Default is <em>yesterday.</em>
+ *   </desc>
+ *   <term>NSThisDayDesignations</term>
+ *   <desc>Identifies the current day. Default is <em>today.</em>
+ *   </desc>
+ *   <term>NSYearMonthWeekDesignations</term>
+ *   <desc>An array giving the word for year, month, and week.<br />
+ *   Defaults are <em>year</em>, <em>month</em> and <em>week</em>.
+ *   </desc>
+ * </deflist>
+ */
++ (id) dateWithNaturalLanguageString: (NSString*)string
+                              locale: (NSDictionary*)locale;
+#endif
+
+/** Returns an autoreleased instance with the date and time value given
+ * by the string using the ISO standard format YYYY-MM-DD HH:MM:SS +/-HHHMM
+ * (all the fields of which must be present).
+ */
++ (id) dateWithString: (NSString*)description;
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6,GS_API_LATEST)
+/** Returns an autoreleased NSDate instance whose value is offset from
+ * that of the given date by the specified interval in seconds.
+ */
++ (id) dateWithTimeInterval: (NSTimeInterval)seconds sinceDate: (NSDate*)date;
+#endif
+
+/** Returns an autoreleased instance with the offset from the unix system
+ * reference date of 1 January 1970, GMT.
+ */
++ (id) dateWithTimeIntervalSince1970: (NSTimeInterval)seconds;
+
+/** Returns an autoreleased instance with the offset from the current
+ * date/time given by seconds (which may be fractional).
+ */
++ (id) dateWithTimeIntervalSinceNow: (NSTimeInterval)seconds;
+
+/** Returns an autoreleased instance with the offset from the OpenStep
+ * reference date of 1 January 2001, GMT.
+ */
++ (id) dateWithTimeIntervalSinceReferenceDate: (NSTimeInterval)seconds;
+
+/** Returns an autoreleased instance with the date/time set in the far
+ * past.
+ */
++ (id) distantPast;
+
+/** Returns an autoreleased instance with the date/time set in the far
+ * future.
+ */
++ (id) distantFuture;
+
+/** Returns the time interval between the reference date and the current
+ * time.
+ */
++ (NSTimeInterval) timeIntervalSinceReferenceDate;
+
+/** Returns an autorelease date instance formed by adding the specified
+ * time interval in seconds to the receiver's time interval.
+ */
+- (id) addTimeInterval: (NSTimeInterval)seconds;
+
+/** Returns the time interval between the receivers value and the
+ * OpenStep reference date of 1 Jan 2001 GMT.
+ */
+- (NSComparisonResult) compare: (NSDate*)otherDate;
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6,GS_API_LATEST)
+/** Returns an autoreleased NSDate instance whose value is offset from
+ * that of the receiver by the specified interval.
+ */
+- (id) dateByAddingTimeInterval: (NSTimeInterval)ti;
+#endif
+
+/** Returns an autoreleased instance of the [NSCalendarDate] class whose
+ * date/time value is the same as that of the receiver, and which uses
+ * the formatString and timeZone specified.
+ */
+- (NSCalendarDate*) dateWithCalendarFormat: (NSString*)formatString
+				  timeZone: (NSTimeZone*)timeZone;
+
+/** Returns a string representation of the receiver formatted according
+ * to the default format string, time zone, and locale.
+ */
+- (NSString*) description;
+
+/** Returns a string representation of the receiver formatted according
+ * to the specified format string, time zone, and locale.
+ */
+- (NSString*) descriptionWithCalendarFormat: (NSString*)format
+				   timeZone: (NSTimeZone*)aTimeZone
+				     locale: (NSDictionary*)l;
+
+/** Returns a string representation of the receiver formatted according
+ * to the default format string and time zone, but using the given locale.
+ */
+- (NSString*) descriptionWithLocale: (id)locale;
+
+/** Returns the earlier of the receiver and otherDate.<br />
+ * If the two represent identical date/time values, returns the receiver.
+ */
+- (NSDate*) earlierDate: (NSDate*)otherDate;
+
+/** Returns an instance initialised with the current date/time.
+ */
+- (id) init;
+
+/** Returns an instance with the date and time value given
+ * by the string using the ISO standard format YYYY-MM-DD HH:MM:SS +/-HHHMM
+ * (all the fields of which must be present).
+ */
+- (id) initWithString: (NSString*)description;
+
+/** Returns an instance with the given offset from anotherDate.
+ */
+- (id) initWithTimeInterval: (NSTimeInterval)secsToBeAdded
+		  sinceDate: (NSDate*)anotherDate;
+
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+/** Returns an instance with the offset from the unix system
+ * reference date of 1 January 1970, GMT.
+ */
+- (id) initWithTimeIntervalSince1970: (NSTimeInterval)seconds;
+#endif
+
+/** Returns an instance with the offset from the current date/time.
+ */
+- (id) initWithTimeIntervalSinceNow: (NSTimeInterval)secsToBeAdded;
+
+/** <init />
+ * Returns an instance with the given offset from the OpenStep
+ * reference date of 1 January 2001, GMT.
+ */
+- (id) initWithTimeIntervalSinceReferenceDate: (NSTimeInterval)secs;
+
+/** Returns NO if other is not a date, otherwise returns the result of
+ * calling the -isEqualtoDate: method.
+ */
+- (BOOL) isEqual: (id)other;
+
+/**  Returns whether the receiver is exactly equal to other, to the limit
+ *  of the NSTimeInterval precision.<br />
+ *  This is the behavior of the current MacOS-X system, not that of the
+ *  OpenStep specification (which counted two dates within a second of
+ *  each other as being equal).<br />
+ *  The old behavior meant that two dates equal to a third date were not
+ *  necessarily equal to each other (confusing), and meant that there was
+ *  no reasonable way to use a date as a dictionary key or store dates
+ *  in a set.
+ */
+- (BOOL) isEqualToDate: (NSDate*)other;
+
+/** Returns the earlier of the receiver and otherDate.<br />
+ * If the two represent identical date/time values, returns the receiver.
+ */
+- (NSDate*) laterDate: (NSDate*)otherDate;
+
+/** Returns the time interval between the receivers value and the
+ * unix system reference date of 1 January 1970, GMT.
+ */
+- (NSTimeInterval) timeIntervalSince1970;
+
+/** Returns the time interval between the receivers value and that of the
+ * otherDate argument.  If otherDate is earlier than the receiver, the
+ * returned value will be positive, if it is later it will be negative.<br />
+ * For current (2011) OSX compatibility, this method returns NaN if otherDate
+ * is nil ... do not write code depending on that behavior.
+ */
+- (NSTimeInterval) timeIntervalSinceDate: (NSDate*)otherDate;
+
+/** Returns the time interval between the receivers value and the
+ * current date/time.  If the receiver represents a date/time in
+ * the past this will be negative, if it is in the future the
+ * returned value will be positive.
+ */
+- (NSTimeInterval) timeIntervalSinceNow;
+
+/** Returns the time interval between the receivers value and the
+ * OpenStep reference date of 1 Jan 2001 GMT.
+ */
+- (NSTimeInterval) timeIntervalSinceReferenceDate;
+
+@end
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#endif  /* __NSDate_h_GNUSTEP_BASE_INCLUDE*/
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSArray.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSArray.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSArray.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,430 @@
+/* Interface for NSArray for GNUStep
+   Copyright (C) 1995-2015 Free Software Foundation, Inc.
+
+   Written by:  Andrew Kachites McCallum <mccallum@gnu.ai.mit.edu>
+   Created: 1995
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+   */
+
+#ifndef __NSArray_h_GNUSTEP_BASE_INCLUDE
+#define __NSArray_h_GNUSTEP_BASE_INCLUDE
+#import	"../GNUstepBase/GSVersionMacros.h"
+
+#import	"NSObject.h"
+#import	"NSRange.h"
+#import "NSEnumerator.h"
+#if __BLOCKS__
+#import "../GNUstepBase/GSBlocks.h"
+#endif
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+@class NSString;
+@class NSURL;
+@class NSIndexSet;
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
+enum
+{
+  NSBinarySearchingFirstEqual = (1UL << 8), /** Specifies that the binary
+   * search should find the first object equal in the array.
+   */
+  NSBinarySearchingLastEqual = (1UL << 9), /** Specifies that the binary
+   * search should find the last object equal in the array.
+   */
+  NSBinarySearchingInsertionIndex = (1UL << 10), /** Specifies that the binary
+   * search should find the index at which an equal object should be inserted
+   * in order to keep the array sorted
+   */
+};
+
+typedef NSUInteger NSBinarySearchingOptions;
+#endif
+
+@interface GS_GENERIC_CLASS(NSArray, __covariant ElementT) : NSObject
+  <NSCoding, NSCopying, NSMutableCopying, NSFastEnumeration>
+
++ (instancetype) array;
++ (instancetype) arrayWithArray: (GS_GENERIC_CLASS(NSArray, ElementT) *)array;
++ (instancetype) arrayWithContentsOfFile: (NSString*)file;
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
++ (instancetype) arrayWithContentsOfURL: (NSURL*)aURL;
+#endif
++ (instancetype) arrayWithObject: (id)anObject;
++ (instancetype) arrayWithObjects: (id)firstObject, ...;
++ (instancetype) arrayWithObjects: (const id[])objects count: (NSUInteger)count;
+
+- (GS_GENERIC_CLASS(NSArray, ElementT) *) arrayByAddingObject:
+  (GS_GENERIC_TYPE(ElementT))anObject;
+- (GS_GENERIC_CLASS(NSArray, ElementT) *) arrayByAddingObjectsFromArray:
+  (GS_GENERIC_CLASS(NSArray, ElementT)*)anotherArray;
+- (BOOL) containsObject: (GS_GENERIC_TYPE(ElementT))anObject;
+
+/** <override-subclass />
+ * Returns the number of elements contained in the receiver.
+ */
+- (NSUInteger) count;
+- (void) getObjects: (__unsafe_unretained GS_GENERIC_TYPE(ElementT)[])aBuffer;
+- (void) getObjects: (__unsafe_unretained GS_GENERIC_TYPE(ElementT)[])aBuffer
+              range: (NSRange)aRange;
+- (NSUInteger) indexOfObject: (GS_GENERIC_TYPE(ElementT))anObject;
+- (NSUInteger) indexOfObject: (GS_GENERIC_TYPE(ElementT))anObject
+                     inRange: (NSRange)aRange;
+- (NSUInteger) indexOfObjectIdenticalTo: (GS_GENERIC_TYPE(ElementT))anObject;
+- (NSUInteger) indexOfObjectIdenticalTo: (GS_GENERIC_TYPE(ElementT))anObject
+                                inRange: (NSRange)aRange;
+- (instancetype) init;
+- (instancetype) initWithArray: (GS_GENERIC_CLASS(NSArray, ElementT)*)array;
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+- (instancetype) initWithArray: (GS_GENERIC_CLASS(NSArray, ElementT)*)array
+                     copyItems: (BOOL)shouldCopy;
+#endif
+- (instancetype) initWithContentsOfFile: (NSString*)file;
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+- (instancetype) initWithContentsOfURL: (NSURL*)aURL;
+#endif
+- (instancetype) initWithObjects: (GS_GENERIC_TYPE(ElementT)) firstObject, ...;
+
+/** <init /> <override-subclass />
+ * This should initialize the array with count (may be zero) objects.<br />
+ * Retains each object placed in the array.<br />
+ * Calls -init (which does nothing but maintain MacOS-X compatibility),
+ * and needs to be re-implemented in subclasses in order to have all
+ * other initialisers work.
+ */
+- (instancetype) initWithObjects: (const GS_GENERIC_TYPE(ElementT)[])objects
+                           count: (NSUInteger)count;
+- (GS_GENERIC_TYPE(ElementT)) lastObject;
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
+- (GS_GENERIC_TYPE(ElementT)) firstObject;
+#endif
+
+/** <override-subclass />
+ * Returns the object at the specified index.
+ * Raises an exception of the index is beyond the array.
+ */
+- (GS_GENERIC_TYPE(ElementT)) objectAtIndex: (NSUInteger)index;
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+- (GS_GENERIC_CLASS(NSArray, ElementT) *) objectsAtIndexes:
+  (NSIndexSet *)indexes;
+#endif
+
+- (GS_GENERIC_TYPE(ElementT)) firstObjectCommonWithArray:
+    (GS_GENERIC_CLASS(NSArray, ElementT) *)otherArray;
+- (BOOL) isEqualToArray: (NSArray*)otherArray;
+
+#if OS_API_VERSION(GS_API_OPENSTEP, GS_API_MACOSX)
+- (void) makeObjectsPerform: (SEL)aSelector;
+- (void) makeObjectsPerform: (SEL)aSelector withObject: (id)argument;
+#endif
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+- (void) makeObjectsPerformSelector: (SEL)aSelector;
+- (void) makeObjectsPerformSelector: (SEL)aSelector withObject: (id)arg;
+#endif
+
+- (NSData*) sortedArrayHint;
+- (GS_GENERIC_CLASS(NSArray, ElementT)*) sortedArrayUsingFunction:
+    (NSComparisonResult (*)(id, id, void*))comparator
+			        context: (void*)context;
+- (GS_GENERIC_CLASS(NSArray, ElementT)*) sortedArrayUsingFunction:
+    (NSComparisonResult (*)(id, id, void*))comparator
+			      context: (void*)context
+				     hint: (NSData*)hint;
+- (GS_GENERIC_CLASS(NSArray, ElementT)*) sortedArrayUsingSelector:
+  (SEL)comparator;
+- (GS_GENERIC_CLASS(NSArray, ElementT)*) subarrayWithRange: (NSRange)aRange;
+
+- (NSString*) componentsJoinedByString: (NSString*)separator;
+- (GS_GENERIC_CLASS(NSArray, NSString*)*) pathsMatchingExtensions:
+    (GS_GENERIC_CLASS(NSArray, NSString*)*)extensions;
+
+- (GS_GENERIC_CLASS(NSEnumerator, ElementT)*) objectEnumerator;
+- (GS_GENERIC_CLASS(NSEnumerator, ElementT)*) reverseObjectEnumerator;
+
+- (NSString*) description;
+- (NSString*) descriptionWithLocale: (id)locale;
+- (NSString*) descriptionWithLocale: (id)locale
+			     indent: (NSUInteger)level;
+
+- (BOOL) writeToFile: (NSString*)path atomically: (BOOL)useAuxiliaryFile;
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+- (BOOL) writeToURL: (NSURL*)url atomically: (BOOL)useAuxiliaryFile;
+- (GS_GENERIC_TYPE(ElementT)) valueForKey: (NSString*)key;
+- (void) setValue: (GS_GENERIC_TYPE(ElementT))value forKey: (NSString*)key;
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
+
+#if __BLOCKS__
+DEFINE_BLOCK_TYPE(GSEnumeratorBlock, void, GS_GENERIC_TYPE(ElementT),
+  NSUInteger, BOOL*);
+DEFINE_BLOCK_TYPE(GSPredicateBlock, BOOL, GS_GENERIC_TYPE(ElementT),
+  NSUInteger, BOOL*);
+/**
+ * Enumerate over the collection using the given block.  The first argument is
+ * the object and the second is the index in the array.  The final argument is
+ * a pointer to a BOOL indicating whether the enumeration should stop.  Setting
+ * this to YES will interrupt the enumeration.
+ */
+- (void) enumerateObjectsUsingBlock: (GSEnumeratorBlock)aBlock;
+
+/**
+ * Enumerate over the collection using the given block.  The first argument is
+ * the object and the second is the index in the array.  The final argument is
+ * a pointer to a BOOL indicating whether the enumeration should stop.  Setting
+ * this to YES will interrupt the enumeration.
+ *
+ * The opts argument is a bitfield.  Setting the NSNSEnumerationConcurrent flag
+ * specifies that it is thread-safe.  The NSEnumerationReverse bit specifies
+ * that it should be enumerated in reverse order.
+ */
+- (void) enumerateObjectsWithOptions: (NSEnumerationOptions)opts
+			  usingBlock: (GSEnumeratorBlock)aBlock;
+/**
+ * Enumerate over the specified indexes in the collection using the given
+ * block.  The first argument is the object and the second is the index in the
+ * array.  The final argument is a pointer to a BOOL indicating whether the
+ * enumeration should stop.  Setting this to YES will interrupt the
+ * enumeration.
+ *
+ * The opts argument is a bitfield.  Setting the NSNSEnumerationConcurrent flag
+ * specifies that it is thread-safe.  The NSEnumerationReverse bit specifies
+ * that it should be enumerated in reverse order.
+ */
+- (void) enumerateObjectsAtIndexes: (NSIndexSet*)indexSet
+			   options: (NSEnumerationOptions)opts
+			usingBlock: (GSEnumeratorBlock)block;
+/**
+ * Returns the indexes of the objects in a collection that match the condition
+ * specified by the block.
+ *
+ * The opts argument is a bitfield.  Setting the NSNSEnumerationConcurrent flag
+ * specifies that it is thread-safe.  The NSEnumerationReverse bit specifies
+ * that it should be enumerated in reverse order.
+ */
+- (NSIndexSet *) indexesOfObjectsWithOptions: (NSEnumerationOptions)opts
+				 passingTest: (GSPredicateBlock)predicate;
+
+/**
+ * Returns the indexes of the objects in a collection that match the condition
+ * specified by the block.
+ */
+- (NSIndexSet*) indexesOfObjectsPassingTest: (GSPredicateBlock)predicate;
+
+/**
+ * Returns the indexes of the objects in a collection that match the condition
+ * specified by the block and are in the range specified by the index set.
+ *
+ * The opts argument is a bitfield.  Setting the NSNSEnumerationConcurrent flag
+ * specifies that it is thread-safe.  The NSEnumerationReverse bit specifies
+ * that it should be enumerated in reverse order.
+ */
+- (NSIndexSet*) indexesOfObjectsAtIndexes: (NSIndexSet*)indexSet
+				  options: (NSEnumerationOptions)opts
+			      passingTest: (GSPredicateBlock)predicate;
+
+/**
+ * Returns the index of the first object in the array that matches the
+ * condition specified by the block.
+ *
+ * The opts argument is a bitfield.  Setting the NSNSEnumerationConcurrent flag
+ * specifies that it is thread-safe.  The NSEnumerationReverse bit specifies
+ * that it should be enumerated in reverse order.
+ */
+- (NSUInteger) indexOfObjectWithOptions: (NSEnumerationOptions)opts
+			    passingTest: (GSPredicateBlock)predicate;
+
+/**
+ * Returns the index of the first object in the array that matches the
+ * condition specified by the block.
+ */
+- (NSUInteger) indexOfObjectPassingTest: (GSPredicateBlock)predicate;
+
+/**
+ * Returns the index of the first object in the specified range in a collection
+ * that matches the condition specified by the block.
+ *
+ * The opts argument is a bitfield.  Setting the NSNSEnumerationConcurrent flag
+ * specifies that it is thread-safe.  The NSEnumerationReverse bit specifies
+ * that it should be enumerated in reverse order.
+ */
+- (NSUInteger) indexOfObjectAtIndexes: (NSIndexSet*)indexSet
+			      options: (NSEnumerationOptions)opts
+			  passingTest: (GSPredicateBlock)predicate;
+
+/** Returns a sorted array using the comparator to determine the
+ * order of objects.
+ */
+- (GS_GENERIC_CLASS(NSArray, ElementT) *) sortedArrayUsingComparator:
+    (NSComparator)comparator;
+
+/** Returns a sorted array using the block to determine the order of objects.
+ *
+ * The opts argument is a bitfield.  Setting the NSSortConcurrent flag
+ * specifies that it is thread-safe.  The NSSortStable bit specifies that
+ * it should keep equal objects in the same order.
+ */
+- (GS_GENERIC_CLASS(NSArray, ElementT) *)
+    sortedArrayWithOptions: (NSSortOptions)options
+           usingComparator: (NSComparator)comparator;
+
+/**
+ * Performs a binary search of the array within the specified range for the
+ * index of an object equal to obj according to cmp.
+ * If NSBinarySearchingInsertionIndex is specified, searches for the index
+ * at which such an object should be inserted.
+ */
+- (NSUInteger) indexOfObject: (id)key
+               inSortedRange: (NSRange)range
+                     options: (NSBinarySearchingOptions)options
+             usingComparator: (NSComparator)comparator;
+#endif
+#endif
+/**
+ * Accessor for subscripting.  This is called by the compiler when you write
+ * code like anArray[12].  It should not be called directly.
+ */
+- (GS_GENERIC_TYPE(ElementT)) objectAtIndexedSubscript: (NSUInteger)anIndex;
+@end
+
+
+@interface GS_GENERIC_CLASS(NSMutableArray, ElementT) : NSArray
+
++ (instancetype) arrayWithCapacity: (NSUInteger)numItems;
+
+/** <override-subclass />
+ * Adds anObject at the end of the array, thus increasing the size of
+ * the array.  The object is retained upon addition.
+ */
+- (void) addObject: (GS_GENERIC_TYPE(ElementT))anObject;
+- (void) addObjectsFromArray: (GS_GENERIC_CLASS(NSArray, ElementT)*)otherArray;
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+- (void) exchangeObjectAtIndex: (NSUInteger)i1
+	     withObjectAtIndex: (NSUInteger)i2;
+#endif
+
+/** <init /> <override-subclass />
+ * Initialise the array with the specified capacity ... this
+ * should ensure that the array can have numItems added efficiently.<br />
+ * Calls -init (which does nothing but maintain MacOS-X compatibility),
+ * and needs to be re-implemented in subclasses in order to have all
+ * other initialisers work.
+ */
+- (instancetype) initWithCapacity: (NSUInteger)numItems;
+
+/** <override-subclass />
+ * Inserts an object into the receiver at the specified location.<br />
+ * Raises an exception if given an array index which is too large.<br />
+ * The size of the array increases by one.<br />
+ * The object is retained by the array.
+ */
+- (void) insertObject: (GS_GENERIC_TYPE(ElementT))anObject
+              atIndex: (NSUInteger)index;
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+- (void) insertObjects: (GS_GENERIC_CLASS(NSArray, ElementT) *)objects
+             atIndexes: (NSIndexSet *)indexes;
+#endif
+
+/** <override-subclass />
+ * Removes an object from the receiver at the specified location.<br />
+ * The size of the array decreases by one.<br />
+ * Raises an exception if given an array index which is too large.<br />
+ */
+- (void) removeObjectAtIndex: (NSUInteger)index;
+
+- (void) removeObjectsAtIndexes: (NSIndexSet *)indexes;
+
+/** <override-subclass />
+ * Places an object into the receiver at the specified location.<br />
+ * Raises an exception if given an array index which is too large.<br />
+ * The object is retained by the array.
+ */
+- (void) replaceObjectAtIndex: (NSUInteger)index
+		   withObject: (GS_GENERIC_TYPE(ElementT))anObject;
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+- (void) replaceObjectsAtIndexes: (NSIndexSet *)indexes
+                     withObjects: (GS_GENERIC_CLASS(NSArray, ElementT)*)objects;
+#endif
+
+- (void) replaceObjectsInRange: (NSRange)aRange
+          withObjectsFromArray: (GS_GENERIC_CLASS(NSArray, ElementT)*)anArray;
+
+- (void) replaceObjectsInRange: (NSRange)aRange
+          withObjectsFromArray: (GS_GENERIC_CLASS(NSArray, ElementT)*)anArray
+                         range: (NSRange)anotherRange;
+
+- (void) setArray: (GS_GENERIC_CLASS(NSArray, ElementT) *)otherArray;
+
+- (void) removeAllObjects;
+- (void) removeLastObject;
+- (void) removeObject: (GS_GENERIC_TYPE(ElementT))anObject;
+- (void) removeObject: (GS_GENERIC_TYPE(ElementT))anObject
+              inRange: (NSRange)aRange;
+- (void) removeObjectIdenticalTo: (GS_GENERIC_TYPE(ElementT))anObject;
+- (void) removeObjectIdenticalTo: (GS_GENERIC_TYPE(ElementT))anObject
+                         inRange: (NSRange)aRange;
+- (void) removeObjectsInArray: (GS_GENERIC_CLASS(NSArray, ElementT)*)otherArray;
+- (void) removeObjectsInRange: (NSRange)aRange;
+- (void) removeObjectsFromIndices: (NSUInteger*)indices
+		       numIndices: (NSUInteger)count;
+
+- (void) sortUsingFunction:
+    (NSComparisonResult (*)(GS_GENERIC_TYPE(ElementT),
+       GS_GENERIC_TYPE(ElementT),void*))compare
+		           context: (void*)context;
+- (void) sortUsingSelector: (SEL)comparator;
+
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
+#if __BLOCKS__
+/**
+ * Sorts the array using the specified comparator block.
+ */
+- (void) sortUsingComparator: (NSComparator)comparator;
+
+/**
+ * Sorts the array using the specified comparator block and options.
+ */
+- (void) sortWithOptions: (NSSortOptions)options
+         usingComparator: (NSComparator)comparator;
+#endif
+#endif
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_8, GS_API_LATEST)
+/** Set method called by the compiler with array subscripting.<br />
+ * Replaces the object at anIndex or, if anIndex is the length of the array,
+ * this method appends abObject to the array.
+ */
+- (void) setObject: (GS_GENERIC_TYPE(ElementT))anObject
+atIndexedSubscript: (NSUInteger)anIndex;
+#endif
+@end
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#if	!NO_GNUSTEP && !defined(GNUSTEP_BASE_INTERNAL)
+#import	"../GNUstepBase/NSArray+GNUstepBase.h"
+#endif
+
+#endif /* __NSArray_h_GNUSTEP_BASE_INCLUDE */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSEnumerator.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSEnumerator.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSEnumerator.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,63 @@
+/*
+   NSEnumerator.h
+
+   Copyright (C) 1998 Free Software Foundation, Inc.
+
+   Author:  Scott Christley <scottc@net-community.com>
+   Date: January 1998
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+*/
+
+#ifndef __NSEnumerator_h_GNUSTEP_BASE_INCLUDE
+#define __NSEnumerator_h_GNUSTEP_BASE_INCLUDE
+#import	"../GNUstepBase/GSVersionMacros.h"
+
+#import	"NSObject.h"
+
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+@class GS_GENERIC_CLASS(NSArray, ElementT);
+
+typedef struct
+{
+  unsigned long	state;
+  __unsafe_unretained id		*itemsPtr;
+  unsigned long	*mutationsPtr;
+  unsigned long	extra[5];
+} NSFastEnumerationState;
+
+@protocol NSFastEnumeration
+- (NSUInteger) countByEnumeratingWithState: (NSFastEnumerationState *)state
+				   objects: (__unsafe_unretained id[])stackbuf
+				     count: (NSUInteger)len;
+@end
+
+@interface GS_GENERIC_CLASS(NSEnumerator, IterT) : NSObject <NSFastEnumeration>
+- (GS_GENERIC_CLASS(NSArray, IterT) *) allObjects;
+- (GS_GENERIC_TYPE(IterT)) nextObject;
+@end
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#endif /* __NSEnumerator_h_GNUSTEP_BASE_INCLUDE */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSObjCRuntime.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSObjCRuntime.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSObjCRuntime.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,317 @@
+/** Interface to ObjC runtime for GNUStep
+   Copyright (C) 1995, 1997, 2000 Free Software Foundation, Inc.
+
+   Written by:  Andrew Kachites McCallum <mccallum@gnu.ai.mit.edu>
+   Date: 1995
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+
+    AutogsdocSource: NSObjCRuntime.m
+    AutogsdocSource: NSLog.m
+
+   */
+
+#ifndef __NSObjCRuntime_h_GNUSTEP_BASE_INCLUDE
+#define __NSObjCRuntime_h_GNUSTEP_BASE_INCLUDE
+
+#ifdef __cplusplus
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+#endif
+
+#import	"../GNUstepBase/GSVersionMacros.h"
+#import	"../GNUstepBase/GSConfig.h"
+#import	"../GNUstepBase/GNUstep.h"
+#if __BLOCKS__
+#import	"../GNUstepBase/GSBlocks.h"
+#endif
+
+#include <stdarg.h>
+#include <limits.h>
+#include <float.h>
+
+/* PA HP-UX kludge.  */
+#if defined(__hppa__) && defined(__hpux__) && !defined(PRIuPTR)
+#define PRIuPTR "lu"
+#endif
+
+/* IRIX kludge.  */
+#if defined(__sgi)
+/* IRIX 6.5 <inttypes.h> provides all definitions, but only for C99
+   compilations.  */
+#define PRId8 "hhd"
+#define PRIu8 "hhu"
+#if (_MIPS_SZLONG == 32)
+#define PRId64 "lld"
+#define PRIu64 "llu"
+#endif
+/* This doesn't match <inttypes.h>, which always has "lld" here, but the
+   arguments are uint64_t, int64_t, which are unsigned long, long for
+   64-bit in <sgidefs.h>.  */
+#if (_MIPS_SZLONG == 64)
+#define PRId64 "ld"
+#define PRIu64 "lu"
+#endif
+/* This doesn't match <inttypes.h>, which has "u" here, but the arguments
+   are uintptr_t, which is always unsigned long.  */
+#define PRIuPTR "lu"
+#endif
+
+/* Solaris < 10 kludge.  */
+#if defined(__sun__) && defined(__svr4__) && !defined(PRIuPTR)
+#if defined(__arch64__) || defined (__x86_64__)
+#define PRIuPTR "lu"
+#define PRIdPTR "ld"
+#define PRIxPTR "lx"
+#else
+#define PRIuPTR "u"
+#define PRIdPTR "d"
+#define PRIxPTR "x"
+#endif
+#endif
+
+
+/* These typedefs must be in place before GSObjCRuntime.h is imported.
+ */
+
+#if     !defined(NSINTEGER_DEFINED)
+typedef	intptr_t	NSInteger;
+typedef	uintptr_t	NSUInteger;
+#	define NSIntegerMax  INTPTR_MAX
+#	define NSIntegerMin  INTPTR_MIN
+#	define NSUIntegerMax UINTPTR_MAX
+#endif /* !defined(NSINTEGER_DEFINED) */
+
+#if     !defined(CGFLOAT_DEFINED)
+#if     GS_SIZEOF_VOIDP == 8
+#define CGFLOAT_IS_DBL  1
+typedef double          CGFloat;
+#define CGFLOAT_MIN	DBL_MIN
+#define CGFLOAT_MAX	DBL_MAX
+#else
+typedef float           CGFloat;
+#define CGFLOAT_MIN	FLT_MIN
+#define CGFLOAT_MAX	FLT_MAX
+#endif
+#endif /* !defined(CGFLOAT_DEFINED) */
+
+#define NSINTEGER_DEFINED 1
+#define CGFLOAT_DEFINED 1
+#ifndef NS_AUTOMATED_REFCOUNT_UNAVAILABLE
+#  if __has_feature(objc_arc)
+#    define NS_AUTOMATED_REFCOUNT_UNAVAILABLE \
+      __attribute__((unavailable("Not available with automatic reference counting")))
+#  else
+#    define NS_AUTOMATED_REFCOUNT_UNAVAILABLE
+#  endif
+#endif
+
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+
+/*
+ * We can have strongly typed enums in C++11 mode or when the objc_fixed_enum
+ * feature is availble.
+ */
+#if (__has_feature(objc_fixed_enum) || (__cplusplus && (__cplusplus > 199711L) && __has_extension(cxx_strong_enums)))
+#  define _GS_NAMED_ENUM(ty, name) enum name : ty name; enum name : ty
+#  define _GS_ANON_ENUM(ty) enum : ty
+#  if __cplusplus
+#    define NS_OPTIONS(ty,name) ty name; enum : ty
+#  else
+#    define NS_OPTIONS(ty,name) NS_ENUM(ty,name)
+#  endif
+#else // this provides less information, but works with older compilers
+#  define _GS_NAMED_ENUM(ty, name) ty name; enum
+#  define _GS_ANON_ENUM(ty) enum
+#  define NS_OPTIONS(ty, name) NS_ENUM(ty, name)
+#endif
+// A bit of fairy dust to expand NS_ENUM to the correct variant
+#define _GS_GET_ENUM_MACRO(_first,_second,NAME,...) NAME
+/* The trick here is that placing the variadic args first will push the name
+ * that the _GS_GET_ENUM_MACRO expands to into the correct position.
+ */
+#define NS_ENUM(...) _GS_GET_ENUM_MACRO(__VA_ARGS__,_GS_NAMED_ENUM,_GS_ANON_ENUM)(__VA_ARGS__)
+
+/*
+ * If the compiler supports nullability qualifiers, we define the macros for
+ * non-null sections.
+ */
+#if __has_feature(nullability)
+#  define NS_ASSUME_NONNULL_BEGIN _Pragma("clang assume_nonnull begin")
+#  define NS_ASSUME_NONNULL_END   _Pragma("clang assume_nonnull end")
+#else
+#  define NS_ASSUME_NONNULL_BEGIN
+#  define NS_ASSUME_NONNULL_END
+#endif
+
+/*
+ * Backwards compatibility macro for instance type.
+ */
+#if !__has_feature(objc_instancetype)
+# define instancetype id
+#endif
+
+/*
+ * Backwards compatibility macros for Objective-C lightweight generics.
+ */
+#if __has_feature(objc_generics)
+# define GS_GENERIC_CLASS(clz, ...) clz<__VA_ARGS__>
+# define GS_GENERIC_TYPE_F(typeRef, fallback) typeRef
+#else
+# define GS_GENERIC_CLASS(clz, ...) clz
+# define GS_GENERIC_TYPE_F(typeRef, fallback) fallback
+#endif
+#define GS_GENERIC_TYPE(typeRef) GS_GENERIC_TYPE_F(typeRef, id)
+
+/**
+ * Backwards compatibility macro for the objc_designated_initializer attribute
+ */
+#if __has_attribute(objc_designated_initializer)
+#  define NS_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
+#else
+#  define NS_DESIGNATED_INITIALIZER
+#endif
+
+/** Bitfield used to specify options to control enumeration over collections.
+ */
+typedef NS_OPTIONS(NSUInteger, NSEnumerationOptions)
+{
+  NSEnumerationConcurrent = (1UL << 0), /** Specifies that the enumeration
+   * is concurrency-safe.  Note that this does not mean that it will be
+   * carried out in a concurrent manner, only that it can be.
+   */
+
+  NSEnumerationReverse = (1UL << 1) /** Specifies that the enumeration should
+   * happen in the opposite of the natural order of the collection.
+   */
+};
+
+
+/** Bitfield used to specify options to control the sorting of collections.
+ */
+typedef NS_OPTIONS(NSUInteger, NSSortOptions)
+{
+    NSSortConcurrent = (1UL << 0), /** Specifies that the sort
+     * is concurrency-safe.  Note that this does not mean that it will be
+     * carried out in a concurrent manner, only that it can be.
+     */
+    NSSortStable = (1UL << 4) /** Specifies that the sort should keep
+     * equal objects in the same order in the collection.
+     */
+};
+
+
+#import "../GNUstepBase/GSObjCRuntime.h"
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST)
+GS_EXPORT NSString	*NSStringFromProtocol(Protocol *aProtocol);
+GS_EXPORT Protocol	*NSProtocolFromString(NSString *aProtocolName);
+#endif
+GS_EXPORT SEL		NSSelectorFromString(NSString *aSelectorName);
+GS_EXPORT NSString	*NSStringFromSelector(SEL aSelector);
+GS_EXPORT SEL		NSSelectorFromString(NSString *aSelectorName);
+GS_EXPORT Class		NSClassFromString(NSString *aClassName);
+GS_EXPORT NSString	*NSStringFromClass(Class aClass);
+GS_EXPORT const char	*NSGetSizeAndAlignment(const char *typePtr,
+  NSUInteger *sizep, NSUInteger *alignp);
+
+#if OS_API_VERSION(GS_API_NONE, GS_API_NONE)
+/* Logging */
+/**
+ *  OpenStep spec states that log messages go to stderr, but just in case
+ *  someone wants them to go somewhere else, they can implement a function
+ *  like this and assign a pointer to it to _NSLog_printf_handler.
+ */
+typedef void NSLog_printf_handler (NSString* message);
+GS_EXPORT NSLog_printf_handler	*_NSLog_printf_handler;
+GS_EXPORT int	_NSLogDescriptor;
+@class NSRecursiveLock;
+GS_EXPORT NSRecursiveLock	*GSLogLock(void);
+#endif
+
+GS_EXPORT void	NSLog(NSString *format, ...) NS_FORMAT_FUNCTION(1,2);
+GS_EXPORT void	NSLogv(NSString *format, va_list args) NS_FORMAT_FUNCTION(1,0);
+
+#ifndef YES
+#define YES		1
+#endif
+#ifndef NO
+#define NO		0
+#endif
+#ifndef nil
+#define nil		0
+#endif
+
+/**
+ * Contains values <code>NSOrderedSame</code>, <code>NSOrderedAscending</code>
+ * <code>NSOrderedDescending</code>, for left hand side equals, less than, or
+ * greater than right hand side.
+ */
+typedef NS_ENUM(NSInteger, NSComparisonResult)
+{
+  NSOrderedAscending = (NSInteger)-1, NSOrderedSame, NSOrderedDescending
+};
+
+enum {NSNotFound = NSIntegerMax};
+
+#if __BLOCKS__
+DEFINE_BLOCK_TYPE(NSComparator, NSComparisonResult, id, id);
+#endif
+
+/**
+ * Declare the foundation export macro as an alias to GS_EXPORT 
+ */
+#define FOUNDATION_EXPORT GS_EXPORT
+
+#if	defined(__cplusplus)
+}
+#endif
+
+/**
+ * Declare Apple availability macros for compatibility purposes as no-ops.
+ */
+#define NS_CLASS_AVAILABLE(...)
+#define NS_AVAILABLE(...)
+#define NS_AVAILABLE_MAC(...)
+#define NS_DEPRECATED(...)
+#define NS_DEPRECATED_MAC(...)
+#define NS_ENUM_AVAILABLE(...)
+#define NS_ENUM_AVAILABLE_MAC(...)
+#define NS_ENUM_DEPRECATED(...)
+#define NS_ENUM_DEPRECATED_MAC(...)
+#define NS_CLASS_AVAILABLE(...)
+#define NS_CLASS_DEPRECATED(...)
+#define NS_CLASS_AVAILABLE_MAC(...)
+#define NS_CLASS_DEPRECATED_MAC(...)
+#define NS_UNAVAILABLE
+
+/* Define root class NS macro */
+#ifndef NS_ROOT_CLASS
+#if __has_attribute(objc_root_class)
+#define NS_ROOT_CLASS __attribute__((objc_root_class))
+#else
+#define NS_ROOT_CLASS
+#endif
+#endif
+
+#endif /* __NSObjCRuntime_h_GNUSTEP_BASE_INCLUDE */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSAutoreleasePool.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSAutoreleasePool.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSAutoreleasePool.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,333 @@
+/* Interface for NSAutoreleasePool for GNUStep
+   Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.
+
+   Written by:  Andrew Kachites McCallum <mccallum@gnu.ai.mit.edu>
+   Date: 1995
+   
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+   
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+   */ 
+
+#ifndef __NSAutoreleasePool_h_GNUSTEP_BASE_INCLUDE
+#define __NSAutoreleasePool_h_GNUSTEP_BASE_INCLUDE
+#import	"../GNUstepBase/GSVersionMacros.h"
+
+#import	"NSObject.h"
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+@class NSAutoreleasePool;
+@class NSThread;
+
+
+/**
+ * Each thread has its own copy of these variables.
+ <example>
+{
+  NSAutoreleasePool *current_pool; // current pool for thread
+  unsigned total_objects_count;    // total #/autoreleased objects over thread's lifetime
+  id *pool_cache;                  // cache of previously-allocated pools,
+  int pool_cache_size;             //  used internally for recycling
+  int pool_cache_count;
+}
+ </example>
+*/
+typedef struct autorelease_thread_vars
+{
+  /* The current, default NSAutoreleasePool for the calling thread;
+     the one that will hold objects that are arguments to
+     [NSAutoreleasePool +addObject:]. */
+  __unsafe_unretained NSAutoreleasePool *current_pool;
+
+  /* The total number of objects autoreleased since the thread was
+     started, or since -resetTotalAutoreleasedObjects was called
+     in this thread. (if compiled in) */
+  unsigned total_objects_count;
+
+  /* A cache of NSAutoreleasePool's already alloc'ed.  Caching old pools
+     instead of deallocating and re-allocating them will save time. */
+  __unsafe_unretained id *pool_cache;
+  int pool_cache_size;
+  int pool_cache_count;
+} thread_vars_struct;
+
+/* Initialize an autorelease_thread_vars structure for a new thread.
+   This function is called in NSThread each time an NSThread is created.
+   TV should be of type `struct autorelease_thread_vars *' */
+#define init_autorelease_thread_vars(TV) \
+memset (TV, 0, sizeof (__typeof__ (*TV)))
+
+
+
+/**
+ *  Each pool holds its objects-to-be-released in a linked-list of 
+    these structures.
+    <example>
+{
+  struct autorelease_array_list *next;
+  unsigned size;
+  unsigned count;
+  id objects[0];
+}
+    </example>
+ */
+typedef struct autorelease_array_list
+{
+  struct autorelease_array_list *next;
+  unsigned size;
+  unsigned count;
+  __unsafe_unretained id objects[0];
+} array_list_struct;
+
+
+
+/**
+ * <p>
+ *   The standard OpenStep system of memory management employs retain counts.
+ *   When an object is created, it has a retain count of 1.  When an object
+ *   is retained, the retain count is incremented.  When it is released the
+ *   retain count is decremented, and when the retain count goes to zero the
+ *   object gets deallocated.
+ * </p>
+ * <p>
+ *   A simple retain/release mechanism has problems with passing objects
+ *   from one scope to another,
+ *   so it's augmented with autorelease pools.  You can use the
+ *   AUTORELEASE() macro to call the [NSObject-autorelease]
+ *   method, which adds an object to the current autorelease pool by
+ *   calling [NSAutoreleasePool+addObject:].<br />
+ *   An autorelease pool simply maintains a reference to each object
+ *   added to it, and for each addition, the autorelease pool will
+ *   call the [NSObject-release] method of the object when the pool
+ *   is released.  So doing an AUTORELEASE() is just the same as
+ *   doing a RELEASE(), but deferred until the current autorelease
+ *   pool is deallocated.
+ * </p>
+ * <p>
+ *   The NSAutoreleasePool class maintains a separate stack of
+ *   autorelease pools objects in each thread.
+ * </p>
+ * <p>
+ *   When an autorelease pool is created, it is automatically
+ *   added to the stack of pools in the thread.
+ * </p>
+ * <p>
+ *   When a pool is destroyed, it (and any pool later in
+ *   the stack) is removed from the stack.
+ * </p>
+ * <p>
+ *   This mechanism provides a simple but controllable and reasonably
+ *   efficient way of managing temporary objects.  An object can be
+ *   autoreleased and then passed around and used until the topmost 
+ *   pool in the stack is destroyed.
+ * </p>   
+ * <p>
+ *   Most methods return objects which are either owned by autorelease
+ *   pools or by the receiver of the method, so the lifetime of the
+ *   returned object can be assumed to be the shorter of the lifetime
+ *   of the current autorelease pool, or that of the receiver on which
+ *   the method was called.<br />
+ *   The exceptions to this are those object returned by -
+ * </p>
+ * <deflist>
+ *   <term>[NSObject+alloc], [NSObject+allocWithZone:]</term>
+ *   <desc>
+ *     Methods whose names begin with alloc return an uninitialised
+ *     object, owned by the caller.
+ *   </desc>
+ *   <term>[NSObject-init]</term>
+ *   <desc>
+ *     Methods whose names begin with init return an initialised
+ *     version of the receiving object, owned by the caller.<br />
+ *     NB. The returned object may not actually be the same as the
+ *     receiver ... sometimes an init method releases the original
+ *     receiver and returns an alternative.
+ *   </desc>
+ *   <term>[NSObject+new]</term>
+ *   <desc>
+ *     Methods whose names begin with new combine the effects of
+ *     allocation and initialisation.
+ *   </desc>
+ *   <term>[NSObject-copy], [(NSCopying)-copyWithZone:]</term>
+ *   <desc>
+ *     Methods whose names begin with copy create a copy of the receiver
+ *     which is owned by the caller.
+ *   </desc>
+ *   <term>
+ *     [NSObject-mutableCopy], [(NSMutableCopying)-mutableCopyWithZone:]
+ *   </term>
+ *   <desc>
+ *     Methods whose names begin with mutableCopy create a copy of the receiver
+ *     which is owned by the caller.
+ *   </desc>
+ * </deflist>
+ */
+NS_AUTOMATED_REFCOUNT_UNAVAILABLE
+@interface NSAutoreleasePool : NSObject 
+{
+#if	GS_EXPOSE(NSAutoreleasePool) && !__has_feature(objc_arc)
+  /* For re-setting the current pool when we are dealloc'ed. */
+  NSAutoreleasePool *_parent;
+  /* This pointer to our child pool is  necessary for co-existing
+     with exceptions. */
+  NSAutoreleasePool *_child;
+  /* A collection of the objects to be released. */
+  struct autorelease_array_list *_released;
+  struct autorelease_array_list *_released_head;
+  /* The total number of objects autoreleased in this pool. */
+  unsigned _released_count;
+  /* The method to add an object to this pool */
+  void 	(*_addImp)(id, SEL, id);
+#endif
+#if     GS_NONFRAGILE
+#else
+  /* Pointer to private additional data used to avoid breaking ABI
+   * when we don't have the non-fragile ABI available.
+   * Use this mechanism rather than changing the instance variable
+   * layout (see Source/GSInternal.h for details).
+   */
+  @private id _internal GS_UNUSED_IVAR;
+#endif
+}
+
+/**
+ * Adds anObj to the current autorelease pool.<br />
+ * If there is no autorelease pool in the thread,
+ * a warning is logged and the object is leaked (ie it will not be released).
+ */
++ (void) addObject: (id)anObj;
+
+/**
+ * Allocate and return an autorelease pool instance.<br />
+ * If there is an already-allocated NSAutoreleasePool available,
+ * save time by just returning that, rather than allocating a new one.<br />
+ * The pool instance becomes the current autorelease pool for this thread.
+ */
++ (id) allocWithZone: (NSZone*)zone;
+
+/**
+ * Adds anObj to this autorelease pool.
+ */
+- (void) addObject: (id)anObj;
+
+/**
+ * Raises an exception - pools should not be autoreleased.
+ */
+- (id) autorelease;
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+/**
+ * Intended to trigger a garbage collection run (if needed) when called in
+ * a garbage collected environment.<br />
+ * In a non-garbage collected environment, this method implements the
+ * undocumented MacOS-X behavior, and releases the receiver.
+ */
+- (void) drain;
+#endif
+
+/**
+ * Destroys the receiver (calls -dealloc).
+ */
+- (oneway void) release;
+
+/**
+ * Raises an exception ... pools should not be retained.
+ */
+- (id) retain;
+
+#if OS_API_VERSION(GS_API_NONE, GS_API_NONE)
+/**
+ * <p>
+ *   Counts the number of times that the specified object occurs
+ *   in autorelease pools in the current thread.
+ * </p>
+ * <p>
+ *   This method is <em>slow</em> and should probably only be
+ *   used for debugging purposes.
+ * </p>
+ */
++ (unsigned) autoreleaseCountForObject: (id)anObject;
+
+/** 
+ * Return the currently active autorelease pool.
+ */
++ (id) currentPool;
+
+/**
+ * <p>
+ *   Specifies whether objects contained in autorelease pools are to
+ *   be released when the pools are deallocated (by default YES).
+ * </p>
+ * <p>
+ *   You can set this to NO for debugging purposes.
+ * </p>
+ */
++ (void) enableRelease: (BOOL)enable;
+
+/**
+ * <p>
+ *   When autorelease pools are deallocated, the memory they used
+ *   is retained in a cache for re-use so that new polls can be
+ *   created very quickly.
+ * </p>
+ * <p>
+ *   This method may be used to empty that cache, ensuring that
+ *   the minimum memory is used by the application.
+ * </p>
+ */
++ (void) freeCache;
+
+/**
+ * <p>
+ *   Specifies a limit to the number of objects that may be added to
+ *   an autorelease pool.  When this limit is reached an exception is
+ *   raised.
+ * </p>
+ * <p>
+ *   You can set this to a smallish value to catch problems with code
+ *   that autoreleases too many objects to operate efficiently.
+ * </p>
+ * <p>
+ *   Default value is maxint.
+ * </p>
+ */
++ (void) setPoolCountThreshold: (unsigned)c;
+
+/**
+ * Return the number of objects in this pool.
+ */
+- (unsigned) autoreleaseCount;
+
+/**
+ * Empties the current pool by releasing all the autoreleased objects
+ * in it.  Also destroys any child pools (ones created after
+ * the receiver in the same thread) causing any objects in those pools
+ * to be released.<br />
+ * This is a low cost (efficient) method which may be used to get rid of
+ * autoreleased objects in the pool, but carry on using the pool.
+ */
+- (void) emptyPool;
+#endif
+@end
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#endif /* __NSAutoreleasePool_h_GNUSTEP_BASE_INCLUDE */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSObject.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSObject.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSObject.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,594 @@
+/**Interface for NSObject for GNUStep
+   Copyright (C) 1995, 1996, 1998 Free Software Foundation, Inc.
+
+   Written by:  Andrew Kachites McCallum <mccallum@gnu.ai.mit.edu>
+   Date: 1995
+   
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+   
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+
+   AutogsdocSource: NSObject.m
+   */ 
+
+#ifndef __NSObject_h_GNUSTEP_BASE_INCLUDE
+#define __NSObject_h_GNUSTEP_BASE_INCLUDE
+
+#import	"NSObjCRuntime.h"
+#import <objc/objc.h>
+#import	"NSZone.h"
+
+#ifdef	GS_WITH_GC
+#undef  GS_WITH_GC
+#endif
+#define	GS_WITH_GC	0
+
+#import	"../GNUstepBase/GNUstep.h"
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+@class NSArchiver;
+@class NSArray;
+@class NSCoder;
+@class NSDictionary;
+@class NSPortCoder;
+@class NSMethodSignature;
+@class NSMutableString;
+@class NSRecursiveLock;
+@class NSString;
+@class NSInvocation;
+@class Protocol;
+
+/**
+ * The NSObject protocol describes a minimal set of methods that all
+ * objects are expected to support.  You should be able to send any
+ * of the messages listed in this protocol to an object, and be safe
+ * in assuming that the receiver can handle it.
+ */
+@protocol NSObject
+/**
+ * Returns the class of the receiver.  If the receiver is a proxy, then this
+ * may return the class of the proxy target.  Use -isProxy to determine whether
+ * the receiver is a proxy.  If you wish to find the real class of the
+ * receiver, ignoring proxies, then use object_getClass().  
+ */
+- (Class) class;
+/**
+ * Returns the superclass of receiver's class.  If the receiver is a proxy,
+ * then this may return the class of the proxy target.  Use -isProxy to
+ * determine whether the receiver is a proxy.  If you wish to find the real
+ * superclass of the receiver's class, ignoring proxies, then use
+ * class_getSuperclass(object_getClass()).
+ */
+- (Class) superclass;
+/**
+ * Returns whether the receiver is equal to the argument.  Defining equality is
+ * complex, so be careful when implementing this method.  Collections such as
+ * NSSet depend on the behaviour of this method.  In particular, this method
+ * must be commutative, so for any objects a and b:
+ *
+ * [a isEqual: b] == [b isEqual: a]
+ *
+ * This means that you must be very careful when returning YES if the argument
+ * is of another class.  For example, if you define a number class that returns
+ * YES if the argument is a string representation of the number, then this will
+ * break because the string will not recognise your object as being equal to
+ * itself.
+ *
+ * If two objects are equal, then they must have the same hash value, however
+ * equal hash values do not imply equality.
+ */
+- (BOOL) isEqual: (id)anObject;
+/**
+ * Returns YES if the receiver is an instance of the class, an instance of the
+ * subclass, or (in the case of proxies), an instance of something that can be
+ * treated as an instance of the class.
+ */
+- (BOOL) isKindOfClass: (Class)aClass;
+/**
+ * Returns YES if the receiver is an instance of the class or (in the case of
+ * proxies), an instance of something that can be treated as an instance of the
+ * class.
+ *
+ * Calling this method is rarely the correct thing to do.  In most cases, a
+ * subclass can be substituted for a superclass, so you should never need to
+ * check that an object is really an instance of a specific class and not a
+ * subclass.  
+ */
+- (BOOL) isMemberOfClass: (Class)aClass;
+/**
+ * Returns YES if the receiver is a proxy, NO otherwise.  The default
+ * implementation of this method in NSObject returns NO, while the
+ * implementation in NSProxy returns YES.
+ */
+- (BOOL) isProxy;
+/**
+ * Returns a hash value for the object.  All objects that are equal *MUST*
+ * return the same hash value.  For efficient storage in sets, or as keys in
+ * dictionaries, different objects should return hashes spread evenly over the
+ * range of an integer.
+ *
+ * An object may not return different values from this method after being
+ * stored in a collection.  This typically means that ether the hash value must
+ * be constant after the object's creation, or that the object may not be
+ * modified while stored in an unordered collection.
+ */
+- (NSUInteger) hash;
+/**
+ * Returns the receiver.  In a proxy, this may (but is not required to) return
+ * the proxied object.
+ */
+- (id) self;
+/**
+ * Performs the specified selector.  The selector must correspond to a method
+ * that takes no arguments.
+ */
+- (id) performSelector: (SEL)aSelector;
+/**
+ * Performs the specified selector, with the object as the argument.  This
+ * method does not perform any automatic unboxing, so the selector must
+ * correspond to a method that takes one object argument.
+ */
+- (id) performSelector: (SEL)aSelector
+	    withObject: (id)anObject;
+/**
+ * Performs the specified selector, with the objects as the arguments.  This
+ * method does not perform any automatic unboxing, so the selector must
+ * correspond to a method that takes two object arguments.
+ */
+- (id) performSelector: (SEL)aSelector
+	    withObject: (id)object1
+	    withObject: (id)object2;
+/**
+ * Returns YES if the object can respond to messages with the specified
+ * selector.  The default implementation in NSObject returns YES if the
+ * receiver has a method corresponding to the method, but other classes may
+ * return YES if they can respond to a selector using one of the various
+ * forwarding mechanisms.
+ */
+- (BOOL) respondsToSelector: (SEL)aSelector;
+/**
+ * Returns YES if the receiver conforms to the specified protocol.
+ */
+- (BOOL) conformsToProtocol: (Protocol*)aProtocol;
+/**
+ * Increments the reference count of the object and returns the receiver.  In
+ * garbage collected mode, this method does nothing.  In automated reference
+ * counting mode, you may neither implement this method nor call it directly.
+ */
+- (id) retain NS_AUTOMATED_REFCOUNT_UNAVAILABLE;
+/**
+ * Decrements the reference count of the object and destroys if it there are no
+ * remaining references.  In garbage collected mode, this method does nothing.
+ * In automated reference counting mode, you may neither implement this method
+ * nor call it directly.
+ */
+- (oneway void) release NS_AUTOMATED_REFCOUNT_UNAVAILABLE;
+/**
+ * Performs a deferred -release operation.  The object's reference count is
+ * decremented at the end of the scope of the current autorelease pool,
+ * identified either by a -drain message sent to the current NSAutoreleasePool
+ * instance, or in more recent versions of Objective-C by the end of an
+ * @autorelease_pool scope.
+ *
+ * In garbage collected mode, this method does nothing.  In automated reference
+ * counting mode, you may neither implement this method nor call it directly.
+ */
+- (id) autorelease NS_AUTOMATED_REFCOUNT_UNAVAILABLE;
+/**
+ * Returns the current retain count of an object.  This does not include the
+ * result of any pending autorelease operations.
+ *
+ * Code that relies on this method returning a sane value is broken.  For
+ * singletons, it may return NSUIntegerMax.  Even when it is tracking a retain
+ * count, it will not include on-stack pointers in manual retain/release mode,
+ * pointers marked as __unsafe_unretain or __weak in ARC mode, or pending
+ * autorelease operations.  Its value is therefore largely meaningless.  It can
+ * occasionally be useful for debugging.
+ */
+- (NSUInteger) retainCount NS_AUTOMATED_REFCOUNT_UNAVAILABLE;
+/**
+ * Returns the description of the object.  This is used by the %@ format
+ * specifier in strings.
+ */
+- (NSString*) description;
+/**
+ * Returns the zone of the object.
+ */
+- (NSZone*) zone NS_AUTOMATED_REFCOUNT_UNAVAILABLE;
+@end
+
+/**
+ * This protocol must be adopted by any class wishing to support copying -
+ * ie where instances of the class should be able to create new instances
+ * which are copies of the original and, where a class has mutable and
+ * immutable versions, where the copies are immutable.
+ */
+@protocol NSCopying
+/**
+ * Called by [NSObject-copy] passing NSDefaultMallocZone() as zone.<br />
+ * This method returns a copy of the receiver and, where the receiver is a
+ * mutable variant of a class which has an immutable partner class, the
+ * object returned is an instance of that immutable class.<br />
+ * The new object is <em>not</em> autoreleased, and is considered to be
+ * 'owned' by the calling code ... which is therefore responsible for
+ * releasing it.<br />
+ * In the case where the receiver is an instance of a container class,
+ * it is undefined whether contained objects are merely retained in the
+ * new copy, or are themselves copied, or whether some other mechanism
+ * entirely is used.
+ */
+- (id) copyWithZone: (NSZone*)zone;
+@end
+
+/**
+ * This protocol must be adopted by any class wishing to support
+ * mutable copying - ie where instances of the class should be able
+ * to create mutable copies of themselves.
+ */
+@protocol NSMutableCopying
+/**
+ * Called by [NSObject-mutableCopy] passing NSDefaultMallocZone() as zone.<br />
+ * This method returns a copy of the receiver and, where the receiver is an
+ * immutable variant of a class which has a mutable partner class, the
+ * object returned is an instance of that mutable class.
+ * The new object is <em>not</em> autoreleased, and is considered to be
+ * 'owned' by the calling code ... which is therefore responsible for
+ * releasing it.<br />
+ * In the case where the receiver is an instance of a container class,
+ * it is undefined whether contained objects are merely retained in the
+ * new copy, or are themselves copied, or whether some other mechanism
+ * entirely is used.
+ */
+- (id) mutableCopyWithZone: (NSZone*)zone;
+@end
+
+/**
+ * This protocol must be adopted by any class wishing to support
+ * saving and restoring instances to an archive, or copying them
+ * to remote processes via the Distributed Objects mechanism.
+ */
+@protocol NSCoding
+
+/**
+ * Called when it is time for receiver to be serialized for writing to an
+ * archive or network connection.  Receiver should record all of its instance
+ * variables using methods on aCoder.  See documentation for [NSCoder],
+ * [NSArchiver], [NSKeyedArchiver], and/or [NSPortCoder] for more information.
+ */
+- (void) encodeWithCoder: (NSCoder*)aCoder;
+
+/**
+ * Called on a freshly allocated receiver when it is time to reconstitute from
+ * serialized bytes in an archive or from a network connection.  Receiver
+ * should load all of its instance variables using methods on aCoder.  See
+ * documentation for [NSCoder], [NSUnarchiver], [NSKeyedUnarchiver], and/or
+ * [NSPortCoder] for more information.
+ */
+- (id) initWithCoder: (NSCoder*)aDecoder;
+@end
+
+@protocol NSSecureCoding <NSCoding>
++ (BOOL)supportsSecureCoding;
+@end
+
+
+GS_ROOT_CLASS @interface NSObject <NSObject>
+{
+ /**
+  * Points to instance's class.  Used by runtime to access method
+  * implementations, etc..  Set in +alloc, Unlike other instance variables,
+  * which are cleared there.
+  */
+  Class isa;
+}
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+/** On a system which performs garbage collection, you should implement
+ * this method to execute code when the receiver is collected.<br />
+ * You must not call this method yourself (except when a subclass
+ * calls the superclass method within its own implementation).
+ */
+- (void) finalize;
+#endif
+
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+- (NSString*) className;
+#endif
+
++ (id) allocWithZone: (NSZone*)z;
++ (id) alloc;
++ (Class) class;
+
+/**
+ * This method is automatically invoked on any class which implements it
+ * when the class is loaded into the runtime.<br />
+ * It is also invoked on any category where the method is implemented
+ * when that category is loaded into the runtime.<br />
+ * The +load method is called directly by the runtime and you should never
+ * send a +load message to a class yourself.<br />
+ * This method is called <em>before</em> the +initialize message is sent
+ * to the class, so you cannot depend on class initialisation having been
+ * performed, or upon other classes existing (apart from superclasses of
+ * the receiver, since +load is called on superclasses before it is called
+ * on their subclasses).<br />
+ * As a gross generalisation, it is safe to use C code, including
+ * most ObjectiveC runtime functions within +load, but attempting to send
+ * messages to ObjectiveC objects is likely to fail.<br />
+ * In GNUstep, this method is implemented for NSObject to perform some
+ * initialisation for the base library.<br />
+ * If you implement +load for a class, don't call [super load] in your
+ * implementation.
+ */
++ (void) load;
+
+/**
+ * This message is automatically sent to a class by the runtime.  It is
+ * sent once for each class, just before the class is used for the first
+ * time (excluding any automatic call to +load by the runtime).<br />
+ * The message is sent in a thread-safe manner ... other threads may not
+ * call methods of the class until +initialize has finished executing.<br />
+ * If the class has a superclass, its implementation of +initialize is
+ * called first.<br />
+ * If the class does not implement +initialize then the implementation
+ * in the closest superclass may be called.  This means that +initialize may
+ * be called more than once, and the recommended way to handle this by
+ * using the
+ * <code>
+ * if (self == [classname class])
+ * </code>
+ * conditional to check whether the method is being called for a subclass.<br />
+ * You should never call +initialize yourself ... let the runtime do it.<br />
+ * You can implement +initialize in your own class if you need to.
+ * NSObject's implementation handles essential root object and base
+ * library initialization.<br />
+ * It should be safe to call [super initialize] in your implementation
+ * of +initialize.
+ */
++ (void) initialize;
++ (IMP) instanceMethodForSelector: (SEL)aSelector;
++ (NSMethodSignature*) instanceMethodSignatureForSelector: (SEL)aSelector;
++ (BOOL) instancesRespondToSelector: (SEL)aSelector;
++ (BOOL) isSubclassOfClass: (Class)aClass;
++ (id) new;
++ (void) poseAsClass: (Class)aClassObject;
++ (id) setVersion: (NSInteger)aVersion;
++ (NSInteger) version;
+
+- (id) awakeAfterUsingCoder: (NSCoder*)aDecoder;
+- (Class) classForArchiver;
+- (Class) classForCoder;
+- (id) copy;
+- (void) dealloc;
+- (void) doesNotRecognizeSelector: (SEL)aSelector;
+- (void) forwardInvocation: (NSInvocation*)anInvocation;
+- (id) init;
+- (IMP) methodForSelector: (SEL)aSelector;
+- (NSMethodSignature*) methodSignatureForSelector: (SEL)aSelector;
+- (id) mutableCopy;
+- (id) replacementObjectForArchiver: (NSArchiver*)anArchiver;
+- (id) replacementObjectForCoder: (NSCoder*)anEncoder;
+- (Class) superclass;
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+/**
+ * This method will be called when attempting to send a message a class that
+ * does not understand it.  The class may install a new method for the given
+ * selector and return YES, otherwise it should return NO.
+ *
+ * Note: This method is only reliable when using the GNUstep runtime.  If you
+ * require compatibility with the GCC runtime, you must also implement
+ * -forwardInvocation: with equivalent semantics.  This will be considerably
+ *  slower, but more portable.
+ */
++ (BOOL) resolveClassMethod: (SEL)name;
+
+/**
+ * This method will be called when attempting to send a message an instance
+ * that does not understand it.  The class may install a new method for the
+ * given selector and return YES, otherwise it should return NO.
+ *
+ * Note: This method is only reliable when using the GNUstep runtime.  If you
+ * require compatibility with the GCC runtime, you must also implement
+ * -forwardInvocation: with equivalent semantics.  This will be considerably
+ *  slower, but more portable.
+ */
++ (BOOL) resolveInstanceMethod: (SEL)name;
+#endif
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
+/**
+ * Returns an auto-accessing proxy for the given object.  This proxy sends a
+ * -beginContentAccess message to the receiver when it is created and an
+ * -endContentAccess message when it is destroyed.  This prevents an object
+ * that implements the NSDiscardableContent protocol from having its contents
+ * discarded for as long as the proxy exists.  
+ *
+ * On systems using the GNUstep runtime, messages send to the proxy will be
+ * slightly slower than direct messages.  With the GCC runtime, they will be
+ * approximately two orders of magnitude slower.  The GNUstep runtime,
+ * therefore, is strongly recommended for code calling this method.
+ */
+- (id) autoContentAccessingProxy;
+
+/**
+ * If an object does not understand a message, it may delegate it to another
+ * object.  Returning nil indicates that forwarding should not take place.  The
+ * default implementation of this returns nil, but care should be taken when
+ * subclassing NSObject subclasses and overriding this method that
+ * the superclass implementation is called if returning nil.
+ *
+ * Note: This method is only reliable when using the GNUstep runtime and code
+ * compiled with clang.  If you require compatibility with GCC and the GCC
+ * runtime, you must also implement -forwardInvocation: with equivalent
+ * semantics.  This will be considerably slower, but more portable.
+ */
+- (id) forwardingTargetForSelector: (SEL)aSelector;
+
+#endif
+@end
+
+/**
+ * Used to allocate memory to hold an object, and initialise the
+ * class of the object to be aClass etc.  The allocated memory will
+ * be extraBytes larger than the space actually needed to hold the
+ * instance variables of the object.<br />
+ * This function is used by the [NSObject+allocWithZone:] method.
+ */
+GS_EXPORT id
+NSAllocateObject(Class aClass, NSUInteger extraBytes, NSZone *zone);
+
+/**
+ * Used to release the memory used by an object.<br />
+ * This function is used by the [NSObject-dealloc] method.
+ */
+GS_EXPORT void
+NSDeallocateObject(id anObject);
+
+/**
+ * Used to copy anObject.  This makes a bitwise copy of anObject to
+ * memory allocated from zone.  The allocated memory will be extraBytes
+ * longer than that necessary to actually store the instance variables
+ * of the copied object.<br />
+ */
+GS_EXPORT NSObject *
+NSCopyObject(NSObject *anObject, NSUInteger extraBytes, NSZone *zone);
+
+/**
+ * Returns a flag to indicate whether anObject should be retained or
+ * copied in order to make a copy in the specified zone.<br />
+ * Basically, this tests to see if anObject was allocated from
+ * requestedZone and returns YES if it was.
+ */
+GS_EXPORT BOOL
+NSShouldRetainWithZone(NSObject *anObject, NSZone *requestedZone);
+
+GS_EXPORT BOOL
+NSDecrementExtraRefCountWasZero(id anObject);
+
+GS_EXPORT NSUInteger
+NSExtraRefCount(id anObject);
+
+GS_EXPORT void
+NSIncrementExtraRefCount(id anObject);
+
+#if OS_API_VERSION(GS_API_NONE, GS_API_NONE)
+
+/** Global lock to be used by classes when operating on any global
+    data that invoke other methods which also access global; thus,
+    creating the potential for deadlock. */
+GS_EXPORT NSRecursiveLock *gnustep_global_lock;
+
+@interface NSObject (NEXTSTEP)
+- (id) error:(const char *)aString, ...;
+/* - (const char *) name;
+   Removed because OpenStep has -(NSString*)name; */
+@end
+
+#if GS_API_VERSION(GS_API_NONE, 011700)
+@interface NSObject (GNUstep)
++ (void) enableDoubleReleaseCheck: (BOOL)enable;
+@end
+#endif
+
+#endif
+
+#import	"NSDate.h"
+/**
+ *  Declares some methods for sending messages to self after a fixed delay.
+ *  (These methods <em>are</em> in OpenStep and OS X.)
+ */
+@interface NSObject (TimedPerformers)
+
+/**
+ * Cancels any perform operations set up for the specified target
+ * in the current run loop.
+ */
++ (void) cancelPreviousPerformRequestsWithTarget: (id)obj;
+
+/**
+ * Cancels any perform operations set up for the specified target
+ * in the current loop, but only if the value of aSelector and argument
+ * with which the performs were set up match those supplied.<br />
+ * Matching of the argument may be either by pointer equality or by
+ * use of the [NSObject-isEqual:] method.
+ */
++ (void) cancelPreviousPerformRequestsWithTarget: (id)obj
+					selector: (SEL)s
+					  object: (id)arg;
+/**
+ * Sets given message to be sent to this instance after given delay,
+ * in any run loop mode.  See [NSRunLoop].
+ */
+- (void) performSelector: (SEL)s
+	      withObject: (id)arg
+	      afterDelay: (NSTimeInterval)seconds;
+
+/**
+ * Sets given message to be sent to this instance after given delay,
+ * in given run loop modes.  See [NSRunLoop].
+ */
+- (void) performSelector: (SEL)s
+	      withObject: (id)arg
+	      afterDelay: (NSTimeInterval)seconds
+		 inModes: (NSArray*)modes;
+@end
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
+/**
+ * The NSDiscardableContent protocol is used by objects which encapsulate data
+ * which may be discarded if resource constraints are exceeded.  These
+ * constraints are typically, but not always, related memory.  
+ */
+@protocol NSDiscardableContent
+
+/**
+ * This method is called before any access to the object.  It returns YES if
+ * the object's content is still valid.  The caller must call -endContentAccess
+ * once for every call to -beginContentAccess;
+ */
+- (BOOL) beginContentAccess;
+
+/**
+ * Discards the contents of the object if it is not currently being edited.
+ */
+- (void) discardContentIfPossible;
+
+/**
+ * This method indicates that the caller has finished accessing the contents of
+ * the object adopting this protocol.  Every call to -beginContentAccess must
+ * be be paired with a call to this method after the caller has finished
+ * accessing the contents.
+ */
+- (void) endContentAccess;
+
+/**
+ * Returns YES if the contents of the object have been discarded, either via a
+ * call to -discardContentIfPossible while the object is not in use, or by some
+ * implementation dependent mechanism.  
+ */
+- (BOOL) isContentDiscarded;
+@end
+#endif
+#if	defined(__cplusplus)
+}
+#endif
+
+#if     !NO_GNUSTEP && !defined(GNUSTEP_BASE_INTERNAL)
+#import "../GNUstepBase/NSObject+GNUstepBase.h"
+#endif
+
+#endif /* __NSObject_h_GNUSTEP_BASE_INCLUDE */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSString.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSString.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSString.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,977 @@
+/* Interface for NSString for GNUstep
+   Copyright (C) 1995, 1996, 1999 Free Software Foundation, Inc.
+
+   Written by:  Andrew Kachites McCallum <mccallum@gnu.ai.mit.edu>
+   Date: 1995
+   
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+   
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+  */
+
+/**
+<chapter>
+ <heading>Portable path handling</heading>
+ <p>Portable path handling (across both unix-like and mswindows operating
+ systems) requires some care.  A modern operating system uses the concept
+ of a single root to the filesystem, but mswindows has multiple filesystems
+ with no common root, so code must be aware of this.  There is also the
+ more minor issue that windows often uses a backslash as a separator between
+ the components of a path and unix-like systems always use forward slash.<br />
+ On windows there is also the issue that two styles of path are used,
+ most commonly with a drive letter and a path on that drive
+ (eg. 'C:\directory\file') but also UNC paths
+ (eg. '//host/share/directory/file') so path handling functions must deal
+ with both formats.
+ </p>
+ <p>GNUstep has three path handling modes, 'gnustep', 'unix', and 'windows'.
+ The mode defaults to 'gnustep' but may be set using the GSPathHandling()
+ function.<br />
+ You should probably stick to using the default 'gnustep' mode in which the
+ path handling methods cope with both 'unix' and 'windows' style paths in
+ portable and tolerant manner:<br />
+ Paths are read in literally so they can be in the native format provided
+ by the operating system or in a non-native format. See
+ [NSFileManager-stringWithFileSystemRepresentation:length:].<br />
+ Paths are written out using the native format of the system the application
+ is running on (eg on windows slashes are converted to backslashes).
+ See [NSFileManager-fileSystemRepresentationWithPath:].<br />
+ The path handling methods accept either a forward or backward slash as a
+ path separator when parsing any path.<br />
+ Unless operating in 'unix' mode, a leading letter followed by a colon is
+ considered the start of a windows style path (the drive specifier), and a
+ path beginning with something of the form '//host/share/' is considered
+ the start of a UNC style path.<br />
+ The path handling methods add forward slashes when building new paths
+ internally or when standardising paths, so those path strings provide
+ a portable representation (as long as they are relative paths, not including
+ system specific roots).<br />
+ An important case to note is that on windows a path which looks at first
+ glance like an absolute path may actually be a relative one.<br />
+ 'C:file' is a relative path because it specifies  a file on the C drive
+ but does not say what directory it is in.<br />
+Similarly, '/dir/file' is a relative path because it specifies the full
+location fo a file on a drive, but does not specify which drive it is on.
+ </p>
+<p>As a consequence of this path handling, you are able to work completely
+portably using relative paths (adding components, extensions and
+relative paths to a pth, or removing components, extensions and relative
+paths from a path etc), and when you save paths as strings in files
+which may be transferred to another platform, you should save a relative
+path.<br />
+When you need to know absolute paths of various points in the filesystem,
+you can use various path utility functions to obtain those absolute paths.
+For instance, instead of saving an absolute path to a file, you might want
+to save a path relative to a user's home directory.  You could do that by
+calling NSHomeDirectory() to get the home directory, and only saving the
+part of the full path after that prefix.
+</p>
+</chapter>
+ */ 
+
+#ifndef __NSString_h_GNUSTEP_BASE_INCLUDE
+#define __NSString_h_GNUSTEP_BASE_INCLUDE
+#import	"../GNUstepBase/GSVersionMacros.h"
+
+#import	"NSObject.h"
+#import	"NSRange.h"
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+/**
+ * Type for representing unicode characters.  (16-bit)
+ */
+typedef uint16_t unichar;
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
+#define NSMaximumStringLength   (INT_MAX-1)
+#endif
+
+@class NSArray;
+@class NSCharacterSet;
+@class NSData;
+@class NSDictionary;
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+@class NSError;
+@class NSLocale;
+@class NSURL;
+#endif
+
+#define NSMaximumStringLength	(INT_MAX-1)
+
+enum 
+{
+  NSCaseInsensitiveSearch = 1,
+  NSLiteralSearch = 2,
+  NSBackwardsSearch = 4,
+  NSAnchoredSearch = 8,
+  NSNumericSearch = 64	/* MacOS-X 10.2 */
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
+ ,
+ NSDiacriticInsensitiveSearch = 128,
+ NSWidthInsensitiveSearch = 256,
+ NSForcedOrderingSearch = 512
+#endif
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_7,GS_API_LATEST) 
+ ,
+ /**
+  * Treats the search string as a regular expression.  This option may be
+  * combined with NSCaseInsensitiveSearch and NSAnchoredSearch, but no other
+  * search options.
+  *
+  * This option may only be used with the -rangeOfString: family of methods.
+  */
+ NSRegularExpressionSearch = 1024
+#endif
+};
+typedef NSUInteger NSStringCompareOptions;
+
+/**
+ *  <p>Enumeration of available encodings for converting between bytes and
+ *  characters (in [NSString]s).  The ones that are shared with OpenStep and
+ *  Cocoa are: <code>NSASCIIStringEncoding, NSNEXTSTEPStringEncoding,
+ *  NSJapaneseEUCStringEncoding, NSUTF8StringEncoding,
+ *  NSISOLatin1StringEncoding, NSSymbolStringEncoding,
+ *  NSNonLossyASCIIStringEncoding, NSShiftJISStringEncoding,
+ *  NSISOLatin2StringEncoding, NSUnicodeStringEncoding,
+ *  NSWindowsCP1251StringEncoding, NSWindowsCP1252StringEncoding,
+ *  NSWindowsCP1253StringEncoding, NSWindowsCP1254StringEncoding,
+ *  NSWindowsCP1250StringEncoding, NSISO2022JPStringEncoding,
+ *  NSMacOSRomanStringEncoding, NSProprietaryStringEncoding</code>.</p>
+ *  
+ *  <p>Additional encodings available under GNUstep are:
+ *  <code>NSKOI8RStringEncoding, NSISOLatin3StringEncoding,
+ *  NSISOLatin4StringEncoding, NSISOCyrillicStringEncoding,
+ *  NSISOArabicStringEncoding, NSISOGreekStringEncoding,
+ *  NSISOHebrewStringEncoding, NSISOLatin5StringEncoding,
+ *  NSISOLatin6StringEncoding, NSISOThaiStringEncoding,
+ *  NSISOLatin7StringEncoding, NSISOLatin8StringEncoding,
+ *  NSISOLatin9StringEncoding, NSGB2312StringEncoding, NSUTF7StringEncoding,
+ *  NSGSM0338StringEncoding, NSBIG5StringEncoding,
+ *  NSKoreanEUCStringEncoding</code>.</p>
+ */
+typedef enum _NSStringEncoding
+{
+/* NB. Must not have an encoding with value zero - so we can use zero to
+   tell that a variable that should contain an encoding has not yet been
+   initialised */
+  GSUndefinedEncoding = 0,
+  NSASCIIStringEncoding = 1,
+  NSNEXTSTEPStringEncoding = 2,
+  NSJapaneseEUCStringEncoding = 3,
+  NSUTF8StringEncoding = 4,
+  NSISOLatin1StringEncoding = 5,	// ISO-8859-1; West European
+  NSSymbolStringEncoding = 6,
+  NSNonLossyASCIIStringEncoding = 7,
+  NSShiftJISStringEncoding = 8,
+  NSISOLatin2StringEncoding = 9,	// ISO-8859-2; East European
+  NSUnicodeStringEncoding = 10,
+  NSUTF16StringEncoding = NSUnicodeStringEncoding,      // An alias
+  NSWindowsCP1251StringEncoding = 11,
+  NSWindowsCP1252StringEncoding = 12,	// WinLatin1
+  NSWindowsCP1253StringEncoding = 13,	// Greek
+  NSWindowsCP1254StringEncoding = 14,	// Turkish
+  NSWindowsCP1250StringEncoding = 15,	// WinLatin2
+  NSISO2022JPStringEncoding = 21,
+  NSMacOSRomanStringEncoding = 30,
+  NSProprietaryStringEncoding = 31,
+
+  NSKOI8RStringEncoding = 50,		// Russian/Cyrillic
+  NSISOLatin3StringEncoding = 51,	// ISO-8859-3; South European
+  NSISOLatin4StringEncoding = 52,	// ISO-8859-4; North European
+  NSISOCyrillicStringEncoding = 22,	// ISO-8859-5
+  NSISOArabicStringEncoding = 53,	// ISO-8859-6
+  NSISOGreekStringEncoding = 54,	// ISO-8859-7
+  NSISOHebrewStringEncoding = 55,	// ISO-8859-8
+  NSISOLatin5StringEncoding = 57,	// ISO-8859-9; Turkish
+  NSISOLatin6StringEncoding = 58,	// ISO-8859-10; Nordic
+  NSISOThaiStringEncoding = 59,		// ISO-8859-11
+/* Possible future ISO-8859 additions
+					// ISO-8859-12
+*/
+  NSISOLatin7StringEncoding = 61,	// ISO-8859-13
+  NSISOLatin8StringEncoding = 62,	// ISO-8859-14
+  NSISOLatin9StringEncoding = 63,	// ISO-8859-15; Replaces ISOLatin1
+  NSGB2312StringEncoding = 56,
+  NSUTF7StringEncoding = 64,		// RFC 2152
+  NSGSM0338StringEncoding,		// GSM (mobile phone) default alphabet
+  NSBIG5StringEncoding,			// Traditional chinese
+  NSKoreanEUCStringEncoding		// Korean
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST) 
+  ,
+  NSUTF16BigEndianStringEncoding = 0x90000100,
+  NSUTF16LittleEndianStringEncoding = 0x94000100,
+  NSUTF32StringEncoding = 0x8c000100,
+  NSUTF32BigEndianStringEncoding = 0x98000100,
+  NSUTF32LittleEndianStringEncoding = 0x9c000100
+#endif
+} NSStringEncoding;
+
+enum {
+  NSOpenStepUnicodeReservedBase = 0xF400
+};
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST) 
+enum {
+  NSStringEncodingConversionAllowLossy = 1,
+  NSStringEncodingConversionExternalRepresentation = 2
+};
+typedef NSUInteger NSStringEncodingConversionOptions;
+#endif
+
+/**
+ * <p>
+ *   <code>NSString</code> objects represent an immutable string of Unicode 3.0
+ *   characters.  These may be accessed individually as type
+ *   <code>unichar</code>, an unsigned short.<br/>
+ *   The [NSMutableString] subclass represents a modifiable string.  Both are
+ *   implemented as part of a class cluster and the instances you receive may
+ *   actually be of unspecified concrete subclasses.
+ * </p>
+ * <p>
+ *   A constant <code>NSString</code> can be created using the following syntax:
+ *   <code>@"..."</code>, where the contents of the quotes are the
+ *   string, using only ASCII characters.
+ * </p>
+ * <p>
+ *   A variable string can be created using a C printf-like <em>format</em>,
+ *   as in <code>[NSString stringWithFormat: @"Total is %f", t]</code>.
+ * </p>
+ * <p>
+ *   To create a concrete subclass of <code>NSString</code>, you must have your
+ *   class inherit from <code>NSString</code> and override at least the two
+ *   primitive methods - -length and -characterAtIndex:
+ * </p>
+ * <p>
+ *   In general the rule is that your subclass must override any
+ *   initialiser that you want to use with it.  The GNUstep
+ *   implementation relaxes that to say that, you may override
+ *   only the <em>designated initialiser</em> and the other
+ *   initialisation methods should work.
+ * </p>
+ * <p>
+ *   Where an NSString instance method returns an NSString object,
+ *   the class of the actual object returned may be any subclass
+ *   of NSString.  The actual value returned may be a new
+ *   autoreleased object, an autoreleased copy of the receiver,
+ *   or the receiver itsself.  While the abstract base class
+ *   implementations of methods (other than initialisers) will
+ *   avoid returning mutable strings by returning an autoreleased
+ *   copy of a mutable receiver, concrete subclasses may behave
+ *   differently, so code should not rely upon the mutability of
+ *   returned strings nor upon their lifetime being greater than
+ *   that of the receiver which returned them.
+ * </p>
+ */
+@interface NSString :NSObject <NSCoding, NSCopying, NSMutableCopying>
+
++ (id) string;
++ (id) stringWithCharacters: (const unichar*)chars
+		     length: (NSUInteger)length;
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST) && GS_API_VERSION( 10200,GS_API_LATEST)
++ (id) stringWithCString: (const char*)byteString
+		encoding: (NSStringEncoding)encoding;
+#endif
++ (id) stringWithCString: (const char*)byteString
+		  length: (NSUInteger)length;
++ (id) stringWithCString: (const char*)byteString;
++ (id) stringWithFormat: (NSString*)format, ... NS_FORMAT_FUNCTION(1,2);
++ (id) stringWithContentsOfFile:(NSString *)path;
+
+// Initializing Newly Allocated Strings
+- (id) init;
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST) && GS_API_VERSION( 10200,GS_API_LATEST)
+- (id) initWithBytes: (const void*)bytes
+	      length: (NSUInteger)length
+	    encoding: (NSStringEncoding)encoding;
+- (id) initWithBytesNoCopy: (void*)bytes
+		    length: (NSUInteger)length
+		  encoding: (NSStringEncoding)encoding 
+	      freeWhenDone: (BOOL)flag;
+#endif
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST)
++ (id) stringWithContentsOfFile: (NSString*)path
+                   usedEncoding: (NSStringEncoding*)enc
+                          error: (NSError**)error;
+- (id) initWithContentsOfFile: (NSString*)path
+                 usedEncoding: (NSStringEncoding*)enc
+                        error: (NSError**)error;
++ (id) stringWithContentsOfFile: (NSString*)path
+                       encoding: (NSStringEncoding)enc
+                          error: (NSError**)error;
+- (id) initWithContentsOfFile: (NSString*)path
+                     encoding: (NSStringEncoding)enc
+                        error: (NSError**)error;
++ (id) stringWithContentsOfURL: (NSURL*)url
+                  usedEncoding: (NSStringEncoding*)enc
+                         error: (NSError**)error;
+- (id) initWithContentsOfURL: (NSURL*)url
+                usedEncoding: (NSStringEncoding*)enc
+                       error: (NSError**)error;
++ (id) stringWithContentsOfURL: (NSURL*)url
+                      encoding: (NSStringEncoding)enc
+                         error: (NSError**)error;
+- (id) initWithContentsOfURL: (NSURL*)url
+                    encoding: (NSStringEncoding)enc
+                       error: (NSError**)error;
+- (BOOL) writeToFile: (NSString*)path
+	  atomically: (BOOL)atomically
+	    encoding: (NSStringEncoding)enc
+	       error: (NSError**)error;
+- (BOOL) writeToURL: (NSURL*)url
+	 atomically: (BOOL)atomically
+	   encoding: (NSStringEncoding)enc
+	      error: (NSError**)error;
+#endif
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST)
+- (NSString*)stringByReplacingOccurrencesOfString: (NSString*)replace
+                                       withString: (NSString*)by
+                                          options: (NSStringCompareOptions)opts
+                                            range: (NSRange)searchRange;
+- (NSString*)stringByReplacingOccurrencesOfString: (NSString*)replace
+                                       withString: (NSString*)by;
+- (NSString*) stringByReplacingCharactersInRange: (NSRange)aRange 
+                                      withString: (NSString*)by;
+#endif
+- (id) initWithCharactersNoCopy: (unichar*)chars
+			 length: (NSUInteger)length
+		   freeWhenDone: (BOOL)flag;
+- (id) initWithCharacters: (const unichar*)chars
+		   length: (NSUInteger)length;
+- (id) initWithCStringNoCopy: (char*)byteString
+		      length: (NSUInteger)length
+	        freeWhenDone: (BOOL)flag;
+- (id) initWithCString: (const char*)byteString
+	        length: (NSUInteger)length;
+- (id) initWithCString: (const char*)byteString;
+- (id) initWithString: (NSString*)string;
+- (id) initWithFormat: (NSString*)format, ... NS_FORMAT_FUNCTION(1,2);
+- (id) initWithFormat: (NSString*)format
+	    arguments: (va_list)argList NS_FORMAT_FUNCTION(1,0);
+- (id) initWithData: (NSData*)data
+	   encoding: (NSStringEncoding)encoding;
+- (id) initWithContentsOfFile: (NSString*)path;
+
+// Getting a String's Length
+- (NSUInteger) length;
+
+// Accessing Characters
+- (unichar) characterAtIndex: (NSUInteger)index;
+- (void) getCharacters: (unichar*)buffer;
+- (void) getCharacters: (unichar*)buffer
+		 range: (NSRange)aRange;
+
+// Combining Strings
+- (NSString*) stringByAppendingFormat: (NSString*)format, ...
+  NS_FORMAT_FUNCTION(1,2);
+- (NSString*) stringByAppendingString: (NSString*)aString;
+
+// Dividing Strings into Substrings
+- (NSArray*) componentsSeparatedByString: (NSString*)separator;
+- (NSString*) substringFromIndex: (NSUInteger)index;
+- (NSString*) substringToIndex: (NSUInteger)index;
+
+// Finding Ranges of Characters and Substrings
+- (NSRange) rangeOfCharacterFromSet: (NSCharacterSet*)aSet;
+- (NSRange) rangeOfCharacterFromSet: (NSCharacterSet*)aSet
+			    options: (NSUInteger)mask;
+- (NSRange) rangeOfCharacterFromSet: (NSCharacterSet*)aSet
+			    options: (NSUInteger)mask
+			      range: (NSRange)aRange;
+- (NSRange) rangeOfString: (NSString*)string;
+- (NSRange) rangeOfString: (NSString*)string
+		  options: (NSUInteger)mask;
+- (NSRange) rangeOfString: (NSString*)aString
+		  options: (NSUInteger)mask
+		    range: (NSRange)aRange;
+
+// Determining Composed Character Sequences
+- (NSRange) rangeOfComposedCharacterSequenceAtIndex: (NSUInteger)anIndex;
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2,GS_API_LATEST) 
+/** Returns a copy of the receiver normalised using the KD form.
+ */
+- (NSString *) decomposedStringWithCompatibilityMapping;
+
+/** Returns a copy of the receiver normalised using the D form.
+ */
+- (NSString *) decomposedStringWithCanonicalMapping;
+
+/** Returns a copy of the receiver normalised using the KC form.
+ */
+- (NSString *) precomposedStringWithCompatibilityMapping;
+
+/** Returns a copy of the receiver normalised using the C form.
+ */
+- (NSString *) precomposedStringWithCanonicalMapping;
+#endif
+
+// Converting String Contents into a Property List
+- (id) propertyList;
+- (NSDictionary*) propertyListFromStringsFileFormat;
+
+// Identifying and Comparing Strings
+- (NSComparisonResult) compare: (NSString*)aString;
+- (NSComparisonResult) compare: (NSString*)aString	
+		       options: (NSUInteger)mask;
+- (NSComparisonResult) compare: (NSString*)aString
+		       options: (NSUInteger)mask
+			 range: (NSRange)aRange;
+- (BOOL) hasPrefix: (NSString*)aString;
+- (BOOL) hasSuffix: (NSString*)aString;
+- (BOOL) isEqual: (id)anObject;
+- (BOOL) isEqualToString: (NSString*)aString;
+- (NSUInteger) hash;
+
+// Getting a Shared Prefix
+- (NSString*) commonPrefixWithString: (NSString*)aString
+			     options: (NSUInteger)mask;
+
+// Changing Case
+- (NSString*) capitalizedString;
+- (NSString*) lowercaseString;
+- (NSString*) uppercaseString;
+
+// Getting C Strings
+- (const char*) cString;
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST) && GS_API_VERSION( 10200,GS_API_LATEST)
+- (const char*) cStringUsingEncoding: (NSStringEncoding)encoding;
+- (BOOL) getCString: (char*)buffer
+	  maxLength: (NSUInteger)maxLength
+	   encoding: (NSStringEncoding)encoding;
+- (id) initWithCString: (const char*)byteString
+	      encoding: (NSStringEncoding)encoding;
+- (NSUInteger) lengthOfBytesUsingEncoding: (NSStringEncoding)encoding;
+- (NSUInteger) maximumLengthOfBytesUsingEncoding: (NSStringEncoding)encoding;
+#endif
+
+#endif
+- (NSUInteger) cStringLength;
+- (void) getCString: (char*)buffer;
+- (void) getCString: (char*)buffer
+	  maxLength: (NSUInteger)maxLength;
+- (void) getCString: (char*)buffer
+	  maxLength: (NSUInteger)maxLength
+	      range: (NSRange)aRange
+     remainingRange: (NSRange*)leftoverRange;
+
+// Getting Numeric Values
+- (float) floatValue;
+- (int) intValue;
+
+// Working With Encodings
+- (BOOL) canBeConvertedToEncoding: (NSStringEncoding)encoding;
+- (NSData*) dataUsingEncoding: (NSStringEncoding)encoding;
+- (NSData*) dataUsingEncoding: (NSStringEncoding)encoding
+	 allowLossyConversion: (BOOL)flag;
++ (NSStringEncoding) defaultCStringEncoding;
+- (NSString*) description;
+- (NSStringEncoding) fastestEncoding;
+- (NSStringEncoding) smallestEncoding;
+
+/**
+ * Attempts to complete this string as a path in the filesystem by finding
+ * a unique completion if one exists and returning it by reference in
+ * outputName (which must be a non-nil pointer), or if it finds a set of
+ * completions they are returned by reference in outputArray, if it is non-nil.
+ * filterTypes can be an array of strings specifying extensions to consider;
+ * files without these extensions will be ignored and will not constitute
+ * completions.  Returns 0 if no match found, else a positive number that is
+ * only accurate if outputArray was non-nil.
+ */
+- (NSUInteger) completePathIntoString: (NSString**)outputName
+			caseSensitive: (BOOL)flag
+		     matchesIntoArray: (NSArray**)outputArray
+			  filterTypes: (NSArray*)filterTypes;
+
+/**
+ * Converts the receiver to a C string path expressed in the character
+ * encoding appropriate for the local host file system.  This string will be
+ * automatically freed soon after it is returned, so copy it if you need it
+ * for long.<br />
+ * NB. On mingw32 systems the filesystem representation of a path is a 16-bit
+ * unicode character string, so you should only pass the value returned by
+ * this method to functions expecting wide characters.<br />
+ * This method uses [NSFileManager-fileSystemRepresentationWithPath:] to
+ * perform the conversion.
+ */
+- (const GSNativeChar*) fileSystemRepresentation;
+
+/**
+ * Converts the receiver to a C string path using the character encoding
+ * appropriate to the local file system.  This string will be stored
+ * into buffer if it is shorter (number of characters) than size,
+ * otherwise NO is returned.<br />
+ * NB. On mingw32 systems the filesystem representation of a path is a 16-bit
+ * unicode character string, so the buffer you pass to this method must be
+ * twice as many bytes as the size (number of characters) you expect to
+ * receive.<br />
+ * This method uses [NSFileManager-fileSystemRepresentationWithPath:] to
+ * perform the conversion.
+ */
+- (BOOL) getFileSystemRepresentation: (GSNativeChar*)buffer
+			   maxLength: (NSUInteger)size;
+
+/**
+ * Returns a string containing the last path component of the receiver.<br />
+ * The path component is the last non-empty substring delimited by the ends
+ * of the string, or by path separator characters.<br />
+ * If the receiver only contains a root part, this method returns it.<br />
+ * If there are no non-empty substrings, this returns an empty string.<br />
+ * NB. In a windows UNC path, the host and share specification is treated as
+ * a single path component, even though it contains separators.
+ * So a string of the form '//host/share' may be returned.<br />
+ * Other special cases are apply when the string is the root.
+ * <example>
+ *   @"foo/bar" produces @"bar"
+ *   @"foo/bar/" produces @"bar"
+ *   @"/foo/bar" produces @"bar"
+ *   @"/foo" produces @"foo"
+ *   @"/" produces @"/" (root is a special case)
+ *   @"" produces @""
+ *   @"C:/" produces @"C:/" (root is a special case)
+ *   @"C:" produces @"C:"
+ *   @"//host/share/" produces @"//host/share/" (root is a special case)
+ *   @"//host/share" produces @"//host/share"
+ * </example>
+ */
+- (NSString*) lastPathComponent;
+
+/**
+ * Returns a new string containing the path extension of the receiver.<br />
+ * The path extension is a suffix on the last path component which starts
+ * with the extension separator (a '.') (for example .tiff is the
+ * pathExtension for /foo/bar.tiff).<br />
+ * Returns an empty string if no such extension exists.
+ * <example>
+ *   @"a.b" produces @"b"
+ *   @"a.b/" produces @"b"
+ *   @"/path/a.ext" produces @"ext"
+ *   @"/path/a." produces @""
+ *   @"/path/.a" produces @"" (.a is not an extension to a file)
+ *   @".a" produces @"" (.a is not an extension to a file)
+ * </example>
+ */
+- (NSString*) pathExtension;
+
+/**
+ * Returns a string where a prefix of the current user's home directory is
+ * abbreviated by '~', or returns the receiver (or an immutable copy) if
+ * it was not found to have the home directory as a prefix.
+ */
+- (NSString*) stringByAbbreviatingWithTildeInPath;
+
+/**
+ * Returns a new string with the path component given in aString
+ * appended to the receiver.<br />
+ * This removes trailing path separators from the receiver and the root
+ * part from aString and replaces them with a single slash as a path
+ * separator.<br />
+ * Also condenses any multiple separator sequences in the result into
+ * single path separators.
+ * <example>
+ *   @"" with @"file" produces @"file"
+ *   @"path" with @"file" produces @"path/file"
+ *   @"/" with @"file" produces @"/file"
+ *   @"/" with @"file" produces @"/file"
+ *   @"/" with @"/file" produces @"/file"
+ *   @"path with @"C:/file" produces @"path/file"
+ * </example>
+ * NB. Do not use this method to modify strings other than filesystem
+ * paths as the behavior in such cases is undefined ... for instance
+ * the string may have repeated slashes or slash-dot-slash sequences
+ * removed.
+ */
+- (NSString*) stringByAppendingPathComponent: (NSString*)aString;
+
+/**
+ * Returns a new string with the path extension given in aString
+ * appended to the receiver after an extensionSeparator ('.').<br />
+ * If the receiver has trailing path separator characters, they are
+ * stripped before the extension separator is added.<br />
+ * If the receiver contains no components after the root, the extension
+ * cannot be appended (an extension can only be appended to a file name),
+ * so a copy of the unmodified receiver is returned.<br />
+ * An empty string may be used as an extension ... in which case the extension
+ * separator is appended.<br />
+ * This behavior mirrors that of the -stringByDeletingPathExtension method.
+ * <example>
+ *   @"Mail" with @"app" produces @"Mail.app"
+ *   @"Mail.app" with @"old" produces @"Mail.app.old"
+ *   @"file" with @"" produces @"file."
+ *   @"/" with @"app" produces @"/" (no file name to append to)
+ *   @"" with @"app" produces @"" (no file name to append to)
+ * </example>
+ * NB. Do not use this method to modify strings other than filesystem
+ * paths as the behavior in such cases is undefined ... for instance
+ * the string may have repeated slashes or slash-dot-slash sequences
+ * removed.
+ */
+- (NSString*) stringByAppendingPathExtension: (NSString*)aString;
+
+/**
+ * Returns a new string with the last path component (including any final
+ * path separators) removed from the receiver.<br />
+ * A string without a path component other than the root is returned
+ * without alteration.<br />
+ * See -lastPathComponent for a definition of a path component.
+ * <example>
+ *   @"hello/there" produces @"hello" (a relative path)
+ *   @"hello" produces @"" (a relative path)
+ *   @"/hello" produces @"/" (an absolute unix path)
+ *   @"/" produces @"/" (an absolute unix path)
+ *   @"C:file" produces @"C:" (a relative windows path)
+ *   @"C:" produces @"C:" (a relative windows path)
+ *   @"C:/file" produces @"C:/" (an absolute windows path)
+ *   @"C:/" produces @"C:/" (an absolute windows path)
+ *   @"//host/share/file" produces @"//host/share/" (a UNC path)
+ *   @"//host/share/" produces @"//host/share/" (a UNC path)
+ *   @"//path/file" produces @"//path" (an absolute Unix path)
+ * </example>
+ * NB. Do not use this method to modify strings other than filesystem
+ * paths as the behavior in such cases is undefined ... for instance
+ * the string may have repeated slashes or slash-dot-slash sequences
+ * removed.
+ */
+- (NSString*) stringByDeletingLastPathComponent;
+
+/**
+ * Returns a new string with the path extension removed from the receiver.<br />
+ * Strips any trailing path separators before checking for the extension
+ * separator.<br />
+ * NB. This method does not consider a string which contains nothing
+ * between the root part and the extension separator ('.') to be a path
+ * extension. This mirrors the behavior of the -stringByAppendingPathExtension:
+ * method.
+ * <example>
+ *   @"file.ext" produces @"file"
+ *   @"/file.ext" produces @"/file"
+ *   @"/file.ext/" produces @"/file" (trailing path separators are ignored)
+ *   @"/file..ext" produces @"/file."
+ *   @"/file." produces @"/file"
+ *   @"/.ext" produces @"/.ext" (there is no file to strip from)
+ *   @".ext" produces @".ext" (there is no file to strip from)
+ * </example>
+ * NB. Do not use this method to modify strings other than filesystem
+ * paths as the behavior in such cases is undefined ... for instance
+ * the string may have repeated slashes or slash-dot-slash sequences
+ * removed.
+ */
+- (NSString*) stringByDeletingPathExtension;
+
+/**
+ * Returns a string created by expanding the initial tilde ('~') and any
+ * following username to be the home directory of the current user or the
+ * named user.<br />
+ * Returns the receiver or an immutable copy if it was not possible to
+ * expand it.
+ */
+- (NSString*) stringByExpandingTildeInPath;
+
+/**
+ * First calls -stringByExpandingTildeInPath if necessary.<br />
+ * Replaces path string by one in which path components representing symbolic
+ * links have been replaced by their referents.<br />
+ * Removes a leading '/private' if the result is valid.<br />
+ * If links cannot be resolved, returns an unmodified copy of the receiver.
+ */
+- (NSString*) stringByResolvingSymlinksInPath;
+
+/**
+ * Returns a standardised form of the receiver, with unnecessary parts
+ * removed, tilde characters expanded, and symbolic links resolved
+ * where possible.<br />
+ * NB. Refers to the local filesystem to resolve symbolic links in
+ * absolute paths, and to expand tildes ... so this can't be used for
+ * general path manipulation.<br />
+ * If the string is an invalid path, the unmodified receiver is returned.<br />
+ * <p>
+ *   Uses -stringByExpandingTildeInPath to expand tilde expressions.<br />
+ *   Simplifies '//' and '/./' sequences and removes trailing '/' or '.'.<br />
+ * </p>
+ * <p>
+ *  For absolute paths, uses -stringByResolvingSymlinksInPath to resolve
+ *  any links, then gets rid of '/../' sequences and removes any '/private'
+ *  prefix.
+ * </p>
+ */
+- (NSString*) stringByStandardizingPath;
+
+
+// for methods working with decomposed strings
+- (int) _baseLength;
+
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+/**
+ * Concatenates the path components in the array and returns the result.<br />
+ * This method does not remove empty path components, but does recognize an
+ * empty initial component as a special case meaning that the string
+ * returned will begin with a slash.
+ */
++ (NSString*) pathWithComponents: (NSArray*)components;
+
+/**
+ * Returns YES if the receiver represents an absolute path ...<br />
+ * Returns NO otherwise.<br />
+ * An absolute path in unix mode is one which begins
+ * with a slash or tilde.<br />
+ * In windows mode a drive specification (eg C:) followed by a slash or
+ * backslash, is an absolute path, as is any path beginning with a tilde.<br />
+ * In any mode a UNC path (//host/share...) is always absolute.<br />
+ * In the default gnustep path handling mode,
+ * the rules are the same as for windows,
+ * except that a path whose root is a slash denotes an absolute path
+ * when running on unix and a relative path when running under windows.
+ */
+- (BOOL) isAbsolutePath;
+
+/**
+ * Returns the path components of the receiver separated into an array.<br />
+ * If the receiver begins with a root sequence such as the path separator
+ * character (or a drive specification in windows) then that is used as the
+ * first element in the array.<br />
+ * Empty components are removed.<br />
+ * If a trailing path separator (which was not part of the root) was present,
+ * it is added as the last element in the array.
+ */
+- (NSArray*) pathComponents;
+
+/**
+ * Returns an array of strings made by appending the values in paths
+ * to the receiver.
+ */
+- (NSArray*) stringsByAppendingPaths: (NSArray*)paths;
+
++ (NSString*) localizedStringWithFormat: (NSString*)format, ...
+  NS_FORMAT_FUNCTION(1,2);
+
++ (id) stringWithString: (NSString*)aString;
++ (id) stringWithContentsOfURL: (NSURL*)url;
++ (id) stringWithUTF8String: (const char*)bytes;
+- (id) initWithFormat: (NSString*)format
+	       locale: (NSDictionary*)locale, ... NS_FORMAT_FUNCTION(1,3);
+- (id) initWithFormat: (NSString*)format
+	       locale: (NSDictionary*)locale
+	    arguments: (va_list)argList NS_FORMAT_FUNCTION(1,0);
+- (id) initWithUTF8String: (const char *)bytes;
+- (id) initWithContentsOfURL: (NSURL*)url;
+- (NSString*) substringWithRange: (NSRange)aRange;
+- (NSComparisonResult) caseInsensitiveCompare: (NSString*)aString;
+- (NSComparisonResult) compare: (NSString*)string 
+		       options: (NSUInteger)mask 
+			 range: (NSRange)compareRange 
+			locale: (id)locale;
+- (NSComparisonResult) localizedCompare: (NSString *)string;
+- (NSComparisonResult) localizedCaseInsensitiveCompare: (NSString *)string;
+- (BOOL) writeToFile: (NSString*)filename
+	  atomically: (BOOL)useAuxiliaryFile;
+- (BOOL) writeToURL: (NSURL*)url atomically: (BOOL)atomically;
+- (double) doubleValue;
++ (NSStringEncoding*) availableStringEncodings;
++ (NSString*) localizedNameOfStringEncoding: (NSStringEncoding)encoding;
+- (void) getLineStart: (NSUInteger *)startIndex
+                  end: (NSUInteger *)lineEndIndex
+          contentsEnd: (NSUInteger *)contentsEndIndex
+             forRange: (NSRange)aRange;
+- (NSRange) lineRangeForRange: (NSRange)aRange;
+- (const char*) lossyCString;
+- (NSString*) stringByAddingPercentEscapesUsingEncoding: (NSStringEncoding)e;
+- (NSString*) stringByPaddingToLength: (NSUInteger)newLength
+			   withString: (NSString*)padString
+		      startingAtIndex: (NSUInteger)padIndex;
+- (NSString*) stringByReplacingPercentEscapesUsingEncoding: (NSStringEncoding)e;
+- (NSString*) stringByTrimmingCharactersInSet: (NSCharacterSet*)aSet;
+- (const char *)UTF8String;
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_9,GS_API_LATEST)
+- (NSString *) stringByAddingPercentEncodingWithAllowedCharacters: (NSCharacterSet *)aSet;
+- (NSString *) stringByRemovingPercentEncoding;
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_3,GS_API_LATEST) 
+/** Not implemented */
+- (void) getParagraphStart: (NSUInteger *)startIndex
+                       end: (NSUInteger *)parEndIndex
+               contentsEnd: (NSUInteger *)contentsEndIndex
+                 forRange: (NSRange)range;
+/** Not implemented */
+ - (NSRange) paragraphRangeForRange: (NSRange)range;
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
+/**
+ * Returns YES when scanning the receiver's text from left to right
+ * finds an initial digit in the range 1-9 or a letter in the set
+ * ('Y', 'y', 'T', 't').<br />
+ * Any trailing characters are ignored.<br />
+ * Any leading whitespace or zeros or signs are also ignored.<br />
+ * Returns NO if the above conditions are not met.
+ */
+- (BOOL) boolValue;
+- (NSArray *) componentsSeparatedByCharactersInSet: (NSCharacterSet *)separator;
+- (NSInteger) integerValue;
+- (long long) longLongValue;
+/** Not implemented */
+- (NSRange) rangeOfComposedCharacterSequencesForRange: (NSRange)range;
+/** Not implemented */
+- (NSRange) rangeOfString: (NSString *)aString
+                  options: (NSStringCompareOptions)mask
+                    range: (NSRange)searchRange
+                   locale: (NSLocale *)locale;
+
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_10,GS_API_LATEST) 
+
+/**
+  * Returns YES if the receiver contains string, otherwise, NO.
+  */
+- (BOOL) containsString: (NSString *)string;
+
+#endif
+
+#if OS_API_VERSION(GS_API_NONE, GS_API_NONE)
++ (Class) constantStringClass;
+#endif	/* GS_API_NONE */
+
+@end
+
+@interface NSMutableString : NSString
+
+// Creating Temporary Strings
++ (id) string;
++ (id) stringWithCharacters: (const unichar*)characters
+		     length: (NSUInteger)length;
++ (id) stringWithCString: (const char*)byteString
+		  length: (NSUInteger)length;
++ (id) stringWithCString: (const char*)byteString;
++ (id) stringWithFormat: (NSString*)format, ... NS_FORMAT_FUNCTION(1,2);
++ (id) stringWithContentsOfFile: (NSString*)path;
++ (NSMutableString*) stringWithCapacity: (NSUInteger)capacity;
+
+// Initializing Newly Allocated Strings
+- (id) initWithCapacity: (NSUInteger)capacity;
+
+// Modify A String
+- (void) appendFormat: (NSString*)format, ... NS_FORMAT_FUNCTION(1,2);
+- (void) appendString: (NSString*)aString;
+- (void) deleteCharactersInRange: (NSRange)range;
+- (void) insertString: (NSString*)aString atIndex: (NSUInteger)loc;
+- (void) replaceCharactersInRange: (NSRange)range 
+		       withString: (NSString*)aString;
+- (NSUInteger) replaceOccurrencesOfString: (NSString*)replace
+				 withString: (NSString*)by
+				    options: (NSUInteger)opts
+				      range: (NSRange)searchRange;
+- (void) setString: (NSString*)aString;
+
+@end
+
+#ifdef __OBJC_GNUSTEP_RUNTIME_ABI__
+#  if __OBJC_GNUSTEP_RUNTIME_ABI__ >= 20
+#    define GNUSTEP_NEW_STRING_ABI
+#  endif
+#endif
+
+/**
+ * <p>The NXConstantString class is used to hold constant 8-bit character
+ * string objects produced by the compiler where it sees @"..." in the
+ * source.  The compiler generates the instances of this class - which
+ * has three instance variables -</p>
+ * <list>
+ * <item>a pointer to the class (this is the sole ivar of NSObject)</item>
+ * <item>a pointer to the 8-bit data</item>
+ * <item>the length of the string</item>
+ * </list>
+ * <p>In older versions of the compiler, the isa variable is always set to
+ * the NXConstantString class.  In newer versions a compiler option was
+ * added for GNUstep, to permit the isa variable to be set to another
+ * class, and GNUstep uses this to avoid conflicts with the default
+ * implementation of NXConstantString in the ObjC runtime library (the
+ * preprocessor is used to change all occurrences of NXConstantString
+ * in the source code to NSConstantString).</p>
+ * <p>Since GNUstep will generally use the GNUstep extension to the
+ * compiler, you should never refer to the constant string class by
+ * name, but should use the [NSString+constantStringClass] method to
+ * get the actual class being used for constant strings.</p>
+ * What follows is a dummy declaration of the class to keep the compiler
+ * happy.
+ */
+@interface NXConstantString : NSString
+{
+@public
+#ifdef GNUSTEP_NEW_STRING_ABI
+  /**
+   * Flags.  The low 16 bits are reserved for the compiler, the top 16 for use
+   * by the Foundation Framework.  Currently only the low 2 bits are used, to
+   * indicate the encoding of the string, with the following values:
+   *
+   * 0. ASCII (UTF-8 using only 7-bit characters)
+   * 1. UTF-8
+   * 2. UTF-16
+   * 3. UTF-32
+   *
+   */
+  uint32_t flags;
+  /**
+   * The number of characters (UTF-16 code units) in the string.
+   */
+  uint32_t nxcslen;
+  /**
+   * The number of bytes in the string.  For fixed-length encodings, this is a
+   * fixed multiple of nxcslen, but for UTF-8 it can be different.
+   */
+  uint32_t size;
+  /**
+   * Hash value.
+   */
+  uint32_t hash;
+  /**
+   * Pointer to the byte data of the string.  Note that `char*` is the correct
+   * type only if the low two bits of the flags indicate that this is an ASCII
+   * or UTF-8 string, otherwise it is a pointer to 16- or 32-bit characters in
+   * native byte order.
+   */
+  const char * const nxcsptr;
+#else
+  const char * const nxcsptr;
+  const unsigned int nxcslen;
+#endif
+}
+@end
+
+#ifdef NeXT_RUNTIME
+/** For internal use with NeXT runtime;
+    needed, until Apple Radar 2870817 is fixed. */
+extern struct objc_class _NSConstantStringClassReference;
+#endif
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#if     !NO_GNUSTEP && !defined(GNUSTEP_BASE_INTERNAL)
+#import "../GNUstepBase/NSString+GNUstepBase.h"
+#import "../GNUstepBase/NSMutableString+GNUstepBase.h"
+#endif
+
+#endif /* __NSString_h_GNUSTEP_BASE_INCLUDE */
Index: gcc/testsuite/objc-obj-c++-shared/F-NSValue.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/F-NSValue.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/F-NSValue.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,33 @@
+/* Copyright (C) 2019 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef _OBJC_F_NSSTRING_H_
+#define _OBJC_F_NSSTRING_H_
+
+/* This is a workaround to PR90709 for the NeXT runtime.
+   If we're on a system version that has headers with items we can't
+   consume, then use the GNUStep header instead.
+*/
+
+#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1090
+#  import "GNUStep/Foundation/NSValue.h"
+#else 
+#  import <Foundation/NSValue.h>
+#endif
+
+#endif /* _OBJC_F_NSSTRING_H_ */
Index: gcc/testsuite/objc-obj-c++-shared/F-NSArray.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/F-NSArray.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/F-NSArray.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,33 @@
+/* Copyright (C) 2019 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef _OBJC_F_NSARRAY_H_
+#define _OBJC_F_NSARRAY_H_
+
+/* This is a workaround to PR90709 for the NeXT runtime.
+   If we're on a system version that has headers with items we can't
+   consume, then use the GNUStep header instead.
+*/
+
+#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1090
+#  import "GNUStep/Foundation/NSArray.h"
+#else 
+#  import <Foundation/NSArray.h>
+#endif
+
+#endif /* _OBJC_F_NSARRAY_H_ */
Index: gcc/testsuite/objc-obj-c++-shared/CF-CFString.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/CF-CFString.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/CF-CFString.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,33 @@
+/* Copyright (C) 2019 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef _OBJC_CF_CFSTRING_H_
+#define _OBJC_CF_CFSTRING_H_
+
+/* This is a workaround to PR90709 for the NeXT runtime.
+   If we're on a system version that has headers with items we can't
+   consume, then use the GNUStep header instead.
+*/
+
+#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1090
+#  import "GNUStep/CoreFoundation/CFString.h"
+#else 
+#  import <CoreFoundation/CFString.h>
+#endif
+
+#endif /* _OBJC_CF_CFSTRING_H_ */
Index: gcc/testsuite/objc-obj-c++-shared/F-NSAutoreleasePool.h
===================================================================
--- a/src/gcc/testsuite/objc-obj-c++-shared/F-NSAutoreleasePool.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc-obj-c++-shared/F-NSAutoreleasePool.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,33 @@
+/* Copyright (C) 2019 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef _OBJC_F_NSAUTORELEASEPOOL_H_
+#define _OBJC_F_NSAUTORELEASEPOOL_H_
+
+/* This is a workaround to PR90709 for the NeXT runtime.
+   If we're on a system version that has headers with items we can't
+   consume, then use the GNUStep header instead.
+*/
+
+#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1090
+#  import "GNUStep/Foundation/NSAutoreleasePool.h"
+#else 
+#  import <Foundation/NSAutoreleasePool.h>
+#endif
+
+#endif /* _OBJC_F_NSAUTORELEASEPOOL_H_ */
Index: gcc/testsuite/g++.dg/debug/pr88181.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/debug/pr88181.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/debug/pr88181.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,29 @@
+// PR c++/88181
+// { dg-do compile }
+// { dg-options "-fpack-struct -g -std=c++11" }
+
+template <typename T> struct A { typedef T B; };
+template <typename...> class C;
+template <typename e> struct D { constexpr D (e) {} };
+template <int, typename...> struct E;
+template <int N, typename T, typename... U>
+struct E<N, T, U...> : E<1, U...>, D<T> {
+  constexpr E (T x, U... y) : E<1, U...>(y...), D<T>(x) {}
+};
+template <int N, typename T> struct E<N, T> : D<T> {
+  constexpr E (T x) : D<T>(x) {}
+};
+template <typename T, typename U> struct C<T, U> : E<0, T, U> {
+  constexpr C (T x, U y) : E<0, T, U>(x, y) {}
+  void operator= (typename A<const C>::B);
+};
+struct F {};
+struct G {};
+
+int
+main ()
+{
+  F f;
+  G g;
+  constexpr C<F, G> c(f, g);
+}
Index: gcc/testsuite/g++.dg/debug/dwarf2/pr91887.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/debug/dwarf2/pr91887.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/debug/dwarf2/pr91887.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+// { dg-do compile }
+// { dg-require-effective-target c++11 }
+// { dg-options "-g -fdebug-types-section" }
+class A {
+public:
+  A();
+  template <typename U> A(U);
+};
+template <class> struct B { typedef A type; };
+template <class R, typename... Args>
+int Bind(R(Args...), typename B<Args>::type...) { return 0; }
+void KeepBufferRefs(A, A) { A a, b(Bind(KeepBufferRefs, a, b)); }
Index: gcc/testsuite/g++.dg/debug/dwarf2/pr85550.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/debug/dwarf2/pr85550.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/debug/dwarf2/pr85550.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,17 @@
+// PR debug/85550
+// { dg-do link }
+// { dg-options "-O2 -g -fdebug-types-section" }
+
+struct A {
+  int bar () const { return 0; }
+};
+template <int (A::*foo)() const>
+struct B {
+};
+
+B<&A::bar> b;
+
+int
+main ()
+{
+}
Index: gcc/testsuite/g++.dg/asm-qual-2.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/asm-qual-2.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/asm-qual-2.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,46 @@
+// Test that qualifiers on asm are allowed in any order.
+// { dg-do compile }
+// { dg-options "-std=c++98" }
+
+void
+f ()
+{
+  asm volatile goto ("" :::: lab);
+  asm volatile inline ("" :::);
+  asm inline volatile ("" :::);
+  asm inline goto ("" :::: lab);
+  asm goto volatile ("" :::: lab);
+  asm goto inline ("" :::: lab);
+
+  asm volatile inline goto ("" :::: lab);
+  asm volatile goto inline ("" :::: lab);
+  asm inline volatile goto ("" :::: lab);
+  asm inline goto volatile ("" :::: lab);
+  asm goto volatile inline ("" :::: lab);
+  asm goto inline volatile ("" :::: lab);
+
+  /* Duplicates are not allowed.  */
+  asm goto volatile volatile ("" :::: lab);  /* { dg-error "" } */
+  asm volatile goto volatile ("" :::: lab);  /* { dg-error "" } */
+  asm volatile volatile goto ("" :::: lab);  /* { dg-error "" } */
+  asm goto goto volatile ("" :::: lab);  /* { dg-error "" } */
+  asm goto volatile goto ("" :::: lab);  /* { dg-error "" } */
+  asm volatile goto goto ("" :::: lab);  /* { dg-error "" } */
+
+  asm inline volatile volatile ("" :::);  /* { dg-error "" } */
+  asm volatile inline volatile ("" :::);  /* { dg-error "" } */
+  asm volatile volatile inline ("" :::);  /* { dg-error "" } */
+  asm inline inline volatile ("" :::);  /* { dg-error "" } */
+  asm inline volatile inline ("" :::);  /* { dg-error "" } */
+  asm volatile inline inline ("" :::);  /* { dg-error "" } */
+
+  asm goto inline inline ("" :::: lab);  /* { dg-error "" } */
+  asm inline goto inline ("" :::: lab);  /* { dg-error "" } */
+  asm inline inline goto ("" :::: lab);  /* { dg-error "" } */
+  asm goto goto inline ("" :::: lab);  /* { dg-error "" } */
+  asm goto inline goto ("" :::: lab);  /* { dg-error "" } */
+  asm inline goto goto ("" :::: lab);  /* { dg-error "" } */
+
+lab:
+  ;
+}
Index: gcc/testsuite/g++.dg/opt/pr84272.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/opt/pr84272.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/opt/pr84272.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,23 @@
+// PR target/84272
+// { dg-do compile }
+// { dg-options "-O2" }
+// { dg-additional-options "-march=armv8-a -mtune=cortex-a57" { target aarch64-*-* } }
+
+struct A
+{
+  float b, c;
+  A ();
+  A (float, float, float);
+  float operator * (A)
+  {
+    float d = b * b + c * c;
+    return d;
+  }
+};
+
+void
+foo ()
+{
+  A g[1];
+  A h (0, 0, h * g[2]);
+}
Index: gcc/testsuite/g++.dg/opt/pr89187.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/opt/pr89187.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/opt/pr89187.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,23 @@
+// PR c++/89187
+// { dg-do compile { target c++11 } }
+// { dg-options "-Os -fno-tree-ccp -fno-tree-sra -fno-inline" }
+
+template <typename T, int N> struct A {
+  typedef T __attribute__((vector_size (N))) type;
+};
+template <typename T, int N> using B = typename A<T, N>::type;
+template <typename T> using C = B<T, 4>;
+struct D {
+  D (C<int> x) : d{x[3]} {}
+  D foo () { return d; }
+  C<int> d;
+};
+extern D d;
+struct { D bar () { return d; } } l;
+struct E { void baz () const; };
+
+void
+E::baz () const
+{
+  l.bar ().foo ();
+}
Index: gcc/testsuite/g++.dg/opt/pr89188.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/opt/pr89188.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/opt/pr89188.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,5 @@
+// PR target/89188
+// { dg-do compile { target c++11 } }
+// { dg-options "-Og -flive-range-shrinkage -fnon-call-exceptions" }
+
+#include "../torture/pr88861.C"
Index: gcc/testsuite/g++.dg/opt/pr90187.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/opt/pr90187.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/opt/pr90187.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,15 @@
+// PR target/90187
+// { dg-do compile }
+// { dg-options "-Ofast -ffloat-store" }
+
+double a[64];
+double *foo (void);
+
+void
+bar (int x, const double *y)
+{
+  int i;
+  for (i = 0; i < x; i++)
+    if (y[i] < a[i])
+      a[i] = y[i];
+}
Index: gcc/testsuite/g++.dg/opt/pr90090.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/opt/pr90090.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/opt/pr90090.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,19 @@
+// PR tree-optimization/90090
+// { dg-do compile }
+// { dg-options "-Ofast -fno-associative-math -fsignaling-nans -fno-tree-dce -fnon-call-exceptions" }
+
+double bar (double, double, double, double, double);
+double baz ();
+
+double
+foo (double a)
+{
+  try
+    {
+      return bar (1.0/a, 2.0/a, 4.0/a, 8.0/a, 16.0/a);
+    }
+  catch (...)
+    {
+      return baz ();
+    }
+}
Index: gcc/testsuite/g++.dg/pr71694.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/pr71694.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/pr71694.C	(.../branches/gcc-7-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O2" } */
+/* { dg-additional-options "-fno-common -mdynamic-no-pic" { target { ia32 && { x86_64-*-darwin* i?86-*-darwin* } } } } */
 
 struct B {
     B() {}
Index: gcc/testsuite/g++.dg/ubsan/pr89234.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ubsan/pr89234.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/ubsan/pr89234.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,11 @@
+// PR rtl-optimization/89234
+// { dg-do compile { target dfp } }
+// { dg-options "-O2 -fnon-call-exceptions -fsanitize=null" }
+
+typedef float __attribute__((mode (SD))) _Decimal32;
+
+void
+foo (_Decimal32 *b, _Decimal32 c)
+{
+  *b = c + 1.5;
+}
Index: gcc/testsuite/g++.dg/ubsan/vptr-14.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ubsan/vptr-14.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/ubsan/vptr-14.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,18 @@
+// PR sanitizer/89869
+// { dg-do run }
+// { dg-options "-fsanitize=vptr -fno-sanitize-recover=vptr" }
+
+struct S { S *s = 0; virtual ~S () {} };
+
+void
+foo (S *x, S *y)
+{
+  (x->s ? y : x) = x->s;
+}
+
+int
+main ()
+{
+  S a;
+  foo (&a, 0);
+}
Index: gcc/testsuite/g++.dg/asm-qual-3.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/asm-qual-3.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/asm-qual-3.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+// Test that asm-qualifiers are not allowed on toplevel asm.
+// { dg-do compile }
+// { dg-options "-std=gnu++98" }
+
+asm const ("");    // { dg-error {'const' is not an asm qualifier} }
+asm volatile ("");
+asm restrict (""); // { dg-error {expected '\(' before 'restrict'} }
+asm inline ("");   // { dg-error {asm qualifier outside of function body} }
+asm goto ("");     // { dg-error {asm qualifier outside of function body} }
+
+// There are many other things wrong with this code, so:
+// { dg-excess-errors "" }
Index: gcc/testsuite/g++.dg/cpp0x/initlist105.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/initlist105.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/initlist105.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,28 @@
+// PR c++/86669
+// { dg-do run { target c++11 } }
+
+#include <initializer_list>
+
+struct S { S (); };
+struct T : public S {};
+int cnt;
+void foo (int) { cnt++; }
+
+S::S ()
+{
+  int e = 1, f = 2, g = 3, h = 4;
+
+  for (auto k : { e, f, g, h })
+    foo (k);
+}
+
+int
+main ()
+{
+  S s;
+  if (cnt != 4)
+    __builtin_abort ();
+  T t;
+  if (cnt != 8)
+    __builtin_abort ();
+}
Index: gcc/testsuite/g++.dg/cpp0x/rv-cond3.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/rv-cond3.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/rv-cond3.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,22 @@
+// PR c++/88103
+// { dg-do compile { target c++11 } }
+
+struct A {
+  A (int);
+  A&& foo () &&;
+  int i;
+};
+void free (A&&);
+
+void test_xvalue (A a){
+  A&& ref = true ? static_cast<A&&> (a) : static_cast<A&&> (a); 
+  free (true ? static_cast<A&&> (a) : static_cast<A&&> (a));
+  (true ? static_cast<A&&> (a) : static_cast<A&&> (a)).foo ();
+  int&& k = (true ? static_cast<A&&> (a) : static_cast<A&&> (a)).i;
+}
+void test_prvalue (A a){
+  A&& ref = true ? static_cast<A&&> (a) : 1; 
+  free (true ? static_cast<A&&> (a) : 1);
+  (true ? static_cast<A&&> (a) : 1).foo ();
+  int&& k = (true ? static_cast<A&&> (a) : 1).i;
+}
Index: gcc/testsuite/g++.dg/cpp0x/constexpr-87506.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/constexpr-87506.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/constexpr-87506.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+// PR c++/87506
+// { dg-do compile { target c++11 } }
+
+struct A {};
+struct B { constexpr B (const A) {} };
+struct C : B { using B::B; };
+
+void
+foo ()
+{
+  C c (A{});
+}
Index: gcc/testsuite/g++.dg/cpp0x/pr89403.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/pr89403.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/pr89403.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,18 @@
+// PR c++/89403
+// { dg-do compile { target c++11 } }
+// { dg-options "-Os -fsyntax-only" }
+
+template <typename T>
+struct A : T {
+  constexpr A() : T() { }
+};
+
+template <typename T>
+struct B {
+  A<T> b;
+  constexpr B() { }
+};
+
+struct C { struct {} s; };
+constexpr B<C> b{};
+constexpr C c = b.b;
Index: gcc/testsuite/g++.dg/cpp0x/initlist106.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/initlist106.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/initlist106.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,29 @@
+// PR c++/86669
+// { dg-do run { target c++11 } }
+
+#include <initializer_list>
+
+struct A { };
+struct S : virtual public A { S (); };
+struct T : public S, virtual public A {};
+int cnt;
+void foo (int) { cnt++; }
+
+S::S ()
+{
+  int e = 1, f = 2, g = 3, h = 4;
+
+  for (auto k : { e, f, g, h })
+    foo (k);
+}
+
+int
+main ()
+{
+  S s;
+  if (cnt != 4)
+    __builtin_abort ();
+  T t;
+  if (cnt != 8)
+    __builtin_abort ();
+}
Index: gcc/testsuite/g++.dg/torture/pr44295.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/torture/pr44295.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/torture/pr44295.C	(.../branches/gcc-7-branch)
@@ -1,4 +1,6 @@
 /* { dg-do compile } */
+/* { dg-skip-if "no pthread_barrier" { *-*-darwin* } } */
+
 extern "C" {
   typedef __SIZE_TYPE__ size_t;
   typedef struct   {
Index: gcc/testsuite/g++.dg/torture/pr88149.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/torture/pr88149.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/torture/pr88149.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,63 @@
+// { dg-do compile }
+// { dg-additional-options "-ftree-vectorize" }
+
+template <typename> struct a;
+template <typename b> struct a<b *> {
+  typedef long c;
+  typedef b &d;
+};
+template <typename e> class f {
+  e ab;
+  typedef a<e> ac;
+
+public:
+  typename ac::d operator[](typename ac::c o) { return ab[o]; }
+};
+template <typename> struct au;
+template <typename b> au<b> operator+(au<b> o, au<b> p2) {
+  au<b> ax = o;
+  ax += p2;
+  return ax;
+}
+template <typename b> au<b> operator-(au<b> o, au<b> p2) {
+  au<b> ax = o;
+  ax -= p2;
+  return ax;
+}
+template <typename b> au<b> operator*(au<b>, au<b> &p2) {
+  au<b> ax;
+  ax *= p2;
+  return ax;
+}
+template <> struct au<double> {
+  double p() { return __real__ az; }
+  double q() { return __imag__ az; }
+  void operator+=(au o) {
+    az += o.p();
+    __imag__ az += o.q();
+  }
+  void operator-=(au o) {
+    az -= o.p();
+    __imag__ az -= o.q();
+  }
+  void operator*=(au &o) {
+    _Complex bd = o.p();
+    __imag__ bd = o.q();
+    az *= bd;
+  }
+  _Complex az;
+};
+long bm, m;
+f<au<double> *> g;
+au<double> h, i, l;
+void bn() {
+  au<double> bq;
+  for (long k; m;) {
+    au<double> br;
+    for (long j = 0; j < bm; ++j) {
+      au<double> n = br * h;
+      i = l + n;
+      g[k] = l - bq;
+    }
+  }
+}
Index: gcc/testsuite/g++.dg/torture/pr88861.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/torture/pr88861.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/torture/pr88861.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,11 @@
+// { dg-options "-fnon-call-exceptions" }
+
+struct Ax {
+  int n, a[];
+};
+
+int i = 12345678;
+int main() {
+  static Ax s{456, i};
+  ((s.a[0]) ? (void)0 : (void)0);
+}
Index: gcc/testsuite/g++.dg/torture/pr90194.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/torture/pr90194.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/torture/pr90194.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,18 @@
+// { dg-do compile }
+// { dg-additional-options "-g" }
+
+struct cb {
+    int yr;
+};
+
+void *
+operator new (__SIZE_TYPE__, void *nq)
+{
+  return nq;
+}
+
+void
+af (int xn)
+{
+  new (&xn) cb { };
+}
Index: gcc/testsuite/g++.dg/torture/pr89303.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/torture/pr89303.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/torture/pr89303.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,792 @@
+// PR middle-end/89303
+// { dg-do run }
+// { dg-additional-options "-std=c++14" }
+
+namespace my
+{
+  typedef __SIZE_TYPE__ size_t;
+  typedef decltype(nullptr) nullptr_t;
+
+  template<typename _Tp, _Tp __v>
+    struct integral_constant
+    {
+      static constexpr _Tp value = __v;
+      typedef _Tp value_type;
+      typedef integral_constant<_Tp, __v> type;
+      constexpr operator value_type() const noexcept { return value; }
+      constexpr value_type operator()() const noexcept { return value; }
+    };
+
+  template<typename _Tp, _Tp __v>
+    constexpr _Tp integral_constant<_Tp, __v>::value;
+
+  typedef integral_constant<bool, true> true_type;
+  typedef integral_constant<bool, false> false_type;
+
+  template<bool __v>
+    using __bool_constant = integral_constant<bool, __v>;
+
+  template<bool, typename, typename>
+    struct conditional;
+
+  template<typename...>
+    struct __and_;
+
+  template<>
+    struct __and_<>
+    : public true_type
+    { };
+
+  template<typename _B1>
+    struct __and_<_B1>
+    : public _B1
+    { };
+
+  template<typename _B1, typename _B2>
+    struct __and_<_B1, _B2>
+    : public conditional<_B1::value, _B2, _B1>::type
+    { };
+
+  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
+    struct __and_<_B1, _B2, _B3, _Bn...>
+    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
+    { };
+
+  template<typename>
+    struct remove_cv;
+
+  template<typename>
+    struct __is_void_helper
+    : public false_type { };
+
+  template<>
+    struct __is_void_helper<void>
+    : public true_type { };
+
+  template<typename _Tp>
+    struct is_void
+    : public __is_void_helper<typename remove_cv<_Tp>::type>::type
+    { };
+
+  template<typename _Tp, typename _Up = _Tp&&>
+    _Up
+    __declval(int);
+
+  template<typename _Tp>
+    _Tp
+    __declval(long);
+
+  template<typename _Tp>
+    auto declval() noexcept -> decltype(__declval<_Tp>(0));
+
+  template<typename, typename>
+    struct is_same
+    : public false_type { };
+
+  template<typename _Tp>
+    struct is_same<_Tp, _Tp>
+    : public true_type { };
+
+  template<typename _Tp>
+    struct remove_const
+    { typedef _Tp type; };
+
+  template<typename _Tp>
+    struct remove_const<_Tp const>
+    { typedef _Tp type; };
+
+  template<typename _Tp>
+    struct remove_volatile
+    { typedef _Tp type; };
+
+  template<typename _Tp>
+    struct remove_volatile<_Tp volatile>
+    { typedef _Tp type; };
+
+  template<typename _Tp>
+    struct remove_cv
+    {
+      typedef typename
+      remove_const<typename remove_volatile<_Tp>::type>::type type;
+    };
+
+  template<typename _Tp>
+    struct remove_reference
+    { typedef _Tp type; };
+
+  template<typename _Tp>
+    struct remove_reference<_Tp&>
+    { typedef _Tp type; };
+
+  template<typename _Tp>
+    struct remove_reference<_Tp&&>
+    { typedef _Tp type; };
+
+  template<bool, typename _Tp = void>
+    struct enable_if
+    { };
+
+  template<typename _Tp>
+    struct enable_if<true, _Tp>
+    { typedef _Tp type; };
+
+  template<typename... _Cond>
+    using _Require = typename enable_if<__and_<_Cond...>::value>::type;
+
+  template<bool _Cond, typename _Iftrue, typename _Iffalse>
+    struct conditional
+    { typedef _Iftrue type; };
+
+  template<typename _Iftrue, typename _Iffalse>
+    struct conditional<false, _Iftrue, _Iffalse>
+    { typedef _Iffalse type; };
+
+  template<typename _Tp>
+    struct __declval_protector
+    {
+      static const bool __stop = false;
+    };
+
+  template<typename _Tp>
+    auto declval() noexcept -> decltype(__declval<_Tp>(0))
+    {
+      static_assert(__declval_protector<_Tp>::__stop,
+      "declval() must not be used!");
+      return __declval<_Tp>(0);
+    }
+
+  namespace void_details {
+    template <class... >
+    struct make_void { using type = void; };
+}
+
+template <class... T> using __void_t = typename void_details ::make_void<T...>::type;
+
+  template<typename _Tp>
+    inline constexpr _Tp*
+    __addressof(_Tp& __r) noexcept
+    {
+      return reinterpret_cast<_Tp*>
+	(&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
+    }
+
+  template<typename _Tp>
+    constexpr _Tp&&
+    forward(typename my::remove_reference<_Tp>::type& __t) noexcept
+    { return static_cast<_Tp&&>(__t); }
+
+  template<typename _Tp>
+    constexpr _Tp&&
+    forward(typename my::remove_reference<_Tp>::type&& __t) noexcept
+    {
+      return static_cast<_Tp&&>(__t);
+    }
+
+  template<typename _Tp>
+    constexpr typename my::remove_reference<_Tp>::type&&
+    move(_Tp&& __t) noexcept
+    { return static_cast<typename my::remove_reference<_Tp>::type&&>(__t); }
+}
+       
+inline void* operator new(my::size_t, void* p) { return p; }
+
+extern "C" void* malloc(my::size_t);
+extern "C" void free(void*);
+
+namespace my
+{
+  template<typename T>
+    class allocator
+    {
+    public:
+      using value_type = T;
+
+      allocator() { }
+
+      template<typename U>
+        allocator(const allocator<U>&) { }
+
+      T* allocate(size_t n) { return (T*)malloc(n*sizeof(T)); }
+      void deallocate(T* p, size_t) { free(p); }
+
+      template<typename U, typename... Args>
+        void construct(U* p, Args&&... args)
+        { ::new((void*)p) U(args...); }
+
+      template<typename U>
+        void destroy(U* p)
+        { p->~U(); }
+    };
+
+  class __undefined;
+
+  template<typename _Tp, typename _Up>
+    struct __replace_first_arg
+    { };
+
+  template<template<typename, typename...> class _Template, typename _Up,
+           typename _Tp, typename... _Types>
+    struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>
+    { using type = _Template<_Up, _Types...>; };
+
+  struct __allocator_traits_base
+  {
+    template<typename _Tp, typename _Up, typename = void>
+      struct __rebind : __replace_first_arg<_Tp, _Up> { };
+
+    template<typename _Tp, typename _Up>
+      struct __rebind<_Tp, _Up,
+        __void_t<typename _Tp::template rebind<_Up>::other>>
+      { using type = typename _Tp::template rebind<_Up>::other; };
+  };
+
+  template<typename _Alloc, typename _Up>
+    using __alloc_rebind
+      = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;
+
+  template<typename _Alloc>
+    struct allocator_traits;
+
+  template<typename _Tp>
+    struct allocator_traits<allocator<_Tp>>
+    {
+      using allocator_type = allocator<_Tp>;
+      using value_type = _Tp;
+      using pointer = _Tp*;
+      using const_pointer = const _Tp*;
+      using size_type = my::size_t;
+
+      static pointer
+      allocate(allocator_type& __a, size_type __n)
+      { return __a.allocate(__n); }
+
+      static void
+      deallocate(allocator_type& __a, pointer __p, size_type __n)
+      { __a.deallocate(__p, __n); }
+
+      template<typename _Up, typename... _Args>
+        static void
+        construct(allocator_type& __a, _Up* __p, _Args&&... __args)
+        { __a.construct(__p, my::forward<_Args>(__args)...); }
+
+      template<typename _Up>
+        static void
+        destroy(allocator_type& __a, _Up* __p)
+        { __a.destroy(__p); }
+    };
+
+  template<typename _Alloc>
+    struct __allocated_ptr
+    {
+      using pointer = typename allocator_traits<_Alloc>::pointer;
+      using value_type = typename allocator_traits<_Alloc>::value_type;
+
+      __allocated_ptr(_Alloc& __a, pointer __ptr) noexcept
+      : _M_alloc(my::__addressof(__a)), _M_ptr(__ptr)
+      { }
+
+      template<typename _Ptr,
+        typename _Req = _Require<is_same<_Ptr, value_type*>>>
+      __allocated_ptr(_Alloc& __a, _Ptr __ptr)
+      : _M_alloc(my::__addressof(__a)),
+      _M_ptr(__ptr)
+      { }
+
+      __allocated_ptr(__allocated_ptr&& __gd) noexcept
+      : _M_alloc(__gd._M_alloc), _M_ptr(__gd._M_ptr)
+      { __gd._M_ptr = nullptr; }
+
+      ~__allocated_ptr()
+      {
+        if (_M_ptr != nullptr)
+          my::allocator_traits<_Alloc>::deallocate(*_M_alloc, _M_ptr, 1);
+      }
+
+      __allocated_ptr&
+      operator=(my::nullptr_t) noexcept
+      {
+        _M_ptr = nullptr;
+        return *this;
+      }
+
+      value_type* get() { return _M_ptr; }
+
+    private:
+      _Alloc* _M_alloc;
+      pointer _M_ptr;
+    };
+
+  template<typename _Alloc>
+    __allocated_ptr<_Alloc>
+    __allocate_guarded(_Alloc& __a)
+    {
+      return { __a, my::allocator_traits<_Alloc>::allocate(__a, 1) };
+    }
+
+  template<typename _Tp>
+    struct __aligned_buffer
+    {
+      alignas(__alignof__(_Tp)) unsigned char _M_storage[sizeof(_Tp)];
+      __aligned_buffer() = default;
+
+      void*
+      _M_addr() noexcept
+      {
+        return static_cast<void*>(&_M_storage);
+      }
+
+      const void*
+      _M_addr() const noexcept
+      {
+        return static_cast<const void*>(&_M_storage);
+      }
+
+      _Tp*
+      _M_ptr() noexcept
+      { return static_cast<_Tp*>(_M_addr()); }
+
+      const _Tp*
+      _M_ptr() const noexcept
+      { return static_cast<const _Tp*>(_M_addr()); }
+    };
+
+  class bad_weak_ptr { };
+
+  inline void
+  __throw_bad_weak_ptr()
+  { (throw (bad_weak_ptr())); }
+
+    class _Sp_counted_base
+    {
+    public:
+      _Sp_counted_base() noexcept
+      : _M_use_count(1), _M_weak_count(1) { }
+
+      virtual
+      ~_Sp_counted_base() noexcept
+      { }
+
+      virtual void
+      _M_dispose() noexcept = 0;
+
+      virtual void
+      _M_destroy() noexcept
+      { delete this; }
+
+      void
+      _M_add_ref_copy()
+      { ++_M_use_count; }
+
+      void
+      _M_add_ref_lock()
+      {
+        if (_M_use_count == 0)
+          __throw_bad_weak_ptr();
+        ++_M_use_count;
+      }
+
+      void
+      _M_release() noexcept
+      {
+        if (--_M_use_count == 0)
+        {
+          _M_dispose();
+          if (--_M_weak_count == 0)
+            _M_destroy();
+        }
+      }
+
+      void
+      _M_weak_add_ref() noexcept
+      { ++_M_weak_count; }
+
+      void
+      _M_weak_release() noexcept
+      {
+        if (--_M_weak_count == 0)
+          _M_destroy();
+      }
+
+      long
+      _M_get_use_count() const noexcept
+      {
+        return _M_use_count;
+      }
+
+    private:
+      _Sp_counted_base(_Sp_counted_base const&) = delete;
+      _Sp_counted_base& operator=(_Sp_counted_base const&) = delete;
+
+      int _M_use_count;
+      int _M_weak_count;
+    };
+
+  template<typename _Tp>
+    class shared_ptr;
+
+  template<typename _Tp>
+    class weak_ptr;
+
+  template<typename _Tp>
+    class enable_shared_from_this;
+
+  class __weak_count;
+
+  class __shared_count;
+
+  template<typename _Alloc>
+    struct _Sp_alloc_shared_tag
+    {
+      const _Alloc& _M_a;
+    };
+
+  template<typename _Tp, typename _Alloc>
+    class _Sp_counted_ptr_inplace final : public _Sp_counted_base
+    {
+      class _Impl : _Alloc
+      {
+      public:
+        explicit _Impl(_Alloc __a) noexcept : _Alloc(__a) { }
+
+        _Alloc& _M_alloc() noexcept { return *this; }
+
+        __aligned_buffer<_Tp> _M_storage;
+      };
+
+    public:
+      using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_ptr_inplace>;
+
+      template<typename... _Args>
+        _Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)
+        : _M_impl(__a)
+        {
+          allocator_traits<_Alloc>::construct(__a, _M_ptr(),
+              my::forward<_Args>(__args)...);
+        }
+
+      ~_Sp_counted_ptr_inplace() noexcept { }
+
+      virtual void
+      _M_dispose() noexcept
+      {
+        allocator_traits<_Alloc>::destroy(_M_impl._M_alloc(), _M_ptr());
+      }
+
+      virtual void
+      _M_destroy() noexcept
+      {
+        __allocator_type __a(_M_impl._M_alloc());
+        __allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
+        this->~_Sp_counted_ptr_inplace();
+      }
+
+    private:
+      friend class __shared_count;
+
+      _Tp* _M_ptr() noexcept { return _M_impl._M_storage._M_ptr(); }
+
+      _Impl _M_impl;
+    };
+
+  class __shared_count
+  {
+  public:
+    constexpr __shared_count() noexcept : _M_pi(0)
+    { }
+
+    template<typename _Tp, typename _Alloc, typename... _Args>
+      __shared_count(_Tp*& __p, _Sp_alloc_shared_tag<_Alloc> __a,
+          _Args&&... __args)
+      {
+        typedef _Sp_counted_ptr_inplace<_Tp, _Alloc> _Sp_cp_type;
+        typename _Sp_cp_type::__allocator_type __a2(__a._M_a);
+        auto __guard = my::__allocate_guarded(__a2);
+        _Sp_cp_type* __mem = __guard.get();
+        auto __pi = ::new (__mem)
+          _Sp_cp_type(__a._M_a, my::forward<_Args>(__args)...);
+        __guard = nullptr;
+        _M_pi = __pi;
+        __p = __pi->_M_ptr();
+      }
+
+    ~__shared_count() noexcept
+    {
+      if (_M_pi != nullptr)
+        _M_pi->_M_release();
+    }
+
+    __shared_count(const __shared_count& __r) noexcept
+    : _M_pi(__r._M_pi)
+    {
+      if (_M_pi != 0)
+        _M_pi->_M_add_ref_copy();
+    }
+
+    explicit __shared_count(const __weak_count& __r);
+
+    long
+    _M_get_use_count() const noexcept
+    { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }
+
+  private:
+    friend class __weak_count;
+
+    _Sp_counted_base* _M_pi;
+  };
+
+  class __weak_count
+  {
+  public:
+    constexpr __weak_count() noexcept : _M_pi(nullptr)
+    { }
+
+    __weak_count(const __shared_count& __r) noexcept
+    : _M_pi(__r._M_pi)
+    {
+      if (_M_pi != nullptr)
+        _M_pi->_M_weak_add_ref();
+    }
+
+    __weak_count(const __weak_count& __r) noexcept
+    : _M_pi(__r._M_pi)
+    {
+      if (_M_pi != nullptr)
+        _M_pi->_M_weak_add_ref();
+    }
+
+    __weak_count(__weak_count&& __r) noexcept
+    : _M_pi(__r._M_pi)
+    { __r._M_pi = nullptr; }
+
+    ~__weak_count() noexcept
+    {
+      if (_M_pi != nullptr)
+      {
+        _M_pi->_M_weak_release();
+      }
+    }
+
+    __weak_count&
+    operator=(const __shared_count& __r) noexcept
+    {
+      _Sp_counted_base* __tmp = __r._M_pi;
+      if (__tmp != nullptr)
+        __tmp->_M_weak_add_ref();
+      if (_M_pi != nullptr)
+        _M_pi->_M_weak_release();
+      _M_pi = __tmp;
+      return *this;
+    }
+
+    long
+    _M_get_use_count() const noexcept
+    { return _M_pi != nullptr ? _M_pi->_M_get_use_count() : 0; }
+
+  private:
+    friend class __shared_count;
+
+    _Sp_counted_base* _M_pi;
+  };
+
+  inline
+  __shared_count::__shared_count(const __weak_count& __r)
+  : _M_pi(__r._M_pi)
+  {
+    if (_M_pi != nullptr)
+      _M_pi->_M_add_ref_lock();
+    else
+      __throw_bad_weak_ptr();
+  }
+
+  template<typename _Tp>
+    class shared_ptr
+    {
+    public:
+      using element_type = _Tp;
+
+      constexpr shared_ptr() noexcept
+        : _M_ptr(0), _M_refcount()
+        { }
+
+      shared_ptr(const shared_ptr&) noexcept = default;
+      shared_ptr& operator=(const shared_ptr&) noexcept = default;
+      ~shared_ptr() = default;
+
+      template<typename _Yp>
+	explicit shared_ptr(const weak_ptr<_Yp>& __r)
+	: _M_refcount(__r._M_refcount) // may throw
+	{
+	  // It is now safe to copy __r._M_ptr, as
+	  // _M_refcount(__r._M_refcount) did not throw.
+	  _M_ptr = __r._M_ptr;
+	}
+
+      long
+      use_count() const noexcept
+      { return _M_refcount._M_get_use_count(); }
+
+      element_type* operator->() const noexcept { return _M_ptr; }
+
+    protected:
+
+      template<typename _Alloc, typename... _Args>
+        shared_ptr(_Sp_alloc_shared_tag<_Alloc> __tag, _Args&&... __args)
+        : _M_ptr(), _M_refcount(_M_ptr, __tag, my::forward<_Args>(__args)...)
+        { _M_enable_shared_from_this_with(_M_ptr); }
+
+      template<typename _Tp1, typename _Alloc,
+        typename... _Args>
+          friend shared_ptr<_Tp1>
+          allocate_shared(const _Alloc& __a, _Args&&... __args);
+
+      friend class weak_ptr<_Tp>;
+
+    private:
+
+      template<typename _Yp>
+        using __esft_base_t = decltype(__enable_shared_from_this_base(
+              my::declval<const __shared_count&>(),
+              my::declval<_Yp*>()));
+
+      template<typename _Yp, typename = void>
+        struct __has_esft_base
+        : false_type { };
+
+      template<typename _Yp>
+        struct __has_esft_base<_Yp, __void_t<__esft_base_t<_Yp>>>
+        : true_type { };
+
+      template<typename _Yp, typename _Yp2 = typename remove_cv<_Yp>::type>
+        typename enable_if<__has_esft_base<_Yp2>::value>::type
+        _M_enable_shared_from_this_with(_Yp* __p) noexcept
+        {
+          if (auto __base = __enable_shared_from_this_base(_M_refcount, __p))
+            __base->_M_weak_assign(const_cast<_Yp2*>(__p), _M_refcount);
+        }
+
+      template<typename _Tp1> friend class shared_ptr;
+      template<typename _Tp1> friend class weak_ptr;
+
+      element_type* _M_ptr;
+      __shared_count _M_refcount;
+    };
+
+  template<typename _Tp>
+    class weak_ptr
+    {
+    public:
+      using element_type = _Tp;
+
+      constexpr weak_ptr() noexcept
+      : _M_ptr(nullptr), _M_refcount()
+      { }
+
+      weak_ptr(const weak_ptr&) noexcept = default;
+
+      ~weak_ptr() = default;
+
+      weak_ptr&
+      operator=(const weak_ptr& __r) noexcept = default;
+
+      long
+      use_count() const noexcept
+      { return _M_refcount._M_get_use_count(); }
+
+    private:
+
+      void
+      _M_assign(_Tp* __ptr, const __shared_count& __refcount) noexcept
+      {
+        if (use_count() == 0)
+        {
+          _M_ptr = __ptr;
+          _M_refcount = __refcount;
+        }
+      }
+
+      template<typename _Tp1> friend class shared_ptr;
+      template<typename _Tp1> friend class weak_ptr;
+      friend class enable_shared_from_this<_Tp>;
+
+      element_type* _M_ptr;
+      __weak_count _M_refcount;
+    };
+
+  template<typename _Tp>
+    class enable_shared_from_this
+    {
+    protected:
+      constexpr enable_shared_from_this() noexcept { }
+
+      enable_shared_from_this(const enable_shared_from_this&) noexcept { }
+
+      enable_shared_from_this&
+      operator=(const enable_shared_from_this&) noexcept
+      { return *this; }
+
+      ~enable_shared_from_this() { }
+
+    public:
+      shared_ptr<_Tp>
+      shared_from_this()
+      { return shared_ptr<_Tp>(this->_M_weak_this); }
+
+      shared_ptr<const _Tp>
+      shared_from_this() const
+      { return shared_ptr<const _Tp>(this->_M_weak_this); }
+
+    private:
+      template<typename _Tp1>
+        void
+        _M_weak_assign(_Tp1* __p, const __shared_count& __n) const noexcept
+        { _M_weak_this._M_assign(__p, __n); }
+
+      friend const enable_shared_from_this*
+      __enable_shared_from_this_base(const __shared_count&,
+         const enable_shared_from_this* __p)
+      { return __p; }
+
+      template<typename>
+        friend class shared_ptr;
+
+      mutable weak_ptr<_Tp> _M_weak_this;
+    };
+
+  template<typename _Tp, typename _Alloc, typename... _Args>
+    inline shared_ptr<_Tp>
+    allocate_shared(const _Alloc& __a, _Args&&... __args)
+    {
+      return shared_ptr<_Tp>(_Sp_alloc_shared_tag<_Alloc>{__a},
+        my::forward<_Args>(__args)...);
+    }
+
+  template<typename _Tp, typename... _Args>
+    inline shared_ptr<_Tp>
+    make_shared(_Args&&... __args)
+    {
+      typedef typename my::remove_const<_Tp>::type _Tp_nc;
+      return my::allocate_shared<_Tp>(my::allocator<_Tp_nc>(),
+           my::forward<_Args>(__args)...);
+    }
+}
+
+class blob final: public my::enable_shared_from_this<blob>
+{
+  int* data;
+
+public:
+  blob() { data = new int; }
+  ~blob() { delete data; }
+};
+
+static int
+bar(my::shared_ptr<blob>)
+{
+  return 0;
+}
+
+int main()
+{
+  my::shared_ptr<blob> tg = my::make_shared<blob>();
+  return tg->shared_from_this().use_count() - 2;
+}
Index: gcc/testsuite/g++.dg/torture/pr89698.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/torture/pr89698.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/torture/pr89698.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,28 @@
+/* { dg-do run } */
+
+extern "C" void abort (void);
+
+class A {
+    virtual void f(){};
+public:
+    int x;
+    A(int in): x(in) {};
+};
+
+class B: public A {
+public:
+    int y;
+    B(int in):A(in-1), y(in) {};
+};
+
+int test(void)
+{
+  int res;
+  B b(2);
+  A* bp = &b;
+  void* vp = dynamic_cast<void*>(bp);
+  if (((A*)vp)->x == 1 && ((B*)vp)->y == 2)
+    return 1;
+  return 0;
+}
+int main() { if (test() != 1) abort (); return 0; }
Index: gcc/testsuite/g++.dg/ipa/pr89009.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/pr89009.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/pr89009.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,14 @@
+/* PR ipa/89009 */
+/* { dg-do run } */
+/* { dg-require-effective-target fpic } */
+/* { dg-options "-fpic -O2 -fno-inline" } */
+/* { dg-require-visibility "" } */
+
+void foo1() { __builtin_printf ("foo\n"); }
+#pragma GCC visibility push(hidden)
+void foo2() { __builtin_printf ("foo\n"); }
+#pragma GCC visibility pop
+
+int main() { foo2(); return 0; }
+
+/* { dg-output "foo" } */
Index: gcc/testsuite/g++.dg/cpp1y/var-templ61.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/var-templ61.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/var-templ61.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,20 @@
+// PR c++/89512
+// { dg-do compile { target c++14 } }
+
+struct A {
+  template <typename T>
+  static const int a = 0;
+};
+
+struct B {
+  template <typename T>
+  static int foo ()
+  {
+    return T::a;		// { dg-error "missing template arguments" }
+  }
+};
+
+int bar ()
+{
+  return B::foo<A> ();		// { dg-message "required from here" }
+}
Index: gcc/testsuite/g++.dg/cpp1y/pr89767.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/pr89767.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/pr89767.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,32 @@
+// PR c++/89767
+// { dg-do compile { target c++14 } }
+// { dg-options "-O2 -Wall" }
+
+template <typename d> struct e { using g = d; };
+template <typename d, template <typename> class> using h = e<d>;
+template <typename d, template <typename> class i>
+using j = typename h<d, i>::g;
+template <typename c> int k(c);
+template <typename...> class au;
+struct l { template <typename c> using m = typename c::f; };
+struct s : l { using af = j<au<int, int> *, m>; };
+template <unsigned long, typename> struct o;
+template <long p, typename c> using q = typename o<p, c>::g;
+template <typename> struct r;
+template <typename c> struct r<c *> { typedef c aj; };
+template <typename ak, typename> struct al { typename r<ak>::aj operator*(); void operator++(); };
+template <typename am, typename an, typename ao>
+bool operator!=(al<am, ao>, al<an, ao>);
+template <unsigned long, typename...> struct ap;
+template <unsigned long aq, typename ar, typename... as>
+struct ap<aq, ar, as...> : ap<1, as...> {};
+template <unsigned long aq, typename ar> struct ap<aq, ar> {};
+template <typename... at> class au : public ap<0, at...> {};
+template <unsigned long p, typename ar, typename... as>
+struct o<p, au<ar, as...>> : o<p - 1, au<as...>> {};
+template <typename ar, typename... as> struct o<0, au<ar, as...>> { typedef ar g; };
+template <long p, typename ar> constexpr ar av(ap<p, ar> __t) { return ar (); }
+template <int p, typename... at> constexpr q<p, au<at...>> aw(au<at...> __t) { av<p>(__t); return q<p, au<at...>> (); }
+struct bg { typedef s::af af; };
+struct F { typedef al<bg::af, int> bk; bk begin(); bk end(); };
+void bo() { int t = 0; F cv; for (auto bp : cv) [t, n = k(aw<1>(bp))] {}; }
Index: gcc/testsuite/g++.dg/cpp1y/lambda-init18.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/lambda-init18.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/lambda-init18.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+// PR c++/89767
+// { dg-do compile { target c++14 } }
+
+void bar (int);
+
+void
+foo ()
+{
+  int x = 0;
+  auto z = [x, y = [x] { bar (x); }] { y (); bar (x); };
+  z ();
+}
Index: gcc/testsuite/g++.dg/cpp1y/lambda-init19.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/lambda-init19.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/lambda-init19.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,15 @@
+// PR c++/89767
+// { dg-do compile { target c++14 } }
+
+void bar (int);
+
+void
+foo ()
+{
+  int x = 0;
+  int a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0;
+  auto z = [x, y = [x] { bar (x); }, x] { y (); bar (x); };	// { dg-error "already captured 'x' in lambda expression" }
+  auto w = [x, a, b, c, d, y = [x] { bar (x); }, e, f, g, h, x] { y (); bar (x + a + b + c + d + e + f + g + h); };	// { dg-error "already captured 'x' in lambda expression" }
+  z ();
+  w ();
+}
Index: gcc/testsuite/g++.dg/cpp1z/decomp49.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1z/decomp49.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1z/decomp49.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,14 @@
+// PR c++/82075
+// { dg-do run { target c++11 } }
+// { dg-options "" }
+
+struct B { };
+struct D : B { int i; };
+
+int
+main ()
+{
+  auto [i] = D{};	// { dg-warning "only available with" "" { target c++14_down } }
+  if (i != 0)
+    __builtin_abort ();
+}
Index: gcc/testsuite/g++.dg/ext/flexary34.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ext/flexary34.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/ext/flexary34.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,10 @@
+// PR c++/87148
+// { dg-do compile }
+// { dg-options "-pedantic" }
+
+struct Tst { int i; char t[]; };	// { dg-warning "forbids flexible array member" }
+
+Tst t {};				// { dg-warning "extended initializer lists only available with" "" { target c++98_only } }
+Tst u = Tst();
+void foo () { Tst u = {}; }
+Tst *bar () { return new Tst (); }
Index: gcc/testsuite/g++.dg/ext/instantiate2.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ext/instantiate2.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/ext/instantiate2.C	(.../branches/gcc-7-branch)
@@ -8,8 +8,7 @@
 template <class T> T A<T>::t = 0;
 static template struct A<int>;
 
-// { dg-final { scan-assembler "\n_?_ZN1AIiE1tE(:|\n|\t)" { target { ! *-*-darwin* } } } }
-// { dg-final { scan-assembler ".zerofill __DATA,__pu_bss2,__ZN1AIiE1tE" { target *-*-darwin* } } } 
+// { dg-final { scan-assembler "\n_?_ZN1AIiE1tE(:|\n|\t)" } }
 void test_int() { A<int>::t = 42; }
 
 // { dg-final { scan-assembler-not "\n_?_ZN1AIcE1tE(:|\n|\t)" } }
Index: gcc/testsuite/g++.dg/ext/alignof2.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ext/alignof2.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/ext/alignof2.C	(.../branches/gcc-7-branch)
@@ -3,7 +3,7 @@
 // wrong for some fields.
 
 // { dg-do run }
-// { dg-xfail-run-if "AIX ABI increases struct alignment for first member double" { powerpc-ibm-aix* } { "*" } { "" } }
+// { dg-xfail-run-if "AIX/Darwin ABI increases struct alignment for first member double" { powerpc-ibm-aix* || { ilp32 && powerpc-*-darwin* } } }
 
 extern "C" void abort();
 
Index: gcc/testsuite/g++.dg/ext/asm15.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ext/asm15.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/ext/asm15.C	(.../branches/gcc-7-branch)
@@ -6,5 +6,6 @@
 void
 foo (S &s)
 {
-  __asm volatile ("" : "+r" (s) : : "memory");	// { dg-error "" }
+  __asm volatile ("" : "+r" (s) : : "memory");	// { dg-error "impossible constraint" }
+						// { dg-error "must stay in memory" "" { target *-*-* } .-1 }
 }
Index: gcc/testsuite/g++.dg/ext/asm16.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ext/asm16.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/ext/asm16.C	(.../branches/gcc-7-branch)
@@ -6,5 +6,6 @@
 void
 foo ()
 {
-  __asm volatile ("" : "=r" (s) : : "memory");	// { dg-error "" }
+  __asm volatile ("" : "=r" (s) : : "memory");	// { dg-error "impossible constraint" }
+						// { dg-error "must stay in memory" "" { target *-*-* } .-1 }
 }
Index: gcc/testsuite/g++.dg/ext/asm17.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ext/asm17.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/ext/asm17.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,11 @@
+// PR target/89752
+// { dg-do compile }
+
+struct A { A (); ~A (); short c; };
+
+void
+foo ()
+{
+  A a0, a1;
+  __asm volatile ("" : "+rm" (a0), "+rm" (a1));
+}
Index: gcc/testsuite/g++.dg/ext/vector36.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ext/vector36.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/ext/vector36.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,6 @@
+// PR target/89186
+// { dg-do compile }
+// { dg-options "-fnon-call-exceptions" }
+// { dg-additional-options "-mno-sse" { target i?86-*-* x86_64-*-* } }
+
+#include "vector27.C"
Index: gcc/testsuite/g++.dg/ext/sync-4.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ext/sync-4.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/ext/sync-4.C	(.../branches/gcc-7-branch)
@@ -1,4 +1,6 @@
 /* { dg-do run { target hppa*-*-hpux* *-*-linux* *-*-gnu* powerpc*-*-darwin* *-*-darwin[912]* } } */
+/* FIXME The following additional option should be removed after the fix for radr://19802258.
+/* { dg-xfail-run-if "PR60563 radr://19802258" { *-*-darwin* } } */
 /* { dg-require-effective-target sync_long_long_runtime } */
 /* { dg-options "-fexceptions -fnon-call-exceptions -O2" } */
 /* { dg-additional-options "-march=pentium" { target { { i?86-*-* x86_64-*-* } && ia32 } } } */
Index: gcc/testsuite/g++.dg/lookup/pr60994.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/lookup/pr60994.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/lookup/pr60994.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,13 @@
+// PR c++/60994
+// { dg-do compile }
+
+struct s
+{
+  static int i;
+};
+
+template <typename T>
+int s()
+{
+  return s::i;	// { dg-bogus "is not a class" }
+}
Index: gcc/testsuite/g++.dg/pch/pr90326.Hs
===================================================================
--- a/src/gcc/testsuite/g++.dg/pch/pr90326.Hs	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/pch/pr90326.Hs	(.../branches/gcc-7-branch)
@@ -0,0 +1 @@
+// empty
Index: gcc/testsuite/g++.dg/pch/pr90326.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/pch/pr90326.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/pch/pr90326.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,9 @@
+#include "pr90326.H"
+
+int main()
+{
+  float f = __FLT_MAX__;
+  if (f == 0.0)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/g++.dg/gomp/cancel-1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/gomp/cancel-1.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/gomp/cancel-1.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,26 @@
+// PR c++/88976
+// { dg-do compile }
+
+template <class T> void
+foo (T x)
+{
+#pragma omp parallel
+  {
+  #pragma omp cancel parallel if (x)
+  }
+#pragma omp parallel
+  {
+  #pragma omp cancel parallel if (1 == 1)
+  }
+}
+
+void
+bar (int x, double y, long long z)
+{
+  foo (0);
+  foo (1LL);
+  foo (1.25);
+  foo (x);
+  foo (y);
+  foo (z);
+}
Index: gcc/testsuite/g++.dg/gomp/pr88949.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/gomp/pr88949.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/gomp/pr88949.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,23 @@
+// PR c++/88949
+// { dg-do compile }
+
+struct A {
+  int a;
+  A (int x) : a (x) {
+#pragma omp parallel firstprivate (a)
+    --a;
+  }
+  void foo () {
+#pragma omp parallel firstprivate (a)
+    --a;
+  }
+};
+
+int c;
+
+int
+main ()
+{
+  A d(c);
+  d.foo ();
+}
Index: gcc/testsuite/g++.dg/gomp/lastprivate-1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/gomp/lastprivate-1.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/gomp/lastprivate-1.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,16 @@
+// PR c++/90950
+// { dg-do compile }
+
+template <typename T>
+T
+foo (void)
+{
+  T y = 0;
+  T &x = y;
+  #pragma omp parallel for lastprivate (x)
+  for (int i = 0; i < 8; ++i)
+    x = i;
+  return x;
+}
+
+int a = foo<int> ();
Index: gcc/testsuite/g++.dg/gomp/cancel-2.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/gomp/cancel-2.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/gomp/cancel-2.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,20 @@
+// PR c++/88976
+// { dg-do compile }
+
+template <class T> void
+foo (T x)
+{
+#pragma omp parallel
+  {
+  #pragma omp cancel parallel if (x)	// { dg-error "no match for" }
+  }
+}
+
+struct S {};
+
+void
+bar ()
+{
+  S s;
+  foo (s);
+}
Index: gcc/testsuite/g++.dg/gomp/cancel-3.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/gomp/cancel-3.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/gomp/cancel-3.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+// { dg-do compile }
+
+struct S { int s; } s;
+
+void
+foo (void)
+{
+  #pragma omp parallel
+  {
+    #pragma omp cancel parallel if (s)	// { dg-error "could not convert 's' from 'S' to 'bool'" }
+  }
+}
Index: gcc/testsuite/g++.dg/gomp/pr89796.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/gomp/pr89796.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/gomp/pr89796.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,53 @@
+// PR c++/89796
+// { dg-do compile }
+// { dg-additional-options "-Wunused-value" }
+
+int
+f1 (int &c)
+{
+  int r;
+  #pragma omp atomic capture	// { dg-bogus "value computed is not used" }
+  { r = c; c++; }
+  return r;
+}
+
+template <int N>
+int
+f2 (int &c)
+{
+  int r;
+  #pragma omp atomic capture	// { dg-bogus "value computed is not used" }
+  { r = c; c++; }
+  return r;
+}
+
+int
+f3 (int &c)
+{
+  return f2 <0> (c);
+}
+
+int
+f4 (int *p)
+{
+  int r;
+  #pragma omp atomic capture	// { dg-bogus "value computed is not used" }
+  { r = *p; (*p)++; }
+  return r;
+}
+
+template <int N>
+int
+f5 (int *p)
+{
+  int r;
+  #pragma omp atomic capture	// { dg-bogus "value computed is not used" }
+  { r = *p; (*p)++; }
+  return r;
+}
+
+int
+f6 (int *p)
+{
+  return f5 <0> (p);
+}
Index: gcc/testsuite/g++.dg/other/pr86669.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/other/pr86669.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/other/pr86669.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,10 @@
+// PR c++/86669
+// { dg-do compile }
+
+struct S { S (); };
+struct T : public S {};
+
+S::S ()
+{
+  int *p = { (int *) &p };
+}
Index: gcc/testsuite/g++.dg/other/pr88568.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/other/pr88568.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/other/pr88568.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,13 @@
+// PR c/88568
+// { dg-do compile }
+// { dg-require-dll "" }
+
+struct S {
+  __attribute__((dllimport)) static const char foo[];
+};
+
+int
+foo (int x)
+{
+  return S::foo[x];
+}
Index: gcc/testsuite/g++.dg/pr88998.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/pr88998.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/pr88998.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,31 @@
+// PR target/88998
+// { dg-do run { target { { x86_64-*-* i?86-*-* } && sse2_runtime } } }
+// { dg-options "-O2 -msse2 -mfpmath=387" }
+// { dg-require-effective-target c++11 }
+
+#include <cassert>
+#include <unordered_map>
+#include <x86intrin.h>
+
+double
+__attribute__((noinline))
+prepare (int a, int b)
+{
+  __m128i is = _mm_setr_epi32 (a, b, 0, 0);
+  __m128d ds = _mm_cvtepi32_pd (is);
+  return ds[0] + ds[1];
+}
+
+int
+main (int, char **)
+{
+  double d = prepare (1, 2);
+
+  std::unordered_map < int, int >m;
+  m.insert ({0, 0});
+  m.insert ({1, 1});
+  assert (m.load_factor () <= m.max_load_factor ());
+
+  assert (d == 3.0);
+  return 0;
+}
Index: gcc/testsuite/g++.dg/asm-qual-1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/asm-qual-1.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/asm-qual-1.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,13 @@
+// Test that qualifiers other than volatile are disallowed on asm.
+// { dg-do compile }
+// { dg-options "-std=gnu++98" }
+
+void
+f ()
+{
+  asm volatile ("");
+
+  asm const (""); // { dg-error {'const' is not an asm qualifier} }
+
+  asm __restrict (""); // { dg-error {'__restrict' is not an asm qualifier} }
+}
Index: gcc/testsuite/g++.dg/tls/thread_local11.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local11.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local11.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,36 @@
+// PR c++/60702
+// { dg-do compile { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+// { dg-additional-options "-fdump-tree-gimple" }
+// { dg-final { scan-tree-dump-times "_ZTW2s1" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTW2s2" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTW2s3" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTW2s4" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTWN1T2u1E" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTWN1T2u2E" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTWN1T2u3E" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTWN1T2u4E" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTWN1T2u5E" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTWN1T2u6E" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTWN1T2u7E" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTWN1T2u8E" 2 "gimple" } }
+
+#include "thread_local11.h"
+
+void
+foo ()
+{
+  f1 ();
+  f2 ();
+  f3 ();
+  f4 ();
+  f5 ();
+  f6 ();
+  f7<0> ();
+  f8<0> ();
+  f9<0> ();
+  f10<0> ();
+  f11<0> ();
+  f12<0> ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12a.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local12a.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local12a.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (f1 ()->i != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12b.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local12b.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local12b.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (*f2 () != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12c.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local12c.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local12c.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (f3 ()->i != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12d.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local12d.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local12d.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (*f4 () != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12e.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local12e.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local12e.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (f5 ()->i != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12f.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local12f.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local12f.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (*f6 () != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12g.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local12g.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local12g.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (f7<0> ()->i != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12h.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local12h.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local12h.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (*f8<0> () != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12i.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local12i.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local12i.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (f9<0> ()->i != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12j.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local12j.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local12j.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (*f10<0> () != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12k.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local12k.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local12k.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (f11<0> ()->i != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12l.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local12l.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local12l.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (*f12<0> () != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local11a.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local11a.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local11a.C	(.../branches/gcc-7-branch)
@@ -0,0 +1,20 @@
+// PR c++/60702
+// { dg-do compile { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-alias "" }
+// { dg-require-effective-target tls_runtime }
+// { dg-additional-options "-fdump-tree-gimple" }
+// { dg-final { scan-tree-dump-times "_ZTH2s1" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTH2s2" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTH2s3" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTH2s4" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTHN1T2u1E" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTHN1T2u2E" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTHN1T2u3E" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTHN1T2u4E" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTHN1T2u5E" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTHN1T2u6E" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTHN1T2u7E" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTHN1T2u8E" 1 "gimple" } }
+
+#include "thread_local11.C"
Index: gcc/testsuite/g++.dg/tls/thread_local11.h
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local11.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local11.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,26 @@
+// PR c++/60702
+
+extern "C" void abort ();
+struct S { S () { i = 42; }; int i; };
+thread_local S s1, s2, s3, s4;
+struct T { static thread_local S u1, u2, u3, u4, u5, u6, u7, u8; int i; } t;
+thread_local S T::u1, T::u2, T::u3, T::u4, T::u5, T::u6, T::u7, T::u8;
+
+S *f1 () { return &s1; }
+int *f2 () { return &s2.i; }
+S *f3 () { return &t.u1; }
+int *f4 () { return &t.u2.i; }
+S *f5 () { return &T::u3; }
+int *f6 () { return &T::u4.i; }
+template <int N>
+S *f7 () { return &s3; }
+template <int N>
+int *f8 () { return &s4.i; }
+template <int N>
+S *f9 () { return &t.u5; }
+template <int N>
+int *f10 () { return &t.u6.i; }
+template <int N>
+S *f11 () { return &T::u7; }
+template <int N>
+int *f12 () { return &T::u8.i; }
Index: gcc/testsuite/g++.dg/tls/pr77285-2.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/pr77285-2.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/pr77285-2.C	(.../branches/gcc-7-branch)
@@ -3,7 +3,7 @@
 // { dg-require-effective-target tls }
 // { dg-final { scan-assembler "_Z4var1B3tag" } }
 // { dg-final { scan-assembler "_Z4var2B3tag" } }
-// { dg-final { scan-assembler "_ZTH4var1B3tag" } }
+// { dg-final { scan-assembler "_ZTH4var1B3tag" { xfail *-*-darwin* } } }
 // { dg-final { scan-assembler "_ZTW4var1B3tag" } }
 
 struct __attribute__((abi_tag("tag"))) X { ~X () {} int i = 0; };
Index: gcc/testsuite/g++.dg/gcov/pr16855.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/gcov/pr16855.C	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/gcov/pr16855.C	(.../branches/gcc-7-branch)
@@ -1,6 +1,8 @@
 /* { dg-options "-fprofile-arcs -ftest-coverage" } */
 /* { dg-do run { target native } } */
 
+/* See PR91087 for information on Darwin xfails. */
+
 #include <stdlib.h>
 #include <stdio.h>
 
@@ -18,7 +20,9 @@
 {
 public:
   Test (void) { fprintf (stderr, "In Test::Test\n"); /* count(1) */ }
-  ~Test (void) { fprintf (stderr, "In Test::~Test\n"); /* count(1) */ }
+  ~Test (void) {
+   fprintf (stderr, "In Test::~Test\n"); /* count(1) { xfail *-*-darwin* } */
+  }
 } T1;
 
 void
@@ -42,7 +46,7 @@
 
 static void __attribute__ ((destructor)) dtor_default ()
 {
-  fprintf (stderr, "in destructor(())\n"); /* count(1) */
+  fprintf (stderr, "in destructor(())\n"); /* count(1) { xfail *-*-darwin* } */
 }
 
-/* { dg-final { run-gcov branches { -b pr16855.C } } } */
+/* { dg-final { run-gcov branches { -b pr16855.C } { xfail *-*-darwin* } } } */
Index: gcc/testsuite/objc.dg/no-extra-load.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/no-extra-load.m	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc.dg/no-extra-load.m	(.../branches/gcc-7-branch)
@@ -1,7 +1,7 @@
 /* { dg-do compile { target *-*-darwin* } } */
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 
-#include <Foundation/NSObject.h>
+#include "../objc-obj-c++-shared/F-NSObject.h"
 main() { [NSObject new]; }
 
 /* { dg-final { scan-assembler-not "L_objc_msgSend\\\$non_lazy_ptr" } } */
Index: gcc/testsuite/objc.dg/method-6.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/method-6.m	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc.dg/method-6.m	(.../branches/gcc-7-branch)
@@ -5,12 +5,12 @@
 /* { dg-options "-Wstrict-selector-match" } */
 
 #ifdef __NEXT_RUNTIME__
-#include <Foundation/NSObject.h>
-#define OBJECT NSObject
+# include "../objc-obj-c++-shared/F-NSObject.h"
+# define OBJECT NSObject
 #else
-#include <objc/Object.h>
-#include <objc/Protocol.h>
-#define OBJECT Object
+# include <objc/Object.h>
+# include <objc/Protocol.h>
+# define OBJECT Object
 #endif
 
 @interface Base
Index: gcc/testsuite/objc.dg/objc-gc-4.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/objc-gc-4.m	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc.dg/objc-gc-4.m	(.../branches/gcc-7-branch)
@@ -3,6 +3,7 @@
 /* Contributed by Ziemowit Laski <zlaski@apple.com>  */
 
 /* { dg-do compile } */
+/* { dg-skip-if "GC API is an error from Darwin16." { *-*-darwin1[6-8]* } { "-fnext-runtime" } { "" } } */
 /* { dg-options "-fobjc-gc" } */
 /* { dg-prune-output "cc1obj: warning: '-fobjc-gc' is ignored for '-fgnu-runtime'" } */
 
Index: gcc/testsuite/objc.dg/strings/const-cfstring-5.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/strings/const-cfstring-5.m	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc.dg/strings/const-cfstring-5.m	(.../branches/gcc-7-branch)
@@ -6,7 +6,7 @@
 /* { dg-skip-if "NeXT only" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-options "-mconstant-cfstrings" } */
 
-#include <Foundation/NSObject.h>
+#include "../../objc-obj-c++-shared/F-NSObject.h"
 
 @interface Foo: NSObject {
   char *cString;
Index: gcc/testsuite/objc.dg/strings/const-str-12b.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/strings/const-str-12b.m	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc.dg/strings/const-str-12b.m	(.../branches/gcc-7-branch)
@@ -6,11 +6,11 @@
 /* { dg-options "-mno-constant-cfstrings -fconstant-string-class=Foo" { target *-*-darwin* } } */
 
 #ifdef __NEXT_RUNTIME__
-#include <Foundation/NSObject.h>
-#define OBJECT NSObject
+# include "../../objc-obj-c++-shared/F-NSObject.h"
+# define OBJECT NSObject
 #else
-#include <objc/Object.h>
-#define OBJECT Object
+# include <objc/Object.h>
+# define OBJECT Object
 #endif
 #include "../../objc-obj-c++-shared/objc-test-suite-types.h"
 
Index: gcc/testsuite/objc.dg/strings/const-cfstring-2.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/strings/const-cfstring-2.m	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc.dg/strings/const-cfstring-2.m	(.../branches/gcc-7-branch)
@@ -8,8 +8,8 @@
 /* { dg-skip-if "NeXT only" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-options "-mconstant-cfstrings -Wnonportable-cfstrings" } */
 
-#import <Foundation/NSString.h>
-#import <CoreFoundation/CFString.h>
+#include "../../objc-obj-c++-shared/F-NSString.h"
+#include "../../objc-obj-c++-shared/CF-CFString.h"
 
 #ifndef __CONSTANT_CFSTRINGS__
 #error The -fconstant-cfstrings option is not functioning properly
Index: gcc/testsuite/objc.dg/encode-7-next-64bit.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/encode-7-next-64bit.m	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc.dg/encode-7-next-64bit.m	(.../branches/gcc-7-branch)
@@ -9,10 +9,11 @@
 #include <stdbool.h>
 #include <string.h>
 #include <stdlib.h>
-#include <Foundation/NSObject.h>
+#include <stdio.h>
+#include "../objc-obj-c++-shared/F-NSObject.h"
+#include "../objc-obj-c++-shared/CF-CFString.h"
 #include "../objc-obj-c++-shared/runtime.h"
 
-extern int printf(char *,...);
 void CHECK_IF(const char *s1, const char *s2)
 {
  if (strcmp(s1,s2) != 0) {
Index: gcc/testsuite/objc.dg/proto-lossage-7.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/proto-lossage-7.m	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc.dg/proto-lossage-7.m	(.../branches/gcc-7-branch)
@@ -3,7 +3,7 @@
 /* { dg-do compile } */
 
 #ifdef __NEXT_RUNTIME__
-#include <Foundation/NSObject.h>
+#include "../objc-obj-c++-shared/F-NSObject.h"
 #define OBJECT NSObject
 #else
 #include <objc/Object.h>
Index: gcc/testsuite/objc.dg/symtab-1.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/symtab-1.m	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc.dg/symtab-1.m	(.../branches/gcc-7-branch)
@@ -4,7 +4,7 @@
 /* { dg-do compile { target { *-*-darwin* } } } */
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 
-#include <Foundation/NSObject.h>
+#include "../objc-obj-c++-shared/F-NSObject.h"
 
 @interface Base: NSObject 
 - (void)setValues;
Index: gcc/testsuite/objc.dg/headers.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/headers.m	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc.dg/headers.m	(.../branches/gcc-7-branch)
@@ -2,6 +2,7 @@
 // test in libstdc++-v3).  Author: Loren J. Rittle <ljrittle@acm.org>.
 // { dg-options "-Wall -Wpointer-arith -Wcast-qual -Wstrict-prototypes -Wshadow" }
 // { dg-do compile }
+/* { dg-xfail-if "PR90709" { *-*-darwin1[4-9]* } { "-fnext-runtime" } { "" } } */
 
 #ifdef __NEXT_RUNTIME__
 #include <Foundation/NSString.h>
Index: gcc/testsuite/objc.dg/stubify-1.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/stubify-1.m	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc.dg/stubify-1.m	(.../branches/gcc-7-branch)
@@ -4,7 +4,7 @@
 /* { dg-do compile { target *-*-darwin* } } */
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-require-effective-target ilp32 } */
-/* { dg-options "-Os -mdynamic-no-pic -mmacosx-version-min=10.4" } */
+/* { dg-options "-Os -mdynamic-no-pic -mmacosx-version-min=10.4 -msymbol-stubs" } */
 
 typedef struct objc_object { } *id ;
 int x = 41 ;
Index: gcc/testsuite/objc.dg/objc-foreach-4.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/objc-foreach-4.m	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc.dg/objc-foreach-4.m	(.../branches/gcc-7-branch)
@@ -5,9 +5,9 @@
 /* { dg-skip-if "No NeXT fast enum. pre-Darwin9" { *-*-darwin[5-8]* } { "-fnext-runtime" } { "" } } */
 /* { dg-additional-options "-framework Foundation" { target { *-*-darwin* } } } */
 
-#include <Foundation/NSString.h>
-#include <Foundation/NSAutoreleasePool.h>
-#include <Foundation/NSArray.h>
+#include "../objc-obj-c++-shared/F-NSString.h"
+#include "../objc-obj-c++-shared/F-NSAutoreleasePool.h"
+#include "../objc-obj-c++-shared/F-NSArray.h"
 
 // gcc -o foo foo.m -framework Foundation
 
Index: gcc/testsuite/objc.dg/instancetype-0.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/instancetype-0.m	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc.dg/instancetype-0.m	(.../branches/gcc-7-branch)
@@ -0,0 +1,30 @@
+/* Contributed by Iain Sandoe <iain@sandoe.co.uk>, May 2019.  */
+/* { dg-do compile } */
+
+/* Basic check of parsing instancetype.  */
+
+extern id class_createInstance (id, int);
+extern id class_getSuperclass (id);
+
+@interface MyObject
+{
+  Class isa;
+}
++ (instancetype)alloc;
+- (instancetype)init;
++ (instancetype)initialize;
++ (instancetype)factoryMethodA;
++ (id)factoryMethodB;
++ (Class) class;
++ (Class) superclass;
+@end
+
+@implementation MyObject
++ (instancetype)alloc { return class_createInstance (self, 0); }
+- (instancetype)init  { return self; }
++ (instancetype)initialize { return self; }
++ (instancetype)factoryMethodA { return [[[self class] alloc] init]; }
++ (id)factoryMethodB { return [[[self class] alloc] init]; }
++ (Class) class { return self; }
++ (Class) superclass { return class_getSuperclass (self); }
+@end
Index: gcc/testsuite/objc.dg/objc-foreach-5.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/objc-foreach-5.m	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc.dg/objc-foreach-5.m	(.../branches/gcc-7-branch)
@@ -4,8 +4,9 @@
 /* { dg-skip-if "No NeXT fast enum. pre-Darwin9" { *-*-darwin[5-8]* } { "-fnext-runtime" } { "" } } */
 /* { dg-additional-options "-framework Foundation" { target { *-*-darwin* } } } */
 
-#include <Foundation/NSArray.h>
-#include <Foundation/NSAutoreleasePool.h>
+#include "../objc-obj-c++-shared/F-NSArray.h"
+#include "../objc-obj-c++-shared/F-NSAutoreleasePool.h"
+#include "../objc-obj-c++-shared/F-NSValue.h"
 
 NSArray * createTestVictim(unsigned capacity) {
     NSMutableArray * arr = [[NSMutableArray alloc] initWithCapacity:capacity];
Index: gcc/testsuite/objc.dg/stubify-2.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/stubify-2.m	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc.dg/stubify-2.m	(.../branches/gcc-7-branch)
@@ -4,7 +4,7 @@
 /* { dg-do compile { target powerpc*-*-darwin* } } */
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-require-effective-target ilp32 } */
-/* { dg-options "-mdynamic-no-pic -fdump-rtl-jump -mmacosx-version-min=10.4" } */
+/* { dg-options "-mdynamic-no-pic -fdump-rtl-jump -mmacosx-version-min=10.4 -msymbol-stubs" } */
 
 typedef struct objc_object { } *id ;
 int x = 41 ;
Index: gcc/testsuite/objc.dg/zero-link-1.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/zero-link-1.m	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc.dg/zero-link-1.m	(.../branches/gcc-7-branch)
@@ -5,7 +5,7 @@
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-options "-fzero-link" } */
 
-#include <Foundation/NSObject.h>
+#include "../objc-obj-c++-shared/F-NSObject.h"
 
 extern void abort(void);
 #define CHECK_IF(expr) if(!(expr)) abort();
Index: gcc/testsuite/objc.dg/zero-link-2.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/zero-link-2.m	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc.dg/zero-link-2.m	(.../branches/gcc-7-branch)
@@ -5,7 +5,7 @@
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-options "-fno-zero-link" } */
 
-#include <Foundation/NSObject.h>
+#include "../objc-obj-c++-shared/F-NSObject.h"
 
 extern void abort(void);
 #define CHECK_IF(expr) if(!(expr)) abort();
Index: gcc/testsuite/objc.dg/torture/strings/const-str-10.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/torture/strings/const-str-10.m	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc.dg/torture/strings/const-str-10.m	(.../branches/gcc-7-branch)
@@ -6,7 +6,8 @@
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-options "-mno-constant-cfstrings" { target *-*-darwin* } } */
 
-#include <Foundation/NSObject.h>
+#include "../../../objc-obj-c++-shared/F-NSObject.h"
+#include <stdlib.h>
 #include "../../../objc-obj-c++-shared/runtime.h" /* For NEXT_OBJC_USE_NEW_INTERFACE.  */
 
 @interface NSString: NSObject
Index: gcc/testsuite/objc.dg/torture/strings/const-str-11.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/torture/strings/const-str-11.m	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc.dg/torture/strings/const-str-11.m	(.../branches/gcc-7-branch)
@@ -7,7 +7,7 @@
 /* { dg-options "-fconstant-string-class=XStr" } */
 /* { dg-options "-mno-constant-cfstrings -fconstant-string-class=XStr" { target *-*-darwin* } } */
 
-#include <Foundation/NSObject.h>
+#include "../../../objc-obj-c++-shared/F-NSObject.h"
 #include "../../../objc-obj-c++-shared/runtime.h" /* For NEXT_OBJC_USE_NEW_INTERFACE.  */
 
 @interface XString: NSObject {
Index: gcc/testsuite/objc.dg/torture/strings/const-cfstring-1.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/torture/strings/const-cfstring-1.m	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc.dg/torture/strings/const-cfstring-1.m	(.../branches/gcc-7-branch)
@@ -13,8 +13,8 @@
    Well, we don't implement writable ones at this juncture.  */
 /* { dg-options "-mconstant-cfstrings -framework Cocoa -Wl,-w" { target *-*-darwin[123]* } } */
 
-#import <Foundation/NSString.h>
-#import <CoreFoundation/CFString.h>
+#include "../../../objc-obj-c++-shared/F-NSString.h"
+#include "../../../objc-obj-c++-shared/CF-CFString.h"
 #include <stdlib.h>
 
 void printOut(NSString *str) {
Index: gcc/testsuite/objc.dg/torture/strings/const-str-9.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/torture/strings/const-str-9.m	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc.dg/torture/strings/const-str-9.m	(.../branches/gcc-7-branch)
@@ -5,7 +5,7 @@
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-options "-mno-constant-cfstrings" { target *-*-darwin* } } */
 
-#include <Foundation/NSObject.h>
+#include "../../../objc-obj-c++-shared/F-NSObject.h"
 #include "../../../objc-obj-c++-shared/runtime.h" /* For NEXT_OBJC_USE_NEW_INTERFACE.  */
 
 @interface NSConstantString: NSObject {
Index: gcc/testsuite/objc.dg/zero-link-3.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/zero-link-3.m	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc.dg/zero-link-3.m	(.../branches/gcc-7-branch)
@@ -7,12 +7,12 @@
 /* { dg-xfail-run-if "Needs OBJC2 ABI" { *-*-darwin* && { lp64 && { ! objc2 } } } { "-fnext-runtime" } { "" } } */
 
 #ifdef __NEXT_RUNTIME__
-#include <Foundation/NSObject.h>
-#define OBJECT NSObject
+# include "../objc-obj-c++-shared/F-NSObject.h"
+# define OBJECT NSObject
 #else
-#include <objc/Object.h>
-#include <objc/Protocol.h>
-#define OBJECT Object
+# include <objc/Object.h>
+# include <objc/Protocol.h>
+# define OBJECT Object
 #endif
 
 extern void abort(void);
Index: gcc/testsuite/objc.dg/image-info.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/image-info.m	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc.dg/image-info.m	(.../branches/gcc-7-branch)
@@ -7,7 +7,7 @@
 /* { dg-skip-if "NeXT-only" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-options "-freplace-objc-classes" } */
 
-#include <Foundation/NSObject.h>
+#include "../objc-obj-c++-shared/F-NSObject.h"
 
 extern void abort(void);
 #define CHECK_IF(expr) if(!(expr)) abort();
Index: gcc/testsuite/objc.dg/isa-field-1.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/isa-field-1.m	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/objc.dg/isa-field-1.m	(.../branches/gcc-7-branch)
@@ -1,5 +1,7 @@
 /* Ensure there are no bizarre difficulties with accessing the 'isa' field of objects.  */
 /* { dg-do compile } */
+/* The use of isa is deprecated, but we still want to test that it works. */
+/* { dg-additional-options "-Wno-deprecated-declarations" } */
 
 #include "../objc-obj-c++-shared/TestsuiteObject.h"
 #include "../objc-obj-c++-shared/runtime.h"
Index: gcc/testsuite/obj-c++.dg/stubify-1.mm
===================================================================
--- a/src/gcc/testsuite/obj-c++.dg/stubify-1.mm	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/obj-c++.dg/stubify-1.mm	(.../branches/gcc-7-branch)
@@ -4,13 +4,13 @@
 /* { dg-do compile { target *-*-darwin* } } */
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-require-effective-target ilp32 } */
-/* { dg-options "-Os -mdynamic-no-pic -fno-exceptions -mmacosx-version-min=10.4" } */
+/* { dg-options "-Os -mdynamic-no-pic -fno-exceptions -mmacosx-version-min=10.4 -msymbol-stubs" } */
 
 typedef struct objc_object { } *id ;
 int x = 41 ;
 
 extern "C" {
-  extern id objc_msgSend(id self, char * op, ...);
+  extern id objc_msgSend(id self, objc_selector* op, ...);
   extern int bogonic (int, int, int);
 }
 
@@ -20,9 +20,9 @@
 - (Document *) close;
 @end
 @implementation Document
-- (Document *) class { }
-- (Document *) close { }
-- (Document *) window { }
+- (Document *) class { return (Document *)0; }
+- (Document *) close { return (Document *)0; }
+- (Document *) window { return (Document *)0; }
 - (void)willEndCloseSheet:(void *)sheet returnCode:(int)returnCode contextInfo:(void *)contextInfo {
   [[self window] close];
   ((void (*)(id, char *, int))objc_msgSend)([self class], (char *)contextInfo, 1);
Index: gcc/testsuite/obj-c++.dg/isa-field-1.mm
===================================================================
--- a/src/gcc/testsuite/obj-c++.dg/isa-field-1.mm	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/obj-c++.dg/isa-field-1.mm	(.../branches/gcc-7-branch)
@@ -1,5 +1,7 @@
 /* Ensure there are no bizarre difficulties with accessing the 'isa' field of objects.  */
 /* { dg-do compile } */
+/* The use of isa is deprecated, but we still want to test that is works. */
+/* { dg-additional-options "-Wno-deprecated-declarations" } */
 
 #include "../objc-obj-c++-shared/TestsuiteObject.h"
 #include "../objc-obj-c++-shared/runtime.h"
Index: gcc/testsuite/obj-c++.dg/try-catch-1.mm
===================================================================
--- a/src/gcc/testsuite/obj-c++.dg/try-catch-1.mm	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/obj-c++.dg/try-catch-1.mm	(.../branches/gcc-7-branch)
@@ -39,4 +39,5 @@
   @finally {
     printf("In @finally block (%d)... ", exc_control);
   }
+  return -1;
 }
Index: gcc/testsuite/obj-c++.dg/cxx-ivars-3.mm
===================================================================
--- a/src/gcc/testsuite/obj-c++.dg/cxx-ivars-3.mm	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/obj-c++.dg/cxx-ivars-3.mm	(.../branches/gcc-7-branch)
@@ -2,13 +2,14 @@
 
 // { dg-do run { target *-*-darwin* } }
 // { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } }
+// { dg-skip-if "Headers incompatible with 10.4 APIs" { *-*-darwin1[3-8]* } { "-fnext-runtime" } { "" } }
 // { dg-additional-options "-fobjc-call-cxx-cdtors -mmacosx-version-min=10.4 -framework Foundation" }
 // This test has no equivalent or meaning for m64/ABI V2
-// { dg-xfail-run-if "No Test Avail" { *-*-darwin* && lp64 } { "-fnext-runtime" } { "" } }
+// { dg-xfail-run-if "No Test Avail" {  *-*-darwin* && lp64 } { "-fnext-runtime" } { "" } }
 
 #include <objc/objc-runtime.h>
 #include <stdlib.h>
-#include <Foundation/NSObject.h>
+#include "../objc-obj-c++-shared/F-NSObject.h"
 
 //extern "C" { int printf(const char *,...); }
 #define CHECK_IF(expr) if(!(expr)) abort()
Index: gcc/testsuite/obj-c++.dg/torture/strings/const-str-10.mm
===================================================================
--- a/src/gcc/testsuite/obj-c++.dg/torture/strings/const-str-10.mm	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/obj-c++.dg/torture/strings/const-str-10.mm	(.../branches/gcc-7-branch)
@@ -6,7 +6,7 @@
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-options "-mno-constant-cfstrings" { target *-*-darwin* } } */
 
-#include <Foundation/NSObject.h>
+#include "../../../objc-obj-c++-shared/F-NSObject.h"
 #include "../../../objc-obj-c++-shared/runtime.h" /* For NEXT_OBJC_USE_NEW_INTERFACE.  */
 
 @interface NSString: NSObject
Index: gcc/testsuite/obj-c++.dg/torture/strings/const-str-11.mm
===================================================================
--- a/src/gcc/testsuite/obj-c++.dg/torture/strings/const-str-11.mm	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/obj-c++.dg/torture/strings/const-str-11.mm	(.../branches/gcc-7-branch)
@@ -7,7 +7,7 @@
 /* { dg-options "-fconstant-string-class=XStr" } */
 /* { dg-options "-mno-constant-cfstrings -fconstant-string-class=XStr" { target *-*-darwin* } } */
 
-#include <Foundation/NSObject.h>
+#include "../../../objc-obj-c++-shared/F-NSObject.h"
 #include "../../../objc-obj-c++-shared/runtime.h" /* For NEXT_OBJC_USE_NEW_INTERFACE.  */
 
 @interface XString: NSObject {
Index: gcc/testsuite/obj-c++.dg/torture/strings/const-cfstring-1.mm
===================================================================
--- a/src/gcc/testsuite/obj-c++.dg/torture/strings/const-cfstring-1.mm	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/obj-c++.dg/torture/strings/const-cfstring-1.mm	(.../branches/gcc-7-branch)
@@ -13,8 +13,8 @@
    well, we don't implement writable ones at this juncture.  */
 /* { dg-options "-mconstant-cfstrings -framework Cocoa -Wl,-w" { target *-*-darwin[123]* } } */
 
-#import <Foundation/NSString.h>
-#import <CoreFoundation/CFString.h>
+#include "../../../objc-obj-c++-shared/F-NSString.h"
+#include "../../../objc-obj-c++-shared/CF-CFString.h"
 #include <stdlib.h>
 
 void printOut(NSString *str) {
@@ -47,10 +47,10 @@
   checkNSRange([@"Hello World" rangeOfString:(id)CFSTR("World")]);
   checkNSRange([(id)CFSTR("Hello World") rangeOfString:(id)CFSTR("World")]);
 
-  checkCFRange(CFStringFind((CFStringRef)@"Hello World", (CFStringRef)@"World", 0));
-  checkCFRange(CFStringFind(CFSTR("Hello World"), (CFStringRef)@"World", 0));
-  checkCFRange(CFStringFind((CFStringRef)@"Hello World", CFSTR("World"), 0));
-  checkCFRange(CFStringFind(CFSTR("Hello World"), CFSTR("World"), 0));
+  checkCFRange(CFStringFind((CFStringRef)@"Hello World", (CFStringRef)@"World", (CFStringCompareFlags)0));
+  checkCFRange(CFStringFind(CFSTR("Hello World"), (CFStringRef)@"World", (CFStringCompareFlags)0));
+  checkCFRange(CFStringFind((CFStringRef)@"Hello World", CFSTR("World"), (CFStringCompareFlags)0));
+  checkCFRange(CFStringFind(CFSTR("Hello World"), CFSTR("World"), (CFStringCompareFlags)0));
 
   /* Check for string uniquing.  */
   if (s0a != s0b || s0a != s2 || s1 != (id)s2) {
Index: gcc/testsuite/obj-c++.dg/torture/strings/const-str-9.mm
===================================================================
--- a/src/gcc/testsuite/obj-c++.dg/torture/strings/const-str-9.mm	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/obj-c++.dg/torture/strings/const-str-9.mm	(.../branches/gcc-7-branch)
@@ -5,7 +5,7 @@
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-options "-mno-constant-cfstrings" { target *-*-darwin* } } */
 
-#include <Foundation/NSObject.h>
+#include "../../../objc-obj-c++-shared/F-NSObject.h"
 #include "../../../objc-obj-c++-shared/runtime.h" /* For NEXT_OBJC_USE_NEW_INTERFACE.  */
 
 @interface NSConstantString: NSObject {
Index: gcc/testsuite/obj-c++.dg/strings/const-str-12.mm
===================================================================
--- a/src/gcc/testsuite/obj-c++.dg/strings/const-str-12.mm	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/obj-c++.dg/strings/const-str-12.mm	(.../branches/gcc-7-branch)
@@ -6,7 +6,7 @@
 /* { dg-options "-mno-constant-cfstrings -fconstant-string-class=Foo" { target *-*-darwin* } } */
 
 #ifdef __NEXT_RUNTIME__
-#include <Foundation/NSObject.h>
+#include "../../objc-obj-c++-shared/F-NSObject.h"
 #define OBJECT NSObject
 #else
 #include <objc/Object.h>
Index: gcc/testsuite/obj-c++.dg/strings/const-cfstring-2.mm
===================================================================
--- a/src/gcc/testsuite/obj-c++.dg/strings/const-cfstring-2.mm	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/obj-c++.dg/strings/const-cfstring-2.mm	(.../branches/gcc-7-branch)
@@ -8,8 +8,8 @@
 /* { dg-skip-if "NeXT only" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-options "-ftrack-macro-expansion=0 -mconstant-cfstrings -Wnonportable-cfstrings" } */
 
-#import <Foundation/NSString.h>
-#import <CoreFoundation/CFString.h>
+#include "../../objc-obj-c++-shared/F-NSString.h"
+#include "../../objc-obj-c++-shared/CF-CFString.h"
 
 #ifndef __CONSTANT_CFSTRINGS__
 #error The -fconstant-cfstrings option is not functioning properly
Index: gcc/testsuite/obj-c++.dg/strings/const-cfstring-5.mm
===================================================================
--- a/src/gcc/testsuite/obj-c++.dg/strings/const-cfstring-5.mm	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/obj-c++.dg/strings/const-cfstring-5.mm	(.../branches/gcc-7-branch)
@@ -6,7 +6,7 @@
 /* { dg-skip-if "NeXT only" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-options "-mconstant-cfstrings" } */
 
-#include <Foundation/NSObject.h>
+#include "../../objc-obj-c++-shared/F-NSObject.h"
 
 @interface Foo: NSObject {
   char *cString;
Index: gcc/testsuite/obj-c++.dg/stubify-2.mm
===================================================================
--- a/src/gcc/testsuite/obj-c++.dg/stubify-2.mm	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/obj-c++.dg/stubify-2.mm	(.../branches/gcc-7-branch)
@@ -4,7 +4,7 @@
 /* { dg-do compile { target *-*-darwin* } } */
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-require-effective-target ilp32 } */
-/* { dg-options "-mdynamic-no-pic -fdump-rtl-jump -mmacosx-version-min=10.4" } */
+/* { dg-options "-mdynamic-no-pic -fdump-rtl-jump -mmacosx-version-min=10.4 -msymbol-stubs" } */
 
 typedef struct objc_object { } *id ;
 int x = 41 ;
@@ -16,9 +16,9 @@
 - (Document *) close;
 @end
 @implementation Document
-- (Document *) class { }
-- (Document *) close { }
-- (Document *) window { }
+- (Document *) class { return (Document *)0; }
+- (Document *) close { return (Document *)0; }
+- (Document *) window { return (Document *)0; }
 - (void)willEndCloseSheet:(void *)sheet returnCode:(int)returnCode contextInfo:(void *)contextInfo {
   [[self window] close];
   ((void (*)(id, char *, int))objc_msgSend)([self class], (char *)contextInfo, 1);
Index: gcc/testsuite/obj-c++.dg/objc-gc-3.mm
===================================================================
--- a/src/gcc/testsuite/obj-c++.dg/objc-gc-3.mm	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/obj-c++.dg/objc-gc-3.mm	(.../branches/gcc-7-branch)
@@ -3,6 +3,7 @@
 /* Contributed by Ziemowit Laski <zlaski@apple.com>  */
 
 /* { dg-do compile } */
+/* { dg-skip-if "GC API is an error from Darwin16." { *-*-darwin1[6-8]* } { "-fnext-runtime" } { "" } } */
 /* { dg-options "-fobjc-gc" } */
 /* { dg-prune-output "cc1objplus: warning: '-fobjc-gc' is ignored for '-fgnu-runtime'" } */
 
Index: gcc/testsuite/obj-c++.dg/qual-types-1.mm
===================================================================
--- a/src/gcc/testsuite/obj-c++.dg/qual-types-1.mm	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/obj-c++.dg/qual-types-1.mm	(.../branches/gcc-7-branch)
@@ -4,6 +4,8 @@
 
 /* { dg-do run } */
 /* { dg-xfail-run-if "Needs OBJC2 ABI" { *-*-darwin* && { lp64 && { ! objc2 } } } { "-fnext-runtime" } { "" } } */
+/* { dg-prune-output ".*ld: warning: direct access in.*" } */
+
 #include "../objc-obj-c++-shared/TestsuiteObject.m"
 #include <stdlib.h>
 
Index: gcc/testsuite/obj-c++.dg/proto-lossage-7.mm
===================================================================
--- a/src/gcc/testsuite/obj-c++.dg/proto-lossage-7.mm	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/obj-c++.dg/proto-lossage-7.mm	(.../branches/gcc-7-branch)
@@ -1,9 +1,11 @@
 /* Check that typedefs of ObjC classes preserve 
    any @protocol qualifiers.  */
 /* { dg-do compile } */
+/* Suppress warnings that the GNUStep headers introduce.  */
+/* { dg-additional-options "-std=gnu++11 -Wno-expansion-to-defined -Wno-variadic-macros" { target *-*-darwin* } } */
 
 #ifdef __NEXT_RUNTIME__
-#include <Foundation/NSObject.h>
+#include "../objc-obj-c++-shared/F-NSObject.h"
 #define OBJECT NSObject
 #else
 #include <objc/Object.h>
Index: gcc/testsuite/obj-c++.dg/syntax-error-1.mm
===================================================================
--- a/src/gcc/testsuite/obj-c++.dg/syntax-error-1.mm	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/obj-c++.dg/syntax-error-1.mm	(.../branches/gcc-7-branch)
@@ -1,8 +1,10 @@
 /* Graceful handling of a syntax error.  */
 /* { dg-do compile } */
+/* Suppress warnings that the GNUStep headers introduce.  */
+/* { dg-additional-options "-std=gnu++11 -Wno-expansion-to-defined -Wno-variadic-macros" { target *-*-darwin* } } */
 
 #ifdef __NEXT_RUNTIME__
-#include <Foundation/NSObject.h>
+#include "../objc-obj-c++-shared/F-NSObject.h"
 #define OBJECT NSObject
 #else
 #include <objc/Object.h>
@@ -29,4 +31,4 @@
 } /* { dg-error "stray .\}. between Objective\\-C\\+\\+ methods" } */
 @end
 
-/* { dg-error "expected constructor, destructor, or type conversion before" "" { target *-*-* } 28 } */
+/* { dg-error "expected constructor, destructor, or type conversion before" "" { target *-*-* } 30 } */
Index: gcc/testsuite/obj-c++.dg/try-catch-3.mm
===================================================================
--- a/src/gcc/testsuite/obj-c++.dg/try-catch-3.mm	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/obj-c++.dg/try-catch-3.mm	(.../branches/gcc-7-branch)
@@ -15,4 +15,5 @@
   @catch (TestsuiteObject* theException) {
     return [theException name];
   }
+  return (const char *)0;
 }
Index: gcc/testsuite/c-c++-common/pr89933.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/pr89933.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/c-c++-common/pr89933.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,5 @@
+/* PR c/89933 */
+/* { dg-do compile } */
+
+typedef unsigned int a __attribute__ ((__aligned__(8), __may_alias__));
+typedef unsigned int a __attribute__ ((__aligned__(8), __may_alias__));
Index: gcc/testsuite/c-c++-common/pr90108.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/pr90108.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/c-c++-common/pr90108.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,6 @@
+/* PR c++/90108 */
+/* { dg-do compile } */
+/* { dg-options "--param ggc-min-heapsize=0" } */
+
+typedef unsigned int a __attribute__ ((__aligned__(8), __may_alias__));
+typedef unsigned int a __attribute__ ((__aligned__(8), __may_alias__));
Index: gcc/testsuite/c-c++-common/torture/asm-inline.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/torture/asm-inline.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/c-c++-common/torture/asm-inline.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,53 @@
+/* { dg-do compile } */
+/* -O0 does no inlining, and -O3 does it too aggressively for this test:  */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O3" } { "" } }
+/* The normal asm is not inlined:  */
+/* { dg-final { scan-assembler-times "w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w" 2 } } */
+/* But the asm inline is inlined:  */
+/* { dg-final { scan-assembler-times "x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x" 8 } } */
+
+static void f(void)
+{
+  asm ("w\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\n"
+       "w\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw");
+}
+
+int f0(void) { f(); return 0; }
+int f1(void) { f(); return 1; }
+int f2(void) { f(); return 2; }
+int f3(void) { f(); return 3; }
+
+static void fg(void)
+{
+  asm goto("w\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\n"
+	   "w\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw" :::: q);
+  q: ;
+}
+
+int fg0(void) { fg(); return 0; }
+int fg1(void) { fg(); return 1; }
+int fg2(void) { fg(); return 2; }
+int fg3(void) { fg(); return 3; }
+
+static void g(void)
+{
+  asm inline("x\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\n"
+	     "x\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx");
+}
+
+int g0(void) { g(); return 0; }
+int g1(void) { g(); return 1; }
+int g2(void) { g(); return 2; }
+int g3(void) { g(); return 3; }
+
+static void gg(void)
+{
+  asm inline goto("x\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\n"
+		  "x\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx" :::: q);
+  q: ;
+}
+
+int gg0(void) { gg(); return 0; }
+int gg1(void) { gg(); return 1; }
+int gg2(void) { gg(); return 2; }
+int gg3(void) { gg(); return 3; }
Index: gcc/testsuite/c-c++-common/gomp/pr88588.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/gomp/pr88588.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/c-c++-common/gomp/pr88588.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,18 @@
+/* PR middle-end/88588 */
+/* { dg-do compile } */
+/* { dg-options "-fopenmp -O1" } */
+
+int *v;
+
+#pragma omp declare simd
+void
+foo (int x)
+{
+  int *a = &x;
+
+  for (;;)
+    {
+      *v = *a;
+      a = v;
+    }
+}
Index: gcc/testsuite/c-c++-common/gomp/pr90954.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/gomp/pr90954.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/c-c++-common/gomp/pr90954.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,27 @@
+/* PR sanitizer/90954 */
+/* { dg-do compile } */
+/* { dg-options "-fopenmp -fsanitize=undefined" } */
+
+float v;
+int i;
+
+void
+foo (float x, float y)
+{
+  #pragma omp atomic
+  v += x / y;
+}
+
+void
+bar (int x, int y)
+{
+  #pragma omp atomic
+  i += x / y;
+}
+
+void
+baz (int x, int y)
+{
+  #pragma omp atomic
+  i *= (x << y);
+}
Index: gcc/testsuite/c-c++-common/gomp/sink-3.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/gomp/sink-3.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/c-c++-common/gomp/sink-3.c	(.../branches/gcc-7-branch)
@@ -14,7 +14,7 @@
   for (i=0; i < 100; ++i)
     {
 #pragma omp ordered depend(sink:poo-1,paa+1) /* { dg-error "poo.*declared.*paa.*declared" } */
-    bar(&i);
+    bar(&i);				     /* { dg-error "may not be closely nested" "" { target *-*-* } .-1 } */
 #pragma omp ordered depend(source)
     }
 }
Index: gcc/testsuite/c-c++-common/gomp/schedule-modifiers-1.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/gomp/schedule-modifiers-1.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/c-c++-common/gomp/schedule-modifiers-1.c	(.../branches/gcc-7-branch)
@@ -80,21 +80,21 @@
   #pragma omp for schedule (nonmonotonic : auto)	/* { dg-error ".nonmonotonic. modifier specified for .auto. schedule kind" } */
   for (i = 0; i < 64; i++)
     ;
-  #pragma omp for schedule (nonmonotonic, dynamic) ordered	/* { dg-error ".nonmonotonic. schedule modifier specified together with .ordered. clause" } */
+  #pragma omp for schedule (nonmonotonic : dynamic) ordered	/* { dg-error ".nonmonotonic. schedule modifier specified together with .ordered. clause" } */
   for (i = 0; i < 64; i++)
     #pragma omp ordered
       ;
-  #pragma omp for ordered schedule(nonmonotonic, dynamic, 5)	/* { dg-error ".nonmonotonic. schedule modifier specified together with .ordered. clause" } */
+  #pragma omp for ordered schedule(nonmonotonic : dynamic, 5)	/* { dg-error ".nonmonotonic. schedule modifier specified together with .ordered. clause" } */
   for (i = 0; i < 64; i++)
     #pragma omp ordered
       ;
-  #pragma omp for schedule (nonmonotonic, guided) ordered(1)	/* { dg-error ".nonmonotonic. schedule modifier specified together with .ordered. clause" } */
+  #pragma omp for schedule (nonmonotonic : guided) ordered(1)	/* { dg-error ".nonmonotonic. schedule modifier specified together with .ordered. clause" } */
   for (i = 0; i < 64; i++)
     {
       #pragma omp ordered depend(sink: i - 1)
       #pragma omp ordered depend(source)
     }
-  #pragma omp for ordered(1) schedule(nonmonotonic, guided, 2)	/* { dg-error ".nonmonotonic. schedule modifier specified together with .ordered. clause" } */
+  #pragma omp for ordered(1) schedule(nonmonotonic : guided, 2)	/* { dg-error ".nonmonotonic. schedule modifier specified together with .ordered. clause" } */
   for (i = 0; i < 64; i++)
     {
       #pragma omp ordered depend(source)
Index: gcc/testsuite/c-c++-common/gomp/doacross-2.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/gomp/doacross-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/c-c++-common/gomp/doacross-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,49 @@
+/* PR middle-end/87649 */
+
+void
+foo (void)
+{
+  int i;
+  #pragma omp for ordered(1)
+  for (i = 0; i < 64; i++)
+    {
+      #pragma omp ordered			/* { dg-error "'ordered' region without 'depend' clause may not be closely nested inside a loop region with an 'ordered' clause with a parameter" } */
+      ;
+    }
+  #pragma omp for ordered(1)
+  for (i = 0; i < 64; i++)
+    {
+      #pragma omp ordered threads		/* { dg-error "'ordered' region without 'depend' clause may not be closely nested inside a loop region with an 'ordered' clause with a parameter" } */
+      ;
+    }
+}
+
+void
+bar (void)
+{
+  int i;
+  #pragma omp for ordered
+  for (i = 0; i < 64; i++)
+    {
+      #pragma omp ordered depend(source)	/* { dg-error "'ordered' construct with 'depend' clause must be closely nested inside a loop with 'ordered' clause with a parameter" } */
+      #pragma omp ordered depend(sink: i - 1)	/* { dg-error "'ordered' construct with 'depend' clause must be closely nested inside a loop with 'ordered' clause with a parameter" } */
+    }
+  #pragma omp for
+  for (i = 0; i < 64; i++)
+    {
+      #pragma omp ordered depend(source)	/* { dg-error "'ordered' construct with 'depend' clause must be closely nested inside a loop with 'ordered' clause with a parameter" } */
+      #pragma omp ordered depend(sink: i - 1)	/* { dg-error "'ordered' construct with 'depend' clause must be closely nested inside a loop with 'ordered' clause with a parameter" } */
+    }
+  #pragma omp for
+  for (i = 0; i < 64; i++)
+    {
+      #pragma omp ordered			/* { dg-error "'ordered' region must be closely nested inside a loop region with an 'ordered' clause" } */
+      ;
+    }
+  #pragma omp for
+  for (i = 0; i < 64; i++)
+    {
+      #pragma omp ordered threads		/* { dg-error "'ordered' region must be closely nested inside a loop region with an 'ordered' clause" } */
+      ;
+    }
+}
Index: gcc/testsuite/c-c++-common/gomp/cancel-2.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/gomp/cancel-2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/testsuite/c-c++-common/gomp/cancel-2.c	(.../branches/gcc-7-branch)
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+
+void
+foo (void)
+{
+  #pragma omp parallel
+  {
+    #pragma omp cancel parallel if (1) if (1)			/* { dg-error "too many 'if' clauses without modifier" } */
+  }
+}
Index: gcc/objcp/ChangeLog
===================================================================
--- a/src/gcc/objcp/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/objcp/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,12 @@
+2019-08-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR pch/90326
+	* config-lang.in (gtfiles): Remove c-family/c-lex.c, add
+	c-family/c-cppbuiltin.c.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: gcc/objcp/config-lang.in
===================================================================
--- a/src/gcc/objcp/config-lang.in	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/objcp/config-lang.in	(.../branches/gcc-7-branch)
@@ -45,6 +45,6 @@
 
 # This list is separated in two parts: the first one is identical to
 # the C++ one, the second one contains our ObjC++ additions.
-gtfiles="\$(srcdir)/cp/rtti.c \$(srcdir)/cp/mangle.c \$(srcdir)/cp/name-lookup.h \$(srcdir)/cp/name-lookup.c \$(srcdir)/cp/cp-tree.h \$(srcdir)/cp/decl.h \$(srcdir)/cp/call.c \$(srcdir)/cp/decl.c \$(srcdir)/cp/decl2.c \$(srcdir)/cp/pt.c \$(srcdir)/cp/repo.c \$(srcdir)/cp/semantics.c \$(srcdir)/cp/tree.c \$(srcdir)/cp/parser.h \$(srcdir)/cp/parser.c \$(srcdir)/cp/method.c \$(srcdir)/cp/typeck2.c \$(srcdir)/c-family/c-common.c \$(srcdir)/c-family/c-common.h \$(srcdir)/c-family/c-objc.h \$(srcdir)/c-family/c-lex.c \$(srcdir)/c-family/c-pragma.h \$(srcdir)/c-family/c-pragma.c \$(srcdir)/cp/class.c \$(srcdir)/cp/cp-objcp-common.c \$(srcdir)/cp/except.c \$(srcdir)/cp/vtable-class-hierarchy.c \$(srcdir)/cp/constexpr.c \$(srcdir)/cp/cp-gimplify.c \
+gtfiles="\$(srcdir)/cp/rtti.c \$(srcdir)/cp/mangle.c \$(srcdir)/cp/name-lookup.h \$(srcdir)/cp/name-lookup.c \$(srcdir)/cp/cp-tree.h \$(srcdir)/cp/decl.h \$(srcdir)/cp/call.c \$(srcdir)/cp/decl.c \$(srcdir)/cp/decl2.c \$(srcdir)/cp/pt.c \$(srcdir)/cp/repo.c \$(srcdir)/cp/semantics.c \$(srcdir)/cp/tree.c \$(srcdir)/cp/parser.h \$(srcdir)/cp/parser.c \$(srcdir)/cp/method.c \$(srcdir)/cp/typeck2.c \$(srcdir)/c-family/c-common.c \$(srcdir)/c-family/c-common.h \$(srcdir)/c-family/c-objc.h \$(srcdir)/c-family/c-pragma.h \$(srcdir)/c-family/c-pragma.c \$(srcdir)/cp/class.c \$(srcdir)/cp/cp-objcp-common.c \$(srcdir)/cp/except.c \$(srcdir)/cp/vtable-class-hierarchy.c \$(srcdir)/cp/constexpr.c \$(srcdir)/cp/cp-gimplify.c \
 \$(srcdir)/objc/objc-map.h \$(srcdir)/objc/objc-act.h \$(srcdir)/objc/objc-act.c \$(srcdir)/objc/objc-runtime-shared-support.c \$(srcdir)/objc/objc-gnu-runtime-abi-01.c \$(srcdir)/objc/objc-next-runtime-abi-01.c \$(srcdir)/objc/objc-next-runtime-abi-02.c \$(srcdir)/c-family/c-cppbuiltin.c"
 
Index: gcc/cp/typeck.c
===================================================================
--- a/src/gcc/cp/typeck.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cp/typeck.c	(.../branches/gcc-7-branch)
@@ -37,6 +37,7 @@
 #include "c-family/c-ubsan.h"
 #include "params.h"
 #include "gcc-rich-location.h"
+#include "gimplify.h"
 
 static tree cp_build_addr_expr_strict (tree, tsubst_flags_t);
 static tree cp_build_function_call (tree, tree, tsubst_flags_t);
@@ -2362,7 +2363,13 @@
   {
     tree temp = unary_complex_lvalue (ADDR_EXPR, object);
     if (temp)
-      object = cp_build_indirect_ref (temp, RO_NULL, complain);
+      {
+	temp = cp_build_indirect_ref (temp, RO_NULL, complain);
+	if (xvalue_p (object) && !xvalue_p (temp))
+	  /* Preserve xvalue kind.  */
+	  temp = move (temp);
+	object = temp;
+      }
   }
 
   /* In [expr.ref], there is an explicit list of the valid choices for
@@ -2372,6 +2379,12 @@
       /* A static data member.  */
       result = member;
       mark_exp_read (object);
+
+      if (tree wrap = maybe_get_tls_wrapper_call (result))
+	/* Replace an evaluated use of the thread_local variable with
+	   a call to its wrapper.  */
+	result = wrap;
+
       /* If OBJECT has side-effects, they are supposed to occur.  */
       if (TREE_SIDE_EFFECTS (object))
 	result = build2 (COMPOUND_EXPR, TREE_TYPE (result), object, result);
@@ -7664,8 +7677,6 @@
 	/* Produce (a ? (b = rhs) : (c = rhs))
 	   except that the RHS goes through a save-expr
 	   so the code to compute it is only emitted once.  */
-	tree cond;
-
 	if (VOID_TYPE_P (TREE_TYPE (rhs)))
 	  {
 	    if (complain & tf_error)
@@ -7680,13 +7691,20 @@
 	if (!lvalue_or_else (lhs, lv_assign, complain))
 	  return error_mark_node;
 
-	cond = build_conditional_expr
-	  (input_location, TREE_OPERAND (lhs, 0),
-	   cp_build_modify_expr (loc, TREE_OPERAND (lhs, 1),
-				 modifycode, rhs, complain),
-	   cp_build_modify_expr (loc, TREE_OPERAND (lhs, 2),
-				 modifycode, rhs, complain),
-           complain);
+	tree op1 = cp_build_modify_expr (loc, TREE_OPERAND (lhs, 1),
+					 modifycode, rhs, complain);
+	/* When sanitizing undefined behavior, even when rhs doesn't need
+	   stabilization at this point, the sanitization might add extra
+	   SAVE_EXPRs in there and so make sure there is no tree sharing
+	   in the rhs, otherwise those SAVE_EXPRs will have initialization
+	   only in one of the two branches.  */
+	if (flag_sanitize & (SANITIZE_UNDEFINED | SANITIZE_NONDEFAULT))
+	  rhs = unshare_expr (rhs);
+	tree op2 = cp_build_modify_expr (loc, TREE_OPERAND (lhs, 2),
+					 modifycode, rhs, complain);
+	tree cond = build_conditional_expr (input_location,
+					    TREE_OPERAND (lhs, 0), op1, op2,
+					    complain);
 
 	if (cond == error_mark_node)
 	  return cond;
Index: gcc/cp/optimize.c
===================================================================
--- a/src/gcc/cp/optimize.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cp/optimize.c	(.../branches/gcc-7-branch)
@@ -61,7 +61,26 @@
   DECL_GIMPLE_REG_P (cloned_parm) = DECL_GIMPLE_REG_P (parm);
 }
 
+/* Like copy_decl_no_change, but handle DECL_OMP_PRIVATIZED_MEMBER
+   properly.  */
 
+static tree
+cxx_copy_decl (tree decl, copy_body_data *id)
+{
+  tree copy = copy_decl_no_change (decl, id);
+  if (VAR_P (decl)
+      && DECL_HAS_VALUE_EXPR_P (decl)
+      && DECL_ARTIFICIAL (decl)
+      && DECL_LANG_SPECIFIC (decl)
+      && DECL_OMP_PRIVATIZED_MEMBER (decl))
+    {
+      tree expr = DECL_VALUE_EXPR (copy);
+      walk_tree (&expr, copy_tree_body_r, id, NULL);
+      SET_DECL_VALUE_EXPR (copy, expr);
+    }
+  return copy;
+}
+
 /* FN is a function in High GIMPLE form that has a complete body and no
    CFG.  CLONE is a function whose body is to be set to a copy of FN,
    mapping argument declarations according to the ARG_MAP splay_tree.  */
@@ -80,7 +99,7 @@
   id.src_cfun = DECL_STRUCT_FUNCTION (fn);
   id.decl_map = static_cast<hash_map<tree, tree> *> (arg_map);
 
-  id.copy_decl = copy_decl_no_change;
+  id.copy_decl = cxx_copy_decl;
   id.transform_call_graph_edges = CB_CGE_DUPLICATE;
   id.transform_new_cfg = true;
   id.transform_return_to_modify = false;
@@ -384,6 +403,8 @@
 		  gcc_assert (clone_parm);
 		  DECL_ABSTRACT_ORIGIN (clone_parm) = NULL;
 		  args[parmno] = clone_parm;
+		  /* Clear TREE_ADDRESSABLE on thunk arguments.  */
+		  TREE_ADDRESSABLE (clone_parm) = 0;
 		  clone_parm = TREE_CHAIN (clone_parm);
 		}
 	      if (fn_parm_typelist)
Index: gcc/cp/init.c
===================================================================
--- a/src/gcc/cp/init.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cp/init.c	(.../branches/gcc-7-branch)
@@ -409,6 +409,15 @@
 	      if (ftype == error_mark_node)
 		continue;
 
+	      /* Ignore flexible array members for value initialization.  */
+	      if (TREE_CODE (ftype) == ARRAY_TYPE
+		  && !COMPLETE_TYPE_P (ftype)
+		  && !TYPE_DOMAIN (ftype)
+		  && COMPLETE_TYPE_P (TREE_TYPE (ftype))
+		  && (next_initializable_field (DECL_CHAIN (field))
+		      == NULL_TREE))
+		continue;
+
 	      /* We could skip vfields and fields of types with
 		 user-defined constructors, but I think that won't improve
 		 performance at all; it should be simpler in general just
Index: gcc/cp/class.c
===================================================================
--- a/src/gcc/cp/class.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cp/class.c	(.../branches/gcc-7-branch)
@@ -2088,6 +2088,7 @@
   unsigned align = TYPE_ALIGN (t);
   bool user_align = TYPE_USER_ALIGN (t);
   bool may_alias = lookup_attribute ("may_alias", attrs);
+  bool packed = TYPE_PACKED (t);
 
   if (may_alias)
     fixup_may_alias (t);
@@ -2105,6 +2106,7 @@
       else
 	TYPE_USER_ALIGN (variants) = user_align;
       SET_TYPE_ALIGN (variants, valign);
+      TYPE_PACKED (variants) = packed;
       if (may_alias)
 	fixup_may_alias (variants);
     }
Index: gcc/cp/decl.c
===================================================================
--- a/src/gcc/cp/decl.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cp/decl.c	(.../branches/gcc-7-branch)
@@ -2130,13 +2130,33 @@
 	  if (TYPE_NAME (TREE_TYPE (newdecl)) == newdecl)
 	    {
 	      tree remove = TREE_TYPE (newdecl);
-	      for (tree t = TYPE_MAIN_VARIANT (remove); ;
-		   t = TYPE_NEXT_VARIANT (t))
-		if (TYPE_NEXT_VARIANT (t) == remove)
-		  {
-		    TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (remove);
-		    break;
-		  }
+	      if (TYPE_MAIN_VARIANT (remove) == remove)
+		{
+		  gcc_assert (TYPE_NEXT_VARIANT (remove) == NULL_TREE);
+		  /* If remove is the main variant, no need to remove that
+		     from the list.  One of the DECL_ORIGINAL_TYPE
+		     variants, e.g. created for aligned attribute, might still
+		     refer to the newdecl TYPE_DECL though, so remove that one
+		     in that case.  */
+		  if (tree orig = DECL_ORIGINAL_TYPE (newdecl))
+		    if (orig != remove)
+		      for (tree t = TYPE_MAIN_VARIANT (orig); t;
+			   t = TYPE_MAIN_VARIANT (t))
+			if (TYPE_NAME (TYPE_NEXT_VARIANT (t)) == newdecl)
+			  {
+			    TYPE_NEXT_VARIANT (t)
+			      = TYPE_NEXT_VARIANT (TYPE_NEXT_VARIANT (t));
+			    break;
+			  }
+		}	    
+	      else
+		for (tree t = TYPE_MAIN_VARIANT (remove); ;
+		     t = TYPE_NEXT_VARIANT (t))
+		  if (TYPE_NEXT_VARIANT (t) == remove)
+		    {
+		      TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (remove);
+		      break;
+		    }
 	    }
 	}
       else
Index: gcc/cp/constexpr.c
===================================================================
--- a/src/gcc/cp/constexpr.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cp/constexpr.c	(.../branches/gcc-7-branch)
@@ -1212,6 +1212,8 @@
   /* Avoid wrapping an aggregate value in a NOP_EXPR.  */
   if (TREE_CODE (temp) == CONSTRUCTOR)
     return build_constructor (type, CONSTRUCTOR_ELTS (temp));
+  if (TREE_CODE (temp) == EMPTY_CLASS_EXPR)
+    return build0 (EMPTY_CLASS_EXPR, type);
   gcc_assert (scalarish_type_p (type));
   return cp_fold_convert (type, temp);
 }
Index: gcc/cp/ChangeLog
===================================================================
--- a/src/gcc/cp/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cp/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,198 @@
+2019-09-05  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from mainline
+	2019-08-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR pch/61250
+	* parser.c (cp_parser_initial_pragma): Call c_common_no_more_pch ()
+	after determining that the first token is not
+	PRAGMA_GCC_PCH_PREPROCESS.
+
+2019-09-02  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-02-21  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89392
+	* vtable-class-hierarchy.c (vtv_generate_init_routine): Do not
+	make symtab process new functions here.
+
+2019-08-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-06-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90950
+	* semantics.c (finish_omp_clauses): Don't reject references to
+	incomplete types if processing_template_decl.
+
+	2019-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR pch/90326
+	* config-lang.in (gtfiles): Remove c-family/c-lex.c, add
+	c-family/c-cppbuiltin.c.
+
+	2019-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90108
+	* decl.c (duplicate_decls): If remove is main variant and
+	DECL_ORIGINAL_TYPE is some other type, remove a DECL_ORIGINAL_TYPE
+	variant that has newdecl as TYPE_NAME if any.
+
+	2019-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/89933
+	* decl.c (duplicate_decls): When newdecl's type is its main variant,
+	don't try to remove it from the variant list, but instead assert
+	it has no variants.
+
+	2019-03-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/89869
+	* typeck.c: Include gimplify.h.
+	(cp_build_modify_expr) <case COND_EXPR>: Unshare rhs before using it
+	for second time.  Formatting fixes.
+
+	2019-03-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89796
+	* semantics.c (finish_omp_atomic): Add warning_sentinel for
+	-Wunused-value around finish_expr_stmt call.
+
+	2019-03-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/60702
+	* cp-tree.h (get_tls_wrapper_fn): Remove declaration.
+	(maybe_get_tls_wrapper_call): Declare.
+	* decl2.c (get_tls_wrapper_fn): Make static.
+	(maybe_get_tls_wrapper_call): New function.
+	* typeck.c (build_class_member_access_expr): Handle accesses to TLS
+	variables.
+	* semantics.c (finish_qualified_id_expr): Likewise.
+	(finish_id_expression_1): Use maybe_get_tls_wrapper_call.
+	* pt.c (tsubst_copy_and_build): Likewise.
+
+	2019-03-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89767
+	* parser.c (cp_parser_lambda_introducer): Add ids and first_capture_id
+	variables, check for duplicates in this function.
+	* lambda.c (add_capture): Don't check for duplicates nor use
+	IDENTIFIER_MARKED.
+	(register_capture_members): Don't clear IDENTIFIER_MARKED here.
+
+	2019-03-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89512
+	* semantics.c (finish_qualified_id_expr): Reject variable templates.
+
+	2019-03-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/87148
+	* init.c (build_value_init_noctor): Ignore flexible array members.
+
+	2019-02-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89403
+	* decl2.c (c_parse_final_cleanups): Move TREE_ASM_WRITTEN setting
+	for flag_syntax_only from here...
+	* semantics.c (expand_or_defer_fn_1): ... here.
+
+	2019-02-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89187
+	* optimize.c (maybe_thunk_body): Clear TREE_ADDRESSABLE on
+	PARM_DECLs of the thunk.
+	* lambda.c (maybe_add_lambda_conv_op): Likewise.
+
+	2019-01-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/88976
+	* semantics.c (finish_omp_cancel): Use maybe_convert_cond when not in
+	template or build_x_binary_op otherwise.
+
+	2019-01-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/88949
+	* optimize.c (cxx_copy_decl): New function.
+	(clone_body): Use it instead of copy_decl_no_change.
+
+	2018-12-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/86669
+	* call.c (make_temporary_var_for_ref_to_temp): Call pushdecl even for
+	automatic vars.
+
+	PR c++/87506
+	* constexpr.c (adjust_temp_type): Handle EMPTY_CLASS_EXPR.
+
+	2018-12-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/88103
+	* typeck.c (build_class_member_access_expr): If unary_complex_lvalue
+	turned xvalue_p into non-xvalue_p, call move on it.
+
+	2018-11-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/88181
+	* class.c (fixup_attribute_variants): Also propagate TYPE_PACKED
+	to variants.
+
+2019-04-10  Matthias Klose  <doko@ubuntu.com>
+
+	Backport from the gcc-8 branch
+	2019-03-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89585
+	* parser.c (cp_parser_asm_definition): Parse asm qualifiers even
+	at toplevel, but diagnose them.
+
+2018-01-02  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR inline-asm/55681
+	* parser.c (cp_parser_asm_definition): Update grammar.  Allow any
+	combination of volatile and goto, in any order, without repetitions.
+
+	Backport from trunk
+	2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* cp-tree.h (finish_asm_stmt): Update declaration.
+	* parser.c (cp_parser_asm_definition): Detect the inline keyword
+	after asm.  Pass a flag for it to finish_asm_stmt.
+	* pt.c (tsubst_expr): Pass the ASM_INLINE_P flag to finish_asm_stmt.
+	* semantics.c (finish_asm_stmt): Add inline_p parameter.  Use it to
+	set ASM_INLINE_P.
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* parser.c (cp_parser_asm_definition): Rewrite the loop to work without
+	"done" boolean variable.
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* parser.c (cp_parser_asm_definition): Rewrite the loop to work without
+	"done" boolean variable.
+	* parser.c (cp_parser_asm_definition): Keep track of the location each
+	asm qualifier is first seen; use that to give nicer "duplicate asm
+	qualifier" messages.
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* parser.c (cp_parser_asm_definition) <RID_CONST, RID_RESTRICT>: Give
+	a more specific error message (instead of just falling through).
+
+	Backport from trunk
+	2018-12-10  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* parser.c (cp_parser_asm_definition): Do not allow any asm qualifiers
+	on top-level asm.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: gcc/cp/pt.c
===================================================================
--- a/src/gcc/cp/pt.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cp/pt.c	(.../branches/gcc-7-branch)
@@ -16159,7 +16159,7 @@
 	tree labels = tsubst_copy_asm_operands (ASM_LABELS (t), args,
 						complain, in_decl);
 	tmp = finish_asm_stmt (ASM_VOLATILE_P (t), string, outputs, inputs,
-			       clobbers, labels);
+			       clobbers, labels, ASM_INLINE_P (t));
 	tree asm_expr = tmp;
 	if (TREE_CODE (asm_expr) == CLEANUP_POINT_EXPR)
 	  asm_expr = TREE_OPERAND (asm_expr, 0);
@@ -17897,17 +17897,10 @@
       {
 	tree r = tsubst_copy (t, args, complain, in_decl);
 	/* ??? We're doing a subset of finish_id_expression here.  */
-	if (VAR_P (r)
-	    && !processing_template_decl
-	    && !cp_unevaluated_operand
-	    && (TREE_STATIC (r) || DECL_EXTERNAL (r))
-	    && CP_DECL_THREAD_LOCAL_P (r))
-	  {
-	    if (tree wrap = get_tls_wrapper_fn (r))
-	      /* Replace an evaluated use of the thread_local variable with
-		 a call to its wrapper.  */
-	      r = build_cxx_call (wrap, 0, NULL, tf_warning_or_error);
-	  }
+	if (tree wrap = maybe_get_tls_wrapper_call (r))
+	  /* Replace an evaluated use of the thread_local variable with
+	     a call to its wrapper.  */
+	  r = wrap;
 	else if (outer_automatic_var_p (r))
 	  {
 	    r = process_outer_var_ref (r, complain);
Index: gcc/cp/semantics.c
===================================================================
--- a/src/gcc/cp/semantics.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cp/semantics.c	(.../branches/gcc-7-branch)
@@ -1429,11 +1429,11 @@
 /* Finish an asm-statement, whose components are a STRING, some
    OUTPUT_OPERANDS, some INPUT_OPERANDS, some CLOBBERS and some
    LABELS.  Also note whether the asm-statement should be
-   considered volatile.  */
+   considered volatile, and whether it is asm inline.  */
 
 tree
 finish_asm_stmt (int volatile_p, tree string, tree output_operands,
-		 tree input_operands, tree clobbers, tree labels)
+		 tree input_operands, tree clobbers, tree labels, bool inline_p)
 {
   tree r;
   tree t;
@@ -1587,6 +1587,7 @@
 		  output_operands, input_operands,
 		  clobbers, labels);
   ASM_VOLATILE_P (r) = volatile_p || noutputs == 0;
+  ASM_INLINE_P (r) = inline_p;
   r = maybe_cleanup_point_expr_void (r);
   return add_stmt (r);
 }
@@ -2066,6 +2067,14 @@
     }
   else if (BASELINK_P (expr))
     ;
+  else if (!template_p
+	   && TREE_CODE (expr) == TEMPLATE_DECL
+	   && !DECL_FUNCTION_TEMPLATE_P (expr))
+    {
+      if (complain & tf_error)
+	error ("%qE missing template arguments", expr);
+      return error_mark_node;
+    }
   else
     {
       /* In a template, return a SCOPE_REF for most qualified-ids
@@ -2078,6 +2087,8 @@
 	expr = build_qualified_name (TREE_TYPE (expr),
 				     qualifying_class, expr,
 				     template_p);
+      else if (tree wrap = maybe_get_tls_wrapper_call (expr))
+	expr = wrap;
 
       expr = convert_from_reference (expr);
     }
@@ -3737,18 +3748,10 @@
 	  *non_integral_constant_expression_p = true;
 	}
 
-      tree wrap;
-      if (VAR_P (decl)
-	  && !cp_unevaluated_operand
-	  && !processing_template_decl
-	  && (TREE_STATIC (decl) || DECL_EXTERNAL (decl))
-	  && CP_DECL_THREAD_LOCAL_P (decl)
-	  && (wrap = get_tls_wrapper_fn (decl)))
-	{
-	  /* Replace an evaluated use of the thread_local variable with
-	     a call to its wrapper.  */
-	  decl = build_cxx_call (wrap, 0, NULL, tf_warning_or_error);
-	}
+      if (tree wrap = maybe_get_tls_wrapper_call (decl))
+	/* Replace an evaluated use of the thread_local variable with
+	   a call to its wrapper.  */
+	decl = wrap;
       else if (TREE_CODE (decl) == TEMPLATE_ID_EXPR
 	       && variable_template_p (TREE_OPERAND (decl, 0)))
 	{
@@ -4297,7 +4300,12 @@
   /* There's no reason to do any of the work here if we're only doing
      semantic analysis; this code just generates RTL.  */
   if (flag_syntax_only)
-    return false;
+    {
+      /* Pretend that this function has been written out so that we don't try
+	 to expand it again.  */
+      TREE_ASM_WRITTEN (fn) = 1;
+      return false;
+    }
 
   return true;
 }
@@ -7361,7 +7369,8 @@
 	  t = require_complete_type (t);
 	  if (t == error_mark_node)
 	    remove = true;
-	  else if (TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE
+	  else if (!processing_template_decl
+		   && TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE
 		   && !complete_type_or_else (TREE_TYPE (TREE_TYPE (t)), t))
 	    remove = true;
 	}
@@ -8624,6 +8633,11 @@
       stmt = build2 (OMP_ATOMIC, void_type_node, integer_zero_node, stmt);
       OMP_ATOMIC_SEQ_CST (stmt) = seq_cst;
     }
+
+  /* Avoid -Wunused-value warnings here, the whole construct has side-effects
+     and even if it might be wrapped from fold-const.c or c-omp.c wrapped
+     in some tree that appears to be unused, the value is not unused.  */
+  warning_sentinel w (warn_unused_value);
   finish_expr_stmt (stmt);
 }
 
@@ -8690,10 +8704,13 @@
   tree ifc = omp_find_clause (clauses, OMP_CLAUSE_IF);
   if (ifc != NULL_TREE)
     {
-      tree type = TREE_TYPE (OMP_CLAUSE_IF_EXPR (ifc));
-      ifc = fold_build2_loc (OMP_CLAUSE_LOCATION (ifc), NE_EXPR,
-			     boolean_type_node, OMP_CLAUSE_IF_EXPR (ifc),
-			     build_zero_cst (type));
+      if (!processing_template_decl)
+	ifc = maybe_convert_cond (OMP_CLAUSE_IF_EXPR (ifc));
+      else
+	ifc = build_x_binary_op (OMP_CLAUSE_LOCATION (ifc), NE_EXPR,
+				 OMP_CLAUSE_IF_EXPR (ifc), ERROR_MARK,
+				 integer_zero_node, ERROR_MARK,
+				 NULL, tf_warning_or_error);
     }
   else
     ifc = boolean_true_node;
Index: gcc/cp/decl2.c
===================================================================
--- a/src/gcc/cp/decl2.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cp/decl2.c	(.../branches/gcc-7-branch)
@@ -3255,7 +3255,7 @@
    VAR and then returns a reference to VAR.  The wrapper function is used
    in place of VAR everywhere VAR is mentioned.  */
 
-tree
+static tree
 get_tls_wrapper_fn (tree var)
 {
   /* Only C++11 TLS vars need this wrapper fn.  */
@@ -3307,6 +3307,22 @@
   return fn;
 }
 
+/* If EXPR is a thread_local variable that should be wrapped by init
+   wrapper function, return a call to that function, otherwise return
+   NULL.  */
+
+tree
+maybe_get_tls_wrapper_call (tree expr)
+{
+  if (VAR_P (expr)
+      && !processing_template_decl
+      && !cp_unevaluated_operand
+      && CP_DECL_THREAD_LOCAL_P (expr))
+    if (tree wrap = get_tls_wrapper_fn (expr))
+      return build_cxx_call (wrap, 0, NULL, tf_warning_or_error);
+  return NULL;
+}
+
 /* At EOF, generate the definition for the TLS wrapper function FN:
 
    T& var_wrapper() {
@@ -4725,11 +4741,6 @@
 	      /* Generate RTL for this function now that we know we
 		 need it.  */
 	      expand_or_defer_fn (decl);
-	      /* If we're compiling -fsyntax-only pretend that this
-		 function has been written out so that we don't try to
-		 expand it again.  */
-	      if (flag_syntax_only)
-		TREE_ASM_WRITTEN (decl) = 1;
 	      reconsider = true;
 	    }
 	}
Index: gcc/cp/parser.c
===================================================================
--- a/src/gcc/cp/parser.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cp/parser.c	(.../branches/gcc-7-branch)
@@ -10010,6 +10010,11 @@
       first = false;
     }
 
+  hash_set<tree> *ids = NULL;
+#if GCC_VERSION >= 7000
+  char ids_buf[sizeof (hash_set<tree>) + __alignof__ (hash_set<tree>) - 1];
+#endif
+  tree first_capture_id = NULL_TREE;
   while (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_SQUARE))
     {
       cp_token* capture_token;
@@ -10044,11 +10049,14 @@
 	    pedwarn (loc, 0, "explicit by-copy capture of %<this%> redundant "
 		     "with by-copy capture default");
 	  cp_lexer_consume_token (parser->lexer);
-	  add_capture (lambda_expr,
-		       /*id=*/this_identifier,
-		       /*initializer=*/finish_this_expr (),
-		       /*by_reference_p=*/true,
-		       explicit_init_p);
+	  if (LAMBDA_EXPR_THIS_CAPTURE (lambda_expr))
+	    pedwarn (input_location, 0,
+		     "already captured %qD in lambda expression",
+		     this_identifier);
+	  else
+	    add_capture (lambda_expr, /*id=*/this_identifier,
+			 /*initializer=*/finish_this_expr (),
+			 /*by_reference_p=*/true, explicit_init_p);
 	  continue;
 	}
 
@@ -10062,11 +10070,14 @@
 			     "-std=c++1z or -std=gnu++1z");
 	  cp_lexer_consume_token (parser->lexer);
 	  cp_lexer_consume_token (parser->lexer);
-	  add_capture (lambda_expr,
-		       /*id=*/this_identifier,
-		       /*initializer=*/finish_this_expr (),
-		       /*by_reference_p=*/false,
-		       explicit_init_p);
+	  if (LAMBDA_EXPR_THIS_CAPTURE (lambda_expr))
+	    pedwarn (input_location, 0,
+		     "already captured %qD in lambda expression",
+		     this_identifier);
+	  else
+	    add_capture (lambda_expr, /*id=*/this_identifier,
+			 /*initializer=*/finish_this_expr (),
+			 /*by_reference_p=*/false, explicit_init_p);
 	  continue;
 	}
 
@@ -10190,13 +10201,44 @@
 		     "default", capture_id);
 	}
 
-      add_capture (lambda_expr,
-		   capture_id,
-		   capture_init_expr,
-		   /*by_reference_p=*/capture_kind == BY_REFERENCE,
-		   explicit_init_p);
+      /* Check for duplicates.
+	 Optimize for the zero or one explicit captures cases and only create
+	 the hash_set after adding second capture.  */
+      bool found = false;
+      if (ids && ids->elements ())
+	found = ids->add (capture_id);
+      else if (first_capture_id == NULL_TREE)
+	first_capture_id = capture_id;
+      else if (capture_id == first_capture_id)
+	found = true;
+      else
+	{
+#if GCC_VERSION >= 7000
+	  ids = new (ids_buf
+		     + (-(uintptr_t) ids_buf
+			& (__alignof__ (hash_set <tree>) - 1))) hash_set <tree>;
+#else
+	  ids = new hash_set <tree>;
+#endif
+	  ids->add (first_capture_id);
+	  ids->add (capture_id);
+	}
+      if (found)
+	pedwarn (input_location, 0,
+		 "already captured %qD in lambda expression", capture_id);
+      else
+	add_capture (lambda_expr, capture_id, capture_init_expr,
+		     /*by_reference_p=*/capture_kind == BY_REFERENCE,
+		     explicit_init_p);
     }
 
+  if (ids)
+#if GCC_VERSION >= 7000
+    ids->~hash_set <tree> ();
+#else
+    delete ids;
+#endif
+
   cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);
 }
 
@@ -18789,6 +18831,15 @@
 
 /* Parse an asm-definition.
 
+  asm-qualifier:
+    volatile
+    inline
+    goto
+
+  asm-qualifier-list:
+    asm-qualifier
+    asm-qualifier-list asm-qualifier
+
    asm-definition:
      asm ( string-literal ) ;
 
@@ -18795,17 +18846,21 @@
    GNU Extension:
 
    asm-definition:
-     asm volatile [opt] ( string-literal ) ;
-     asm volatile [opt] ( string-literal : asm-operand-list [opt] ) ;
-     asm volatile [opt] ( string-literal : asm-operand-list [opt]
-			  : asm-operand-list [opt] ) ;
-     asm volatile [opt] ( string-literal : asm-operand-list [opt]
-			  : asm-operand-list [opt]
+     asm asm-qualifier-list [opt] ( string-literal ) ;
+     asm asm-qualifier-list [opt] ( string-literal : asm-operand-list [opt] ) ;
+     asm asm-qualifier-list [opt] ( string-literal : asm-operand-list [opt]
+				    : asm-operand-list [opt] ) ;
+     asm asm-qualifier-list [opt] ( string-literal : asm-operand-list [opt]
+				    : asm-operand-list [opt]
 			  : asm-clobber-list [opt] ) ;
-     asm volatile [opt] goto ( string-literal : : asm-operand-list [opt]
-			       : asm-clobber-list [opt]
-			       : asm-goto-list ) ;  */
+     asm asm-qualifier-list [opt] ( string-literal : : asm-operand-list [opt]
+				    : asm-clobber-list [opt]
+				    : asm-goto-list ) ;
 
+  The form with asm-goto-list is valid if and only if the asm-qualifier-list
+  contains goto, and is the only allowed form in that case.  No duplicates are
+  allowed in an asm-qualifier-list.  */
+
 static void
 cp_parser_asm_definition (cp_parser* parser)
 {
@@ -18815,11 +18870,9 @@
   tree clobbers = NULL_TREE;
   tree labels = NULL_TREE;
   tree asm_stmt;
-  bool volatile_p = false;
   bool extended_p = false;
   bool invalid_inputs_p = false;
   bool invalid_outputs_p = false;
-  bool goto_p = false;
   required_token missing = RT_NONE;
 
   /* Look for the `asm' keyword.  */
@@ -18832,24 +18885,78 @@
       cp_function_chain->invalid_constexpr = true;
     }
 
-  /* See if the next token is `volatile'.  */
-  if (cp_parser_allow_gnu_extensions_p (parser)
-      && cp_lexer_next_token_is_keyword (parser->lexer, RID_VOLATILE))
+  /* Handle the asm-qualifier-list.  */
+  location_t volatile_loc = UNKNOWN_LOCATION;
+  location_t inline_loc = UNKNOWN_LOCATION;
+  location_t goto_loc = UNKNOWN_LOCATION;
+  location_t first_loc = UNKNOWN_LOCATION;
+
+  if (cp_parser_allow_gnu_extensions_p (parser))
+    for (;;)
+      {
+	cp_token *token = cp_lexer_peek_token (parser->lexer);
+	location_t loc = token->location;
+	switch (cp_lexer_peek_token (parser->lexer)->keyword)
+	  {
+	  case RID_VOLATILE:
+	    if (volatile_loc)
+	      {
+		error_at (loc, "duplicate asm qualifier %qT", token->u.value);
+		inform (volatile_loc, "first seen here");
+	      }
+	    else
+	      volatile_loc = loc;
+	    cp_lexer_consume_token (parser->lexer);
+	    continue;
+
+	  case RID_INLINE:
+	    if (inline_loc)
+	      {
+		error_at (loc, "duplicate asm qualifier %qT", token->u.value);
+		inform (inline_loc, "first seen here");
+	      }
+	    else
+	      inline_loc = loc;
+	    if (!first_loc)
+	      first_loc = loc;
+	    cp_lexer_consume_token (parser->lexer);
+	    continue;
+
+	  case RID_GOTO:
+	    if (goto_loc)
+	      {
+		error_at (loc, "duplicate asm qualifier %qT", token->u.value);
+		inform (goto_loc, "first seen here");
+	      }
+	    else
+	      goto_loc = loc;
+	    if (!first_loc)
+	      first_loc = loc;
+	    cp_lexer_consume_token (parser->lexer);
+	    continue;
+
+	  case RID_CONST:
+	  case RID_RESTRICT:
+	    error_at (loc, "%qT is not an asm qualifier", token->u.value);
+	    cp_lexer_consume_token (parser->lexer);
+	    continue;
+
+	  default:
+	    break;
+	  }
+	break;
+      }
+
+  bool volatile_p = (volatile_loc != UNKNOWN_LOCATION);
+  bool inline_p = (inline_loc != UNKNOWN_LOCATION);
+  bool goto_p = (goto_loc != UNKNOWN_LOCATION);
+
+  if (!parser->in_function_body && (inline_p || goto_p))
     {
-      /* Remember that we saw the `volatile' keyword.  */
-      volatile_p = true;
-      /* Consume the token.  */
-      cp_lexer_consume_token (parser->lexer);
+      error_at (first_loc, "asm qualifier outside of function body");
+      inline_p = goto_p = false;
     }
-  if (cp_parser_allow_gnu_extensions_p (parser)
-      && parser->in_function_body
-      && cp_lexer_next_token_is_keyword (parser->lexer, RID_GOTO))
-    {
-      /* Remember that we saw the `goto' keyword.  */
-      goto_p = true;
-      /* Consume the token.  */
-      cp_lexer_consume_token (parser->lexer);
-    }
+
   /* Look for the opening `('.  */
   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))
     return;
@@ -18941,8 +19048,7 @@
 					     CPP_CLOSE_PAREN))
 	    clobbers = cp_parser_asm_clobber_list (parser);
 	}
-      else if (goto_p
-	       && cp_lexer_next_token_is (parser->lexer, CPP_SCOPE))
+      else if (goto_p && cp_lexer_next_token_is (parser->lexer, CPP_SCOPE))
 	/* The labels are coming next.  */
 	labels_p = true;
 
@@ -18976,7 +19082,7 @@
       if (parser->in_function_body)
 	{
 	  asm_stmt = finish_asm_stmt (volatile_p, string, outputs,
-				      inputs, clobbers, labels);
+				      inputs, clobbers, labels, inline_p);
 	  /* If the extended syntax was not used, mark the ASM_EXPR.  */
 	  if (!extended_p)
 	    {
@@ -38126,7 +38232,10 @@
 
   cp_lexer_get_preprocessor_token (NULL, first_token);
   if (cp_parser_pragma_kind (first_token) != PRAGMA_GCC_PCH_PREPROCESS)
-    return;
+    {
+      c_common_no_more_pch ();
+      return;
+    }
 
   cp_lexer_get_preprocessor_token (NULL, first_token);
   if (first_token->type == CPP_STRING)
Index: gcc/cp/config-lang.in
===================================================================
--- a/src/gcc/cp/config-lang.in	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cp/config-lang.in	(.../branches/gcc-7-branch)
@@ -29,4 +29,4 @@
 
 target_libs="target-libstdc++-v3"
 
-gtfiles="\$(srcdir)/cp/rtti.c \$(srcdir)/cp/mangle.c \$(srcdir)/cp/name-lookup.h \$(srcdir)/cp/name-lookup.c \$(srcdir)/cp/cp-tree.h \$(srcdir)/cp/decl.h \$(srcdir)/cp/call.c \$(srcdir)/cp/decl.c \$(srcdir)/cp/decl2.c \$(srcdir)/cp/pt.c \$(srcdir)/cp/repo.c \$(srcdir)/cp/semantics.c \$(srcdir)/cp/tree.c \$(srcdir)/cp/parser.h \$(srcdir)/cp/parser.c \$(srcdir)/cp/method.c \$(srcdir)/cp/typeck2.c \$(srcdir)/c-family/c-common.c \$(srcdir)/c-family/c-common.h \$(srcdir)/c-family/c-objc.h \$(srcdir)/c-family/c-lex.c \$(srcdir)/c-family/c-pragma.h \$(srcdir)/c-family/c-pragma.c \$(srcdir)/cp/class.c \$(srcdir)/cp/cp-objcp-common.c \$(srcdir)/cp/cp-lang.c \$(srcdir)/cp/except.c \$(srcdir)/cp/vtable-class-hierarchy.c \$(srcdir)/cp/constexpr.c \$(srcdir)/cp/cp-gimplify.c"
+gtfiles="\$(srcdir)/cp/rtti.c \$(srcdir)/cp/mangle.c \$(srcdir)/cp/name-lookup.h \$(srcdir)/cp/name-lookup.c \$(srcdir)/cp/cp-tree.h \$(srcdir)/cp/decl.h \$(srcdir)/cp/call.c \$(srcdir)/cp/decl.c \$(srcdir)/cp/decl2.c \$(srcdir)/cp/pt.c \$(srcdir)/cp/repo.c \$(srcdir)/cp/semantics.c \$(srcdir)/cp/tree.c \$(srcdir)/cp/parser.h \$(srcdir)/cp/parser.c \$(srcdir)/cp/method.c \$(srcdir)/cp/typeck2.c \$(srcdir)/c-family/c-common.c \$(srcdir)/c-family/c-common.h \$(srcdir)/c-family/c-objc.h \$(srcdir)/c-family/c-cppbuiltin.c \$(srcdir)/c-family/c-pragma.h \$(srcdir)/c-family/c-pragma.c \$(srcdir)/cp/class.c \$(srcdir)/cp/cp-objcp-common.c \$(srcdir)/cp/cp-lang.c \$(srcdir)/cp/except.c \$(srcdir)/cp/vtable-class-hierarchy.c \$(srcdir)/cp/constexpr.c \$(srcdir)/cp/cp-gimplify.c"
Index: gcc/cp/call.c
===================================================================
--- a/src/gcc/cp/call.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cp/call.c	(.../branches/gcc-7-branch)
@@ -10301,8 +10301,11 @@
       var = pushdecl_top_level (var);
     }
   else
-    /* Create a new cleanup level if necessary.  */
-    maybe_push_cleanup_level (type);
+    {
+      /* Create a new cleanup level if necessary.  */
+      maybe_push_cleanup_level (type);
+      var = pushdecl (var);
+    }
 
   return var;
 }
Index: gcc/cp/lambda.c
===================================================================
--- a/src/gcc/cp/lambda.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cp/lambda.c	(.../branches/gcc-7-branch)
@@ -567,19 +567,6 @@
 	  IDENTIFIER_LENGTH (id) + 1);
   name = get_identifier (buf);
 
-  /* If TREE_TYPE isn't set, we're still in the introducer, so check
-     for duplicates.  */
-  if (!LAMBDA_EXPR_CLOSURE (lambda))
-    {
-      if (IDENTIFIER_MARKED (name))
-	{
-	  pedwarn (input_location, 0,
-		   "already captured %qD in lambda expression", id);
-	  return NULL_TREE;
-	}
-      IDENTIFIER_MARKED (name) = true;
-    }
-
   if (variadic)
     type = make_pack_expansion (type);
 
@@ -634,8 +621,6 @@
   if (PACK_EXPANSION_P (field))
     field = PACK_EXPANSION_PATTERN (field);
 
-  /* We set this in add_capture to avoid duplicates.  */
-  IDENTIFIER_MARKED (DECL_NAME (field)) = false;
   finish_member_declaration (field);
 }
 
@@ -1045,6 +1030,9 @@
       {
 	tree new_node = copy_node (src);
 
+	/* Clear TREE_ADDRESSABLE on thunk arguments.  */
+	TREE_ADDRESSABLE (new_node) = 0;
+
 	if (!fn_args)
 	  fn_args = tgt = new_node;
 	else
Index: gcc/cp/vtable-class-hierarchy.c
===================================================================
--- a/src/gcc/cp/vtable-class-hierarchy.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cp/vtable-class-hierarchy.c	(.../branches/gcc-7-branch)
@@ -1191,8 +1191,6 @@
       gimplify_function_tree (vtv_fndecl);
       cgraph_node::add_new_function (vtv_fndecl, false);
 
-      symtab->process_new_functions ();
-
       if (flag_vtable_verify == VTV_PREINIT_PRIORITY && !TARGET_PECOFF)
         assemble_vtv_preinit_initializer (vtv_fndecl);
 
Index: gcc/cp/cp-tree.h
===================================================================
--- a/src/gcc/cp/cp-tree.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cp/cp-tree.h	(.../branches/gcc-7-branch)
@@ -5962,7 +5962,7 @@
 extern tree get_guard				(tree);
 extern tree get_guard_cond			(tree, bool);
 extern tree set_guard				(tree);
-extern tree get_tls_wrapper_fn			(tree);
+extern tree maybe_get_tls_wrapper_call		(tree);
 extern void mark_needed				(tree);
 extern bool decl_needed_p			(tree);
 extern void note_vague_linkage_fn		(tree);
@@ -6455,7 +6455,7 @@
 
 extern void finish_compound_stmt		(tree);
 extern tree finish_asm_stmt			(int, tree, tree, tree, tree,
-						 tree);
+						 tree, bool);
 extern tree finish_label_stmt			(tree);
 extern void finish_label_decl			(tree);
 extern cp_expr finish_parenthesized_expr	(cp_expr);
Index: gcc/omp-expand.c
===================================================================
--- a/src/gcc/omp-expand.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/omp-expand.c	(.../branches/gcc-7-branch)
@@ -1960,6 +1960,11 @@
 	  t = fold_build2 (fd->loops[i].cond_code, boolean_type_node, v, t);
 	  stmt = gimple_build_cond_empty (t);
 	  gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);
+	  if (walk_tree (gimple_cond_lhs_ptr (as_a <gcond *> (stmt)),
+			 expand_omp_regimplify_p, NULL, NULL)
+	      || walk_tree (gimple_cond_rhs_ptr (as_a <gcond *> (stmt)),
+			    expand_omp_regimplify_p, NULL, NULL))
+	    gimple_regimplify_operands (stmt, &gsi);
 	  e = make_edge (bb, body_bb, EDGE_TRUE_VALUE);
 	  e->probability = REG_BR_PROB_BASE * 7 / 8;
 	}
@@ -3042,20 +3047,21 @@
 
 	  if (fd->ordered && counts[fd->collapse - 1] == NULL_TREE)
 	    {
+	      tree tem;
 	      if (fd->collapse > 1)
-		t = fd->loop.v;
+		tem = fd->loop.v;
 	      else
 		{
-		  t = fold_build2 (MINUS_EXPR, TREE_TYPE (fd->loops[0].v),
-				   fd->loops[0].v, fd->loops[0].n1);
-		  t = fold_convert (fd->iter_type, t);
+		  tem = fold_build2 (MINUS_EXPR, TREE_TYPE (fd->loops[0].v),
+				     fd->loops[0].v, fd->loops[0].n1);
+		  tem = fold_convert (fd->iter_type, tem);
 		}
 	      tree aref = build4 (ARRAY_REF, fd->iter_type,
 				  counts[fd->ordered], size_zero_node,
 				  NULL_TREE, NULL_TREE);
-	      t = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,
-					    true, GSI_SAME_STMT);
-	      expand_omp_build_assign (&gsi, aref, t);
+	      tem = force_gimple_operand_gsi (&gsi, tem, true, NULL_TREE,
+					      true, GSI_SAME_STMT);
+	      expand_omp_build_assign (&gsi, aref, tem);
 	    }
 
 	  t = build2 (fd->loop.cond_code, boolean_type_node,
Index: gcc/tree-ssa-loop-ivopts.c
===================================================================
--- a/src/gcc/tree-ssa-loop-ivopts.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssa-loop-ivopts.c	(.../branches/gcc-7-branch)
@@ -566,6 +566,9 @@
   /* The common candidates.  */
   vec<iv_common_cand *> iv_common_cands;
 
+  /* Hash map recording base object information of tree exp.  */
+  hash_map<tree, tree> *base_object_map;
+
   /* The maximum invariant id.  */
   unsigned max_inv_id;
 
@@ -1066,6 +1069,7 @@
   data->inv_expr_tab = new hash_table<iv_inv_expr_hasher> (10);
   data->max_inv_expr_id = 0;
   data->name_expansion_cache = NULL;
+  data->base_object_map = NULL;
   data->iv_common_cand_tab = new hash_table<iv_common_cand_hasher> (10);
   data->iv_common_cands.create (20);
   decl_rtl_to_reset.create (20);
@@ -1072,53 +1076,61 @@
   gcc_obstack_init (&data->iv_obstack);
 }
 
-/* Returns a memory object to that EXPR points.  In case we are able to
-   determine that it does not point to any such object, NULL is returned.  */
+/* walk_tree callback for determine_base_object.  */
 
 static tree
-determine_base_object (tree expr)
+determine_base_object_1 (tree *tp, int *walk_subtrees, void *wdata)
 {
-  enum tree_code code = TREE_CODE (expr);
-  tree base, obj;
-
-  /* If this is a pointer casted to any type, we need to determine
-     the base object for the pointer; so handle conversions before
-     throwing away non-pointer expressions.  */
-  if (CONVERT_EXPR_P (expr))
-    return determine_base_object (TREE_OPERAND (expr, 0));
-
-  if (!POINTER_TYPE_P (TREE_TYPE (expr)))
-    return NULL_TREE;
-
-  switch (code)
+  tree_code code = TREE_CODE (*tp);
+  tree obj = NULL_TREE;
+  if (code == ADDR_EXPR)
     {
-    case INTEGER_CST:
-      return NULL_TREE;
-
-    case ADDR_EXPR:
-      obj = TREE_OPERAND (expr, 0);
-      base = get_base_address (obj);
-
+      tree base = get_base_address (TREE_OPERAND (*tp, 0));
       if (!base)
-	return expr;
+        obj = *tp;
+      else if (TREE_CODE (base) != MEM_REF)
+        obj = fold_convert (ptr_type_node, build_fold_addr_expr (base));
+    }
+  else if (code == SSA_NAME && POINTER_TYPE_P (TREE_TYPE (*tp)))
+        obj = fold_convert (ptr_type_node, *tp);
 
-      if (TREE_CODE (base) == MEM_REF)
-	return determine_base_object (TREE_OPERAND (base, 0));
+  if (!obj)
+    {
+      if (!EXPR_P (*tp))
+        *walk_subtrees = 0;
 
-      return fold_convert (ptr_type_node,
-			   build_fold_addr_expr (base));
+      return NULL_TREE;
+    }
+  /* Record special node for multiple base objects and stop.  */
+  if (*static_cast<tree *> (wdata))
+    {
+      *static_cast<tree *> (wdata) = integer_zero_node;
+      return integer_zero_node;
+    }
+  /* Record the base object and continue looking.  */
+  *static_cast<tree *> (wdata) = obj;
+  return NULL_TREE;
+}
 
-    case POINTER_PLUS_EXPR:
-      return determine_base_object (TREE_OPERAND (expr, 0));
+/* Returns a memory object to that EXPR points with caching.  Return NULL if we
+   are able to determine that it does not point to any such object; specially
+   return integer_zero_node if EXPR contains multiple base objects.  */
 
-    case PLUS_EXPR:
-    case MINUS_EXPR:
-      /* Pointer addition is done solely using POINTER_PLUS_EXPR.  */
-      gcc_unreachable ();
+static tree
+determine_base_object (struct ivopts_data *data, tree expr)
+{
+  tree *slot, obj = NULL_TREE;
+  if (data->base_object_map)
+    {
+      if ((slot = data->base_object_map->get(expr)) != NULL)
+        return *slot;
+    }
+  else
+    data->base_object_map = new hash_map<tree, tree>;
 
-    default:
-      return fold_convert (ptr_type_node, expr);
-    }
+  (void) walk_tree_without_duplicates (&expr, determine_base_object_1, &obj);
+  data->base_object_map->put (expr, obj);
+  return obj;
 }
 
 /* Return true if address expression with non-DECL_P operand appears
@@ -1176,7 +1188,7 @@
     }
 
   iv->base = base;
-  iv->base_object = determine_base_object (base);
+  iv->base_object = determine_base_object (data, base);
   iv->step = step;
   iv->biv_p = false;
   iv->nonlin_use = NULL;
@@ -7728,6 +7740,8 @@
   delete data->inv_expr_tab;
   data->inv_expr_tab = NULL;
   free_affine_expand_cache (&data->name_expansion_cache);
+  if (data->base_object_map)
+    delete data->base_object_map;
   delete data->iv_common_cand_tab;
   data->iv_common_cand_tab = NULL;
   data->iv_common_cands.release ();
Index: gcc/df-core.c
===================================================================
--- a/src/gcc/df-core.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/df-core.c	(.../branches/gcc-7-branch)
@@ -298,12 +298,12 @@
 
    Artificial defs and uses occur both at the beginning and ends of blocks.
 
-     For blocks that area at the destination of eh edges, the
+     For blocks that are at the destination of eh edges, the
      artificial uses and defs occur at the beginning.  The defs relate
      to the registers specified in EH_RETURN_DATA_REGNO and the uses
-     relate to the registers specified in ED_USES.  Logically these
+     relate to the registers specified in EH_USES.  Logically these
      defs and uses should really occur along the eh edge, but there is
-     no convenient way to do this.  Artificial edges that occur at the
+     no convenient way to do this.  Artificial defs that occur at the
      beginning of the block have the DF_REF_AT_TOP flag set.
 
      Artificial uses occur at the end of all blocks.  These arise from
Index: gcc/ipa-pure-const.c
===================================================================
--- a/src/gcc/ipa-pure-const.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ipa-pure-const.c	(.../branches/gcc-7-branch)
@@ -1233,7 +1233,7 @@
   bool remove_p = false;
   bool has_cdtor;
 
-  order_pos = ipa_reduced_postorder (order, true, false,
+  order_pos = ipa_reduced_postorder (order, true,
 				     ignore_edge_for_pure_const);
   if (dump_file)
     {
@@ -1566,7 +1566,7 @@
   int i;
   struct ipa_dfs_info * w_info;
 
-  order_pos = ipa_reduced_postorder (order, true, false,
+  order_pos = ipa_reduced_postorder (order, true,
 				     ignore_edge_for_nothrow);
   if (dump_file)
     {
Index: gcc/lto-streamer-out.c
===================================================================
--- a/src/gcc/lto-streamer-out.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/lto-streamer-out.c	(.../branches/gcc-7-branch)
@@ -1914,6 +1914,7 @@
 
       /* Write OMP SIMD related info.  */
       streamer_write_hwi (ob, loop->safelen);
+      streamer_write_hwi (ob, loop->owned_clique);
       streamer_write_hwi (ob, loop->dont_vectorize);
       streamer_write_hwi (ob, loop->force_vectorize);
       stream_write_tree (ob, loop->simduid, true);
Index: gcc/xcoffout.c
===================================================================
--- a/src/gcc/xcoffout.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/xcoffout.c	(.../branches/gcc-7-branch)
@@ -63,6 +63,7 @@
 
 char *xcoff_bss_section_name;
 char *xcoff_private_data_section_name;
+char *xcoff_private_rodata_section_name;
 char *xcoff_tls_data_section_name;
 char *xcoff_tbss_section_name;
 char *xcoff_read_only_section_name;
Index: gcc/tree-ssa-math-opts.c
===================================================================
--- a/src/gcc/tree-ssa-math-opts.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssa-math-opts.c	(.../branches/gcc-7-branch)
@@ -337,7 +337,8 @@
 	 /* Do not recognize x / x as valid division, as we are getting
 	    confused later by replacing all immediate uses x in such
 	    a stmt.  */
-	 && gimple_assign_rhs1 (use_stmt) != def;
+	 && gimple_assign_rhs1 (use_stmt) != def
+	 && !stmt_can_throw_internal (use_stmt);
 }
 
 /* Walk the subset of the dominator tree rooted at OCC, setting the
Index: gcc/tree-ssa-dom.c
===================================================================
--- a/src/gcc/tree-ssa-dom.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssa-dom.c	(.../branches/gcc-7-branch)
@@ -531,7 +531,8 @@
 	  if (bb == NULL)
 	    continue;
 	  while (single_succ_p (bb)
-		 && (single_succ_edge (bb)->flags & EDGE_EH) == 0)
+		 && (single_succ_edge (bb)->flags
+		     & (EDGE_EH|EDGE_DFS_BACK)) == 0)
 	    bb = single_succ (bb);
 	  if (bb == EXIT_BLOCK_PTR_FOR_FN (fun))
 	    continue;
Index: gcc/xcoffout.h
===================================================================
--- a/src/gcc/xcoffout.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/xcoffout.h	(.../branches/gcc-7-branch)
@@ -127,6 +127,7 @@
 
 extern char *xcoff_bss_section_name;
 extern char *xcoff_private_data_section_name;
+extern char *xcoff_private_rodata_section_name;
 extern char *xcoff_tls_data_section_name;
 extern char *xcoff_tbss_section_name;
 extern char *xcoff_read_only_section_name;
Index: gcc/ipa-utils.c
===================================================================
--- a/src/gcc/ipa-utils.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ipa-utils.c	(.../branches/gcc-7-branch)
@@ -63,7 +63,6 @@
   int order_pos;
   splay_tree nodes_marked_new;
   bool reduce;
-  bool allow_overwritable;
   int count;
 };
 
@@ -105,7 +104,7 @@
 
       if (w->aux
 	  && (avail > AVAIL_INTERPOSABLE
-	      || (env->allow_overwritable && avail == AVAIL_INTERPOSABLE)))
+	      || avail == AVAIL_INTERPOSABLE))
 	{
 	  w_info = (struct ipa_dfs_info *) w->aux;
 	  if (w_info->new_node)
@@ -162,7 +161,7 @@
 
 int
 ipa_reduced_postorder (struct cgraph_node **order,
-		       bool reduce, bool allow_overwritable,
+		       bool reduce,
 		       bool (*ignore_edge) (struct cgraph_edge *))
 {
   struct cgraph_node *node;
@@ -175,7 +174,6 @@
   env.nodes_marked_new = splay_tree_new (splay_tree_compare_ints, 0, 0);
   env.count = 1;
   env.reduce = reduce;
-  env.allow_overwritable = allow_overwritable;
 
   FOR_EACH_DEFINED_FUNCTION (node)
     {
@@ -182,8 +180,7 @@
       enum availability avail = node->get_availability ();
 
       if (avail > AVAIL_INTERPOSABLE
-	  || (allow_overwritable
-	      && (avail == AVAIL_INTERPOSABLE)))
+	  || avail == AVAIL_INTERPOSABLE)
 	{
 	  /* Reuse the info if it is already there.  */
 	  struct ipa_dfs_info *info = (struct ipa_dfs_info *) node->aux;
Index: gcc/ipa-utils.h
===================================================================
--- a/src/gcc/ipa-utils.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ipa-utils.h	(.../branches/gcc-7-branch)
@@ -36,7 +36,7 @@
 
 /* In ipa-utils.c  */
 void ipa_print_order (FILE*, const char *, struct cgraph_node**, int);
-int ipa_reduced_postorder (struct cgraph_node **, bool, bool,
+int ipa_reduced_postorder (struct cgraph_node **, bool,
 			  bool (*ignore_edge) (struct cgraph_edge *));
 void ipa_free_postorder_info (void);
 vec<cgraph_node *> ipa_get_nodes_in_cycle (struct cgraph_node *);
Index: gcc/lto-wrapper.c
===================================================================
--- a/src/gcc/lto-wrapper.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/lto-wrapper.c	(.../branches/gcc-7-branch)
@@ -1403,7 +1403,9 @@
 	  struct pex_obj *pex;
 	  char jobs[32];
 
-	  fprintf (mstream, "all:");
+	  fprintf (mstream,
+		   ".PHONY: all\n"
+		   "all:");
 	  for (i = 0; i < nr; ++i)
 	    fprintf (mstream, " \\\n\t%s", output_names[i]);
 	  fprintf (mstream, "\n");
Index: gcc/tree-ssa-sink.c
===================================================================
--- a/src/gcc/tree-ssa-sink.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssa-sink.c	(.../branches/gcc-7-branch)
@@ -431,7 +431,10 @@
 	  if (sinkbb == frombb)
 	    return false;
 
-	  *togsi = gsi_for_stmt (use);
+	  if (sinkbb == gimple_bb (use))
+	    *togsi = gsi_for_stmt (use);
+	  else
+	    *togsi = gsi_after_labels (sinkbb);
 
 	  return true;
 	}
Index: gcc/ipa-inline.c
===================================================================
--- a/src/gcc/ipa-inline.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ipa-inline.c	(.../branches/gcc-7-branch)
@@ -1745,7 +1745,7 @@
      metrics.  */
 
   max_count = 0;
-  ipa_reduced_postorder (order, true, true, NULL);
+  ipa_reduced_postorder (order, true, NULL);
   free (order);
 
   FOR_EACH_DEFINED_FUNCTION (node)
Index: gcc/dwarf2out.c
===================================================================
--- a/src/gcc/dwarf2out.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/dwarf2out.c	(.../branches/gcc-7-branch)
@@ -12495,6 +12495,8 @@
 	       && TYPE_PRECISION (sizetype) == TYPE_PRECISION (size_type_node)
 	       && TYPE_UNSIGNED (sizetype) == TYPE_UNSIGNED (size_type_node))
 	qualified_type = size_type_node;
+      if (type == sizetype)
+	type = qualified_type;
     }
 
 
@@ -18677,6 +18679,9 @@
 
     case HIGH:
     case CONST_FIXED:
+    case MINUS:
+    case SIGN_EXTEND:
+    case ZERO_EXTEND:
       return false;
 
     case MEM:
@@ -21207,7 +21212,10 @@
 
       /* If the contexts differ, we may not be talking about the same
 	 thing.  */
-      if (parm_die && parm_die->die_parent != context_die)
+      if (parm_die
+	  && parm_die->die_parent != context_die
+	  && (parm_die->die_parent->die_tag != DW_TAG_GNU_formal_parameter_pack
+	      || parm_die->die_parent->die_parent != context_die))
 	{
 	  if (!DECL_ABSTRACT_P (node))
 	    {
Index: gcc/match.pd
===================================================================
--- a/src/gcc/match.pd	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/match.pd	(.../branches/gcc-7-branch)
@@ -1753,6 +1753,13 @@
        && (TYPE_SIZE (TREE_TYPE (@0)) == TYPE_SIZE (TREE_TYPE (@1))))
    (view_convert @1)))
 
+/* Simplify a view-converted empty constructor.  */
+(simplify
+  (view_convert CONSTRUCTOR@0)
+  (if (TREE_CODE (@0) != SSA_NAME
+       && CONSTRUCTOR_NELTS (@0) == 0)
+   { build_zero_cst (type); }))
+
 /* Re-association barriers around constants and other re-association
    barriers can be removed.  */
 (simplify
Index: gcc/expr.c
===================================================================
--- a/src/gcc/expr.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/expr.c	(.../branches/gcc-7-branch)
@@ -1607,18 +1607,8 @@
   else if (may_use_call
 	   && ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (x))
 	   && ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (y)))
-    {
-      /* Since x and y are passed to a libcall, mark the corresponding
-	 tree EXPR as addressable.  */
-      tree y_expr = MEM_EXPR (y);
-      tree x_expr = MEM_EXPR (x);
-      if (y_expr)
-	mark_addressable (y_expr);
-      if (x_expr)
-	mark_addressable (x_expr);
-      retval = emit_block_copy_via_libcall (x, y, size,
-					    method == BLOCK_OP_TAILCALL);
-    }
+    retval = emit_block_copy_via_libcall (x, y, size,
+					  method == BLOCK_OP_TAILCALL);
 
   else
     emit_block_move_via_loop (x, y, size, align);
@@ -1859,6 +1849,15 @@
   tree call_expr, dst_tree, src_tree, size_tree;
   machine_mode size_mode;
 
+  /* Since dst and src are passed to a libcall, mark the corresponding
+     tree EXPR as addressable.  */
+  tree dst_expr = MEM_EXPR (dst);
+  tree src_expr = MEM_EXPR (src);
+  if (dst_expr)
+    mark_addressable (dst_expr);
+  if (src_expr)
+    mark_addressable (src_expr);
+
   dst_addr = copy_addr_to_reg (XEXP (dst, 0));
   dst_addr = convert_memory_address (ptr_mode, dst_addr);
   dst_tree = make_tree (ptr_type_node, dst_addr);
@@ -5147,9 +5146,14 @@
 		}
 	      else
 		{
-		  rtx from_rtx
-		    = simplify_gen_subreg (GET_MODE (to_rtx), result,
-					   TYPE_MODE (TREE_TYPE (from)), 0);
+		  rtx from_rtx;
+		  if (MEM_P (result))
+		    from_rtx = change_address (result, GET_MODE (to_rtx),
+					       NULL_RTX);
+		  else
+		    from_rtx
+		      = simplify_gen_subreg (GET_MODE (to_rtx), result,
+					     TYPE_MODE (TREE_TYPE (from)), 0);
 		  if (from_rtx)
 		    {
 		      emit_move_insn (XEXP (to_rtx, 0),
@@ -5191,6 +5195,21 @@
 	      emit_move_insn (XEXP (to_rtx, 1), read_complex_part (temp, true));
 	    }
 	}
+      /* For calls to functions returning variable length structures, if TO_RTX
+	 is not a MEM, go through a MEM because we must not create temporaries
+	 of the VLA type.  */
+      else if (!MEM_P (to_rtx)
+	       && TREE_CODE (from) == CALL_EXPR
+	       && COMPLETE_TYPE_P (TREE_TYPE (from))
+	       && TREE_CODE (TYPE_SIZE (TREE_TYPE (from))) != INTEGER_CST)
+	{
+	  rtx temp = assign_stack_temp (GET_MODE (to_rtx),
+					GET_MODE_SIZE (GET_MODE (to_rtx)));
+	  result = store_field (temp, bitsize, bitpos, bitregion_start,
+				bitregion_end, mode1, from, get_alias_set (to),
+				nontemporal, reversep);
+	  emit_move_insn (to_rtx, temp);
+	}
       else
 	{
 	  if (MEM_P (to_rtx))
@@ -8671,7 +8690,7 @@
 	  machine_mode innermode = TYPE_MODE (TREE_TYPE (treeop0));
 	  this_optab = usmul_widen_optab;
 	  if (find_widening_optab_handler (this_optab, mode, innermode, 0)
-		!= CODE_FOR_nothing)
+	      != CODE_FOR_nothing)
 	    {
 	      if (TYPE_UNSIGNED (TREE_TYPE (treeop0)))
 		expand_operands (treeop0, treeop1, NULL_RTX, &op0, &op1,
@@ -8683,8 +8702,8 @@
 		 != INTEGER_CST check.  Handle it.  */
 	      if (GET_MODE (op0) == VOIDmode && GET_MODE (op1) == VOIDmode)
 		{
-		  op0 = convert_modes (innermode, mode, op0, true);
-		  op1 = convert_modes (innermode, mode, op1, false);
+		  op0 = convert_modes (mode, innermode, op0, true);
+		  op1 = convert_modes (mode, innermode, op1, false);
 		  return REDUCE_BIT_FIELD (expand_mult (mode, op0, op1,
 							target, unsignedp));
 		}
@@ -8706,7 +8725,7 @@
 	  if (TREE_CODE (treeop0) != INTEGER_CST)
 	    {
 	      if (find_widening_optab_handler (this_optab, mode, innermode, 0)
-		    != CODE_FOR_nothing)
+		  != CODE_FOR_nothing)
 		{
 		  expand_operands (treeop0, treeop1, NULL_RTX, &op0, &op1,
 				   EXPAND_NORMAL);
@@ -8715,9 +8734,9 @@
 		  if (GET_MODE (op0) == VOIDmode && GET_MODE (op1) == VOIDmode)
 		    {
 		     widen_mult_const:
-		      op0 = convert_modes (innermode, mode, op0, zextend_p);
+		      op0 = convert_modes (mode, innermode, op0, zextend_p);
 		      op1
-			= convert_modes (innermode, mode, op1,
+			= convert_modes (mode, innermode, op1,
 					 TYPE_UNSIGNED (TREE_TYPE (treeop1)));
 		      return REDUCE_BIT_FIELD (expand_mult (mode, op0, op1,
 							    target,
@@ -8728,21 +8747,19 @@
 		  return REDUCE_BIT_FIELD (temp);
 		}
 	      if (find_widening_optab_handler (other_optab, mode, innermode, 0)
-		    != CODE_FOR_nothing
+		  != CODE_FOR_nothing
 		  && innermode == word_mode)
 		{
 		  rtx htem, hipart;
 		  op0 = expand_normal (treeop0);
-		  if (TREE_CODE (treeop1) == INTEGER_CST)
-		    op1 = convert_modes (innermode, mode,
-					 expand_normal (treeop1),
-					 TYPE_UNSIGNED (TREE_TYPE (treeop1)));
-		  else
-		    op1 = expand_normal (treeop1);
-		  /* op0 and op1 might still be constant, despite the above
+		  op1 = expand_normal (treeop1);
+		  /* op0 and op1 might be constants, despite the above
 		     != INTEGER_CST check.  Handle it.  */
 		  if (GET_MODE (op0) == VOIDmode && GET_MODE (op1) == VOIDmode)
 		    goto widen_mult_const;
+		  if (TREE_CODE (treeop1) == INTEGER_CST)
+		    op1 = convert_modes (mode, word_mode, op1,
+					 TYPE_UNSIGNED (TREE_TYPE (treeop1)));
 		  temp = expand_binop (mode, other_optab, op0, op1, target,
 				       unsignedp, OPTAB_LIB_WIDEN);
 		  hipart = gen_highpart (innermode, temp);
Index: gcc/opts.c
===================================================================
--- a/src/gcc/opts.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/opts.c	(.../branches/gcc-7-branch)
@@ -654,9 +654,18 @@
   /* For -O1 only do loop invariant motion for very small loops.  */
   maybe_set_param_value
     (PARAM_LOOP_INVARIANT_MAX_BBS_IN_LOOP,
-     opt2 ? default_param_value (PARAM_LOOP_INVARIANT_MAX_BBS_IN_LOOP) : 1000,
+     opt2 ? default_param_value (PARAM_LOOP_INVARIANT_MAX_BBS_IN_LOOP)
+     : default_param_value (PARAM_LOOP_INVARIANT_MAX_BBS_IN_LOOP) / 10,
      opts->x_param_values, opts_set->x_param_values);
 
+  /* For -O1 reduce the maximum number of active local stores for RTL DSE
+     since this can consume huge amounts of memory (PR89115).  */
+  maybe_set_param_value
+    (PARAM_MAX_DSE_ACTIVE_LOCAL_STORES,
+     opt2 ? default_param_value (PARAM_MAX_DSE_ACTIVE_LOCAL_STORES)
+     : default_param_value (PARAM_MAX_DSE_ACTIVE_LOCAL_STORES) / 10,
+     opts->x_param_values, opts_set->x_param_values);
+
   /* At -Ofast, allow store motion to introduce potential race conditions.  */
   maybe_set_param_value
     (PARAM_ALLOW_STORE_DATA_RACES,
Index: gcc/tree-ssa-loop-ivcanon.c
===================================================================
--- a/src/gcc/tree-ssa-loop-ivcanon.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssa-loop-ivcanon.c	(.../branches/gcc-7-branch)
@@ -1131,7 +1131,7 @@
   niter = number_of_latch_executions (loop);
   exit = single_exit (loop);
   if (TREE_CODE (niter) == INTEGER_CST)
-    locus = gimple_location (last_stmt (exit->src));
+    locus = gimple_location_safe (last_stmt (exit->src));
   else
     {
       /* If the loop has more than one exit, try checking all of them
@@ -1146,7 +1146,7 @@
 	niter = find_loop_niter_by_eval (loop, &exit);
 
       if (exit)
-        locus = gimple_location (last_stmt (exit->src));
+        locus = gimple_location_safe (last_stmt (exit->src));
 
       if (TREE_CODE (niter) != INTEGER_CST)
 	exit = NULL;
Index: gcc/ada/sem_util.adb
===================================================================
--- a/src/gcc/ada/sem_util.adb	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ada/sem_util.adb	(.../branches/gcc-7-branch)
@@ -5203,10 +5203,7 @@
    -- Defining_Entity --
    ---------------------
 
-   function Defining_Entity
-     (N               : Node_Id;
-      Empty_On_Errors : Boolean := False) return Entity_Id
-   is
+   function Defining_Entity (N : Node_Id) return Entity_Id is
       Err : Entity_Id := Empty;
 
    begin
@@ -5285,14 +5282,10 @@
                --  can continue semantic analysis.
 
                elsif Nam = Error then
-                  if Empty_On_Errors then
-                     return Empty;
-                  else
-                     Err := Make_Temporary (Sloc (N), 'T');
-                     Set_Defining_Unit_Name (N, Err);
+                  Err := Make_Temporary (Sloc (N), 'T');
+                  Set_Defining_Unit_Name (N, Err);
 
-                     return Err;
-                  end if;
+                  return Err;
 
                --  If not an entity, get defining identifier
 
@@ -5307,11 +5300,7 @@
             return Entity (Identifier (N));
 
          when others =>
-            if Empty_On_Errors then
-               return Empty;
-            else
-               raise Program_Error;
-            end if;
+            raise Program_Error;
       end case;
    end Defining_Entity;
 
Index: gcc/ada/sem_util.ads
===================================================================
--- a/src/gcc/ada/sem_util.ads	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ada/sem_util.ads	(.../branches/gcc-7-branch)
@@ -474,9 +474,7 @@
    --  in the case of a descendant of a generic formal type (returns Int'Last
    --  instead of 0).
 
-   function Defining_Entity
-     (N               : Node_Id;
-      Empty_On_Errors : Boolean := False) return Entity_Id;
+   function Defining_Entity (N : Node_Id) return Entity_Id;
    --  Given a declaration N, returns the associated defining entity. If the
    --  declaration has a specification, the entity is obtained from the
    --  specification. If the declaration has a defining unit name, then the
@@ -487,19 +485,6 @@
    --  local entities declared during loop expansion. These entities need
    --  debugging information, generated through Qualify_Entity_Names, and
    --  the loop declaration must be placed in the table Name_Qualify_Units.
-   --
-   --  Set flag Empty_On_Error to change the behavior of this routine as
-   --  follows:
-   --
-   --    * True  - A declaration that lacks a defining entity returns Empty.
-   --      A node that does not allow for a defining entity returns Empty.
-   --
-   --    * False - A declaration that lacks a defining entity is given a new
-   --      internally generated entity which is subsequently returned. A node
-   --      that does not allow for a defining entity raises Program_Error.
-   --
-   --  The former semantics is appropriate for the back end; the latter
-   --  semantics is appropriate for the front end.
 
    function Denotes_Discriminant
      (N                : Node_Id;
Index: gcc/ada/gnatlink.adb
===================================================================
--- a/src/gcc/ada/gnatlink.adb	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ada/gnatlink.adb	(.../branches/gcc-7-branch)
@@ -1888,6 +1888,7 @@
       Clean_Link_Option_Set : declare
          J                  : Natural;
          Shared_Libgcc_Seen : Boolean := False;
+         Static_Libgcc_Seen : Boolean := False;
 
       begin
          J := Linker_Options.First;
@@ -1909,7 +1910,7 @@
                end if;
             end if;
 
-            --  Remove duplicate -shared-libgcc switch
+            --  Remove duplicate -shared-libgcc switches
 
             if Linker_Options.Table (J).all = Shared_Libgcc_String then
                if Shared_Libgcc_Seen then
@@ -1923,6 +1924,20 @@
                end if;
             end if;
 
+            --  Remove duplicate -static-libgcc switches
+
+            if Linker_Options.Table (J).all = Static_Libgcc_String then
+               if Static_Libgcc_Seen then
+                  Linker_Options.Table (J .. Linker_Options.Last - 1) :=
+                    Linker_Options.Table (J + 1 .. Linker_Options.Last);
+                  Linker_Options.Decrement_Last;
+                  Num_Args := Num_Args - 1;
+
+               else
+                  Static_Libgcc_Seen := True;
+               end if;
+            end if;
+
             --  Here we just check for a canonical form that matches the
             --  pragma Linker_Options set in the NT runtime.
 
@@ -1954,14 +1969,27 @@
             --  libgcc, if gcc is not called with -shared-libgcc, call it
             --  with -static-libgcc, as there are some platforms where one
             --  of these two switches is compulsory to link.
+            --  Don't push extra switches if we already saw one.
 
             if Shared_Libgcc_Default = 'T'
               and then not Shared_Libgcc_Seen
+              and then not Static_Libgcc_Seen
             then
                Linker_Options.Increment_Last;
                Linker_Options.Table (Linker_Options.Last) := Static_Libgcc;
                Num_Args := Num_Args + 1;
             end if;
+
+            --  Likewise, the reverse.
+
+            if Shared_Libgcc_Default = 'H'
+              and then not Static_Libgcc_Seen
+              and then not Shared_Libgcc_Seen
+            then
+               Linker_Options.Increment_Last;
+               Linker_Options.Table (Linker_Options.Last) := Shared_Libgcc;
+               Num_Args := Num_Args + 1;
+            end if;
          end if;
       end Clean_Link_Option_Set;
 
Index: gcc/ada/exp_ch6.adb
===================================================================
--- a/src/gcc/ada/exp_ch6.adb	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ada/exp_ch6.adb	(.../branches/gcc-7-branch)
@@ -3937,6 +3937,23 @@
               Unchecked_Convert_To
                 (RTE (RE_Address), Relocate_Node (First_Actual (Call_Node))));
             return;
+
+         --  A call to a null procedure is replaced by a null statement, but we
+         --  are not allowed to ignore possible side effects of the call, so we
+         --  make sure that actuals are evaluated.
+         --  We also suppress this optimization for GNATCoverage.
+
+         elsif Is_Null_Procedure (Subp)
+           and then not Opt.Suppress_Control_Flow_Optimizations
+         then
+            Actual := First_Actual (Call_Node);
+            while Present (Actual) loop
+               Remove_Side_Effects (Actual);
+               Next_Actual (Actual);
+            end loop;
+
+            Rewrite (Call_Node, Make_Null_Statement (Loc));
+            return;
          end if;
 
          --  Handle inlining. No action needed if the subprogram is not inlined
Index: gcc/ada/ChangeLog
===================================================================
--- a/src/gcc/ada/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ada/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,139 @@
+2019-10-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/91995
+	* sem_util.ads (Defining_Entity): Remove 2nd and 3th parameters.
+	* sem_util.adb (Defining_Entity): Remove 2nd and 3th parameters,
+	and adjust accordingly.
+
+2019-10-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (annotate_value) <INTEGER_CST>: Really test the
+	sign of the value when deciding to build a NEGATE_EXPR.
+	<PLUS_EXPR>: Remove redundant line.
+	<BIT_AND_EXPR>: Do the negation here.
+
+2019-09-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (Attribute_to_gnu): Test Can_Use_Internal_Rep
+	on the underlying type of the node.
+	(Call_to_gnu): Likewise with the type of the prefix.
+
+2019-09-06  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-07-02  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* system-darwin-ppc.ads: Set Stack_Check_Probes True for
+	PPC Darwin.
+
+2019-09-06  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gnatlink.adb (Link_Step): Push -shared-libgcc explicitly, when it
+	is the target default (unless overidden by the static flag).
+	When the user has put an instance of shared/static-libgcc do not push
+	a duplicate of this.
+
+2019-06-29  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (mark_visited_r): Set TYPE_SIZES_GIMPLIFIED on
+	the main variant of a type, if any.
+
+2019-06-29  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (set_nonaliased_component_on_array_type): Add
+	missing guard for the presence of TYPE_CANONICAL.
+	(set_reverse_storage_order_on_array_type): Likewise.
+
+2019-05-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (walk_nesting_tree): New static function.
+	(finalize_nrv): Use it to walk the entire nesting tree.
+
+2019-05-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* gcc-interface/Makefile.in (install-gcc-specs): Use foreach.
+	Honor DESTDIR.
+
+2019-02-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/81956
+	Backport from mainline
+	2017-09-06  Ed Schonberg  <schonberg@adacore.com>
+
+	* exp_ch6.adb (Expand_Call_Helper): Do not optimize calls to
+	null procedures when GNAT coverage is used, so that their (empty)
+	bodies are properly covered.
+
+	2017-09-06  Ed Schonberg  <schonberg@adacore.com>
+
+	* exp_ch6.adb (Expand_Call_Helper): Replace call to null
+	procedure by a single null statement, after evaluating the
+	actuals that require it.
+
+2019-02-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/89349
+	Backport from mainline
+	2018-05-25  Arnaud Charlet  <charlet@adacore.com>
+
+	* osint.ads (Unknown_Attributes): No longer pretend this is a constant.
+	(No_File_Info_Cache): Initialize separately.
+	* osint.adb (No_File_Info_Cache): Update initializer.
+
+2019-02-08  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (Loop_Statement_to_gnu): Replace tests on
+	individual flag_unswitch_loops and flag_tree_loop_vectorize switches
+	with test on global optimize switch.
+	(Raise_Error_to_gnu): Likewise.
+
+2019-02-07  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* s-linux-sparc.ads (ETIMEDOUT): Set to correct value.
+
+2019-02-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2017-09-05  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (annotate_value): Tidy up.
+	<INTEGER_CST>: Set TCODE instead of recursing.
+	<COMPONENT_REF>: Set TCODE instead of calling Create_Node manually.
+	<MULT_EXPR, PLUS_EXPR>: Fold conversions into inner operations.
+	<BIT_AND_EXPR>: Adjust.
+	<CALL_EXPR>: Do not fall through.
+
+2019-01-27  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (array_type_has_nonaliased_component): Return
+	the same value for every dimension of a multidimensional array type.
+
+2019-01-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (gnat_to_gnu) <N_Assignment_Statement>: Use
+	DECL_SIZE_UNIT instead of TYPE_SIZE_UNIT for the size to be assigned
+	by a call to memset if the LHS is a DECL.
+
+2019-01-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (struct loop_info_d): Remove artificial field.
+	(Loop_Statement_to_gnu): Do not set it.
+
+2019-01-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (annotate_value) <INTEGER_CST>: Use test on
+	the sign bit instead of on the sign of the value.
+	<PLUS_EXPR>: Turn addition of negative constant into subtraction.
+	<BIT_AND_EXPR>: Simplify.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* adaint.c [__APPLE__] (__gnat_lwp_self): Ensure that the system
+	interface used is available on the target.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: gcc/ada/s-linux-sparc.ads
===================================================================
--- a/src/gcc/ada/s-linux-sparc.ads	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ada/s-linux-sparc.ads	(.../branches/gcc-7-branch)
@@ -70,7 +70,7 @@
    EINVAL    : constant := 22;
    ENOMEM    : constant := 12;
    EPERM     : constant := 1;
-   ETIMEDOUT : constant := 110;
+   ETIMEDOUT : constant := 60;
 
    -------------
    -- Signals --
Index: gcc/ada/system-darwin-ppc.ads
===================================================================
--- a/src/gcc/ada/system-darwin-ppc.ads	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ada/system-darwin-ppc.ads	(.../branches/gcc-7-branch)
@@ -158,7 +158,7 @@
    Preallocated_Stacks       : constant Boolean := False;
    Signed_Zeros              : constant Boolean := True;
    Stack_Check_Default       : constant Boolean := False;
-   Stack_Check_Probes        : constant Boolean := False;
+   Stack_Check_Probes        : constant Boolean := True;
    Stack_Check_Limits        : constant Boolean := False;
    Support_Aggregates        : constant Boolean := True;
    Support_Atomic_Primitives : constant Boolean := Word_Size = 64;
Index: gcc/ada/adaint.c
===================================================================
--- a/src/gcc/ada/adaint.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ada/adaint.c	(.../branches/gcc-7-branch)
@@ -3174,9 +3174,13 @@
 #endif
 
 #if defined (__APPLE__)
-#include <mach/thread_info.h>
-#include <mach/mach_init.h>
-#include <mach/thread_act.h>
+# if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1060
+#  include <mach/thread_info.h>
+#  include <mach/mach_init.h>
+#  include <mach/thread_act.h>
+# else
+#  include <pthread.h>
+# endif
 
 /* System-wide thread identifier.  Note it could be truncated on 32 bit
    hosts.
@@ -3184,6 +3188,7 @@
 void *
 __gnat_lwp_self (void)
 {
+#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1060
   thread_identifier_info_data_t data;
   mach_msg_type_number_t count = THREAD_IDENTIFIER_INFO_COUNT;
   kern_return_t kret;
@@ -3194,6 +3199,9 @@
     return (void *)(uintptr_t)data.thread_id;
   else
     return 0;
+#else
+  return (void *)pthread_mach_thread_np (pthread_self ());
+#endif
 }
 #endif
 
Index: gcc/ada/gcc-interface/Makefile.in
===================================================================
--- a/src/gcc/ada/gcc-interface/Makefile.in	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ada/gcc-interface/Makefile.in	(.../branches/gcc-7-branch)
@@ -2660,9 +2660,8 @@
 install-gcc-specs:
 #	Install all the requested GCC spec files.
 
-	for f in $(GCC_SPEC_FILES); do \
-	    $(INSTALL_DATA_DATE) $(srcdir)/ada/$$f $(libsubdir)/; \
-	done
+	$(foreach f,$(GCC_SPEC_FILES), \
+	    $(INSTALL_DATA_DATE) $(srcdir)/ada/$(f) $(DESTDIR)$(libsubdir)/;)
 
 install-gnatlib: ../stamp-gnatlib-$(RTSDIR) install-gcc-specs
 	$(RMDIR) $(DESTDIR)$(ADA_RTL_OBJ_DIR)
Index: gcc/ada/gcc-interface/decl.c
===================================================================
--- a/src/gcc/ada/gcc-interface/decl.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ada/gcc-interface/decl.c	(.../branches/gcc-7-branch)
@@ -6307,7 +6307,8 @@
 set_nonaliased_component_on_array_type (tree type)
 {
   TYPE_NONALIASED_COMPONENT (type) = 1;
-  TYPE_NONALIASED_COMPONENT (TYPE_CANONICAL (type)) = 1;
+  if (TYPE_CANONICAL (type))
+    TYPE_NONALIASED_COMPONENT (TYPE_CANONICAL (type)) = 1;
 }
 
 /* Set TYPE_REVERSE_STORAGE_ORDER on an array type built by means of
@@ -6317,7 +6318,8 @@
 set_reverse_storage_order_on_array_type (tree type)
 {
   TYPE_REVERSE_STORAGE_ORDER (type) = 1;
-  TYPE_REVERSE_STORAGE_ORDER (TYPE_CANONICAL (type)) = 1;
+  if (TYPE_CANONICAL (type))
+    TYPE_REVERSE_STORAGE_ORDER (TYPE_CANONICAL (type)) = 1;
 }
 
 /* Return true if DISCR1 and DISCR2 represent the same discriminant.  */
@@ -6341,12 +6343,6 @@
 static bool
 array_type_has_nonaliased_component (tree gnu_type, Entity_Id gnat_type)
 {
-  /* If the array type is not the innermost dimension of the GNAT type,
-     then it has a non-aliased component.  */
-  if (TREE_CODE (TREE_TYPE (gnu_type)) == ARRAY_TYPE
-      && TYPE_MULTI_ARRAY_P (TREE_TYPE (gnu_type)))
-    return true;
-
   /* If the array type has an aliased component in the front-end sense,
      then it also has an aliased component in the back-end sense.  */
   if (Has_Aliased_Components (gnat_type))
@@ -6357,15 +6353,17 @@
   if (Is_Derived_Type (gnat_type))
     {
       tree gnu_parent_type = gnat_to_gnu_type (Etype (gnat_type));
-      int index;
       if (TREE_CODE (gnu_parent_type) == UNCONSTRAINED_ARRAY_TYPE)
 	gnu_parent_type
 	  = TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_parent_type))));
-      for (index = Number_Dimensions (gnat_type) - 1; index > 0; index--)
-	gnu_parent_type = TREE_TYPE (gnu_parent_type);
       return TYPE_NONALIASED_COMPONENT (gnu_parent_type);
     }
 
+  /* For a multi-dimensional array type, find the component type.  */
+  while (TREE_CODE (TREE_TYPE (gnu_type)) == ARRAY_TYPE
+	 && TYPE_MULTI_ARRAY_P (TREE_TYPE (gnu_type)))
+    gnu_type = TREE_TYPE (gnu_type);
+
   /* Otherwise, rely exclusively on properties of the element type.  */
   return type_for_nonaliased_component_p (TREE_TYPE (gnu_type));
 }
@@ -8052,9 +8050,8 @@
 annotate_value (tree gnu_size)
 {
   TCode tcode;
-  Node_Ref_Or_Val ops[3], ret, pre_op1 = No_Uint;
+  Node_Ref_Or_Val ops[3] = { No_Uint, No_Uint, No_Uint };
   struct tree_int_map in;
-  int i;
 
   /* See if we've already saved the value for this node.  */
   if (EXPR_P (gnu_size))
@@ -8071,9 +8068,7 @@
     in.base.from = NULL_TREE;
 
   /* If we do not return inside this switch, TCODE will be set to the
-     code to use for a Create_Node operand and LEN (set above) will be
-     the number of recursive calls for us to make.  */
-
+     code to be used in a call to Create_Node.  */
   switch (TREE_CODE (gnu_size))
     {
     case INTEGER_CST:
@@ -8082,38 +8077,46 @@
       if (tree_int_cst_sgn (gnu_size) < 0)
 	{
 	  tree t = wide_int_to_tree (sizetype, wi::neg (gnu_size));
-	  return annotate_value (build1 (NEGATE_EXPR, sizetype, t));
+	  tcode = Negate_Expr;
+	  ops[0] = UI_From_gnu (t);
 	}
+      else
+	return TREE_OVERFLOW (gnu_size) ? No_Uint : UI_From_gnu (gnu_size);
+      break;
 
-      return TREE_OVERFLOW (gnu_size) ? No_Uint : UI_From_gnu (gnu_size);
-
     case COMPONENT_REF:
       /* The only case we handle here is a simple discriminant reference.  */
       if (DECL_DISCRIMINANT_NUMBER (TREE_OPERAND (gnu_size, 1)))
 	{
-	  tree n = DECL_DISCRIMINANT_NUMBER (TREE_OPERAND (gnu_size, 1));
+	  tree ref = gnu_size;
+	  gnu_size = TREE_OPERAND (ref, 1);
 
 	  /* Climb up the chain of successive extensions, if any.  */
-	  while (TREE_CODE (TREE_OPERAND (gnu_size, 0)) == COMPONENT_REF
-		 && DECL_NAME (TREE_OPERAND (TREE_OPERAND (gnu_size, 0), 1))
+	  while (TREE_CODE (TREE_OPERAND (ref, 0)) == COMPONENT_REF
+		 && DECL_NAME (TREE_OPERAND (TREE_OPERAND (ref, 0), 1))
 		    == parent_name_id)
-	    gnu_size = TREE_OPERAND (gnu_size, 0);
+	    ref = TREE_OPERAND (ref, 0);
 
-	  if (TREE_CODE (TREE_OPERAND (gnu_size, 0)) == PLACEHOLDER_EXPR)
-	    return
-	      Create_Node (Discrim_Val, annotate_value (n), No_Uint, No_Uint);
+	  if (TREE_CODE (TREE_OPERAND (ref, 0)) == PLACEHOLDER_EXPR)
+	    {
+	      /* Fall through to common processing as a FIELD_DECL.  */
+	      tcode = Discrim_Val;
+	      ops[0] = UI_From_gnu (DECL_DISCRIMINANT_NUMBER (gnu_size));
+	    }
+	  else
+	    return No_Uint;
 	}
+      else
+	return No_Uint;
+      break;
 
-      return No_Uint;
-
-    CASE_CONVERT:   case NON_LVALUE_EXPR:
+    CASE_CONVERT:
+    case NON_LVALUE_EXPR:
       return annotate_value (TREE_OPERAND (gnu_size, 0));
 
       /* Now just list the operations we handle.  */
     case COND_EXPR:		tcode = Cond_Expr; break;
-    case PLUS_EXPR:		tcode = Plus_Expr; break;
     case MINUS_EXPR:		tcode = Minus_Expr; break;
-    case MULT_EXPR:		tcode = Mult_Expr; break;
     case TRUNC_DIV_EXPR:	tcode = Trunc_Div_Expr; break;
     case CEIL_DIV_EXPR:		tcode = Ceil_Div_Expr; break;
     case FLOOR_DIV_EXPR:	tcode = Floor_Div_Expr; break;
@@ -8138,20 +8141,55 @@
     case EQ_EXPR:		tcode = Eq_Expr; break;
     case NE_EXPR:		tcode = Ne_Expr; break;
 
+    case PLUS_EXPR:
+      /* Turn addition of negative constant into subtraction.  */
+      if (TREE_CODE (TREE_OPERAND (gnu_size, 1)) == INTEGER_CST
+	  && tree_int_cst_sign_bit (TREE_OPERAND (gnu_size, 1)))
+	{
+	  tcode = Minus_Expr;
+	  wide_int wop1 = wi::neg (TREE_OPERAND (gnu_size, 1));
+	  ops[1] = annotate_value (wide_int_to_tree (sizetype, wop1));
+	  break;
+	}
+
+      /* ... fall through ... */
+
+    case MULT_EXPR:
+      tcode = (TREE_CODE (gnu_size) == MULT_EXPR ? Mult_Expr : Plus_Expr);
+      /* Fold conversions from bytes to bits into inner operations.  */
+      if (TREE_CODE (TREE_OPERAND (gnu_size, 1)) == INTEGER_CST
+	  && CONVERT_EXPR_P (TREE_OPERAND (gnu_size, 0)))
+	{
+	  tree inner_op = TREE_OPERAND (TREE_OPERAND (gnu_size, 0), 0);
+	  if (TREE_CODE (inner_op) == TREE_CODE (gnu_size)
+	      && TREE_CODE (TREE_OPERAND (inner_op, 1)) == INTEGER_CST)
+	    {
+	      ops[0] = annotate_value (TREE_OPERAND (inner_op, 0));
+	      tree inner_op_op1 = TREE_OPERAND (inner_op, 1);
+	      tree gnu_size_op1 = TREE_OPERAND (gnu_size, 1);
+	      wide_int op1;
+	      if (TREE_CODE (gnu_size) == MULT_EXPR)
+		op1 = wi::mul (inner_op_op1, gnu_size_op1);
+	      else
+		{
+		  op1 = wi::add (inner_op_op1, gnu_size_op1);
+		  if (wi::zext (op1, TYPE_PRECISION (sizetype)) == 0)
+		    return ops[0];
+		}
+	      ops[1] = annotate_value (wide_int_to_tree (sizetype, op1));
+	    }
+	}
+      break;
+
     case BIT_AND_EXPR:
       tcode = Bit_And_Expr;
       /* For negative values in sizetype, build NEGATE_EXPR of the opposite.
-	 Such values appear in expressions with aligning patterns.  Note that,
-	 since sizetype is unsigned, we have to jump through some hoops.   */
+	 Such values can appear in expressions with aligning patterns.  */
       if (TREE_CODE (TREE_OPERAND (gnu_size, 1)) == INTEGER_CST)
 	{
-	  tree op1 = TREE_OPERAND (gnu_size, 1);
-	  wide_int signed_op1 = wi::sext (op1, TYPE_PRECISION (sizetype));
-	  if (wi::neg_p (signed_op1))
-	    {
-	      op1 = wide_int_to_tree (sizetype, wi::neg (signed_op1));
-	      pre_op1 = annotate_value (build1 (NEGATE_EXPR, sizetype, op1));
-	    }
+	  wide_int wop1 = wi::neg (TREE_OPERAND (gnu_size, 1));
+	  tree op1 = wide_int_to_tree (sizetype, wop1);
+	  ops[1] = annotate_value (build1 (NEGATE_EXPR, sizetype, op1));
 	}
       break;
 
@@ -8162,14 +8200,11 @@
       if (List_Representation_Info == 3 || type_annotate_only)
 	{
 	  tree t = maybe_inline_call_in_expr (gnu_size);
-	  if (t)
-	    return annotate_value (t);
+	  return t ? annotate_value (t) : No_Uint;
 	}
       else
 	return Uint_Minus_1;
 
-      /* Fall through... */
-
     default:
       return No_Uint;
     }
@@ -8176,20 +8211,15 @@
 
   /* Now get each of the operands that's relevant for this code.  If any
      cannot be expressed as a repinfo node, say we can't.  */
-  for (i = 0; i < 3; i++)
-    ops[i] = No_Uint;
-
-  for (i = 0; i < TREE_CODE_LENGTH (TREE_CODE (gnu_size)); i++)
-    {
-      if (i == 1 && pre_op1 != No_Uint)
-	ops[i] = pre_op1;
-      else
+  for (int i = 0; i < TREE_CODE_LENGTH (TREE_CODE (gnu_size)); i++)
+    if (ops[i] == No_Uint)
+      {
 	ops[i] = annotate_value (TREE_OPERAND (gnu_size, i));
-      if (ops[i] == No_Uint)
-	return No_Uint;
-    }
+	if (ops[i] == No_Uint)
+	  return No_Uint;
+      }
 
-  ret = Create_Node (tcode, ops[0], ops[1], ops[2]);
+  Node_Ref_Or_Val ret = Create_Node (tcode, ops[0], ops[1], ops[2]);
 
   /* Save the result in the cache.  */
   if (in.base.from)
@@ -8202,7 +8232,7 @@
       h = annotate_value_cache->find_slot (&in, INSERT);
       gcc_assert (!*h);
       *h = ggc_alloc<tree_int_map> ();
-      (*h)->base.from = gnu_size;
+      (*h)->base.from = in.base.from;
       (*h)->to = ret;
     }
 
Index: gcc/ada/gcc-interface/trans.c
===================================================================
--- a/src/gcc/ada/gcc-interface/trans.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ada/gcc-interface/trans.c	(.../branches/gcc-7-branch)
@@ -197,7 +197,6 @@
   tree low_bound;
   tree high_bound;
   vec<range_check_info, va_gc> *checks;
-  bool artificial;
 };
 
 typedef struct loop_info_d *loop_info;
@@ -1707,32 +1706,29 @@
       /* For other address attributes applied to a nested function,
 	 find an inner ADDR_EXPR and annotate it so that we can issue
 	 a useful warning with -Wtrampolines.  */
-      else if (TREE_CODE (TREE_TYPE (gnu_prefix)) == FUNCTION_TYPE)
+      else if (TREE_CODE (TREE_TYPE (gnu_prefix)) == FUNCTION_TYPE
+	       && (gnu_expr = remove_conversions (gnu_result, false))
+	       && TREE_CODE (gnu_expr) == ADDR_EXPR
+	       && decl_function_context (TREE_OPERAND (gnu_expr, 0)))
 	{
-	  gnu_expr = remove_conversions (gnu_result, false);
+	  set_expr_location_from_node (gnu_expr, gnat_node);
 
-	  if (TREE_CODE (gnu_expr) == ADDR_EXPR
-	      && decl_function_context (TREE_OPERAND (gnu_expr, 0)))
-	    {
-	      set_expr_location_from_node (gnu_expr, gnat_node);
+	  /* Also check the inlining status.  */
+	  check_inlining_for_nested_subprog (TREE_OPERAND (gnu_expr, 0));
 
-	      /* Also check the inlining status.  */
-	      check_inlining_for_nested_subprog (TREE_OPERAND (gnu_expr, 0));
+	  /* Moreover, for 'Access or 'Unrestricted_Access with non-
+	     foreign-compatible representation, mark the ADDR_EXPR so
+	     that we can build a descriptor instead of a trampoline.  */
+	  if ((attribute == Attr_Access
+	       || attribute == Attr_Unrestricted_Access)
+	      && targetm.calls.custom_function_descriptors > 0
+	      && Can_Use_Internal_Rep (Underlying_Type (Etype (gnat_node))))
+	    FUNC_ADDR_BY_DESCRIPTOR (gnu_expr) = 1;
 
-	      /* Moreover, for 'Access or 'Unrestricted_Access with non-
-		 foreign-compatible representation, mark the ADDR_EXPR so
-		 that we can build a descriptor instead of a trampoline.  */
-	      if ((attribute == Attr_Access
-		   || attribute == Attr_Unrestricted_Access)
-		  && targetm.calls.custom_function_descriptors > 0
-		  && Can_Use_Internal_Rep (Etype (gnat_node)))
-		FUNC_ADDR_BY_DESCRIPTOR (gnu_expr) = 1;
-
-	      /* Otherwise, we need to check that we are not violating the
-		 No_Implicit_Dynamic_Code restriction.  */
-	      else if (targetm.calls.custom_function_descriptors != 0)
-	        Check_Implicit_Dynamic_Code_Allowed (gnat_node);
-	    }
+	  /* Otherwise, we need to check that we are not violating the
+	     No_Implicit_Dynamic_Code restriction.  */
+	  else if (targetm.calls.custom_function_descriptors != 0)
+	    Check_Implicit_Dynamic_Code_Allowed (gnat_node);
 	}
       break;
 
@@ -2841,7 +2837,6 @@
 
   /* Save the statement for later reuse.  */
   gnu_loop_info->stmt = gnu_loop_stmt;
-  gnu_loop_info->artificial = !Comes_From_Source (gnat_node);
 
   /* Set the condition under which the loop must keep going.
      For the case "LOOP .... END LOOP;" the condition is always true.  */
@@ -3104,7 +3099,7 @@
 	 unswitching is enabled, do not require the loop bounds to be also
 	 invariant, as their evaluation will still be ahead of the loop.  */
       if (vec_safe_length (gnu_loop_info->checks) > 0
-	 && (make_invariant (&gnu_low, &gnu_high) || flag_unswitch_loops))
+	 && (make_invariant (&gnu_low, &gnu_high) || optimize >= 3))
 	{
 	  struct range_check_info_d *rci;
 	  unsigned int i, n_remaining_checks = 0;
@@ -3156,14 +3151,15 @@
 
 	  /* Note that loop unswitching can only be applied a small number of
 	     times to a given loop (PARAM_MAX_UNSWITCH_LEVEL default to 3).  */
-	  if (0 < n_remaining_checks && n_remaining_checks <= 3
-	      && optimize > 1 && !optimize_size)
+	  if (IN_RANGE (n_remaining_checks, 1, 3)
+	      && optimize >= 2
+	      && !optimize_size)
 	    FOR_EACH_VEC_ELT (*gnu_loop_info->checks, i, rci)
 	      if (rci->invariant_cond != boolean_false_node)
 		{
 		  TREE_OPERAND (rci->inserted_cond, 0) = rci->invariant_cond;
 
-		  if (flag_unswitch_loops)
+		  if (optimize >= 3)
 		    add_stmt_with_node_force (rci->inserted_cond, gnat_node);
 		}
 	}
@@ -3170,8 +3166,7 @@
 
       /* Second, if loop vectorization is enabled and the iterations of the
 	 loop can easily be proved as independent, mark the loop.  */
-      if (optimize
-	  && flag_tree_loop_vectorize
+      if (optimize >= 3
 	  && independent_iterations_p (LOOP_STMT_BODY (gnu_loop_stmt)))
 	LOOP_STMT_IVDEP (gnu_loop_stmt) = 1;
 
@@ -3521,6 +3516,20 @@
   return NULL_TREE;
 }
 
+/* Apply FUNC to all the sub-trees of nested functions in NODE.  FUNC is called
+   with the DATA and the address of each sub-tree.  If FUNC returns a non-NULL
+   value, the traversal is stopped.  */
+
+static void
+walk_nesting_tree (struct cgraph_node *node, walk_tree_fn func, void *data)
+{
+  for (node = node->nested; node; node = node->next_nested)
+    {
+      walk_tree_without_duplicates (&DECL_SAVED_TREE (node->decl), func, data);
+      walk_nesting_tree (node, func, data);
+    }
+}
+
 /* Finalize the Named Return Value optimization for FNDECL.  The NRV bitmap
    contains the candidates for Named Return Value and OTHER is a list of
    the other return values.  GNAT_RET is a representative return node.  */
@@ -3528,7 +3537,6 @@
 static void
 finalize_nrv (tree fndecl, bitmap nrv, vec<tree, va_gc> *other, Node_Id gnat_ret)
 {
-  struct cgraph_node *node;
   struct nrv_data data;
   walk_tree_fn func;
   unsigned int i;
@@ -3549,10 +3557,7 @@
     return;
 
   /* Prune also the candidates that are referenced by nested functions.  */
-  node = cgraph_node::get_create (fndecl);
-  for (node = node->nested; node; node = node->next_nested)
-    walk_tree_without_duplicates (&DECL_SAVED_TREE (node->decl), prune_nrv_r,
-				  &data);
+  walk_nesting_tree (cgraph_node::get_create (fndecl), prune_nrv_r, &data);
   if (bitmap_empty_p (nrv))
     return;
 
@@ -4282,7 +4287,8 @@
       /* If the access type doesn't require foreign-compatible representation,
 	 be prepared for descriptors.  */
       if (targetm.calls.custom_function_descriptors > 0
-	  && Can_Use_Internal_Rep (Etype (Prefix (Name (gnat_node)))))
+	  && Can_Use_Internal_Rep
+	     (Underlying_Type (Etype (Prefix (Name (gnat_node))))))
 	by_descriptor = true;
     }
   else if (Nkind (Name (gnat_node)) == N_Attribute_Reference)
@@ -5639,7 +5645,7 @@
 		= build1 (SAVE_EXPR, boolean_type_node, boolean_true_node);
 	      vec_safe_push (loop->checks, rci);
 	      gnu_cond = build_noreturn_cond (gnat_to_gnu (gnat_cond));
-	      if (flag_unswitch_loops)
+	      if (optimize >= 3)
 		gnu_cond = build_binary_op (TRUTH_ANDIF_EXPR,
 					    boolean_type_node,
 					    rci->inserted_cond,
@@ -6906,14 +6912,22 @@
 	  /* Or else, use memset when the conditions are met.  */
 	  else if (use_memset_p)
 	    {
-	      tree value = fold_convert (integer_type_node, gnu_rhs);
-	      tree to = gnu_lhs;
-	      tree type = TREE_TYPE (to);
-	      tree size
-	        = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_SIZE_UNIT (type), to);
-	      tree to_ptr = build_fold_addr_expr (to);
+	      tree value
+		= real_zerop (gnu_rhs)
+		  ? integer_zero_node
+		  : fold_convert (integer_type_node, gnu_rhs);
+	      tree dest = build_fold_addr_expr (gnu_lhs);
 	      tree t = builtin_decl_explicit (BUILT_IN_MEMSET);
-	      if (TREE_CODE (value) == INTEGER_CST)
+	      /* Be extra careful not to write too much data.  */
+	      tree size;
+	      if (TREE_CODE (gnu_lhs) == COMPONENT_REF)
+		size = DECL_SIZE_UNIT (TREE_OPERAND (gnu_lhs, 1));
+	      else if (DECL_P (gnu_lhs))
+		size = DECL_SIZE_UNIT (gnu_lhs);
+	      else
+		size = TYPE_SIZE_UNIT (TREE_TYPE (gnu_lhs));
+	      size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (size, gnu_lhs);
+	      if (TREE_CODE (value) == INTEGER_CST && !integer_zerop (value))
 		{
 		  tree mask
 		    = build_int_cst (integer_type_node,
@@ -6920,7 +6934,7 @@
 				     ((HOST_WIDE_INT) 1 << BITS_PER_UNIT) - 1);
 		  value = int_const_binop (BIT_AND_EXPR, value, mask);
 		}
-	      gnu_result = build_call_expr (t, 3, to_ptr, value, size);
+	      gnu_result = build_call_expr (t, 3, dest, value, size);
 	    }
 
 	  /* Otherwise build a regular assignment.  */
@@ -8084,8 +8098,9 @@
   else if (!TYPE_IS_DUMMY_P (t))
     TREE_VISITED (t) = 1;
 
+  /* The test in gimplify_type_sizes is on the main variant.  */
   if (TYPE_P (t))
-    TYPE_SIZES_GIMPLIFIED (t) = 1;
+    TYPE_SIZES_GIMPLIFIED (TYPE_MAIN_VARIANT (t)) = 1;
 
   return NULL_TREE;
 }
Index: gcc/ada/osint.adb
===================================================================
--- a/src/gcc/ada/osint.adb	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ada/osint.adb	(.../branches/gcc-7-branch)
@@ -250,8 +250,7 @@
       Attr : aliased File_Attributes;
    end record;
 
-   No_File_Info_Cache : constant File_Info_Cache :=
-                          (No_File, Unknown_Attributes);
+   No_File_Info_Cache : constant File_Info_Cache := (No_File, (others => 0));
 
    package File_Name_Hash_Table is new GNAT.HTable.Simple_HTable (
      Header_Num => File_Hash_Num,
Index: gcc/ada/osint.ads
===================================================================
--- a/src/gcc/ada/osint.ads	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ada/osint.ads	(.../branches/gcc-7-branch)
@@ -273,10 +273,26 @@
    --  from the disk and then cached in the File_Attributes parameter (possibly
    --  along with other values).
 
-   type File_Attributes is private;
-   Unknown_Attributes : constant File_Attributes;
+   File_Attributes_Size : constant Natural := 32;
+   --  This should be big enough to fit a "struct file_attributes" on any
+   --  system. It doesn't cause any malfunction if it is too big (which avoids
+   --  the need for either mapping the struct exactly or importing the sizeof
+   --  from C, which would result in dynamic code). However, it does waste
+   --  space (e.g. when a component of this type appears in a record, if it is
+   --  unnecessarily large). Note: for runtime units, use System.OS_Constants.
+   --  SIZEOF_struct_file_attributes instead, which has the exact value.
+
+   type File_Attributes is
+     array (1 .. File_Attributes_Size)
+       of System.Storage_Elements.Storage_Element;
+   for File_Attributes'Alignment use Standard'Maximum_Alignment;
+
+   Unknown_Attributes : File_Attributes;
    --  A cache for various attributes for a file (length, accessibility,...)
-   --  This must be initialized to Unknown_Attributes prior to the first call.
+   --  Will be initialized properly at elaboration (for efficiency later on,
+   --  avoid function calls every time we want to reset the attributes) prior
+   --  to the first usage. We cannot make it constant since the compiler may
+   --  put it in a read-only section.
 
    function Is_Directory
      (Name : C_File_Name;
@@ -769,22 +785,4 @@
    --  detected, the file being written is deleted, and a fatal error is
    --  signalled.
 
-   File_Attributes_Size : constant Natural := 32;
-   --  This should be big enough to fit a "struct file_attributes" on any
-   --  system. It doesn't cause any malfunction if it is too big (which avoids
-   --  the need for either mapping the struct exactly or importing the sizeof
-   --  from C, which would result in dynamic code). However, it does waste
-   --  space (e.g. when a component of this type appears in a record, if it is
-   --  unnecessarily large). Note: for runtime units, use System.OS_Constants.
-   --  SIZEOF_struct_file_attributes instead, which has the exact value.
-
-   type File_Attributes is
-     array (1 .. File_Attributes_Size)
-       of System.Storage_Elements.Storage_Element;
-   for File_Attributes'Alignment use Standard'Maximum_Alignment;
-
-   Unknown_Attributes : constant File_Attributes := (others => 0);
-   --  Will be initialized properly at elaboration (for efficiency later on,
-   --  avoid function calls every time we want to reset the attributes).
-
 end Osint;
Index: gcc/dse.c
===================================================================
--- a/src/gcc/dse.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/dse.c	(.../branches/gcc-7-branch)
@@ -2389,10 +2389,13 @@
 		clear_rhs_from_active_local_stores ();
 	    }
 	}
-      else if (SIBLING_CALL_P (insn) && reload_completed)
+      else if (SIBLING_CALL_P (insn)
+	       && (reload_completed || HARD_FRAME_POINTER_IS_ARG_POINTER))
 	/* Arguments for a sibling call that are pushed to memory are passed
 	   using the incoming argument pointer of the current function.  After
-	   reload that might be (and likely is) frame pointer based.  */
+	   reload that might be (and likely is) frame pointer based.  And, if
+	   it is a frame pointer on the target, even before reload we need to
+	   kill frame pointer based stores.  */
 	add_wild_read (bb_info);
       else
 	/* Every other call, including pure functions, may read any memory
Index: gcc/lto-streamer-in.c
===================================================================
--- a/src/gcc/lto-streamer-in.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/lto-streamer-in.c	(.../branches/gcc-7-branch)
@@ -829,6 +829,7 @@
 
       /* Read OMP SIMD related info.  */
       loop->safelen = streamer_read_hwi (ib);
+      loop->owned_clique = streamer_read_hwi (ib);
       loop->dont_vectorize = streamer_read_hwi (ib);
       loop->force_vectorize = streamer_read_hwi (ib);
       loop->simduid = stream_read_tree (ib, data_in);
Index: gcc/gimple-ssa-strength-reduction.c
===================================================================
--- a/src/gcc/gimple-ssa-strength-reduction.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/gimple-ssa-strength-reduction.c	(.../branches/gcc-7-branch)
@@ -1220,7 +1220,7 @@
       c->next_interp = c2->cand_num;
       c2->first_interp = c->cand_num;
     }
-  else
+  else if (TREE_CODE (rhs2) == INTEGER_CST && !integer_zerop (rhs2))
     {
       /* Record an interpretation for the multiply-immediate.  */
       c = create_mul_imm_cand (gs, rhs1, rhs2, speed);
Index: gcc/fortran/openmp.c
===================================================================
--- a/src/gcc/fortran/openmp.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/openmp.c	(.../branches/gcc-7-branch)
@@ -1699,22 +1699,17 @@
 	      locus old_loc2 = gfc_current_locus;
 	      do
 		{
-		  if (!c->sched_simd
-		      && gfc_match ("simd") == MATCH_YES)
+		  if (gfc_match ("simd") == MATCH_YES)
 		    {
 		      c->sched_simd = true;
 		      nmodifiers++;
 		    }
-		  else if (!c->sched_monotonic
-			   && !c->sched_nonmonotonic
-			   && gfc_match ("monotonic") == MATCH_YES)
+		  else if (gfc_match ("monotonic") == MATCH_YES)
 		    {
 		      c->sched_monotonic = true;
 		      nmodifiers++;
 		    }
-		  else if (!c->sched_monotonic
-			   && !c->sched_nonmonotonic
-			   && gfc_match ("nonmonotonic") == MATCH_YES)
+		  else if (gfc_match ("nonmonotonic") == MATCH_YES)
 		    {
 		      c->sched_nonmonotonic = true;
 		      nmodifiers++;
@@ -1725,7 +1720,7 @@
 			gfc_current_locus = old_loc2;
 		      break;
 		    }
-		  if (nmodifiers == 0
+		  if (nmodifiers == 1
 		      && gfc_match (" , ") == MATCH_YES)
 		    continue;
 		  else if (gfc_match (" : ") == MATCH_YES)
@@ -4062,6 +4057,30 @@
 	gfc_warning (0, "INTEGER expression of SCHEDULE clause's chunk_size "
 		     "at %L must be positive", &expr->where);
     }
+  if (omp_clauses->sched_kind != OMP_SCHED_NONE
+      && omp_clauses->sched_nonmonotonic)
+    {
+      if (omp_clauses->sched_kind != OMP_SCHED_DYNAMIC
+	  && omp_clauses->sched_kind != OMP_SCHED_GUIDED)
+	{
+	  const char *p;
+	  switch (omp_clauses->sched_kind)
+	    {
+	    case OMP_SCHED_STATIC: p = "STATIC"; break;
+	    case OMP_SCHED_RUNTIME: p = "RUNTIME"; break;
+	    case OMP_SCHED_AUTO: p = "AUTO"; break;
+	    default: gcc_unreachable ();
+	    }
+	  gfc_error ("NONMONOTONIC modifier specified for %s schedule kind "
+		     "at %L", p, &code->loc);
+	}
+      else if (omp_clauses->sched_monotonic)
+	gfc_error ("Both MONOTONIC and NONMONOTONIC schedule modifiers "
+		   "specified at %L", &code->loc);
+      else if (omp_clauses->ordered)
+	gfc_error ("NONMONOTONIC schedule modifier specified with ORDERED "
+		   "clause at %L", &code->loc);
+    }
 
   /* Check that no symbol appears on multiple clauses, except that
      a symbol can appear on both firstprivate and lastprivate.  */
Index: gcc/fortran/interface.c
===================================================================
--- a/src/gcc/fortran/interface.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/interface.c	(.../branches/gcc-7-branch)
@@ -691,6 +691,15 @@
   if (ts1->type == BT_VOID || ts2->type == BT_VOID)
     return true;
 
+  /* Special case for our C interop types.  There should be a better
+     way of doing this...  */
+
+  if (((ts1->type == BT_INTEGER && ts2->type == BT_DERIVED)
+       || (ts1->type == BT_DERIVED && ts2->type == BT_INTEGER))
+      && ts1->u.derived && ts2->u.derived
+      && ts1->u.derived == ts2->u.derived)
+    return true;
+
   /* The _data component is not always present, therefore check for its
      presence before assuming, that its derived->attr is available.
      When the _data component is not present, then nevertheless the
@@ -3576,6 +3585,7 @@
 	gfc_warning (OPT_Wimplicit_procedure,
 		     "Procedure %qs called at %L is not explicitly declared",
 		     sym->name, where);
+      gfc_find_proc_namespace (sym->ns)->implicit_interface_calls = 1;
     }
 
   if (sym->attr.if_source == IFSRC_UNKNOWN)
Index: gcc/fortran/intrinsic.c
===================================================================
--- a/src/gcc/fortran/intrinsic.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/intrinsic.c	(.../branches/gcc-7-branch)
@@ -4919,6 +4919,8 @@
   if (ts->type == BT_UNKNOWN)
     goto bad;
 
+  expr->do_not_warn = ! wflag;
+
   /* NULL and zero size arrays get their type here.  */
   if (expr->expr_type == EXPR_NULL
       || (expr->expr_type == EXPR_ARRAY && expr->value.constructor == NULL))
Index: gcc/fortran/trans-expr.c
===================================================================
--- a/src/gcc/fortran/trans-expr.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/trans-expr.c	(.../branches/gcc-7-branch)
@@ -391,7 +391,7 @@
       e->ref = NULL;
     }
 
-  base_expr = gfc_expr_to_initialize (e);
+  base_expr = gfc_copy_expr (e);
 
   /* Restore the original tail expression.  */
   if (class_ref)
@@ -2987,6 +2987,83 @@
     if (gfc_conv_cst_int_power (se, lse.expr, rse.expr))
       return;
 
+  if (INTEGER_CST_P (lse.expr)
+      && TREE_CODE (TREE_TYPE (rse.expr)) == INTEGER_TYPE)
+    {
+      wide_int wlhs = lse.expr;
+      HOST_WIDE_INT v;
+      v = wlhs.to_shwi ();
+      if (v == 1)
+	{
+	  /* 1**something is always 1.  */
+	  se->expr = build_int_cst (TREE_TYPE (lse.expr), 1);
+	  return;
+	}
+      else if (v == 2 || v == 4 || v == 8 || v == 16)
+	{
+	  /* 2**n = 1<<n, 4**n = 1<<(n+n), 8**n = 1 <<(3*n), 16**n =
+	   1<<(4*n), but we have to make sure to return zero if the
+	   number of bits is too large. */
+	  tree lshift;
+	  tree type;
+	  tree shift;
+	  tree ge;
+	  tree cond;
+	  tree num_bits;
+	  tree cond2;
+
+	  type = TREE_TYPE (lse.expr);
+
+	  if (v == 2)
+	    shift = rse.expr;
+	  else if (v == 4)
+	    shift = fold_build2_loc (input_location, PLUS_EXPR,
+				     TREE_TYPE (rse.expr),
+				       rse.expr, rse.expr);
+	  else if (v == 8)
+	    shift = fold_build2_loc (input_location, MULT_EXPR,
+				     TREE_TYPE (rse.expr),
+				     build_int_cst (TREE_TYPE (rse.expr), 3),
+				     rse.expr);
+	  else if (v == 16)
+	    shift = fold_build2_loc (input_location, MULT_EXPR,
+				     TREE_TYPE (rse.expr),
+				     build_int_cst (TREE_TYPE (rse.expr), 4),
+				     rse.expr);
+	  else
+	    gcc_unreachable ();
+
+	  lshift = fold_build2_loc (input_location, LSHIFT_EXPR, type,
+				    build_int_cst (type, 1), shift);
+	  ge = fold_build2_loc (input_location, GE_EXPR, logical_type_node,
+				rse.expr, build_int_cst (type, 0));
+	  cond = fold_build3_loc (input_location, COND_EXPR, type, ge, lshift,
+				 build_int_cst (type, 0));
+	  num_bits = build_int_cst (TREE_TYPE (rse.expr), TYPE_PRECISION (type));
+	  cond2 = fold_build2_loc (input_location, GE_EXPR, logical_type_node,
+				   rse.expr, num_bits);
+	  se->expr = fold_build3_loc (input_location, COND_EXPR, type, cond2,
+				      build_int_cst (type, 0), cond);
+	  return;
+	}
+      else if (v == -1)
+	{
+	  /* (-1)**n is 1 - ((n & 1) << 1) */
+	  tree type;
+	  tree tmp;
+
+	  type = TREE_TYPE (lse.expr);
+	  tmp = fold_build2_loc (input_location, BIT_AND_EXPR, type,
+				 rse.expr, build_int_cst (type, 1));
+	  tmp = fold_build2_loc (input_location, LSHIFT_EXPR, type,
+				 tmp, build_int_cst (type, 1));
+	  tmp = fold_build2_loc (input_location, MINUS_EXPR, type,
+				 build_int_cst (type, 1), tmp);
+	  se->expr = tmp;
+	  return;
+	}
+    }
+
   gfc_int4_type_node = gfc_get_int_type (4);
 
   /* In case of integer operands with kinds 1 or 2, we call the integer kind 4
@@ -3722,7 +3799,8 @@
 
 
 static void
-conv_function_val (gfc_se * se, gfc_symbol * sym, gfc_expr * expr)
+conv_function_val (gfc_se * se, gfc_symbol * sym, gfc_expr * expr,
+		   gfc_actual_arglist *actual_args)
 {
   tree tmp;
 
@@ -3740,7 +3818,7 @@
   else
     {
       if (!sym->backend_decl)
-	sym->backend_decl = gfc_get_extern_function_decl (sym);
+	sym->backend_decl = gfc_get_extern_function_decl (sym, actual_args);
 
       TREE_USED (sym->backend_decl) = 1;
 
@@ -5635,6 +5713,16 @@
 	      break;
 	    }
 
+	  if (e->ts.type == BT_DERIVED && fsym && fsym->ts.type == BT_CLASS)
+	    {
+	      /* The derived type is passed to gfc_deallocate_alloc_comp.
+		 Therefore, class actuals can be handled correctly but derived
+		 types passed to class formals need the _data component.  */
+	      tmp = gfc_class_data_get (tmp);
+	      if (!CLASS_DATA (fsym)->attr.dimension)
+		tmp = build_fold_indirect_ref_loc (input_location, tmp);
+	    }
+
 	  if (e->expr_type == EXPR_OP
 		&& e->value.op.op == INTRINSIC_PARENTHESES
 		&& e->value.op.op1->expr_type == EXPR_VARIABLE)
@@ -5646,16 +5734,6 @@
 	      gfc_add_expr_to_block (&se->post, local_tmp);
 	    }
 
-	  if (e->ts.type == BT_DERIVED && fsym && fsym->ts.type == BT_CLASS)
-	    {
-	      /* The derived type is passed to gfc_deallocate_alloc_comp.
-		 Therefore, class actuals can handled correctly but derived
-		 types passed to class formals need the _data component.  */
-	      tmp = gfc_class_data_get (tmp);
-	      if (!CLASS_DATA (fsym)->attr.dimension)
-		tmp = build_fold_indirect_ref_loc (input_location, tmp);
-	    }
-
 	  tmp = gfc_deallocate_alloc_comp (e->ts.u.derived, tmp, parm_rank);
 
 	  gfc_prepend_expr_to_block (&post, tmp);
@@ -6161,7 +6239,7 @@
 
   /* Generate the actual call.  */
   if (base_object == NULL_TREE)
-    conv_function_val (se, sym, expr);
+    conv_function_val (se, sym, expr, args);
   else
     conv_base_obj_fcn_val (se, base_object, expr);
 
@@ -8255,24 +8333,7 @@
     }
 }
 
-/* Indentify class valued proc_pointer assignments.  */
 
-static bool
-pointer_assignment_is_proc_pointer (gfc_expr * expr1, gfc_expr * expr2)
-{
-  gfc_ref * ref;
-
-  ref = expr1->ref;
-  while (ref && ref->next)
-     ref = ref->next;
-
-  return ref && ref->type == REF_COMPONENT
-      && ref->u.c.component->attr.proc_pointer
-      && expr2->expr_type == EXPR_VARIABLE
-      && expr2->symtree->n.sym->attr.flavor == FL_PROCEDURE;
-}
-
-
 /* Do everything that is needed for a CLASS function expr2.  */
 
 static tree
@@ -8325,7 +8386,7 @@
   tree tmp;
   tree decl;
   tree expr1_vptr = NULL_TREE;
-  bool scalar, non_proc_pointer_assign;
+  bool scalar, non_proc_ptr_assign;
   gfc_ss *ss;
 
   gfc_start_block (&block);
@@ -8333,7 +8394,9 @@
   gfc_init_se (&lse, NULL);
 
   /* Usually testing whether this is not a proc pointer assignment.  */
-  non_proc_pointer_assign = !pointer_assignment_is_proc_pointer (expr1, expr2);
+  non_proc_ptr_assign = !(gfc_expr_attr (expr1).proc_pointer
+			&& expr2->expr_type == EXPR_VARIABLE
+			&& expr2->symtree->n.sym->attr.flavor == FL_PROCEDURE);
 
   /* Check whether the expression is a scalar or not; we cannot use
      expr1->rank as it can be nonzero for proc pointers.  */
@@ -8343,7 +8406,7 @@
     gfc_free_ss_chain (ss);
 
   if (expr1->ts.type == BT_DERIVED && expr2->ts.type == BT_CLASS
-      && expr2->expr_type != EXPR_FUNCTION && non_proc_pointer_assign)
+      && expr2->expr_type != EXPR_FUNCTION && non_proc_ptr_assign)
     {
       gfc_add_data_component (expr2);
       /* The following is required as gfc_add_data_component doesn't
@@ -8363,7 +8426,7 @@
       else
 	gfc_conv_expr (&rse, expr2);
 
-      if (non_proc_pointer_assign && expr1->ts.type == BT_CLASS)
+      if (non_proc_ptr_assign && expr1->ts.type == BT_CLASS)
 	{
 	  trans_class_vptr_len_assignment (&block, expr1, expr2, &rse, NULL,
 					   NULL);
@@ -10102,19 +10165,27 @@
   /* When assigning a character function result to a deferred-length variable,
      the function call must happen before the (re)allocation of the lhs -
      otherwise the character length of the result is not known.
-     NOTE: This relies on having the exact dependence of the length type
+     NOTE 1: This relies on having the exact dependence of the length type
      parameter available to the caller; gfortran saves it in the .mod files.
-     NOTE ALSO: The concatenation operation generates a temporary pointer,
+     NOTE 2: Vector array references generate an index temporary that must
+     not go outside the loop. Otherwise, variables should not generate
+     a pre block.
+     NOTE 3: The concatenation operation generates a temporary pointer,
      whose allocation must go to the innermost loop.
-     NOTE ALSO (2): A character conversion may generate a temporary, too.  */
+     NOTE 4: Elemental functions may generate a temporary, too.  */
   if (flag_realloc_lhs
       && expr2->ts.type == BT_CHARACTER && expr1->ts.deferred
       && !(lss != gfc_ss_terminator
-	   && ((expr2->expr_type == EXPR_OP
-		&& expr2->value.op.op == INTRINSIC_CONCAT)
+	   && rss != gfc_ss_terminator
+	   && ((expr2->expr_type == EXPR_VARIABLE && expr2->rank)
 	       || (expr2->expr_type == EXPR_FUNCTION
+		   && expr2->value.function.esym != NULL
+		   && expr2->value.function.esym->attr.elemental)
+	       || (expr2->expr_type == EXPR_FUNCTION
 		   && expr2->value.function.isym != NULL
-		   && expr2->value.function.isym->id == GFC_ISYM_CONVERSION))))
+		   && expr2->value.function.isym->elemental)
+	       || (expr2->expr_type == EXPR_OP
+		   && expr2->value.op.op == INTRINSIC_CONCAT))))
     gfc_add_block_to_block (&block, &rse.pre);
 
   /* Nullify the allocatable components corresponding to those of the lhs
Index: gcc/fortran/trans-array.c
===================================================================
--- a/src/gcc/fortran/trans-array.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/trans-array.c	(.../branches/gcc-7-branch)
@@ -2498,6 +2498,9 @@
   if (ss_info->type != GFC_SS_REFERENCE)
     return false;
 
+  if (ss_info->data.scalar.needs_temporary)
+    return false;
+
   /* If the actual argument can be absent (in other words, it can
      be a NULL reference), don't try to evaluate it; pass instead
      the reference directly.  */
@@ -5482,6 +5485,7 @@
   tree var_overflow = NULL_TREE;
   tree cond;
   tree set_descriptor;
+  tree not_prev_allocated = NULL_TREE;
   stmtblock_t set_descriptor_block;
   stmtblock_t elseblock;
   gfc_expr **lower;
@@ -5619,8 +5623,6 @@
 	}
     }
 
-  gfc_start_block (&elseblock);
-
   /* Allocate memory to store the data.  */
   if (POINTER_TYPE_P (TREE_TYPE (se->expr)))
     se->expr = build_fold_indirect_ref_loc (input_location, se->expr);
@@ -5636,6 +5638,19 @@
     pointer = gfc_conv_descriptor_data_get (se->expr);
   STRIP_NOPS (pointer);
 
+  if (allocatable)
+    {
+      not_prev_allocated = gfc_create_var (logical_type_node,
+					   "not_prev_allocated");
+      tmp = fold_build2_loc (input_location, EQ_EXPR,
+			     logical_type_node, pointer,
+			     build_int_cst (TREE_TYPE (pointer), 0));
+
+      gfc_add_modify (&se->pre, not_prev_allocated, tmp);
+    }
+
+  gfc_start_block (&elseblock);
+
   /* The allocatable variant takes the old pointer as first argument.  */
   if (allocatable)
     gfc_allocate_allocatable (&elseblock, pointer, size, token,
@@ -5672,6 +5687,11 @@
       cond = fold_build2_loc (input_location, EQ_EXPR,
 			  logical_type_node, status,
 			  build_int_cst (TREE_TYPE (status), 0));
+
+      if (not_prev_allocated != NULL_TREE)
+	cond = fold_build2_loc (input_location, TRUTH_OR_EXPR,
+				logical_type_node, cond, not_prev_allocated);
+
       gfc_add_expr_to_block (&se->pre,
 		 fold_build3_loc (input_location, COND_EXPR, void_type_node,
 				  cond,
@@ -9755,6 +9775,8 @@
 {
   gfc_ref *ref;
 
+  gfc_fix_class_refs (expr);
+
   for (ref = expr->ref; ref; ref = ref->next)
     if (ref->type == REF_ARRAY && ref->u.ar.type != AR_ELEMENT)
       break;
Index: gcc/fortran/symbol.c
===================================================================
--- a/src/gcc/fortran/symbol.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/symbol.c	(.../branches/gcc-7-branch)
@@ -477,7 +477,7 @@
   /* The copying of procedure dummy arguments for module procedures in
      a submodule occur whilst the current state is COMP_CONTAINS. It
      is necessary, therefore, to let this through.  */
-  if (attr->dummy
+  if (name && attr->dummy
       && (attr->function || attr->subroutine)
       && gfc_current_state () == COMP_CONTAINS
       && !(gfc_new_block && gfc_new_block->abr_modproc_decl))
@@ -509,6 +509,7 @@
 
   conf (external, intrinsic);
   conf (entry, intrinsic);
+  conf (abstract, intrinsic);
 
   if ((attr->if_source == IFSRC_DECL && !attr->procedure) || attr->contained)
     conf (external, subroutine);
@@ -1595,7 +1596,15 @@
     return false;
 
   attr->subroutine = 1;
-  return check_conflict (attr, name, where);
+
+  /* If we are looking at a BLOCK DATA statement and we encounter a
+     name with a leading underscore (which must be
+     compiler-generated), do not check. See PR 84394.  */
+
+  if (name && *name != '_' && gfc_current_state () != COMP_BLOCK_DATA)
+    return check_conflict (attr, name, where);
+  else
+    return true;
 }
 
 
@@ -1711,7 +1720,8 @@
   if (where == NULL)
     where = &gfc_current_locus;
 
-  if (attr->proc != PROC_UNKNOWN && !attr->module_procedure)
+  if (attr->proc != PROC_UNKNOWN && !attr->module_procedure
+      && attr->access == ACCESS_UNKNOWN)
     {
       if (attr->proc == PROC_ST_FUNCTION && t == PROC_INTERNAL
 	  && !gfc_notification_std (GFC_STD_F2008))
@@ -4173,7 +4183,7 @@
 /* Get a global symbol, creating it if it doesn't exist.  */
 
 gfc_gsymbol *
-gfc_get_gsymbol (const char *name)
+gfc_get_gsymbol (const char *name, bool bind_c)
 {
   gfc_gsymbol *s;
 
@@ -4184,6 +4194,7 @@
   s = XCNEW (gfc_gsymbol);
   s->type = GSYM_UNKNOWN;
   s->name = gfc_get_string ("%s", name);
+  s->bind_c = bind_c;
 
   gfc_insert_bbt (&gfc_gsym_root, s, gsym_compare);
 
Index: gcc/fortran/class.c
===================================================================
--- a/src/gcc/fortran/class.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/class.c	(.../branches/gcc-7-branch)
@@ -899,6 +899,9 @@
   if (!comp_is_finalizable (comp))
     return;
 
+  if (comp->finalized)
+    return;
+
   e = gfc_copy_expr (expr);
   if (!e->ref)
     e->ref = ref = gfc_get_ref ();
@@ -1026,6 +1029,7 @@
 			    sub_ns);
       gfc_free_expr (e);
     }
+  comp->finalized = true;
 }
 
 
Index: gcc/fortran/decl.c
===================================================================
--- a/src/gcc/fortran/decl.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/decl.c	(.../branches/gcc-7-branch)
@@ -552,6 +552,7 @@
 gfc_match_data (void)
 {
   gfc_data *new_data;
+  gfc_expr *e;
   match m;
 
   /* Before parsing the rest of a DATA statement, check F2008:c1206.  */
@@ -588,6 +589,30 @@
 	  goto cleanup;
 	}
 
+      /* Check for an entity with an allocatable component, which is not
+	 allowed.  */
+      e = new_data->var->expr;
+      if (e)
+	{
+	  bool invalid;
+
+	  invalid = false;
+	  for (gfc_ref *ref = e->ref; ref; ref = ref->next)
+	    if ((ref->type == REF_COMPONENT
+		 && ref->u.c.component->attr.allocatable)
+		|| (ref->type == REF_ARRAY
+		    && e->symtree->n.sym->attr.pointer != 1
+		    && ref->u.ar.as && ref->u.ar.as->type == AS_DEFERRED))
+	      invalid = true;
+
+	  if (invalid)
+	    {
+	      gfc_error ("Allocatable component or deferred-shaped array "
+			 "near %C in DATA statement");
+	      goto cleanup;
+	    }
+	}
+
       m = top_val_list (new_data);
       if (m != MATCH_YES)
 	goto cleanup;
@@ -1771,7 +1796,7 @@
 		    }
 		  else if (init->ts.u.cl && init->ts.u.cl->length)
 		    sym->ts.u.cl->length =
-				gfc_copy_expr (sym->value->ts.u.cl->length);
+				gfc_copy_expr (init->ts.u.cl->length);
 		}
 	    }
 	  /* Update initializer character length according symbol.  */
@@ -2544,6 +2569,22 @@
       goto cleanup;
     }
 
+  /* Before adding a possible initilizer, do a simple check for compatibility
+     of lhs and rhs types.  Assigning a REAL value to a derive type is not a
+     good thing.  */
+  if (current_ts.type == BT_DERIVED && initializer
+      && (gfc_numeric_ts (&initializer->ts)
+	  || initializer->ts.type == BT_LOGICAL
+	  || initializer->ts.type == BT_CHARACTER))
+    {
+      gfc_error ("Incompatible initialization between a derive type "
+		 "entity and an entity with %qs type at %C",
+		  gfc_typename (&initializer->ts));
+      m = MATCH_ERROR;
+      goto cleanup;
+    }
+
+
   /* Add the initializer.  Note that it is fine if initializer is
      NULL here, because we sometimes also need to check if a
      declaration *must* have an initialization expression.  */
@@ -6239,7 +6280,7 @@
      name is a global identifier.  */
   if (!binding_label || gfc_notification_std (GFC_STD_F2008))
     {
-      s = gfc_get_gsymbol (name);
+      s = gfc_get_gsymbol (name, false);
 
       if (s->defined || (s->type != GSYM_UNKNOWN && s->type != type))
 	{
@@ -6261,7 +6302,7 @@
       && (!gfc_notification_std (GFC_STD_F2008)
 	  || strcmp (name, binding_label) != 0))
     {
-      s = gfc_get_gsymbol (binding_label);
+      s = gfc_get_gsymbol (binding_label, true);
 
       if (s->defined || (s->type != GSYM_UNKNOWN && s->type != type))
 	{
@@ -6438,9 +6479,11 @@
 	      gfc_error ("Missing required parentheses before BIND(C) at %C");
 	      return MATCH_ERROR;
 	    }
-	    if (!gfc_add_is_bind_c (&(entry->attr), entry->name,
-				    &(entry->declared_at), 1))
-	      return MATCH_ERROR;
+
+	  if (!gfc_add_is_bind_c (&(entry->attr), entry->name,
+				  &(entry->declared_at), 1))
+	    return MATCH_ERROR;
+	
 	}
 
       if (!gfc_current_ns->parent
@@ -6524,6 +6567,14 @@
       return MATCH_ERROR;
     }
 
+  /* F2018:C1546 An elemental procedure shall not have the BIND attribute.  */
+  if (proc->attr.elemental && entry->attr.is_bind_c)
+    {
+      gfc_error ("ENTRY statement at %L with BIND(C) prohibited in an "
+		 "elemental procedure", &entry->declared_at);
+      return MATCH_ERROR;
+    }
+
   entry->attr.recursive = proc->attr.recursive;
   entry->attr.elemental = proc->attr.elemental;
   entry->attr.pure = proc->attr.pure;
Index: gcc/fortran/trans-openmp.c
===================================================================
--- a/src/gcc/fortran/trans-openmp.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/trans-openmp.c	(.../branches/gcc-7-branch)
@@ -460,7 +460,8 @@
 
   if ((! GFC_DESCRIPTOR_TYPE_P (type)
        || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)
-      && !GFC_DECL_GET_SCALAR_ALLOCATABLE (OMP_CLAUSE_DECL (clause)))
+      && (!GFC_DECL_GET_SCALAR_ALLOCATABLE (OMP_CLAUSE_DECL (clause))
+	  || !POINTER_TYPE_P (type)))
     {
       if (gfc_has_alloc_comps (type, OMP_CLAUSE_DECL (clause)))
 	{
@@ -546,6 +547,9 @@
 			     build3_loc (input_location, COND_EXPR,
 					 void_type_node, cond, then_b,
 					 else_b));
+      /* Avoid -W*uninitialized warnings.  */
+      if (DECL_P (decl))
+	TREE_NO_WARNING (decl) = 1;
     }
   else
     gfc_add_expr_to_block (&block, then_b);
@@ -567,7 +571,8 @@
 
   if ((! GFC_DESCRIPTOR_TYPE_P (type)
        || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)
-      && !GFC_DECL_GET_SCALAR_ALLOCATABLE (OMP_CLAUSE_DECL (clause)))
+      && (!GFC_DECL_GET_SCALAR_ALLOCATABLE (OMP_CLAUSE_DECL (clause))
+	  || !POINTER_TYPE_P (type)))
     {
       if (gfc_has_alloc_comps (type, OMP_CLAUSE_DECL (clause)))
 	{
@@ -651,6 +656,9 @@
   gfc_add_expr_to_block (&block,
 			 build3_loc (input_location, COND_EXPR,
 				     void_type_node, cond, then_b, else_b));
+  /* Avoid -W*uninitialized warnings.  */
+  if (DECL_P (dest))
+    TREE_NO_WARNING (dest) = 1;
 
   return gfc_finish_block (&block);
 }
@@ -667,7 +675,8 @@
 
   if ((! GFC_DESCRIPTOR_TYPE_P (type)
        || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)
-      && !GFC_DECL_GET_SCALAR_ALLOCATABLE (OMP_CLAUSE_DECL (clause)))
+      && (!GFC_DECL_GET_SCALAR_ALLOCATABLE (OMP_CLAUSE_DECL (clause))
+	  || !POINTER_TYPE_P (type)))
     {
       if (gfc_has_alloc_comps (type, OMP_CLAUSE_DECL (clause)))
 	{
@@ -905,7 +914,8 @@
 
   if ((! GFC_DESCRIPTOR_TYPE_P (type)
        || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)
-      && !GFC_DECL_GET_SCALAR_ALLOCATABLE (OMP_CLAUSE_DECL (clause)))
+      && (!GFC_DECL_GET_SCALAR_ALLOCATABLE (OMP_CLAUSE_DECL (clause))
+	  || !POINTER_TYPE_P (type)))
     {
       gcc_assert (TREE_CODE (type) == ARRAY_TYPE);
       if (!TYPE_DOMAIN (type)
@@ -989,7 +999,8 @@
 
   if ((! GFC_DESCRIPTOR_TYPE_P (type)
        || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)
-      && !GFC_DECL_GET_SCALAR_ALLOCATABLE (OMP_CLAUSE_DECL (clause)))
+      && (!GFC_DECL_GET_SCALAR_ALLOCATABLE (OMP_CLAUSE_DECL (clause))
+	  || !POINTER_TYPE_P (type)))
     {
       if (gfc_has_alloc_comps (type, OMP_CLAUSE_DECL (clause)))
 	return gfc_walk_alloc_comps (decl, NULL_TREE,
Index: gcc/fortran/gfortran.h
===================================================================
--- a/src/gcc/fortran/gfortran.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/gfortran.h	(.../branches/gcc-7-branch)
@@ -1058,6 +1058,7 @@
   struct gfc_typebound_proc *tb;
   /* When allocatable/pointer and in a coarray the associated token.  */
   tree caf_token;
+  bool finalized;
 }
 gfc_component;
 
@@ -1827,6 +1828,9 @@
 
   /* Set to 1 for !$ACC ROUTINE namespaces.  */
   unsigned oacc_routine:1;
+
+  /* Set to 1 if there are any calls to procedures with implicit interface.  */
+  unsigned implicit_interface_calls:1;
 }
 gfc_namespace;
 
@@ -1854,6 +1858,7 @@
   enum gfc_symbol_type type;
 
   int defined, used;
+  bool bind_c;
   locus where;
   gfc_namespace *ns;
 }
@@ -2106,6 +2111,9 @@
   /* Will require finalization after use.  */
   unsigned int must_finalize : 1;
 
+  /* Set this if no warning should be given somewhere in a lower level.  */
+
+  unsigned int do_not_warn : 1;
   /* If an expression comes from a Hollerith constant or compile-time
      evaluation of a transfer statement, it may have a prescribed target-
      memory representation, and these cannot always be backformed from
@@ -2988,7 +2996,7 @@
 void gfc_free_dt_list (void);
 
 
-gfc_gsymbol *gfc_get_gsymbol (const char *);
+gfc_gsymbol *gfc_get_gsymbol (const char *, bool bind_c);
 gfc_gsymbol *gfc_find_gsymbol (gfc_gsymbol *, const char *);
 
 gfc_typebound_proc* gfc_get_typebound_proc (gfc_typebound_proc*);
@@ -3124,7 +3132,7 @@
 
 bool gfc_check_conformance (gfc_expr *, gfc_expr *, const char *, ...) ATTRIBUTE_PRINTF_3;
 bool gfc_check_assign (gfc_expr *, gfc_expr *, int, bool c = true);
-bool gfc_check_pointer_assign (gfc_expr *, gfc_expr *);
+bool gfc_check_pointer_assign (gfc_expr *, gfc_expr *, bool is_init_expr = false);
 bool gfc_check_assign_symbol (gfc_symbol *, gfc_component *, gfc_expr *);
 
 gfc_expr *gfc_build_default_init_expr (gfc_typespec *, locus *);
@@ -3269,7 +3277,7 @@
 void gfc_free_close (gfc_close *);
 bool gfc_resolve_close (gfc_close *);
 void gfc_free_filepos (gfc_filepos *);
-bool gfc_resolve_filepos (gfc_filepos *);
+bool gfc_resolve_filepos (gfc_filepos *, locus *);
 void gfc_free_inquire (gfc_inquire *);
 bool gfc_resolve_inquire (gfc_inquire *);
 void gfc_free_dt (gfc_dt *);
Index: gcc/fortran/lang.opt
===================================================================
--- a/src/gcc/fortran/lang.opt	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/lang.opt	(.../branches/gcc-7-branch)
@@ -718,6 +718,13 @@
 Fortran Var(flag_sign_zero) Init(1)
 Apply negative sign to zero values.
 
+ftail-call-workaround
+Frotran Alias(ftail-call-workaround=,1,0)
+
+ftail-call-workaround=
+Fortran RejectNegative Joined UInteger IntegerRange(0, 2) Var(flag_tail_call_workaround) Init(1)
+Disallow tail call optimization when a calling routine may have omitted character lengths.
+
 funderscoring
 Fortran Var(flag_underscoring) Init(1)
 Append underscores to externally visible names.
Index: gcc/fortran/ChangeLog
===================================================================
--- a/src/gcc/fortran/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,464 @@
+2019-10-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/86248
+	* resolve.c (flag_fn_result_spec): Correct a typo before the
+	function declaration.
+	* trans-decl.c (gfc_sym_identifier): Boost the length of 'name'
+	to allow for all variants. Simplify the code by using a pointer
+	to the symbol's proc_name and taking the return out of each of
+	the conditional branches. Allow symbols with fn_result_spec set
+	that do not come from a procedure namespace and have a module
+	name to go through the non-fn_result_spec branch.
+
+2019-10-18  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/69455
+	* trans-decl.c (generate_local_decl): Avoid misconstructed
+	intrinsic modules in a BLOCK construct.
+
+2019-09-15  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91557
+	* trans-decl.c (generate_local_decl): Do not warn if the symbol
+	is artificial.
+	* trans-types.c (get_formal_from_actual_arglist): Set artificial
+	attribute on dummy arguments.
+
+2019-09-12  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/91686
+	Backport from mainline
+	* trans-expr.c (gfc_trans_assignment_1): Copy and paste section
+	handling the rse.pre block from mainline.
+
+2019-08-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-05-30  Jakub Jelinek  <jakub@redhat.com>
+
+	* lang.opt (ftail-call-workaround=): Fix a typo - lenghts to lengths.
+
+	2019-05-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/90329
+	* lang.opt (fbroken-callers): Remove.
+	(ftail-call-workaround, ftail-call-workaround=): New options.
+	* gfortran.h (struct gfc_namespace): Add implicit_interface_calls.
+	* interface.c (gfc_procedure_use): Set implicit_interface_calls
+	for calls to implicit interface procedures.
+	* trans-decl.c (create_function_arglist): Use flag_tail_call_workaround
+	instead of flag_broken_callers.  If it is not 2, also require
+	sym->ns->implicit_interface_calls.
+	* invoke.texi (fbroken-callers): Remove documentation.
+	(ftail-call-workaround, ftail-call-workaround=): Document.
+
+	2019-05-19  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/90329
+	* invoke.texi: Document -fbroken-callers.
+	* lang.opt: Add -fbroken-callers.
+	* trans-decl.c (create_function_arglist): Only set
+	DECL_HIDDEN_STRING_LENGTH if flag_broken_callers is set.
+
+	2019-05-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/90329
+	* trans-decl.c (create_function_arglist): Set
+	DECL_HIDDEN_STRING_LENGTH on hidden string length PARM_DECLs if
+	len is constant.
+
+	2019-03-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/89651
+	* trans-openmp.c (gfc_omp_clause_default_ctor): Set TREE_NO_WARNING
+	on decl if adding COND_EXPR for allocatable.
+	(gfc_omp_clause_copy_ctor): Set TREE_NO_WARNING on dest.
+
+	2019-02-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/83246
+	PR fortran/89084
+	* trans-decl.c (generate_local_decl): Add referenced FL_PARAMETERs
+	if sym->ns->construct_entities rather than if
+	sym->ns->parent->code->op == EXEC_BLOCK.
+
+	2019-01-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/88902
+	* trans-decl.c (gfc_get_symbol_decl): Don't add length to function
+	or parent function if it has been added there already.
+
+	2018-12-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/88377
+	* trans-openmp.c (gfc_omp_clause_default_ctor,
+	gfc_omp_clause_copy_ctor, gfc_omp_clause_assign_op,
+	gfc_omp_clause_linear_ctor, gfc_omp_clause_dtor): Only consider
+	GFC_DECL_GET_SCALAR_ALLOCATABLE vars as scalar allocatables if they
+	have pointer type.
+
+	2018-10-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/87725
+	* openmp.c (gfc_match_omp_clauses): Parse simd, monotonic and
+	nonmonotonic modifiers regardless of if they have been parsed
+	already or if the opposite one has.  Fix up check whether
+	comma after modifier should be parsed.
+	(resolve_omp_clauses): Diagnose schedule modifier restrictions.
+
+2019-08-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	    Paul Thomas <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90786
+	PR fortran/90813
+	* trans-expr.c (pointer_assignment_is_proc_pointer) Remove as
+	it is very simple and only called from one place.
+	(gfc_trans_pointer_assignment): Rename non_proc_pointer_assign
+	as non_proc_ptr_assign. Assign to it directly, rather than call
+	to above, deleted function and use gfc_expr_attr instead of
+	only checking the reference chain.
+	* trans-decl.c (sym_identifier): New function.
+	(mangled_identifier): New function, doing most of the work
+	of gfc_sym_mangled_identifier.
+	(gfc_sym_mangled_identifier): Use mangled_identifier.  Add mangled
+	identifier to global symbol table.
+	(get_proc_pointer_decl): Use backend decl from global identifier
+	if present.
+
+2019-06-21  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90937
+	* trans-types.c (get_formal_from_actual_arglist): Get symbol from
+	current namespace so it will be freed later.  If symbol is of type
+	character, get an empty character length.
+
+2019-06-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	Tom Trnka  <trnka@scm.com>
+
+	Backport from trunk
+	PR fortran/90744
+	* trans-types.c (get_formal_from_actual_arglist): Unset typespec
+	flags which make no sense for procedures without explicit
+	interface.
+
+2019-05-05  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/90344
+	* frontend-passes.c (create_var): Bring into sync with gcc 8.
+
+2019-04-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87352
+	Backport from trunk
+	* gfortran.h (gfc_component): Add finalized field.
+	* class.c (finalize_component): If the component is already
+	finalized, return early.  Set component->finalized on exit.
+
+2019-04-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89904
+	* check.c (gfc_check_transfer): Reject procedures as actual
+	arguments for SOURCE and MOLD of TRANSFER intrinsic.
+
+2019-03-31  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/83515
+	PR fortran/85797
+	* trans-types.c (gfc_typenode_for_spec): Handle conversion for
+	procedure pointers.
+	* target-memory.c (gfc_element_size): Handle size determination
+	for procedure pointers.
+
+2019-03-25  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/71861
+	Backport from trunk
+	* symbol.c (check_conflict): ABSTRACT attribute conflicts with
+	INTRINSIC attribute.
+
+2019-03-23  Thomas Koenig  <tkoeng@gcc.gnu.org>
+
+	PR fortran/68009
+	Backport from trunk
+	* iresolve.c: Include trans.h.
+	(gfc_resolve_fe_runtine_error): Set backend_decl on
+	resolved_sym.
+
+2019-03-17  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/84394
+	Backport from trunk
+	* symbol.c (gfc_add_subroutine): If we are encountering a
+	subrtoutine within a BLOCK DATA and the name starts with an
+	underscore, do not check.
+
+2019-03-16  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/66089
+	Backport from trunk
+	* trans-array.c (gfc_scalar_elemental_arg_saved_as_reference):
+	Return false if a scalar tempoary is needed.
+	(gfc_walk_variable_expr): Fix up class refs.
+
+2019-03-16  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/66695
+	PR fortran/77746
+	PR fortran/79485
+	Backport from trunk
+	* gfortran.h (gfc_symbol): Add bind_c component.
+	(gfc_get_gsymbol): Add argument bind_c.
+	* decl.c (add_global_entry): Add bind_c argument to
+	gfc_get_symbol.
+	* parse.c (parse_block_data): Likewise.
+	(parse_module): Likewise.
+	(add_global_procedure): Likewise.
+	(add_global_program): Likewise.
+	* resolve.c (resolve_common_blocks): Likewise.
+	(resolve_global_procedure): Likewise.
+	(gfc_verify_binding_labels): Likewise.
+	* symbol.c (gfc_get_gsymbol): Add argument bind_c. Set bind_c
+	in gsym.
+	* trans-decl.c (gfc_get_module_backend_decl): Add bind_c argument
+	to gfc_get_symbol.
+	(gfc_get_extern_function_decl): If the sym has a binding label
+	and it cannot be found in the global symbol tabel, it is the wrong
+	one and vice versa.
+
+2019-03-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87673
+	Backport from trunk
+	* match.c (gfc_match_type_spec): Remove call to
+	gfc_resolve_expr for character length.
+
+2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71544
+	Backport from trunk
+	* trans-types.c (gfc_typenode_for_spec) Set ts->is_c_interop of
+	C_PTR and C_FUNPTR.
+	(create_fn_spec): Mark argument as escaping if ts->is_c_interop is set.
+
+2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/87734
+	Backort from trunk
+	* symbol.c (gfc_add_procedure): Only throw an error if the
+	procedure has not been declared either PUBLIC or PRIVATE.
+	* resolve.c (is_illegal_recursion): Remove an assert().
+
+2019-03-06  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/72714
+	Backport from trunk
+	* resolve.c (resolve_allocate_expr): Add some tests for coarrays.
+
+2019-03-03  Harald Anlauf  <anlauf@gmx.de>
+	    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/77583
+	* symbol.c (check_conflict): Check for valid procedure name
+	passed to error reporting routine.
+
+2019-03-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87689
+	Backport from trunk
+	* trans-decl.c (gfc_get_extern_function_decl): Add argument
+	actual_args and pass it through to gfc_get_function_type.
+	* trans-expr.c (conv_function_val): Add argument actual_args
+	and pass it on to gfc_get_extern_function_decl.
+	(conv_procedure_call): Pass actual arguments to conv_function_val.
+	* trans-types.c (get_formal_from_actual_arglist): New function.
+	(gfc_get_function_type): Add argument actual_args.  Generate
+	formal args from actual args if necessary.
+	* trans-types.h (gfc_get_function_type): Add optional argument.
+	* trans.h (gfc_get_extern_function_decl): Add optional argument.
+
+2019-02-23  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/88117
+	* resolve.c (deferred_op_assign): Return if the lhs expression
+	has the pointer attribute.
+
+2019-02-23  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71066
+	Backport from trunk
+	* trans-decl.c (generate_coarray_sym_init):  For an array
+	constructor in a DATA statement of a coarray variable, set the
+	rank to 1 to avoid confusion later on.  If the constructor
+	contains only one value, use that for initiailizig.
+
+2019-02-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89077
+	* decl.c (add_init_expr_to_sym): Copy length of string initializer
+	to declared symbol.
+
+2019-02-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71723
+	Backport from trunk
+	* expr.c (gfc_check_assign): Add argument is_init_expr.  If we are
+	looking at an init expression, issue error if the target is not a
+	TARGET and we are not looking at a procedure pointer.
+	* gfortran.h (gfc_check_assign): Add optional argument
+	is_init_expr.
+
+2019-02-05  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/67679
+	Backport from trunk
+	* trans-array.c (gfc_array_allocate):  For setting the bounds on
+	the new array, add a condition for a not previously allocated
+	variable.
+
+2019-02-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/88393
+	* trans-expr.c (gfc_conv_procedure_call): For derived entities,
+	passed in parentheses to class formals, invert the order of
+	copying allocatable components to taking the _data of the
+	class expression.
+
+2019-02-02  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/88298
+	Backport from trunk
+	* arith.c (gfc_int2int): Do not warn if src->do_not_warn is set.
+	* gfortran.h (gfc_expr): Add flag do_not_warn.
+	* intrinsic.c (gfc_convert_type_warn): Set expr->do_not_warn if
+	no warning is desired.
+
+2019-02-02  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/57048
+	Backport from trunk
+	* interface.c (gfc_compare_types): If a derived type and an
+	integer both have a derived type, and they are identical,
+	this is a C binding type and compares equal.
+
+2019-01-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/56386
+	PR fortran/58906
+	PR fortran/77385
+	PR fortran/80260
+	PR fortran/82077
+	* resolve.c (resolve_variable): Fix up expressions with array
+	associate names, where the parser did not detect that this is
+	array and there was no array part_ref in the expression.
+	* trans-expr.c (gfc_find_and_cut_at_last_class_ref): base_expr
+	should be a copy of e and not the initialization expr.
+
+2019-01-15  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/81849
+	* resolve.c (resolve_symbol): Host associated varaibles can appear
+	in the specification statement of a RESULT array.
+
+2019-01-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/35031
+	* decl.c (gfc_match_entry): Check for F2018:C1546.  Fix nearby
+	mis-indentation.
+
+2018-12-29  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/82550
+	* trans_decl.c (gfc_get_symbol_decl): Procedure symbols that
+	have the 'used_in_submodule' attribute should be processed by
+	'gfc_get_extern_function_decl'.
+
+2018-12-23  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/77703
+	* resolve.c (get_temp_from_expr): Use the string length of
+	constant character expressions.
+
+2018-12-22  Steven G . Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85798
+	* decl.c (gfc_match_data): If a component of a derived type entity
+	appears in data statement, check that does not have the allocatable
+	attribute.
+
+2018-12-22  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/85544
+	* frontend-passes.c (optimize_power): Remove.
+	(optimize_op): Remove call to optimize_power.
+	* trans-expr.c (gfc_conv_power_op): Handle cases of 1**integer,
+	(2|4|8|16) ** integer and (-1) ** integer.
+
+2018-12-21  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88169
+	* module.c (mio_namelist): Remove an error condition/message that
+	is contrary to the Fortran standard.
+
+2018-12-15  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88138
+	* decl.c (variable_decl): Check that a derived isn't being assigned
+	an incompatible entity in an initialization.
+
+2018-12-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88155
+	* primary.c (gfc_match_structure_constructor):  Set the locus of
+	an expression to avoid a NULL pointer dereference.
+
+2018-12-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88249
+	* gfortran.h: Update prototype for gfc_resolve_filepos().
+	* io.c (gfc_resolve_filepos): Check for UNIT number if ERR= is present.
+	Use passed in locus for error message.
+	* resolve.c (gfc_resolve_code): Pass locus in gfc_resolve_filepos()
+	call.
+
+2018-12-10  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88269
+	* io.c (io_constraint): Update macro. If locus line buffer is NULL,
+	use gfc_current_locus in error messages.
+	(check_io_constraints): Catch missing IO UNIT in write and read
+	statements.  io_constraint macro is incompatible here.
+
+2018-12-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88205
+	* io.c (gfc_match_open): Move NEWUNIT checks to after STATUS checks.
+
+2018-12-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88206
+	* match.c (gfc_match_type_spec): REAL can be an intrinsic function.
+
+2018-12-09  Fritz Reese  <fritzoreese@gmail.com>
+
+	PR fortran/88228
+	* resolve.c (resolve_operator):  Do not call resolve_function.
+	Break like other cases.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: gcc/fortran/expr.c
===================================================================
--- a/src/gcc/fortran/expr.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/expr.c	(.../branches/gcc-7-branch)
@@ -3342,7 +3342,7 @@
    NULLIFY statement.  */
 
 bool
-gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)
+gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue, bool is_init_expr)
 {
   symbol_attribute attr, lhs_attr;
   gfc_ref *ref;
@@ -3773,12 +3773,36 @@
       return false;
     }
 
-  if (!attr.target && !attr.pointer)
+  if (is_init_expr)
     {
-      gfc_error ("Pointer assignment target is neither TARGET "
-		 "nor POINTER at %L", &rvalue->where);
-      return false;
+      gfc_symbol *sym;
+      bool target;
+
+      gcc_assert (rvalue->symtree);
+      sym = rvalue->symtree->n.sym;
+
+      if (sym->ts.type == BT_CLASS && sym->attr.class_ok)
+	target = CLASS_DATA (sym)->attr.target;
+      else
+	target = sym->attr.target;
+
+      if (!target && !proc_pointer)
+	{
+	  gfc_error ("Pointer assignment target in initialization expression "
+		     "does not have the TARGET attribute at %L",
+		     &rvalue->where);
+	  return false;
+	}
     }
+  else
+    {
+      if (!attr.target && !attr.pointer)
+	{
+	  gfc_error ("Pointer assignment target is neither TARGET "
+		     "nor POINTER at %L", &rvalue->where);
+	  return false;
+	}
+    }
 
   if (is_pure && gfc_impure_variable (rvalue->symtree->n.sym))
     {
@@ -3903,7 +3927,7 @@
     }
 
   if (pointer || proc_pointer)
-    r = gfc_check_pointer_assign (&lvalue, rvalue);
+    r = gfc_check_pointer_assign (&lvalue, rvalue, true);
   else
     {
       /* If a conversion function, e.g., __convert_i8_i4, was inserted
Index: gcc/fortran/module.c
===================================================================
--- a/src/gcc/fortran/module.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/module.c	(.../branches/gcc-7-branch)
@@ -3632,7 +3632,6 @@
 mio_namelist (gfc_symbol *sym)
 {
   gfc_namelist *n, *m;
-  const char *check_name;
 
   mio_lparen ();
 
@@ -3643,17 +3642,6 @@
     }
   else
     {
-      /* This departure from the standard is flagged as an error.
-	 It does, in fact, work correctly. TODO: Allow it
-	 conditionally?  */
-      if (sym->attr.flavor == FL_NAMELIST)
-	{
-	  check_name = find_use_name (sym->name, false);
-	  if (check_name && strcmp (check_name, sym->name) != 0)
-	    gfc_error ("Namelist %s cannot be renamed by USE "
-		       "association to %s", sym->name, check_name);
-	}
-
       m = NULL;
       while (peek_atom () != ATOM_RPAREN)
 	{
Index: gcc/fortran/trans-types.c
===================================================================
--- a/src/gcc/fortran/trans-types.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/trans-types.c	(.../branches/gcc-7-branch)
@@ -1139,7 +1139,8 @@
         {
           spec->type = BT_INTEGER;
           spec->kind = gfc_index_integer_kind;
-          spec->f90_type = BT_VOID;
+	  spec->f90_type = BT_VOID;
+	  spec->is_c_interop = 1;  /* Mark as escaping later.  */
         }
       break;
     case BT_VOID:
@@ -1156,6 +1157,9 @@
 	    basetype = pfunc_type_node;
 	}
        break;
+    case BT_PROCEDURE:
+      basetype = pfunc_type_node;
+      break;
     default:
       gcc_unreachable ();
     }
@@ -2884,7 +2888,8 @@
 		    || f->sym->ts.u.derived->attr.pointer_comp))
 	    || (f->sym->ts.type == BT_CLASS
 		&& (CLASS_DATA (f->sym)->ts.u.derived->attr.proc_pointer_comp
-		    || CLASS_DATA (f->sym)->ts.u.derived->attr.pointer_comp)))
+		    || CLASS_DATA (f->sym)->ts.u.derived->attr.pointer_comp))
+	    || (f->sym->ts.type == BT_INTEGER && f->sym->ts.is_c_interop))
 	  spec[spec_len++] = '.';
 	else if (f->sym->attr.intent == INTENT_IN)
 	  spec[spec_len++] = 'r';
@@ -2897,9 +2902,65 @@
   return build_type_attribute_variant (fntype, tmp);
 }
 
+/* Helper function - if we do not find an interface for a procedure,
+   construct it from the actual arglist.  Luckily, this can only
+   happen for call by reference, so the information we actually need
+   to provide (and which would be impossible to guess from the call
+   itself) is not actually needed.  */
 
+static void
+get_formal_from_actual_arglist (gfc_symbol *sym, gfc_actual_arglist *actual_args)
+{
+  gfc_actual_arglist *a;
+  gfc_formal_arglist **f;
+  gfc_symbol *s;
+  char name[GFC_MAX_SYMBOL_LEN + 1];
+  static int var_num;
+
+  f = &sym->formal;
+  for (a = actual_args; a != NULL; a = a->next)
+    {
+      (*f) = gfc_get_formal_arglist ();
+      if (a->expr)
+	{
+	  snprintf (name, GFC_MAX_SYMBOL_LEN, "_formal_%d", var_num ++);
+	  gfc_get_symbol (name, gfc_current_ns, &s);
+	  if (a->expr->ts.type == BT_PROCEDURE)
+	    {
+	      s->attr.flavor = FL_PROCEDURE;
+	    }
+	  else
+	    {
+	      s->ts = a->expr->ts;
+
+	      if (s->ts.type == BT_CHARACTER)
+		s->ts.u.cl = gfc_get_charlen ();
+
+ 	      s->ts.deferred = 0;
+ 	      s->ts.is_iso_c = 0;
+ 	      s->ts.is_c_interop = 0;
+	      s->attr.flavor = FL_VARIABLE;
+	      if (a->expr->rank > 0)
+		{
+		  s->attr.dimension = 1;
+		  s->as = gfc_get_array_spec ();
+		  s->as->type = AS_ASSUMED_SIZE;
+		}
+	    }
+	  s->attr.dummy = 1;
+	  s->attr.artificial = 1;
+	  s->attr.intent = INTENT_UNKNOWN;
+	  (*f)->sym = s;
+	}
+      else  /* If a->expr is NULL, this is an alternate rerturn.  */
+	(*f)->sym = NULL;
+
+      f = &((*f)->next);
+    }
+}
+
 tree
-gfc_get_function_type (gfc_symbol * sym)
+gfc_get_function_type (gfc_symbol * sym, gfc_actual_arglist *actual_args)
 {
   tree type;
   vec<tree, va_gc> *typelist = NULL;
@@ -2957,6 +3018,10 @@
 	    vec_safe_push (typelist, build_pointer_type(gfc_charlen_type_node));
 	}
     }
+  if (sym->backend_decl == error_mark_node && actual_args != NULL
+      && sym->formal == NULL && (sym->attr.proc == PROC_EXTERNAL
+				 || sym->attr.proc == PROC_UNKNOWN))
+    get_formal_from_actual_arglist (sym, actual_args);
 
   /* Build the argument types for the function.  */
   for (f = gfc_sym_get_dummy_args (sym); f; f = f->next)
Index: gcc/fortran/trans.h
===================================================================
--- a/src/gcc/fortran/trans.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/trans.h	(.../branches/gcc-7-branch)
@@ -578,7 +578,8 @@
 tree gfc_get_label_decl (gfc_st_label *);
 
 /* Return the decl for an external function.  */
-tree gfc_get_extern_function_decl (gfc_symbol *);
+tree gfc_get_extern_function_decl (gfc_symbol *,
+				   gfc_actual_arglist *args = NULL);
 
 /* Return the decl for a function.  */
 tree gfc_get_function_decl (gfc_symbol *);
Index: gcc/fortran/trans-types.h
===================================================================
--- a/src/gcc/fortran/trans-types.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/trans-types.h	(.../branches/gcc-7-branch)
@@ -87,7 +87,7 @@
 tree gfc_typenode_for_spec (gfc_typespec *, int c = 0);
 int gfc_copy_dt_decls_ifequal (gfc_symbol *, gfc_symbol *, bool);
 
-tree gfc_get_function_type (gfc_symbol *);
+tree gfc_get_function_type (gfc_symbol *, gfc_actual_arglist *args = NULL);
 
 tree gfc_type_for_size (unsigned, int);
 tree gfc_type_for_mode (machine_mode, int);
Index: gcc/fortran/io.c
===================================================================
--- a/src/gcc/fortran/io.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/io.c	(.../branches/gcc-7-branch)
@@ -2090,33 +2090,6 @@
 
   warn = (open->err || open->iostat) ? true : false;
 
-  /* Checks on NEWUNIT specifier.  */
-  if (open->newunit)
-    {
-      if (open->unit)
-	{
-	  gfc_error ("UNIT specifier not allowed with NEWUNIT at %C");
-	  goto cleanup;
-	}
-
-      if (!open->file && open->status)
-        {
-	  if (open->status->expr_type == EXPR_CONSTANT
-	     && gfc_wide_strncasecmp (open->status->value.character.string,
-				       "scratch", 7) != 0)
-	   {
-	     gfc_error ("NEWUNIT specifier must have FILE= "
-			"or STATUS='scratch' at %C");
-	     goto cleanup;
-	   }
-	}
-    }
-  else if (!open->unit)
-    {
-      gfc_error ("OPEN statement at %C must have UNIT or NEWUNIT specified");
-      goto cleanup;
-    }
-
   /* Checks on the ACCESS specifier.  */
   if (open->access && open->access->expr_type == EXPR_CONSTANT)
     {
@@ -2441,6 +2414,33 @@
 	}
     }
 
+  /* Checks on NEWUNIT specifier.  */
+  if (open->newunit)
+    {
+      if (open->unit)
+	{
+	  gfc_error ("UNIT specifier not allowed with NEWUNIT at %C");
+	  goto cleanup;
+	}
+
+      if (!open->file && open->status)
+        {
+	  if (open->status->expr_type == EXPR_CONSTANT
+	     && gfc_wide_strncasecmp (open->status->value.character.string,
+				       "scratch", 7) != 0)
+	   {
+	     gfc_error ("NEWUNIT specifier must have FILE= "
+			"or STATUS='scratch' at %C");
+	     goto cleanup;
+	   }
+	}
+    }
+  else if (!open->unit)
+    {
+      gfc_error ("OPEN statement at %C must have UNIT or NEWUNIT specified");
+      goto cleanup;
+    }
+
   /* Things that are not allowed for unformatted I/O.  */
   if (open->form && open->form->expr_type == EXPR_CONSTANT
       && (open->delim || open->decimal || open->encoding || open->round
@@ -2774,22 +2774,21 @@
 
 
 bool
-gfc_resolve_filepos (gfc_filepos *fp)
+gfc_resolve_filepos (gfc_filepos *fp, locus *where)
 {
   RESOLVE_TAG (&tag_unit, fp->unit);
   RESOLVE_TAG (&tag_iostat, fp->iostat);
   RESOLVE_TAG (&tag_iomsg, fp->iomsg);
-  if (!gfc_reference_st_label (fp->err, ST_LABEL_TARGET))
-    return false;
 
-  if (!fp->unit && (fp->iostat || fp->iomsg))
+  if (!fp->unit && (fp->iostat || fp->iomsg || fp->err))
     {
-      locus where;
-      where = fp->iostat ? fp->iostat->where : fp->iomsg->where;
-      gfc_error ("UNIT number missing in statement at %L", &where);
+      gfc_error ("UNIT number missing in statement at %L", where);
       return false;
     }
 
+  if (!gfc_reference_st_label (fp->err, ST_LABEL_TARGET))
+    return false;
+
   if (fp->unit->expr_type == EXPR_CONSTANT
       && fp->unit->ts.type == BT_INTEGER
       && mpz_sgn (fp->unit->value.integer) < 0)
@@ -3617,10 +3616,13 @@
 check_io_constraints (io_kind k, gfc_dt *dt, gfc_code *io_code,
 		      locus *spec_end)
 {
-#define io_constraint(condition,msg,arg)\
+#define io_constraint(condition, msg, arg)\
 if (condition) \
   {\
-    gfc_error(msg,arg);\
+    if ((arg)->lb != NULL)\
+      gfc_error ((msg), (arg));\
+    else\
+      gfc_error ((msg), &gfc_current_locus);\
     m = MATCH_ERROR;\
   }
 
@@ -3680,11 +3682,14 @@
   if (expr && expr->ts.type != BT_CHARACTER)
     {
 
-      io_constraint (gfc_pure (NULL) && (k == M_READ || k == M_WRITE),
-		     "IO UNIT in %s statement at %C must be "
+      if (gfc_pure (NULL) && (k == M_READ || k == M_WRITE))
+	{
+	  gfc_error ("IO UNIT in %s statement at %C must be "
 		     "an internal file in a PURE procedure",
 		     io_kind_name (k));
-
+	  return MATCH_ERROR;
+	}
+	  
       if (k == M_READ || k == M_WRITE)
 	gfc_unset_implicit_pure (NULL);
     }
Index: gcc/fortran/frontend-passes.c
===================================================================
--- a/src/gcc/fortran/frontend-passes.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/frontend-passes.c	(.../branches/gcc-7-branch)
@@ -701,6 +701,11 @@
   if (e->expr_type == EXPR_CONSTANT || is_fe_temp (e))
     return gfc_copy_expr (e);
 
+  /* Creation of an array of unknown size requires realloc on assignment.
+     If that is not possible, just return NULL.  */
+  if (flag_realloc_lhs == 0 && e->rank > 0 && e->shape == NULL)
+    return NULL;
+
   ns = insert_block ();
 
   if (vname)
@@ -748,7 +753,7 @@
     }
 
   deferred = 0;
-  if (e->ts.type == BT_CHARACTER && e->rank == 0)
+  if (e->ts.type == BT_CHARACTER)
     {
       gfc_expr *length;
 
@@ -759,6 +764,8 @@
       else
 	{
 	  symbol->attr.allocatable = 1;
+	  symbol->ts.u.cl->length = NULL;
+	  symbol->ts.deferred = 1;
 	  deferred = 1;
 	}
     }
@@ -771,7 +778,7 @@
 
   result = gfc_get_expr ();
   result->expr_type = EXPR_VARIABLE;
-  result->ts = e->ts;
+  result->ts = symbol->ts;
   result->ts.deferred = deferred;
   result->rank = e->rank;
   result->shape = gfc_copy_shape (e->shape, e->rank);
@@ -1422,84 +1429,6 @@
   return true;
 }
 
-/* Change (-1)**k into 1-ishift(iand(k,1),1) and
- 2**k into ishift(1,k) */
-
-static bool
-optimize_power (gfc_expr *e)
-{
-  gfc_expr *op1, *op2;
-  gfc_expr *iand, *ishft;
-
-  if (e->ts.type != BT_INTEGER)
-    return false;
-
-  op1 = e->value.op.op1;
-
-  if (op1 == NULL || op1->expr_type != EXPR_CONSTANT)
-    return false;
-
-  if (mpz_cmp_si (op1->value.integer, -1L) == 0)
-    {
-      gfc_free_expr (op1);
-
-      op2 = e->value.op.op2;
-
-      if (op2 == NULL)
-	return false;
-
-      iand = gfc_build_intrinsic_call (current_ns, GFC_ISYM_IAND,
-				       "_internal_iand", e->where, 2, op2,
-				       gfc_get_int_expr (e->ts.kind,
-							 &e->where, 1));
-
-      ishft = gfc_build_intrinsic_call (current_ns, GFC_ISYM_ISHFT,
-					"_internal_ishft", e->where, 2, iand,
-					gfc_get_int_expr (e->ts.kind,
-							  &e->where, 1));
-
-      e->value.op.op = INTRINSIC_MINUS;
-      e->value.op.op1 = gfc_get_int_expr (e->ts.kind, &e->where, 1);
-      e->value.op.op2 = ishft;
-      return true;
-    }
-  else if (mpz_cmp_si (op1->value.integer, 2L) == 0)
-    {
-      gfc_free_expr (op1);
-
-      op2 = e->value.op.op2;
-      if (op2 == NULL)
-	return false;
-
-      ishft = gfc_build_intrinsic_call (current_ns, GFC_ISYM_ISHFT,
-					"_internal_ishft", e->where, 2,
-					gfc_get_int_expr (e->ts.kind,
-							  &e->where, 1),
-					op2);
-      *e = *ishft;
-      return true;
-    }
-
-  else if (mpz_cmp_si (op1->value.integer, 1L) == 0)
-    {
-      op2 = e->value.op.op2;
-      if (op2 == NULL)
-	return false;
-
-      gfc_free_expr (op1);
-      gfc_free_expr (op2);
-
-      e->expr_type = EXPR_CONSTANT;
-      e->value.op.op1 = NULL;
-      e->value.op.op2 = NULL;
-      mpz_init_set_si (e->value.integer, 1);
-      /* Typespec and location are still OK.  */
-      return true;
-    }
-
-  return false;
-}
-
 /* Recursive optimization of operators.  */
 
 static bool
@@ -1560,9 +1489,6 @@
     case INTRINSIC_DIVIDE:
       return combine_array_constructor (e) || changed;
 
-    case INTRINSIC_POWER:
-      return optimize_power (e);
-
     default:
       break;
     }
Index: gcc/fortran/resolve.c
===================================================================
--- a/src/gcc/fortran/resolve.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/resolve.c	(.../branches/gcc-7-branch)
@@ -1045,7 +1045,7 @@
 	}
       if (!gsym)
 	{
-	  gsym = gfc_get_gsymbol (common_root->n.common->name);
+	  gsym = gfc_get_gsymbol (common_root->n.common->name, false);
 	  gsym->type = GSYM_COMMON;
 	  gsym->where = common_root->n.common->where;
 	  gsym->defined = 1;
@@ -1067,7 +1067,7 @@
 	}
       if (!gsym)
 	{
-	  gsym = gfc_get_gsymbol (common_root->n.common->binding_label);
+	  gsym = gfc_get_gsymbol (common_root->n.common->binding_label, true);
 	  gsym->type = GSYM_COMMON;
 	  gsym->where = common_root->n.common->where;
 	  gsym->defined = 1;
@@ -1576,8 +1576,6 @@
       || gfc_fl_struct (sym->attr.flavor))
     return false;
 
-  gcc_assert (sym->attr.flavor == FL_PROCEDURE);
-
   /* If we've got an ENTRY, find real procedure.  */
   if (sym->attr.entry && sym->ns->entries)
     proc_sym = sym->ns->entries->sym;
@@ -2379,7 +2377,8 @@
 
   type = sub ? GSYM_SUBROUTINE : GSYM_FUNCTION;
 
-  gsym = gfc_get_gsymbol (sym->binding_label ? sym->binding_label : sym->name);
+  gsym = gfc_get_gsymbol (sym->binding_label ? sym->binding_label : sym->name,
+			  sym->binding_label != NULL);
 
   if ((gsym->type != GSYM_UNKNOWN && gsym->type != type))
     gfc_global_used (gsym, where);
@@ -3737,7 +3736,7 @@
 	  if (op2->ts.type != e->ts.type || op2->ts.kind != e->ts.kind)
 	    gfc_convert_type (op2, &e->ts, 1);
 	  e = logical_to_bitwise (e);
-	  return resolve_function (e);
+	  break;
 	}
 
       sprintf (msg, _("Operands of logical operator %%<%s%%> at %%L are %s/%s"),
@@ -3753,7 +3752,7 @@
 	  e->ts.type = BT_INTEGER;
 	  e->ts.kind = op1->ts.kind;
 	  e = logical_to_bitwise (e);
-	  return resolve_function (e);
+	  break;
 	}
 
       if (op1->ts.type == BT_LOGICAL)
@@ -5161,6 +5160,23 @@
 	gfc_fix_class_refs (e);
       if (!sym->attr.dimension && e->ref && e->ref->type == REF_ARRAY)
 	return false;
+       else if (sym->attr.dimension && (!e->ref || e->ref->type != REF_ARRAY))
+	  {
+	    /* This can happen because the parser did not detect that the
+	       associate name is an array and the expression had no array
+	       part_ref.  */
+	    gfc_ref *ref = gfc_get_ref ();
+	    ref->type = REF_ARRAY;
+	    ref->u.ar = *gfc_get_array_ref();
+	    ref->u.ar.type = AR_FULL;
+	    if (sym->as)
+	      {
+		ref->u.ar.as = sym->as;
+		ref->u.ar.dimen = sym->as->rank;
+	      }
+	    ref->next = e->ref;
+	    e->ref = ref;
+	  }
     }
 
   if (sym->ts.type == BT_DERIVED && sym->ts.u.derived->attr.generic)
@@ -6989,6 +7005,10 @@
   for (ref = result->ref; ref; ref = ref->next)
     if (ref->type == REF_ARRAY && ref->next == NULL)
       {
+	if (ref->u.ar.dimen == 0
+	    && ref->u.ar.as && ref->u.ar.as->corank)
+	  return result;
+
 	ref->u.ar.type = AR_FULL;
 
 	for (i = 0; i < ref->u.ar.dimen; i++)
@@ -7414,13 +7434,54 @@
 
   if (codimension)
     for (i = ar->dimen; i < ar->dimen + ar->codimen; i++)
-      if (ar->dimen_type[i] == DIMEN_THIS_IMAGE)
-	{
-	  gfc_error ("Coarray specification required in ALLOCATE statement "
-		     "at %L", &e->where);
-	  goto failure;
-	}
+      {
+	switch (ar->dimen_type[i])
+	  {
+	  case DIMEN_THIS_IMAGE:
+	    gfc_error ("Coarray specification required in ALLOCATE statement "
+		       "at %L", &e->where);
+	    goto failure;
 
+	  case  DIMEN_RANGE:
+	    if (ar->start[i] == 0 || ar->end[i] == 0)
+	      {
+		/* If ar->stride[i] is NULL, we issued a previous error.  */
+		if (ar->stride[i] == NULL)
+		  gfc_error ("Bad array specification in ALLOCATE statement "
+			     "at %L", &e->where);
+		goto failure;
+	      }
+	    else if (gfc_dep_compare_expr (ar->start[i], ar->end[i]) == 1)
+	      {
+		gfc_error ("Upper cobound is less than lower cobound at %L",
+			   &ar->start[i]->where);
+		goto failure;
+	      }
+	    break;
+
+	  case DIMEN_ELEMENT:
+	    if (ar->start[i]->expr_type == EXPR_CONSTANT)
+	      {
+		gcc_assert (ar->start[i]->ts.type == BT_INTEGER);
+		if (mpz_cmp_si (ar->start[i]->value.integer, 1) < 0)
+		  {
+		    gfc_error ("Upper cobound is less than lower cobound "
+			       " of 1 at %L", &ar->start[i]->where);
+		    goto failure;
+		  }
+	      }
+	    break;
+
+	  case DIMEN_STAR:
+	    break;
+
+	  default:
+	    gfc_error ("Bad array specification in ALLOCATE statement at %L",
+		       &e->where);
+	    goto failure;
+
+	  }
+      }
   for (i = 0; i < ar->dimen; i++)
     {
       if (ar->type == AR_ELEMENT || ar->type == AR_FULL)
@@ -10264,6 +10325,11 @@
   gfc_get_sym_tree (name, ns, &tmp, false);
   gfc_add_type (tmp->n.sym, &e->ts, NULL);
 
+  if (e->expr_type == EXPR_CONSTANT && e->ts.type == BT_CHARACTER)
+    tmp->n.sym->ts.u.cl->length = gfc_get_int_expr (gfc_charlen_int_kind,
+						    NULL,
+						    e->value.character.length);
+
   as = NULL;
   ref = NULL;
   aref = NULL;
@@ -10754,6 +10820,9 @@
   if (!gfc_check_dependency ((*code)->expr1, (*code)->expr2, 1))
     return false;
 
+  if (gfc_expr_attr ((*code)->expr1).pointer)
+    return false;
+
   tmp_expr = get_temp_from_expr ((*code)->expr1, ns);
   tmp_expr->where = (*code)->loc;
 
@@ -11163,7 +11232,7 @@
 	case EXEC_ENDFILE:
 	case EXEC_REWIND:
 	case EXEC_FLUSH:
-	  if (!gfc_resolve_filepos (code->ext.filepos))
+	  if (!gfc_resolve_filepos (code->ext.filepos, &code->loc))
 	    break;
 
 	  resolve_branch (code->ext.filepos->err, code);
@@ -11385,7 +11454,7 @@
 	  && (gsym->type == GSYM_FUNCTION || gsym->type == GSYM_SUBROUTINE)))
     {
       if (!gsym)
-	gsym = gfc_get_gsymbol (sym->binding_label);
+	gsym = gfc_get_gsymbol (sym->binding_label, true);
       gsym->where = sym->declared_at;
       gsym->sym_name = sym->name;
       gsym->binding_label = sym->binding_label;
@@ -14854,7 +14923,7 @@
   /* Set the formal_arg_flag so that check_conflict will not throw
      an error for host associated variables in the specification
      expression for an array_valued function.  */
-  if (sym->attr.function && sym->as)
+  if ((sym->attr.function || sym->attr.result) && sym->as)
     formal_arg_flag = true;
 
   saved_specification_expr = specification_expr;
@@ -15883,8 +15952,8 @@
 }
 
 
-/* Function called by resolve_fntype to flag other symbol used in the
-   length type parameter specification of function resuls.  */
+/* Function called by resolve_fntype to flag other symbols used in the
+   length type parameter specification of function results.  */
 
 static bool
 flag_fn_result_spec (gfc_expr *expr,
Index: gcc/fortran/iresolve.c
===================================================================
--- a/src/gcc/fortran/iresolve.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/iresolve.c	(.../branches/gcc-7-branch)
@@ -35,6 +35,7 @@
 #include "intrinsic.h"
 #include "constructor.h"
 #include "arith.h"
+#include "trans.h"
 
 /* Given printf-like arguments, return a stable version of the result string. 
 
@@ -2286,6 +2287,10 @@
     a->name = "%VAL";
 
   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);
+  /* We set the backend_decl here because runtime_error is a
+     variadic function and we would use the wrong calling
+     convention otherwise.  */
+  c->resolved_sym->backend_decl = gfor_fndecl_runtime_error;
 }
 
 void
Index: gcc/fortran/trans-decl.c
===================================================================
--- a/src/gcc/fortran/trans-decl.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/trans-decl.c	(.../branches/gcc-7-branch)
@@ -334,40 +334,45 @@
     }
 }
 
+/* Return the name of an identifier.  */
 
+static const char *
+sym_identifier (gfc_symbol *sym)
+{
+  if (sym->attr.is_main_program && strcmp (sym->name, "main") == 0)
+    return "MAIN__";
+  else
+    return sym->name;
+}
+
 /* Convert a gfc_symbol to an identifier of the same name.  */
 
 static tree
 gfc_sym_identifier (gfc_symbol * sym)
 {
-  if (sym->attr.is_main_program && strcmp (sym->name, "main") == 0)
-    return (get_identifier ("MAIN__"));
-  else
-    return (get_identifier (sym->name));
+  return get_identifier (sym_identifier (sym));
 }
 
+/* Construct mangled name from symbol name.   */
 
-/* Construct mangled name from symbol name.  */
-
-static tree
-gfc_sym_mangled_identifier (gfc_symbol * sym)
+static const char *
+mangled_identifier (gfc_symbol *sym)
 {
-  char name[GFC_MAX_MANGLED_SYMBOL_LEN + 1];
-
+  gfc_symbol *proc = sym->ns->proc_name;
+  static char name[3*GFC_MAX_MANGLED_SYMBOL_LEN + 14];
   /* Prevent the mangling of identifiers that have an assigned
      binding label (mainly those that are bind(c)).  */
+
   if (sym->attr.is_bind_c == 1 && sym->binding_label)
-    return get_identifier (sym->binding_label);
+    return sym->binding_label;
 
-  if (!sym->fn_result_spec)
+  if (!sym->fn_result_spec
+      || (sym->module && !(proc && proc->attr.flavor == FL_PROCEDURE)))
     {
       if (sym->module == NULL)
-	return gfc_sym_identifier (sym);
+	return sym_identifier (sym);
       else
-	{
-	  snprintf (name, sizeof name, "__%s_MOD_%s", sym->module, sym->name);
-	  return get_identifier (name);
-	}
+	snprintf (name, sizeof name, "__%s_MOD_%s", sym->module, sym->name);
     }
   else
     {
@@ -374,25 +379,42 @@
       /* This is an entity that is actually local to a module procedure
 	 that appears in the result specification expression.  Since
 	 sym->module will be a zero length string, we use ns->proc_name
-	 instead. */
-      if (sym->ns->proc_name && sym->ns->proc_name->module)
-	{
-	  snprintf (name, sizeof name, "__%s_MOD__%s_PROC_%s",
-		    sym->ns->proc_name->module,
-		    sym->ns->proc_name->name,
-		    sym->name);
-	  return get_identifier (name);
-	}
+	 to provide the module name instead. */
+      if (proc && proc->module)
+	snprintf (name, sizeof name, "__%s_MOD__%s_PROC_%s",
+		  proc->module, proc->name, sym->name);
       else
-	{
-	  snprintf (name, sizeof name, "__%s_PROC_%s",
-		    sym->ns->proc_name->name, sym->name);
-	  return get_identifier (name);
-	}
+	snprintf (name, sizeof name, "__%s_PROC_%s",
+		  proc->name, sym->name);
     }
+
+  return name;
 }
 
+/* Get mangled identifier, adding the symbol to the global table if
+   it is not yet already there.  */
 
+static tree
+gfc_sym_mangled_identifier (gfc_symbol * sym)
+{
+  tree result;
+  gfc_gsymbol *gsym;
+  const char *name;
+
+  name = mangled_identifier (sym);
+  result = get_identifier (name);
+
+  gsym = gfc_find_gsymbol (gfc_gsym_root, name);
+  if (gsym == NULL)
+    {
+      gsym = gfc_get_gsymbol (name, false);
+      gsym->ns = sym->ns;
+      gsym->sym_name = sym->name;
+    }
+
+  return result;
+}
+
 /* Construct mangled function name from symbol name.  */
 
 static tree
@@ -831,7 +853,7 @@
 	{
 	  if (!gsym)
 	    {
-	      gsym = gfc_get_gsymbol (sym->module);
+	      gsym = gfc_get_gsymbol (sym->module, false);
 	      gsym->type = GSYM_MODULE;
 	      gsym->ns = gfc_get_namespace (NULL, 0);
 	    }
@@ -1569,13 +1591,17 @@
 	  if (VAR_P (length) && DECL_FILE_SCOPE_P (length))
 	    {
 	      /* Add the string length to the same context as the symbol.  */
-	      if (DECL_CONTEXT (sym->backend_decl) == current_function_decl)
-	        gfc_add_decl_to_function (length);
-	      else
-		gfc_add_decl_to_parent_function (length);
+	      if (DECL_CONTEXT (length) == NULL_TREE)
+		{
+		  if (DECL_CONTEXT (sym->backend_decl)
+		      == current_function_decl)
+		    gfc_add_decl_to_function (length);
+		  else
+		    gfc_add_decl_to_parent_function (length);
+		}
 
-	      gcc_assert (DECL_CONTEXT (sym->backend_decl) ==
-			    DECL_CONTEXT (length));
+	      gcc_assert (DECL_CONTEXT (sym->backend_decl)
+			  == DECL_CONTEXT (length));
 
 	      gfc_defer_symbol_init (sym);
 	    }
@@ -1655,7 +1681,9 @@
     {
       /* Catch functions. Only used for actual parameters,
 	 procedure pointers and procptr initialization targets.  */
-      if (sym->attr.use_assoc || sym->attr.intrinsic
+      if (sym->attr.use_assoc
+	  || sym->attr.used_in_submodule
+	  || sym->attr.intrinsic
 	  || sym->attr.if_source != IFSRC_DECL)
 	{
 	  decl = gfc_get_extern_function_decl (sym);
@@ -1862,6 +1890,22 @@
   tree decl;
   tree attributes;
 
+  if (sym->module || sym->fn_result_spec)
+    {
+      const char *name;
+      gfc_gsymbol *gsym;
+
+      name = mangled_identifier (sym);
+      gsym = gfc_find_gsymbol (gfc_gsym_root, name);
+      if (gsym != NULL)
+	{
+	  gfc_symbol *s;
+	  gfc_find_symbol (sym->name, gsym->ns, 0, &s);
+	  if (s && s->backend_decl)
+	    return s->backend_decl;
+	}
+    }
+
   decl = sym->backend_decl;
   if (decl)
     return decl;
@@ -1934,7 +1978,7 @@
 /* Get a basic decl for an external function.  */
 
 tree
-gfc_get_extern_function_decl (gfc_symbol * sym)
+gfc_get_extern_function_decl (gfc_symbol * sym, gfc_actual_arglist *actual_args)
 {
   tree type;
   tree fndecl;
@@ -1959,10 +2003,23 @@
     return get_proc_pointer_decl (sym);
 
   /* See if this is an external procedure from the same file.  If so,
-     return the backend_decl.  */
-  gsym =  gfc_find_gsymbol (gfc_gsym_root, sym->binding_label
-					   ? sym->binding_label : sym->name);
+     return the backend_decl.  If we are looking at a BIND(C)
+     procedure and the symbol is not BIND(C), or vice versa, we
+     haven't found the right procedure.  */
 
+  if (sym->binding_label)
+    {
+      gsym = gfc_find_gsymbol (gfc_gsym_root, sym->binding_label);
+      if (gsym && !gsym->bind_c)
+	gsym = NULL;
+    }
+  else
+    {
+      gsym = gfc_find_gsymbol (gfc_gsym_root, sym->name);
+      if (gsym && gsym->bind_c)
+	gsym = NULL;
+    }
+
   if (gsym && !gsym->defined)
     gsym = NULL;
 
@@ -2107,7 +2164,7 @@
       mangled_name = gfc_sym_mangled_function_id (sym);
     }
 
-  type = gfc_get_function_type (sym);
+  type = gfc_get_function_type (sym, actual_args);
   fndecl = build_decl (input_location,
 		       FUNCTION_DECL, name, type);
 
@@ -2457,6 +2514,17 @@
 	  TREE_READONLY (length) = 1;
 	  gfc_finish_decl (length);
 
+	  /* Marking the length DECL_HIDDEN_STRING_LENGTH will lead
+	     to tail calls being disabled.  Only do that if we
+	     potentially have broken callers.  */
+	  if (flag_tail_call_workaround
+	      && f->sym->ts.u.cl
+	      && f->sym->ts.u.cl->length
+	      && f->sym->ts.u.cl->length->expr_type == EXPR_CONSTANT
+	      && (flag_tail_call_workaround == 2
+		  || f->sym->ns->implicit_interface_calls))
+	    DECL_HIDDEN_STRING_LENGTH (length) = 1;
+
 	  /* Remember the passed value.  */
           if (!f->sym->ts.u.cl ||  f->sym->ts.u.cl->passed_length)
             {
@@ -5220,6 +5288,33 @@
   /* Handle "static" initializer.  */
   if (sym->value)
     {
+      if (sym->value->expr_type == EXPR_ARRAY)
+	{
+	  gfc_constructor *c, *cnext;
+
+	  /* Test if the array has more than one element.  */
+	  c = gfc_constructor_first (sym->value->value.constructor);
+	  gcc_assert (c);  /* Empty constructor should not happen here.  */
+	  cnext = gfc_constructor_next (c);
+
+	  if (cnext)
+	    {
+	      /* An EXPR_ARRAY with a rank > 1 here has to come from a
+		 DATA statement.  Set its rank here as not to confuse
+		 the following steps.   */
+	      sym->value->rank = 1;
+	    }
+	  else
+	    {
+	      /* There is only a single value in the constructor, use
+		 it directly for the assignment.  */
+	      gfc_expr *new_expr;
+	      new_expr = gfc_copy_expr (c->expr);
+	      gfc_free_expr (sym->value);
+	      sym->value = new_expr;
+	    }
+	}
+
       sym->attr.pointer = 1;
       tmp = gfc_trans_assignment (gfc_lval_expr_from_sym (sym), sym->value,
 				  true, false);
@@ -5464,9 +5559,11 @@
 	    }
 	  else if (warn_unused_dummy_argument)
 	    {
-	      gfc_warning (OPT_Wunused_dummy_argument,
-			   "Unused dummy argument %qs at %L", sym->name,
-			   &sym->declared_at);
+	      if (!sym->attr.artificial)
+		gfc_warning (OPT_Wunused_dummy_argument,
+			     "Unused dummy argument %qs at %L", sym->name,
+			     &sym->declared_at);
+
 	      if (sym->backend_decl != NULL_TREE)
 		TREE_NO_WARNING(sym->backend_decl) = 1;
 	    }
@@ -5556,12 +5653,16 @@
 			  "imported at %L", sym->name, &sym->declared_at);
 	}
 
-      if (sym->ns
-	  && sym->ns->parent
-	  && sym->ns->parent->code
-	  && sym->ns->parent->code->op == EXEC_BLOCK)
+      if (sym->ns && sym->ns->construct_entities)
 	{
-	  if (sym->attr.referenced)
+	  /* Construction of the intrinsic modules within a BLOCK
+	     construct, where ONLY and RENAMED entities are included,
+	     seems to be bogus.  This is a workaround that can be removed
+	     if someone ever takes on the task to creating full-fledge
+	     modules.  See PR 69455.  */
+	  if (sym->attr.referenced
+	      && sym->from_intmod != INTMOD_ISO_C_BINDING
+	      && sym->from_intmod != INTMOD_ISO_FORTRAN_ENV)
 	    gfc_get_symbol_decl (sym);
 	  sym->mark = 1;
 	}
Index: gcc/fortran/target-memory.c
===================================================================
--- a/src/gcc/fortran/target-memory.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/target-memory.c	(.../branches/gcc-7-branch)
@@ -111,6 +111,7 @@
     case BT_CLASS:
     case BT_VOID:
     case BT_ASSUMED:
+    case BT_PROCEDURE:
       {
 	/* Determine type size without clobbering the typespec for ISO C
 	   binding types.  */
Index: gcc/fortran/match.c
===================================================================
--- a/src/gcc/fortran/match.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/match.c	(.../branches/gcc-7-branch)
@@ -2050,8 +2050,6 @@
       ts->type = BT_CHARACTER;
 
       m = gfc_match_char_spec (ts);
-      if (ts->u.cl && ts->u.cl->length)
-	gfc_resolve_expr (ts->u.cl->length);
 
       if (m == MATCH_NO)
 	m = MATCH_YES;
@@ -2153,6 +2151,9 @@
 	      return MATCH_NO;
 	    }
 
+	  if (e->expr_type != EXPR_CONSTANT)
+	    goto ohno;
+
 	  gfc_next_char (); /* Burn the ')'. */
 	  ts->kind = (int) mpz_get_si (e->value.integer);
 	  if (gfc_validate_kind (ts->type, ts->kind , true) == -1)
@@ -2167,6 +2168,8 @@
 	}
     }
 
+ohno:
+
   /* If a type is not matched, simply return MATCH_NO.  */
   gfc_current_locus = old_locus;
   return MATCH_NO;
Index: gcc/fortran/arith.c
===================================================================
--- a/src/gcc/fortran/arith.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/arith.c	(.../branches/gcc-7-branch)
@@ -2050,7 +2050,7 @@
       gfc_convert_mpz_to_signed (result->value.integer,
 				 gfc_integer_kinds[k].bit_size);
 
-      if (warn_conversion && kind < src->ts.kind)
+      if (warn_conversion && !src->do_not_warn && kind < src->ts.kind)
 	gfc_warning_now (OPT_Wconversion, "Conversion from %qs to %qs at %L",
 			 gfc_typename (&src->ts), gfc_typename (&result->ts),
 			 &src->where);
Index: gcc/fortran/parse.c
===================================================================
--- a/src/gcc/fortran/parse.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/parse.c	(.../branches/gcc-7-branch)
@@ -5780,7 +5780,7 @@
     }
   else
     {
-      s = gfc_get_gsymbol (gfc_new_block->name);
+      s = gfc_get_gsymbol (gfc_new_block->name, false);
       if (s->defined
 	  || (s->type != GSYM_UNKNOWN && s->type != GSYM_BLOCK_DATA))
        gfc_global_used (s, &gfc_new_block->declared_at);
@@ -5862,7 +5862,7 @@
   gfc_gsymbol *s;
   bool error;
 
-  s = gfc_get_gsymbol (gfc_new_block->name);
+  s = gfc_get_gsymbol (gfc_new_block->name, false);
   if (s->defined || (s->type != GSYM_UNKNOWN && s->type != GSYM_MODULE))
     gfc_global_used (s, &gfc_new_block->declared_at);
   else
@@ -5926,7 +5926,7 @@
      name is a global identifier.  */
   if (!gfc_new_block->binding_label || gfc_notification_std (GFC_STD_F2008))
     {
-      s = gfc_get_gsymbol (gfc_new_block->name);
+      s = gfc_get_gsymbol (gfc_new_block->name, false);
 
       if (s->defined
 	  || (s->type != GSYM_UNKNOWN
@@ -5951,7 +5951,7 @@
       && (!gfc_notification_std (GFC_STD_F2008)
           || strcmp (gfc_new_block->name, gfc_new_block->binding_label) != 0))
     {
-      s = gfc_get_gsymbol (gfc_new_block->binding_label);
+      s = gfc_get_gsymbol (gfc_new_block->binding_label, true);
 
       if (s->defined
 	  || (s->type != GSYM_UNKNOWN
@@ -5983,7 +5983,7 @@
 
   if (gfc_new_block == NULL)
     return;
-  s = gfc_get_gsymbol (gfc_new_block->name);
+  s = gfc_get_gsymbol (gfc_new_block->name, false);
 
   if (s->defined || (s->type != GSYM_UNKNOWN && s->type != GSYM_PROGRAM))
     gfc_global_used (s, &gfc_new_block->declared_at);
Index: gcc/fortran/check.c
===================================================================
--- a/src/gcc/fortran/check.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/check.c	(.../branches/gcc-7-branch)
@@ -5295,6 +5295,26 @@
   size_t source_size;
   size_t result_size;
 
+  /* SOURCE shall be a scalar or array of any type.  */
+  if (source->ts.type == BT_PROCEDURE
+      && source->symtree->n.sym->attr.subroutine == 1)
+    {
+      gfc_error ("%<SOURCE%> argument of %<TRANSFER%> intrinsic at %L "
+                 "must not be a %s", &source->where,
+		 gfc_basic_typename (source->ts.type));
+      return false;
+    }
+
+  /* MOLD shall be a scalar or array of any type.  */
+  if (mold->ts.type == BT_PROCEDURE
+      && mold->symtree->n.sym->attr.subroutine == 1)
+    {
+      gfc_error ("%<MOLD%> argument of %<TRANSFER%> intrinsic at %L "
+                 "must not be a %s", &mold->where,
+		 gfc_basic_typename (mold->ts.type));
+      return false;
+    }
+
   if (mold->ts.type == BT_HOLLERITH)
     {
       gfc_error ("%<MOLD%> argument of %<TRANSFER%> intrinsic at %L must not be"
@@ -5302,6 +5322,8 @@
       return false;
     }
 
+  /* SIZE (optional) shall be an integer scalar.  The corresponding actual
+     argument shall not be an optional dummy argument.  */
   if (size != NULL)
     {
       if (!type_check (size, 2, BT_INTEGER))
Index: gcc/fortran/primary.c
===================================================================
--- a/src/gcc/fortran/primary.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/fortran/primary.c	(.../branches/gcc-7-branch)
@@ -2980,6 +2980,7 @@
   e = gfc_get_expr ();
   e->symtree = symtree;
   e->expr_type = EXPR_FUNCTION;
+  e->where = gfc_current_locus;
 
   gcc_assert (gfc_fl_struct (sym->attr.flavor)
 	      && symtree->n.sym->attr.flavor == FL_PROCEDURE);
Index: gcc/gimple-pretty-print.c
===================================================================
--- a/src/gcc/gimple-pretty-print.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/gimple-pretty-print.c	(.../branches/gcc-7-branch)
@@ -1989,6 +1989,8 @@
       pp_string (buffer, "__asm__");
       if (gimple_asm_volatile_p (gs))
 	pp_string (buffer, " __volatile__");
+      if (gimple_asm_inline_p (gs))
+	pp_string (buffer, " __inline__");
       if (gimple_asm_nlabels (gs))
 	pp_string (buffer, " goto");
       pp_string (buffer, "(\"");
Index: gcc/optc-save-gen.awk
===================================================================
--- a/src/gcc/optc-save-gen.awk	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/optc-save-gen.awk	(.../branches/gcc-7-branch)
@@ -84,7 +84,7 @@
 print "cl_optimization_save (struct cl_optimization *ptr, struct gcc_options *opts)";
 print "{";
 
-n_opt_char = 3;
+n_opt_char = 4;
 n_opt_short = 0;
 n_opt_int = 0;
 n_opt_enum = 0;
@@ -92,9 +92,11 @@
 var_opt_char[0] = "optimize";
 var_opt_char[1] = "optimize_size";
 var_opt_char[2] = "optimize_debug";
+var_opt_char[3] = "optimize_fast";
 var_opt_range["optimize"] = "0, 255";
 var_opt_range["optimize_size"] = "0, 1";
 var_opt_range["optimize_debug"] = "0, 1";
+var_opt_range["optimize_fast"] = "0, 1";
 
 # Sort by size to mimic how the structure is laid out to be friendlier to the
 # cache.
@@ -735,13 +737,15 @@
 
 print "}";
 
-n_opt_val = 3;
+n_opt_val = 4;
 var_opt_val[0] = "x_optimize"
 var_opt_val_type[0] = "char "
 var_opt_val[1] = "x_optimize_size"
+var_opt_val_type[1] = "char "
 var_opt_val[2] = "x_optimize_debug"
-var_opt_val_type[1] = "char "
 var_opt_val_type[2] = "char "
+var_opt_val[3] = "x_optimize_fast"
+var_opt_val_type[3] = "char "
 for (i = 0; i < n_opts; i++) {
 	if (flag_set_p("(Optimization|PerFunction)", flags[i])) {
 		name = var_name(flags[i])
Index: gcc/function.c
===================================================================
--- a/src/gcc/function.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/function.c	(.../branches/gcc-7-branch)
@@ -6604,7 +6604,7 @@
       output_matched[match] = true;
 
       start_sequence ();
-      emit_move_insn (output, input);
+      emit_move_insn (output, copy_rtx (input));
       insns = get_insns ();
       end_sequence ();
       emit_insn_before (insns, insn);
Index: gcc/gcse.c
===================================================================
--- a/src/gcc/gcse.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/gcse.c	(.../branches/gcc-7-branch)
@@ -1532,7 +1532,8 @@
 					      0, regno, hrsi)
 		record_last_reg_set_info (insn, regno);
 
-	      if (! RTL_CONST_OR_PURE_CALL_P (insn))
+	      if (! RTL_CONST_OR_PURE_CALL_P (insn)
+		  || RTL_LOOPING_CONST_OR_PURE_CALL_P (insn))
 		record_last_mem_set_info (insn);
 	    }
 
@@ -1963,14 +1964,11 @@
   return rval;
 }
 
-/* Generate RTL to copy an EXPR to its `reaching_reg' and return it.  */
+/* Generate RTL to copy an EXP to REG and return it.  */
 
-static rtx_insn *
-process_insert_insn (struct gcse_expr *expr)
+rtx_insn *
+prepare_copy_insn (rtx reg, rtx exp)
 {
-  rtx reg = expr->reaching_reg;
-  /* Copy the expression to make sure we don't have any sharing issues.  */
-  rtx exp = copy_rtx (expr->expr);
   rtx_insn *pat;
 
   start_sequence ();
@@ -1996,6 +1994,18 @@
   return pat;
 }
 
+/* Generate RTL to copy an EXPR to its `reaching_reg' and return it.  */
+
+static rtx_insn *
+process_insert_insn (struct gcse_expr *expr)
+{
+  rtx reg = expr->reaching_reg;
+  /* Copy the expression to make sure we don't have any sharing issues.  */
+  rtx exp = copy_rtx (expr->expr);
+
+  return prepare_copy_insn (reg, exp);
+}
+
 /* Add EXPR to the end of basic block BB.
 
    This is used by both the PRE and code hoisting.  */
Index: gcc/tree-data-ref.c
===================================================================
--- a/src/gcc/tree-data-ref.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-data-ref.c	(.../branches/gcc-7-branch)
@@ -1396,7 +1396,7 @@
 
 bool
 dr_may_alias_p (const struct data_reference *a, const struct data_reference *b,
-		bool loop_nest)
+		struct loop *loop_nest)
 {
   tree addr_a = DR_BASE_OBJECT (a);
   tree addr_b = DR_BASE_OBJECT (b);
@@ -1420,6 +1420,11 @@
 
   if ((TREE_CODE (addr_a) == MEM_REF || TREE_CODE (addr_a) == TARGET_MEM_REF)
       && (TREE_CODE (addr_b) == MEM_REF || TREE_CODE (addr_b) == TARGET_MEM_REF)
+      /* For cross-iteration dependences the cliques must be valid for the
+	 whole loop, not just individual iterations.  */
+      && (!loop_nest
+	  || MR_DEPENDENCE_CLIQUE (addr_a) == 1
+	  || MR_DEPENDENCE_CLIQUE (addr_a) == loop_nest->owned_clique)
       && MR_DEPENDENCE_CLIQUE (addr_a) == MR_DEPENDENCE_CLIQUE (addr_b)
       && MR_DEPENDENCE_BASE (addr_a) != MR_DEPENDENCE_BASE (addr_b))
     return false;
@@ -1500,7 +1505,7 @@
     }
 
   /* If the data references do not alias, then they are independent.  */
-  if (!dr_may_alias_p (a, b, loop_nest.exists ()))
+  if (!dr_may_alias_p (a, b, loop_nest.exists () ? loop_nest[0] : NULL))
     {
       DDR_ARE_DEPENDENT (res) = chrec_known;
       return res;
@@ -2118,6 +2123,8 @@
   switch (TREE_CODE (chrec))
     {
     case POLYNOMIAL_CHREC:
+      if (!cst_and_fits_in_hwi (CHREC_RIGHT (chrec)))
+	return chrec_dont_know;
       A[index][0] = mult * int_cst_value (CHREC_RIGHT (chrec));
       return initialize_matrix_A (A, CHREC_LEFT (chrec), index + 1, mult);
 
@@ -2499,7 +2506,7 @@
 				 tree *last_conflicts)
 {
   unsigned nb_vars_a, nb_vars_b, dim;
-  HOST_WIDE_INT init_a, init_b, gamma, gcd_alpha_beta;
+  HOST_WIDE_INT gamma, gcd_alpha_beta;
   lambda_matrix A, U, S;
   struct obstack scratch_obstack;
 
@@ -2536,9 +2543,20 @@
   A = lambda_matrix_new (dim, 1, &scratch_obstack);
   S = lambda_matrix_new (dim, 1, &scratch_obstack);
 
-  init_a = int_cst_value (initialize_matrix_A (A, chrec_a, 0, 1));
-  init_b = int_cst_value (initialize_matrix_A (A, chrec_b, nb_vars_a, -1));
-  gamma = init_b - init_a;
+  tree init_a = initialize_matrix_A (A, chrec_a, 0, 1);
+  tree init_b = initialize_matrix_A (A, chrec_b, nb_vars_a, -1);
+  if (init_a == chrec_dont_know
+      || init_b == chrec_dont_know)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "affine-affine test failed: "
+		 "representation issue.\n");
+      *overlaps_a = conflict_fn_not_known ();
+      *overlaps_b = conflict_fn_not_known ();
+      *last_conflicts = chrec_dont_know;
+      goto end_analyze_subs_aa;
+    }
+  gamma = int_cst_value (init_b) - int_cst_value (init_a);
 
   /* Don't do all the hard work of solving the Diophantine equation
      when we already know the solution: for example,
Index: gcc/loop-unroll.c
===================================================================
--- a/src/gcc/loop-unroll.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/loop-unroll.c	(.../branches/gcc-7-branch)
@@ -630,7 +630,7 @@
   if (loop->any_likely_upper_bound)
     loop->nb_iterations_likely_upper_bound
       = wi::udiv_trunc (loop->nb_iterations_likely_upper_bound, max_unroll + 1);
-  desc->niter_expr = GEN_INT (desc->niter);
+  desc->niter_expr = gen_int_mode (desc->niter, desc->mode);
 
   /* Remove the edges.  */
   FOR_EACH_VEC_ELT (remove_edges, i, e)
@@ -996,7 +996,8 @@
       preheader->frequency += iter_freq;
       preheader->count += iter_count;
       single_succ_edge (preheader)->count = preheader->count;
-      branch_code = compare_and_jump_seq (copy_rtx (niter), GEN_INT (j), EQ,
+      branch_code = compare_and_jump_seq (copy_rtx (niter),
+					  gen_int_mode (j, desc->mode), EQ,
 					  block_label (preheader), p,
 					  NULL);
 
Index: gcc/tree-data-ref.h
===================================================================
--- a/src/gcc/tree-data-ref.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-data-ref.h	(.../branches/gcc-7-branch)
@@ -338,7 +338,7 @@
                                         vec<data_reference_p> *);
 
 extern bool dr_may_alias_p (const struct data_reference *,
-			    const struct data_reference *, bool);
+			    const struct data_reference *, struct loop *);
 extern bool dr_equal_offsets_p (struct data_reference *,
                                 struct data_reference *);
 
Index: gcc/tree-vect-data-refs.c
===================================================================
--- a/src/gcc/tree-vect-data-refs.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-vect-data-refs.c	(.../branches/gcc-7-branch)
@@ -50,6 +50,7 @@
 #include "expr.h"
 #include "builtins.h"
 #include "params.h"
+#include "internal-fn.h"
 
 /* Return true if load- or store-lanes optab OPTAB is implemented for
    COUNT vectors of type VECTYPE.  NAME is the name of OPTAB.  */
@@ -131,6 +132,30 @@
       if (rhs < lhs)
         scalar_type = rhs_type;
     }
+  else if (gcall *call = dyn_cast <gcall *> (stmt))
+    {
+      unsigned int i = 0;
+      if (gimple_call_internal_p (call))
+	{
+	  internal_fn ifn = gimple_call_internal_fn (call);
+	  if (internal_load_fn_p (ifn) || internal_store_fn_p (ifn))
+	    /* gimple_expr_type already picked the type of the loaded
+	       or stored data.  */
+	    i = ~0U;
+	  else if (internal_fn_mask_index (ifn) == 0)
+	    i = 1;
+	}
+      if (i < gimple_call_num_args (call))
+	{
+	  tree rhs_type = TREE_TYPE (gimple_call_arg (call, i));
+	  if (tree_fits_uhwi_p (TYPE_SIZE_UNIT (rhs_type)))
+	    {
+	      rhs = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (rhs_type));
+	      if (rhs < lhs)
+		scalar_type = rhs_type;
+	    }
+	}
+    }
 
   *lhs_size_unit = lhs;
   *rhs_size_unit = rhs;
@@ -445,8 +470,19 @@
 	     reversed (to make distance vector positive), and the actual
 	     distance is negative.  */
 	  if (dump_enabled_p ())
-	    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
+	    dump_printf_loc (MSG_NOTE, vect_location,
 	                     "dependence distance negative.\n");
+	  /* When doing outer loop vectorization, we need to check if there is
+	     a backward dependence at the inner loop level if the dependence
+	     at the outer loop is reversed.  See PR81740.  */
+	  if (nested_in_vect_loop_p (loop, DR_STMT (dra))
+	      || nested_in_vect_loop_p (loop, DR_STMT (drb)))
+	    {
+	      unsigned inner_depth = index_in_loop_nest (loop->inner->num,
+							 DDR_LOOP_NEST (ddr));
+	      if (dist_v[inner_depth] < 0)
+		return true;
+	    }
 	  /* Record a negative dependence distance to later limit the
 	     amount of stmt copying / unrolling we can perform.
 	     Only need to handle read-after-write dependence.  */
Index: gcc/gimplify.c
===================================================================
--- a/src/gcc/gimplify.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/gimplify.c	(.../branches/gcc-7-branch)
@@ -185,6 +185,7 @@
   bool target_map_scalars_firstprivate;
   bool target_map_pointers_as_0len_arrays;
   bool target_firstprivatize_array_bases;
+  bool add_safelen1;
 };
 
 static struct gimplify_ctx *gimplify_ctxp;
@@ -1251,12 +1252,17 @@
 		  || splay_tree_lookup (ctx->variables,
 					(splay_tree_key) t) == NULL))
 	    {
+	      int flag = GOVD_LOCAL;
 	      if (ctx->region_type == ORT_SIMD
 		  && TREE_ADDRESSABLE (t)
 		  && !TREE_STATIC (t))
-		omp_add_variable (ctx, t, GOVD_PRIVATE | GOVD_SEEN);
-	      else
-		omp_add_variable (ctx, t, GOVD_LOCAL | GOVD_SEEN);
+		{
+		  if (TREE_CODE (DECL_SIZE_UNIT (t)) != INTEGER_CST)
+		    ctx->add_safelen1 = true;
+		  else
+		    flag = GOVD_PRIVATE;
+		}
+	      omp_add_variable (ctx, t, flag | GOVD_SEEN);
 	    }
 
 	  DECL_SEEN_IN_BIND_EXPR_P (t) = 1;
@@ -4498,6 +4504,7 @@
      otherwise we'd generate a new temporary, and we can as well just
      use the decl we already have.  */
   else if (!TREE_ADDRESSABLE (decl)
+	   && !TREE_THIS_VOLATILE (decl)
 	   && init
 	   && (fallback & fb_lvalue) == 0
 	   && gimple_test_f (init))
@@ -4770,7 +4777,7 @@
 	   one field to assign, initialize the target from a temporary.  */
 	if (TREE_THIS_VOLATILE (object)
 	    && !TREE_ADDRESSABLE (type)
-	    && num_nonzero_elements > 0
+	    && (num_nonzero_elements > 0 || !cleared)
 	    && vec_safe_length (elts) > 1)
 	  {
 	    tree temp = create_tmp_var (TYPE_MAIN_VARIANT (type));
@@ -5966,6 +5973,19 @@
 	  is_inout = false;
 	}
 
+      /* If we can't make copies, we can only accept memory.  */
+      if (TREE_ADDRESSABLE (TREE_TYPE (TREE_VALUE (link))))
+	{
+	  if (allows_mem)
+	    allows_reg = 0;
+	  else
+	    {
+	      error ("impossible constraint in %<asm%>");
+	      error ("non-memory output %d must stay in memory", i);
+	      return GS_ERROR;
+	    }
+	}
+
       if (!allows_reg && allows_mem)
 	mark_addressable (TREE_VALUE (link));
 
@@ -6206,6 +6226,7 @@
 
       gimple_asm_set_volatile (stmt, ASM_VOLATILE_P (expr) || noutputs == 0);
       gimple_asm_set_input (stmt, ASM_INPUT_P (expr));
+      gimple_asm_set_inline (stmt, ASM_INLINE_P (expr));
 
       gimplify_seq_add_stmt (pre_p, stmt);
     }
@@ -8796,6 +8817,19 @@
 			   omp_find_stores_op, &wi);
 	}
     }
+
+  if (ctx->add_safelen1)
+    {
+      /* If there are VLAs in the body of simd loop, prevent
+	 vectorization.  */
+      gcc_assert (ctx->region_type == ORT_SIMD);
+      c = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE_SAFELEN);
+      OMP_CLAUSE_SAFELEN_EXPR (c) = integer_one_node;
+      OMP_CLAUSE_CHAIN (c) = *list_p;
+      *list_p = c;
+      list_p = &OMP_CLAUSE_CHAIN (c);
+    }
+
   while ((c = *list_p) != NULL)
     {
       splay_tree_node n;
@@ -10102,8 +10136,17 @@
 		  seq = &OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (c);
 		else
 		  seq = &OMP_CLAUSE_LINEAR_GIMPLE_SEQ (c);
+		push_gimplify_context ();
 		gimplify_assign (decl, t, seq);
-	    }
+		gimple *bind = NULL;
+		if (gimplify_ctxp->temps)
+		  {
+		    bind = gimple_build_bind (NULL_TREE, *seq, NULL_TREE);
+		    *seq = NULL;
+		    gimplify_seq_add_stmt (seq, bind);
+		  }
+		pop_gimplify_context (bind);
+	      }
 	}
     }
 
Index: gcc/graphite-scop-detection.c
===================================================================
--- a/src/gcc/graphite-scop-detection.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/graphite-scop-detection.c	(.../branches/gcc-7-branch)
@@ -1864,9 +1864,13 @@
   int i, j;
   int *all_vertices;
 
+  struct loop *nest
+    = find_common_loop (scop->scop_info->region.entry->dest->loop_father,
+			scop->scop_info->region.exit->src->loop_father);
+
   FOR_EACH_VEC_ELT (scop->drs, i, dr1)
     for (j = i+1; scop->drs.iterate (j, &dr2); j++)
-      if (dr_may_alias_p (dr1->dr, dr2->dr, true))
+      if (dr_may_alias_p (dr1->dr, dr2->dr, nest))
 	{
 	  add_edge (g, i, j);
 	  add_edge (g, j, i);
Index: gcc/lra-constraints.c
===================================================================
--- a/src/gcc/lra-constraints.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/lra-constraints.c	(.../branches/gcc-7-branch)
@@ -2294,6 +2294,8 @@
 		  break;
 
 		reg:
+		  if (mode == BLKmode)
+		    break;
 		  this_alternative = reg_class_subunion[this_alternative][cl];
 		  IOR_HARD_REG_SET (this_alternative_set,
 				    reg_class_contents[cl]);
@@ -2304,8 +2306,6 @@
 		      IOR_HARD_REG_SET (this_costly_alternative_set,
 					reg_class_contents[cl]);
 		    }
-		  if (mode == BLKmode)
-		    break;
 		  winreg = true;
 		  if (REG_P (op))
 		    {
@@ -5657,6 +5657,9 @@
   enum rtx_code code;
   int i, j;
 
+  if (side_effects_p (x))
+    return false;
+
   code = GET_CODE (x);
   mode = GET_MODE (x);
   if (code == SUBREG)
Index: gcc/tree-ssa-loop-split.c
===================================================================
--- a/src/gcc/tree-ssa-loop-split.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssa-loop-split.c	(.../branches/gcc-7-branch)
@@ -649,7 +649,8 @@
 					false, true)
 	  && niter.cmp != ERROR_MARK
 	  /* We can't yet handle loops controlled by a != predicate.  */
-	  && niter.cmp != NE_EXPR)
+	  && niter.cmp != NE_EXPR
+	  && can_duplicate_loop_p (loop))
 	{
 	  if (split_loop (loop, &niter))
 	    {
Index: gcc/tree-ssa-phiopt.c
===================================================================
--- a/src/gcc/tree-ssa-phiopt.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssa-phiopt.c	(.../branches/gcc-7-branch)
@@ -1792,6 +1792,11 @@
       || gimple_has_volatile_ops (assign))
     return false;
 
+  /* And no PHI nodes so all uses in the single stmt are also
+     available where we insert to.  */
+  if (!gimple_seq_empty_p (phi_nodes (middle_bb)))
+    return false;
+
   locus = gimple_location (assign);
   lhs = gimple_assign_lhs (assign);
   rhs = gimple_assign_rhs1 (assign);
Index: gcc/calls.c
===================================================================
--- a/src/gcc/calls.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/calls.c	(.../branches/gcc-7-branch)
@@ -3333,6 +3333,28 @@
       || dbg_cnt (tail_call) == false)
     try_tail_call = 0;
 
+  /* Workaround buggy C/C++ wrappers around Fortran routines with
+     character(len=constant) arguments if the hidden string length arguments
+     are passed on the stack; if the callers forget to pass those arguments,
+     attempting to tail call in such routines leads to stack corruption.
+     Avoid tail calls in functions where at least one such hidden string
+     length argument is passed (partially or fully) on the stack in the
+     caller and the callee needs to pass any arguments on the stack.
+     See PR90329.  */
+  if (try_tail_call && args_size.constant != 0)
+    for (tree arg = DECL_ARGUMENTS (current_function_decl);
+	 arg; arg = DECL_CHAIN (arg))
+      if (DECL_HIDDEN_STRING_LENGTH (arg) && DECL_INCOMING_RTL (arg))
+	{
+	  subrtx_iterator::array_type array;
+	  FOR_EACH_SUBRTX (iter, array, DECL_INCOMING_RTL (arg), NONCONST)
+	    if (MEM_P (*iter))
+	      {
+		try_tail_call = 0;
+		break;
+	      }
+	}
+
   /* If the user has marked the function as requiring tail-call
      optimization, attempt it.  */
   if (must_tail_call)
Index: gcc/expmed.c
===================================================================
--- a/src/gcc/expmed.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/expmed.c	(.../branches/gcc-7-branch)
@@ -3179,11 +3179,19 @@
 	      tem = gen_lowpart (nmode, op0);
 	    }
 
-          insn = get_last_insn ();
-          set_dst_reg_note (insn, REG_EQUAL,
-			    gen_rtx_MULT (nmode, tem,
-					  gen_int_mode (val_so_far, nmode)),
-			    accum_inner);
+	  /* Don't add a REG_EQUAL note if tem is a paradoxical SUBREG.
+	     In that case, only the low bits of accum would be guaranteed to
+	     be equal to the content of the REG_EQUAL note, the upper bits
+	     can be anything.  */
+	  if (!paradoxical_subreg_p (tem))
+	    {
+	      insn = get_last_insn ();
+	      set_dst_reg_note (insn, REG_EQUAL,
+				gen_rtx_MULT (nmode, tem,
+					      gen_int_mode (val_so_far,
+							    nmode)),
+				accum_inner);
+	    }
 	}
     }
 
Index: gcc/except.c
===================================================================
--- a/src/gcc/except.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/except.c	(.../branches/gcc-7-branch)
@@ -1728,6 +1728,8 @@
       if (note == NULL)
 	return;
     }
+  else if (is_a <rtx_insn *> (note_or_insn))
+    return;
   note = XEXP (note, 0);
 
   for (insn = first; insn != last ; insn = NEXT_INSN (insn))
@@ -1750,6 +1752,8 @@
       if (note == NULL)
 	return;
     }
+  else if (is_a <rtx_insn *> (note_or_insn))
+    return;
   note = XEXP (note, 0);
 
   for (insn = last; insn != first; insn = PREV_INSN (insn))
Index: gcc/gimple-fold.c
===================================================================
--- a/src/gcc/gimple-fold.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/gimple-fold.c	(.../branches/gcc-7-branch)
@@ -2718,11 +2718,10 @@
       gimple_seq stmts = NULL;
       gimple *repl = gimple_build_call (fn, 2, dest, fmt);
       gimple_seq_add_stmt_without_update (&stmts, repl);
-      if (gimple_call_lhs (stmt))
+      if (tree lhs = gimple_call_lhs (stmt))
 	{
-	  repl = gimple_build_assign (gimple_call_lhs (stmt),
-				      build_int_cst (integer_type_node,
-						     strlen (fmt_str)));
+	  repl = gimple_build_assign (lhs, build_int_cst (TREE_TYPE (lhs),
+							  strlen (fmt_str)));
 	  gimple_seq_add_stmt_without_update (&stmts, repl);
 	  gsi_replace_with_seq_vops (gsi, stmts);
 	  /* gsi now points at the assignment to the lhs, get a
@@ -2766,12 +2765,12 @@
       gimple_seq stmts = NULL;
       gimple *repl = gimple_build_call (fn, 2, dest, orig);
       gimple_seq_add_stmt_without_update (&stmts, repl);
-      if (gimple_call_lhs (stmt))
+      if (tree lhs = gimple_call_lhs (stmt))
 	{
-	  if (!useless_type_conversion_p (integer_type_node,
+	  if (!useless_type_conversion_p (TREE_TYPE (lhs),
 					  TREE_TYPE (orig_len)))
-	    orig_len = fold_convert (integer_type_node, orig_len);
-	  repl = gimple_build_assign (gimple_call_lhs (stmt), orig_len);
+	    orig_len = fold_convert (TREE_TYPE (lhs), orig_len);
+	  repl = gimple_build_assign (lhs, orig_len);
 	  gimple_seq_add_stmt_without_update (&stmts, repl);
 	  gsi_replace_with_seq_vops (gsi, stmts);
 	  /* gsi now points at the assignment to the lhs, get a
@@ -2853,10 +2852,10 @@
       gimple_seq stmts = NULL;
       gimple *repl = gimple_build_call (fn, 2, dest, fmt);
       gimple_seq_add_stmt_without_update (&stmts, repl);
-      if (gimple_call_lhs (stmt))
+      if (tree lhs = gimple_call_lhs (stmt))
 	{
-	  repl = gimple_build_assign (gimple_call_lhs (stmt),
-				      build_int_cst (integer_type_node, len));
+	  repl = gimple_build_assign (lhs,
+				      build_int_cst (TREE_TYPE (lhs), len));
 	  gimple_seq_add_stmt_without_update (&stmts, repl);
 	  gsi_replace_with_seq_vops (gsi, stmts);
 	  /* gsi now points at the assignment to the lhs, get a
@@ -2905,12 +2904,12 @@
       gimple_seq stmts = NULL;
       gimple *repl = gimple_build_call (fn, 2, dest, orig);
       gimple_seq_add_stmt_without_update (&stmts, repl);
-      if (gimple_call_lhs (stmt))
+      if (tree lhs = gimple_call_lhs (stmt))
 	{
-	  if (!useless_type_conversion_p (integer_type_node,
+	  if (!useless_type_conversion_p (TREE_TYPE (lhs),
 					  TREE_TYPE (orig_len)))
-	    orig_len = fold_convert (integer_type_node, orig_len);
-	  repl = gimple_build_assign (gimple_call_lhs (stmt), orig_len);
+	    orig_len = fold_convert (TREE_TYPE (lhs), orig_len);
+	  repl = gimple_build_assign (lhs, orig_len);
 	  gimple_seq_add_stmt_without_update (&stmts, repl);
 	  gsi_replace_with_seq_vops (gsi, stmts);
 	  /* gsi now points at the assignment to the lhs, get a
@@ -6319,14 +6318,11 @@
 		= wi::sext (wi::to_offset (idx) - wi::to_offset (low_bound),
 			    TYPE_PRECISION (TREE_TYPE (idx)));
 
+	      woffset *= tree_to_uhwi (unit_size);
+	      woffset *= BITS_PER_UNIT;
 	      if (wi::fits_shwi_p (woffset))
 		{
 		  offset = woffset.to_shwi ();
-		  /* TODO: This code seems wrong, multiply then check
-		     to see if it fits.  */
-		  offset *= tree_to_uhwi (unit_size);
-		  offset *= BITS_PER_UNIT;
-
 		  base = TREE_OPERAND (t, 0);
 		  ctor = get_base_constructor (base, &offset, valueize);
 		  /* Empty constructor.  Always fold to 0.  */
Index: gcc/store-motion.c
===================================================================
--- a/src/gcc/store-motion.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/store-motion.c	(.../branches/gcc-7-branch)
@@ -907,8 +907,7 @@
   rtx_insn *insn;
   rtx mem, note, set;
 
-  mem = smexpr->pattern;
-  insn = gen_move_insn (reg, SET_SRC (single_set (del)));
+  insn = prepare_copy_insn (reg, SET_SRC (single_set (del)));
 
   unsigned int i;
   rtx_insn *temp;
@@ -941,6 +940,7 @@
   /* Now we must handle REG_EQUAL notes whose contents is equal to the mem;
      they are no longer accurate provided that they are reached by this
      definition, so drop them.  */
+  mem = smexpr->pattern;
   for (; insn != NEXT_INSN (BB_END (bb)); insn = NEXT_INSN (insn))
     if (NONDEBUG_INSN_P (insn))
       {
Index: gcc/cfgcleanup.c
===================================================================
--- a/src/gcc/cfgcleanup.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cfgcleanup.c	(.../branches/gcc-7-branch)
@@ -1620,10 +1620,13 @@
   if (crtl->shrink_wrapped
       && single_succ_p (bb1)
       && single_succ (bb1) == EXIT_BLOCK_PTR_FOR_FN (cfun)
-      && !JUMP_P (BB_END (bb1))
+      && (!JUMP_P (BB_END (bb1))
+	  /* Punt if the only successor is a fake edge to exit, the jump
+	     must be some weird one.  */
+	  || (single_succ_edge (bb1)->flags & EDGE_FAKE) != 0)
       && !(CALL_P (BB_END (bb1)) && SIBLING_CALL_P (BB_END (bb1))))
     return false;
-  
+
   /* If BB1 has only one successor, we may be looking at either an
      unconditional jump, or a fake edge to exit.  */
   if (single_succ_p (bb1)
Index: gcc/tree-ssa-pre.c
===================================================================
--- a/src/gcc/tree-ssa-pre.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssa-pre.c	(.../branches/gcc-7-branch)
@@ -3948,6 +3948,13 @@
 			  continue;
 			}
 
+		      /* If the REFERENCE traps and there was a preceding
+		         point in the block that might not return avoid
+			 adding the reference to EXP_GEN.  */
+		      if (BB_MAY_NOTRETURN (block)
+			  && vn_reference_may_trap (ref))
+			continue;
+
 		      /* If the value of the reference is not invalidated in
 			 this block until it is computed, add the expression
 			 to EXP_GEN.  */
Index: gcc/explow.c
===================================================================
--- a/src/gcc/explow.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/explow.c	(.../branches/gcc-7-branch)
@@ -872,16 +872,7 @@
 
   tree type = TREE_TYPE (name);
   int unsignedp = TYPE_UNSIGNED (type);
-  machine_mode mode = TYPE_MODE (type);
-
-  /* Bypass TYPE_MODE when it maps vector modes to BLKmode.  */
-  if (mode == BLKmode)
-    {
-      gcc_assert (VECTOR_TYPE_P (type));
-      mode = type->type_common.mode;
-    }
-
-  machine_mode pmode = promote_mode (type, mode, &unsignedp);
+  machine_mode pmode = promote_mode (type, TYPE_MODE (type), &unsignedp);
   if (punsignedp)
     *punsignedp = unsignedp;
 
Index: gcc/tree-sra.c
===================================================================
--- a/src/gcc/tree-sra.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-sra.c	(.../branches/gcc-7-branch)
@@ -1516,19 +1516,20 @@
 	       && TREE_CODE (f2->type) != COMPLEX_TYPE
 	       && TREE_CODE (f2->type) != VECTOR_TYPE)
 	return -1;
+      /* Put any integral type before any non-integral type.  When splicing, we
+	 make sure that those with insufficient precision and occupying the
+	 same space are not scalarized.  */
+      else if (INTEGRAL_TYPE_P (f1->type)
+	       && !INTEGRAL_TYPE_P (f2->type))
+	return -1;
+      else if (!INTEGRAL_TYPE_P (f1->type)
+	       && INTEGRAL_TYPE_P (f2->type))
+	return 1;
       /* Put the integral type with the bigger precision first.  */
       else if (INTEGRAL_TYPE_P (f1->type)
-	       && INTEGRAL_TYPE_P (f2->type))
+	       && INTEGRAL_TYPE_P (f2->type)
+	       && (TYPE_PRECISION (f2->type) != TYPE_PRECISION (f1->type)))
 	return TYPE_PRECISION (f2->type) - TYPE_PRECISION (f1->type);
-      /* Put any integral type with non-full precision last.  */
-      else if (INTEGRAL_TYPE_P (f1->type)
-	       && (TREE_INT_CST_LOW (TYPE_SIZE (f1->type))
-		   != TYPE_PRECISION (f1->type)))
-	return 1;
-      else if (INTEGRAL_TYPE_P (f2->type)
-	       && (TREE_INT_CST_LOW (TYPE_SIZE (f2->type))
-		   != TYPE_PRECISION (f2->type)))
-	return -1;
       /* Stabilize the sort.  */
       return TYPE_UID (f1->type) - TYPE_UID (f2->type);
     }
@@ -2029,6 +2030,11 @@
       bool grp_partial_lhs = access->grp_partial_lhs;
       bool first_scalar = is_gimple_reg_type (access->type);
       bool unscalarizable_region = access->grp_unscalarizable_region;
+      bool bf_non_full_precision
+	= (INTEGRAL_TYPE_P (access->type)
+	   && TYPE_PRECISION (access->type) != access->size
+	   && TREE_CODE (access->expr) == COMPONENT_REF
+	   && DECL_BIT_FIELD (TREE_OPERAND (access->expr, 1)));
 
       if (first || access->offset >= high)
 	{
@@ -2076,6 +2082,22 @@
 	     this combination of size and offset, the comparison function
 	     should have put the scalars first.  */
 	  gcc_assert (first_scalar || !is_gimple_reg_type (ac2->type));
+	  /* It also prefers integral types to non-integral.  However, when the
+	     precision of the selected type does not span the entire area and
+	     should also be used for a non-integer (i.e. float), we must not
+	     let that happen.  Normally analyze_access_subtree expands the type
+	     to cover the entire area but for bit-fields it doesn't.  */
+	  if (bf_non_full_precision && !INTEGRAL_TYPE_P (ac2->type))
+	    {
+	      if (dump_file && (dump_flags & TDF_DETAILS))
+		{
+		  fprintf (dump_file, "Cannot scalarize the following access "
+			   "because insufficient precision integer type was "
+			   "selected.\n  ");
+		  dump_access (dump_file, access, false);
+		}
+	      unscalarizable_region = true;
+	    }
 	  ac2->group_representative = access;
 	  j++;
 	}
Index: gcc/opth-gen.awk
===================================================================
--- a/src/gcc/opth-gen.awk	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/opth-gen.awk	(.../branches/gcc-7-branch)
@@ -132,7 +132,7 @@
 print "struct GTY(()) cl_optimization";
 print "{";
 
-n_opt_char = 3;
+n_opt_char = 4;
 n_opt_short = 0;
 n_opt_int = 0;
 n_opt_enum = 0;
@@ -140,6 +140,7 @@
 var_opt_char[0] = "unsigned char x_optimize";
 var_opt_char[1] = "unsigned char x_optimize_size";
 var_opt_char[2] = "unsigned char x_optimize_debug";
+var_opt_char[3] = "unsigned char x_optimize_fast";
 
 for (i = 0; i < n_opts; i++) {
 	if (flag_set_p("(Optimization|PerFunction)", flags[i])) {
Index: gcc/tree-streamer-out.c
===================================================================
--- a/src/gcc/tree-streamer-out.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-streamer-out.c	(.../branches/gcc-7-branch)
@@ -207,7 +207,7 @@
       bp_pack_var_len_unsigned (bp, EH_LANDING_PAD_NR (expr));
     }
 
-  if (TREE_CODE (expr) == FIELD_DECL)
+  else if (TREE_CODE (expr) == FIELD_DECL)
     {
       bp_pack_value (bp, DECL_PACKED (expr), 1);
       bp_pack_value (bp, DECL_NONADDRESSABLE_P (expr), 1);
@@ -214,12 +214,15 @@
       bp_pack_value (bp, expr->decl_common.off_align, 8);
     }
 
-  if (VAR_P (expr))
+  else if (VAR_P (expr))
     {
       bp_pack_value (bp, DECL_HAS_DEBUG_EXPR_P (expr), 1);
       bp_pack_value (bp, DECL_NONLOCAL_FRAME (expr), 1);
     }
 
+  else if (TREE_CODE (expr) == PARM_DECL)
+    bp_pack_value (bp, DECL_HIDDEN_STRING_LENGTH (expr), 1);
+
   if (TREE_CODE (expr) == RESULT_DECL
       || TREE_CODE (expr) == PARM_DECL
       || VAR_P (expr))
Index: gcc/ipa-prop.c
===================================================================
--- a/src/gcc/ipa-prop.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ipa-prop.c	(.../branches/gcc-7-branch)
@@ -1577,7 +1577,8 @@
       if (TREE_CODE (arg) == SSA_NAME)
 	{
 	  tree type_size;
-          if (!tree_fits_uhwi_p (TYPE_SIZE (TREE_TYPE (arg_type))))
+          if (!tree_fits_uhwi_p (TYPE_SIZE (TREE_TYPE (arg_type)))
+	      || !POINTER_TYPE_P (TREE_TYPE (arg)))
             return;
 	  check_ref = true;
 	  arg_base = arg;
Index: gcc/tree-ssa-copy.c
===================================================================
--- a/src/gcc/tree-ssa-copy.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssa-copy.c	(.../branches/gcc-7-branch)
@@ -532,13 +532,12 @@
 	      duplicate_ssa_name_ptr_info (copy_of[i].value,
 					   SSA_NAME_PTR_INFO (var));
 	      /* Points-to information is cfg insensitive,
-		 but alignment info might be cfg sensitive, if it
-		 e.g. is derived from VRP derived non-zero bits.
-		 So, do not copy alignment info if the two SSA_NAMEs
-		 aren't defined in the same basic block.  */
+		 but [E]VRP might record context sensitive alignment
+		 info, non-nullness, etc.  So reset context sensitive
+		 info if the two SSA_NAMEs aren't defined in the same
+		 basic block.  */
 	      if (var_bb != copy_of_bb)
-		mark_ptr_info_alignment_unknown
-				(SSA_NAME_PTR_INFO (copy_of[i].value));
+		reset_flow_sensitive_info (copy_of[i].value);
 	    }
 	  else if (!POINTER_TYPE_P (TREE_TYPE (var))
 		   && SSA_NAME_RANGE_INFO (var)
Index: gcc/tree-ssa-forwprop.c
===================================================================
--- a/src/gcc/tree-ssa-forwprop.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssa-forwprop.c	(.../branches/gcc-7-branch)
@@ -2427,6 +2427,8 @@
 		  {
 		    int did_something;
 		    did_something = forward_propagate_into_comparison (&gsi);
+		    if (maybe_clean_or_replace_eh_stmt (stmt, gsi_stmt (gsi)))
+		      bitmap_set_bit (to_purge, bb->index);
 		    if (did_something == 2)
 		      cfg_changed = true;
 		    changed = did_something != 0;
Index: gcc/ggc-page.c
===================================================================
--- a/src/gcc/ggc-page.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ggc-page.c	(.../branches/gcc-7-branch)
@@ -2553,6 +2553,9 @@
 
   count_old_page_tables = G.by_depth_in_use;
 
+  if (fread (&d, sizeof (d), 1, f) != 1)
+    fatal_error (input_location, "cannot read PCH file: %m");
+
   /* We've just read in a PCH file.  So, every object that used to be
      allocated is now free.  */
   clear_marks ();
@@ -2581,8 +2584,6 @@
 
   /* Allocate the appropriate page-table entries for the pages read from
      the PCH file.  */
-  if (fread (&d, sizeof (d), 1, f) != 1)
-    fatal_error (input_location, "can%'t read PCH file: %m");
 
   for (i = 0; i < NUM_ORDERS; i++)
     {
Index: gcc/varasm.c
===================================================================
--- a/src/gcc/varasm.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/varasm.c	(.../branches/gcc-7-branch)
@@ -2881,6 +2881,11 @@
       x = output_constant_def (target, 1);
       break;
 
+    case COMPOUND_LITERAL_EXPR:
+      gcc_assert (COMPOUND_LITERAL_EXPR_DECL (target));
+      x = DECL_RTL (COMPOUND_LITERAL_EXPR_DECL (target));
+      break;
+
     default:
       gcc_unreachable ();
     }
@@ -5175,7 +5180,7 @@
     {
       int this_time;
       int shift;
-      HOST_WIDE_INT value;
+      unsigned HOST_WIDE_INT value;
       HOST_WIDE_INT next_byte = next_offset / BITS_PER_UNIT;
       HOST_WIDE_INT next_bit = next_offset % BITS_PER_UNIT;
 
@@ -5207,15 +5212,13 @@
 	      this_time = end - shift + 1;
 	    }
 
-	  /* Now get the bits from the appropriate constant word.  */
-	  value = TREE_INT_CST_ELT (local->val, shift / HOST_BITS_PER_WIDE_INT);
-	  shift = shift & (HOST_BITS_PER_WIDE_INT - 1);
+	  /* Now get the bits we want to insert.  */
+	  value = wi::extract_uhwi (wi::to_widest (local->val),
+				    shift, this_time);
 
 	  /* Get the result.  This works only when:
 	     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */
-	  local->byte |= (((value >> shift)
-			   & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))
-			  << (BITS_PER_UNIT - this_time - next_bit));
+	  local->byte |= value << (BITS_PER_UNIT - this_time - next_bit);
 	}
       else
 	{
@@ -5232,15 +5235,13 @@
 	    this_time
 	      = HOST_BITS_PER_WIDE_INT - (shift & (HOST_BITS_PER_WIDE_INT - 1));
 
-	  /* Now get the bits from the appropriate constant word.  */
-	  value = TREE_INT_CST_ELT (local->val, shift / HOST_BITS_PER_WIDE_INT);
-	  shift = shift & (HOST_BITS_PER_WIDE_INT - 1);
+	  /* Now get the bits we want to insert.  */
+	  value = wi::extract_uhwi (wi::to_widest (local->val),
+				    shift, this_time);
 
 	  /* Get the result.  This works only when:
 	     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */
-	  local->byte |= (((value >> shift)
-			   & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))
-			  << next_bit);
+	  local->byte |= value << next_bit;
 	}
 
       next_offset += this_time;
Index: gcc/ira.c
===================================================================
--- a/src/gcc/ira.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/ira.c	(.../branches/gcc-7-branch)
@@ -5160,6 +5160,8 @@
   int ira_max_point_before_emit;
   bool saved_flag_caller_saves = flag_caller_saves;
   enum ira_region saved_flag_ira_region = flag_ira_region;
+  unsigned int i;
+  int num_used_regs = 0;
 
   clear_bb_flags ();
 
@@ -5175,12 +5177,17 @@
 
   ira_conflicts_p = optimize > 0;
 
+  /* Determine the number of pseudos actually requiring coloring.  */
+  for (i = FIRST_PSEUDO_REGISTER; i < DF_REG_SIZE (df); i++)
+    num_used_regs += !!(DF_REG_USE_COUNT (i) + DF_REG_DEF_COUNT (i));
+
   /* If there are too many pseudos and/or basic blocks (e.g. 10K
      pseudos and 10K blocks or 100K pseudos and 1K blocks), we will
      use simplified and faster algorithms in LRA.  */
   lra_simple_p
     = (ira_use_lra_p
-       && max_reg_num () >= (1 << 26) / last_basic_block_for_fn (cfun));
+       && num_used_regs >= (1 << 26) / last_basic_block_for_fn (cfun));
+
   if (lra_simple_p)
     {
       /* It permits to skip live range splitting in LRA.  */
Index: gcc/rtl.h
===================================================================
--- a/src/gcc/rtl.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/rtl.h	(.../branches/gcc-7-branch)
@@ -3666,6 +3666,9 @@
 /* In gcse.c */
 extern bool can_copy_p (machine_mode);
 extern bool can_assign_to_reg_without_clobbers_p (rtx, machine_mode);
+extern rtx_insn *prepare_copy_insn (rtx, rtx);
+
+/* In cprop.c */
 extern rtx fis_get_condition (rtx_insn *);
 
 /* In ira.c */
Index: gcc/tree-vect-stmts.c
===================================================================
--- a/src/gcc/tree-vect-stmts.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-vect-stmts.c	(.../branches/gcc-7-branch)
@@ -4943,6 +4943,16 @@
 	  FOR_EACH_VEC_ELT (stmts, k, slpstmt)
 	    if (!operand_equal_p (gimple_assign_rhs2 (slpstmt), op1, 0))
 	      scalar_shift_arg = false;
+
+	  /* For internal SLP defs we have to make sure we see scalar stmts
+	     for all vector elements.
+	     ???  For different vectors we could resort to a different
+	     scalar shift operand but code-generation below simply always
+	     takes the first.  */
+	  if (dt[1] == vect_internal_def
+	      && (nunits_out * SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node)
+		  != stmts.length ()))
+	    scalar_shift_arg = false;
 	}
 
       /* If the shift amount is computed by a pattern stmt we cannot
Index: gcc/tree-inline.c
===================================================================
--- a/src/gcc/tree-inline.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-inline.c	(.../branches/gcc-7-branch)
@@ -569,6 +569,92 @@
   return new_tree;
 }
 
+/* Helper function for remap_type_2, called through walk_tree.  */
+
+static tree
+remap_type_3 (tree *tp, int *walk_subtrees, void *data)
+{
+  copy_body_data *id = (copy_body_data *) data;
+
+  if (TYPE_P (*tp))
+    *walk_subtrees = 0;
+
+  else if (DECL_P (*tp) && remap_decl (*tp, id) != *tp)
+    return *tp;
+
+  return NULL_TREE;
+}
+
+/* Return true if TYPE needs to be remapped because remap_decl on any
+   needed embedded decl returns something other than that decl.  */
+
+static bool
+remap_type_2 (tree type, copy_body_data *id)
+{
+  tree t;
+
+#define RETURN_TRUE_IF_VAR(T) \
+  do								\
+    {								\
+      tree _t = (T);						\
+      if (_t)							\
+	{							\
+	  if (DECL_P (_t) && remap_decl (_t, id) != _t)		\
+	    return true;					\
+	  if (!TYPE_SIZES_GIMPLIFIED (type)			\
+	      && walk_tree (&_t, remap_type_3, id, NULL))	\
+	    return true;					\
+	}							\
+    }								\
+  while (0)
+
+  switch (TREE_CODE (type))
+    {
+    case POINTER_TYPE:
+    case REFERENCE_TYPE:
+    case FUNCTION_TYPE:
+    case METHOD_TYPE:
+      return remap_type_2 (TREE_TYPE (type), id);
+
+    case INTEGER_TYPE:
+    case REAL_TYPE:
+    case FIXED_POINT_TYPE:
+    case ENUMERAL_TYPE:
+    case BOOLEAN_TYPE:
+      RETURN_TRUE_IF_VAR (TYPE_MIN_VALUE (type));
+      RETURN_TRUE_IF_VAR (TYPE_MAX_VALUE (type));
+      return false;
+
+    case ARRAY_TYPE:
+      if (remap_type_2 (TREE_TYPE (type), id)
+	  || (TYPE_DOMAIN (type) && remap_type_2 (TYPE_DOMAIN (type), id)))
+	return true;
+      break;
+
+    case RECORD_TYPE:
+    case UNION_TYPE:
+    case QUAL_UNION_TYPE:
+      for (t = TYPE_FIELDS (type); t; t = DECL_CHAIN (t))
+	if (TREE_CODE (t) == FIELD_DECL)
+	  {
+	    RETURN_TRUE_IF_VAR (DECL_FIELD_OFFSET (t));
+	    RETURN_TRUE_IF_VAR (DECL_SIZE (t));
+	    RETURN_TRUE_IF_VAR (DECL_SIZE_UNIT (t));
+	    if (TREE_CODE (type) == QUAL_UNION_TYPE)
+	      RETURN_TRUE_IF_VAR (DECL_QUALIFIER (t));
+	  }
+      break;
+
+    default:
+      return false;
+    }
+
+  RETURN_TRUE_IF_VAR (TYPE_SIZE (type));
+  RETURN_TRUE_IF_VAR (TYPE_SIZE_UNIT (type));
+  return false;
+#undef RETURN_TRUE_IF_VAR
+}
+
 tree
 remap_type (tree type, copy_body_data *id)
 {
@@ -584,7 +670,10 @@
     return *node;
 
   /* The type only needs remapping if it's variably modified.  */
-  if (! variably_modified_type_p (type, id->src_fn))
+  if (! variably_modified_type_p (type, id->src_fn)
+      /* Don't remap if copy_decl method doesn't always return a new
+	 decl and for all embedded decls returns the passed in decl.  */
+      || (id->dont_remap_vla_if_no_change && !remap_type_2 (type, id)))
     {
       insert_decl_map (id, type, type);
       return type;
@@ -859,7 +948,12 @@
   bool existed;
   unsigned short &newc = id->dependence_map->get_or_insert (clique, &existed);
   if (!existed)
-    newc = ++cfun->last_clique;
+    {
+      /* Clique 1 is reserved for local ones set by PTA.  */
+      if (cfun->last_clique == 0)
+	cfun->last_clique = 1;
+      newc = ++cfun->last_clique;
+    }
   return newc;
 }
 
@@ -2629,7 +2723,11 @@
 	      dest_loop->simduid = remap_decl (src_loop->simduid, id);
 	      cfun->has_simduid_loops = true;
 	    }
-
+	  if (id->src_cfun->last_clique != 0)
+	    dest_loop->owned_clique
+	      = remap_dependence_clique (id,
+					 src_loop->owned_clique
+					 ? src_loop->owned_clique : 1);
 	  /* Recurse.  */
 	  copy_loops (id, dest_loop, src_loop);
 	}
@@ -4173,6 +4271,9 @@
 	   with very long asm statements.  */
 	if (count > 1000)
 	  count = 1000;
+	/* If this asm is asm inline, count anything as minimum size.  */
+	if (gimple_asm_inline_p (as_a <gasm *> (stmt)))
+	  count = MIN (1, count);
 	return count;
       }
 
Index: gcc/tree-inline.h
===================================================================
--- a/src/gcc/tree-inline.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-inline.h	(.../branches/gcc-7-branch)
@@ -119,6 +119,13 @@
   /* > 0 if we are remapping a type currently.  */
   int remapping_type_depth;
 
+  /* Usually copy_decl callback always creates new decls, in that case
+     we want to remap all variably_modified_type_p types.  If this flag
+     is set, remap_type will do further checks to see if remap_decl
+     of any decls mentioned in the type will remap to anything but itself
+     and only in that case will actually remap the type.  */
+  bool dont_remap_vla_if_no_change;
+
   /* A function to be called when duplicating BLOCK nodes.  */
   void (*transform_lang_insert_block) (tree);
 
Index: gcc/omp-simd-clone.c
===================================================================
--- a/src/gcc/omp-simd-clone.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/omp-simd-clone.c	(.../branches/gcc-7-branch)
@@ -240,6 +240,10 @@
 	  }
 	case OMP_CLAUSE_ALIGNED:
 	  {
+	    /* Ignore aligned (x) for declare simd, for the ABI we really
+	       need an alignment specified.  */
+	    if (OMP_CLAUSE_ALIGNED_ALIGNMENT (t) == NULL_TREE)
+	      break;
 	    tree decl = OMP_CLAUSE_DECL (t);
 	    int argno = tree_to_uhwi (decl);
 	    clone_info->args[argno].alignment
@@ -861,6 +865,18 @@
 
   if (tp != orig_tp)
     {
+      if (gimple_code (info->stmt) == GIMPLE_PHI
+	  && cand
+	  && TREE_CODE (*orig_tp) == ADDR_EXPR
+	  && TREE_CODE (TREE_OPERAND (*orig_tp, 0)) == PARM_DECL
+	  && cand->alias_ptr_type)
+	{
+	  gcc_assert (TREE_CODE (cand->alias_ptr_type) == SSA_NAME);
+	  *orig_tp = cand->alias_ptr_type;
+	  info->modified = true;
+	  return NULL_TREE;
+	}
+
       repl = build_fold_addr_expr (repl);
       gimple *stmt;
       if (is_gimple_debug (info->stmt))
@@ -877,7 +893,18 @@
 	  stmt = gimple_build_assign (make_ssa_name (TREE_TYPE (repl)), repl);
 	  repl = gimple_assign_lhs (stmt);
 	}
-      gimple_stmt_iterator gsi = gsi_for_stmt (info->stmt);
+      gimple_stmt_iterator gsi;
+      if (gimple_code (info->stmt) == GIMPLE_PHI)
+	{
+	  gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));
+	  /* Cache SSA_NAME for next time.  */
+	  if (cand
+	      && TREE_CODE (*orig_tp) == ADDR_EXPR
+	      && TREE_CODE (TREE_OPERAND (*orig_tp, 0)) == PARM_DECL)
+	    cand->alias_ptr_type = repl;
+	}
+      else
+	gsi = gsi_for_stmt (info->stmt);
       gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);
       *orig_tp = repl;
     }
@@ -978,6 +1005,31 @@
     {
       gimple_stmt_iterator gsi;
 
+      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+	{
+	  gphi *phi = as_a <gphi *> (gsi_stmt (gsi));
+	  int i, n = gimple_phi_num_args (phi);
+	  info.stmt = phi;
+	  struct walk_stmt_info wi;
+	  memset (&wi, 0, sizeof (wi));
+	  info.modified = false;
+	  wi.info = &info;
+	  for (i = 0; i < n; ++i)
+	    {
+	      int walk_subtrees = 1;
+	      tree arg = gimple_phi_arg_def (phi, i);
+	      tree op = arg;
+	      ipa_simd_modify_stmt_ops (&op, &walk_subtrees, &wi);
+	      if (op != arg)
+		{
+		  SET_PHI_ARG_DEF (phi, i, op);
+		  gcc_assert (TREE_CODE (op) == SSA_NAME);
+		  if (gimple_phi_arg_edge (phi, i)->flags & EDGE_ABNORMAL)
+		    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (op) = 1;
+		}
+	    }
+	}
+
       gsi = gsi_start_bb (bb);
       while (!gsi_end_p (gsi))
 	{
@@ -993,6 +1045,8 @@
 	  if (greturn *return_stmt = dyn_cast <greturn *> (stmt))
 	    {
 	      tree retval = gimple_return_retval (return_stmt);
+	      edge e = find_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun));
+	      e->flags |= EDGE_FALLTHRU;
 	      if (!retval)
 		{
 		  gsi_remove (&gsi, true);
@@ -1133,14 +1187,9 @@
       basic_block orig_exit = EDGE_PRED (EXIT_BLOCK_PTR_FOR_FN (cfun), 0)->src;
       incr_bb = create_empty_bb (orig_exit);
       add_bb_to_loop (incr_bb, body_bb->loop_father);
-      /* The succ of orig_exit was EXIT_BLOCK_PTR_FOR_FN (cfun), with an empty
-	 flag.  Set it now to be a FALLTHRU_EDGE.  */
-      gcc_assert (EDGE_COUNT (orig_exit->succs) == 1);
-      EDGE_SUCC (orig_exit, 0)->flags |= EDGE_FALLTHRU;
-      for (unsigned i = 0;
-	   i < EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds); ++i)
+      while (EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds))
 	{
-	  edge e = EDGE_PRED (EXIT_BLOCK_PTR_FOR_FN (cfun), i);
+	  edge e = EDGE_PRED (EXIT_BLOCK_PTR_FOR_FN (cfun), 0);
 	  redirect_edge_succ (e, incr_bb);
 	}
     }
Index: gcc/tree-streamer-in.c
===================================================================
--- a/src/gcc/tree-streamer-in.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-streamer-in.c	(.../branches/gcc-7-branch)
@@ -244,7 +244,7 @@
       LABEL_DECL_UID (expr) = -1;
     }
 
-  if (TREE_CODE (expr) == FIELD_DECL)
+  else if (TREE_CODE (expr) == FIELD_DECL)
     {
       DECL_PACKED (expr) = (unsigned) bp_unpack_value (bp, 1);
       DECL_NONADDRESSABLE_P (expr) = (unsigned) bp_unpack_value (bp, 1);
@@ -251,12 +251,15 @@
       expr->decl_common.off_align = bp_unpack_value (bp, 8);
     }
 
-  if (VAR_P (expr))
+  else if (VAR_P (expr))
     {
       DECL_HAS_DEBUG_EXPR_P (expr) = (unsigned) bp_unpack_value (bp, 1);
       DECL_NONLOCAL_FRAME (expr) = (unsigned) bp_unpack_value (bp, 1);
     }
 
+  else if (TREE_CODE (expr) == PARM_DECL)
+    DECL_HIDDEN_STRING_LENGTH (expr) = (unsigned) bp_unpack_value (bp, 1);
+
   if (TREE_CODE (expr) == RESULT_DECL
       || TREE_CODE (expr) == PARM_DECL
       || VAR_P (expr))
Index: gcc/symtab.c
===================================================================
--- a/src/gcc/symtab.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/symtab.c	(.../branches/gcc-7-branch)
@@ -1520,7 +1520,7 @@
 void
 symtab_node::set_section (const char *section)
 {
-  gcc_assert (!this->alias);
+  gcc_assert (!this->alias || !this->analyzed);
   call_for_symbol_and_aliases
     (symtab_node::set_section, const_cast<char *>(section), true);
 }
Index: gcc/tree-ssa-phiprop.c
===================================================================
--- a/src/gcc/tree-ssa-phiprop.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssa-phiprop.c	(.../branches/gcc-7-branch)
@@ -338,8 +338,15 @@
 	    && (!type
 		|| types_compatible_p
 		     (TREE_TYPE (gimple_assign_lhs (use_stmt)), type))
-	    /* We cannot replace a load that may throw or is volatile.  */
-	    && !stmt_can_throw_internal (use_stmt)))
+	    /* We cannot replace a load that may throw or is volatile.
+	       For volatiles the transform can change the number of
+	       executions if the load is inside a loop but the address
+	       computations outside (PR91812).  We could relax this
+	       if we guard against that appropriately.  For loads that can
+	       throw we could relax things if the moved loads all are
+	       known to not throw.  */
+	    && !stmt_can_throw_internal (use_stmt)
+	    && !gimple_has_volatile_ops (use_stmt)))
 	continue;
 
       /* Check if we can move the loads.  The def stmt of the virtual use
@@ -495,8 +502,14 @@
   bbs = get_all_dominated_blocks (CDI_DOMINATORS,
 				  single_succ (ENTRY_BLOCK_PTR_FOR_FN (fun)));
   FOR_EACH_VEC_ELT (bbs, i, bb)
-    for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))
-      did_something |= propagate_with_phi (bb, gsi.phi (), phivn, n);
+    {
+      /* Since we're going to move dereferences across predecessor
+         edges avoid blocks with abnormal predecessors.  */
+      if (bb_has_abnormal_pred (bb))
+	continue;
+      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+	did_something |= propagate_with_phi (bb, gsi.phi (), phivn, n);
+    }
 
   if (did_something)
     gsi_commit_edge_inserts ();
Index: gcc/combine.c
===================================================================
--- a/src/gcc/combine.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/combine.c	(.../branches/gcc-7-branch)
@@ -962,14 +962,17 @@
 }
 
 
-/* Delete any insns that copy a register to itself.  */
+/* Delete any insns that copy a register to itself.
+   Return true if the CFG was changed.  */
 
-static void
+static bool
 delete_noop_moves (void)
 {
   rtx_insn *insn, *next;
   basic_block bb;
 
+  bool edges_deleted = false;
+
   FOR_EACH_BB_FN (bb, cfun)
     {
       for (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb)); insn = next)
@@ -980,10 +983,12 @@
 	      if (dump_file)
 		fprintf (dump_file, "deleting noop move %d\n", INSN_UID (insn));
 
-	      delete_insn_and_edges (insn);
+	      edges_deleted |= delete_insn_and_edges (insn);
 	    }
 	}
     }
+
+  return edges_deleted;
 }
 
 
@@ -1122,8 +1127,8 @@
 /* Main entry point for combiner.  F is the first insn of the function.
    NREGS is the first unused pseudo-reg number.
 
-   Return nonzero if the combiner has turned an indirect jump
-   instruction into a direct jump.  */
+   Return nonzero if the CFG was changed (e.g. if the combiner has
+   turned an indirect jump instruction into a direct jump).  */
 static int
 combine_instructions (rtx_insn *f, unsigned int nregs)
 {
@@ -1501,7 +1506,7 @@
   default_rtl_profile ();
   clear_bb_flags ();
   new_direct_jump_p |= purge_all_dead_edges ();
-  delete_noop_moves ();
+  new_direct_jump_p |= delete_noop_moves ();
 
   /* Clean up.  */
   obstack_free (&insn_link_obstack, NULL);
@@ -5807,8 +5812,9 @@
 	    && GET_MODE_PRECISION (mode) < GET_MODE_PRECISION (op0_mode)
 	    && subreg_lowpart_offset (mode, op0_mode) == SUBREG_BYTE (x)
 	    && HWI_COMPUTABLE_MODE_P (op0_mode)
-	    && (nonzero_bits (SUBREG_REG (x), op0_mode)
-		& GET_MODE_MASK (mode)) == 0)
+	    && ((nonzero_bits (SUBREG_REG (x), op0_mode)
+		 & GET_MODE_MASK (mode)) == 0)
+	    && !side_effects_p (SUBREG_REG (x)))
 	  return CONST0_RTX (mode);
       }
 
@@ -7480,6 +7486,7 @@
 	      /* We can't do this if we are widening INNER_MODE (it
 		 may not be aligned, for one thing).  */
 	      && GET_MODE_PRECISION (inner_mode) >= GET_MODE_PRECISION (tmode)
+	      && pos + len <= GET_MODE_PRECISION (is_mode)
 	      && (inner_mode == tmode
 		  || (! mode_dependent_address_p (XEXP (inner, 0),
 						  MEM_ADDR_SPACE (inner))
@@ -7631,6 +7638,10 @@
       && GET_MODE_SIZE (extraction_mode) < GET_MODE_SIZE (mode))
     extraction_mode = mode;
 
+  /* Punt if len is too large for extraction_mode.  */
+  if (len > GET_MODE_PRECISION (extraction_mode))
+    return NULL_RTX;
+
   if (!MEM_P (inner))
     wanted_inner_mode = wanted_inner_reg_mode;
   else
Index: gcc/tree-outof-ssa.c
===================================================================
--- a/src/gcc/tree-outof-ssa.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-outof-ssa.c	(.../branches/gcc-7-branch)
@@ -651,6 +651,8 @@
   tree type = TREE_TYPE (name);
   int unsignedp;
   machine_mode reg_mode = promote_ssa_mode (name, &unsignedp);
+  if (reg_mode == BLKmode)
+    return assign_temp (type, 0, 0);
   rtx x = gen_reg_rtx (reg_mode);
   if (POINTER_TYPE_P (type))
     mark_reg_pointer (x, TYPE_ALIGN (TREE_TYPE (type)));
Index: gcc/resource.c
===================================================================
--- a/src/gcc/resource.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/resource.c	(.../branches/gcc-7-branch)
@@ -966,9 +966,13 @@
     {
       regset regs_live = DF_LR_IN (BASIC_BLOCK_FOR_FN (cfun, b));
       rtx_insn *start_insn, *stop_insn;
+      df_ref def;
 
       /* Compute hard regs live at start of block.  */
       REG_SET_TO_HARD_REG_SET (current_live_regs, regs_live);
+      FOR_EACH_ARTIFICIAL_DEF (def, b)
+	if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)
+	  SET_HARD_REG_BIT (current_live_regs, DF_REF_REGNO (def));
 
       /* Get starting and ending insn, handling the case where each might
 	 be a SEQUENCE.  */
Index: gcc/cfgloop.h
===================================================================
--- a/src/gcc/cfgloop.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cfgloop.h	(.../branches/gcc-7-branch)
@@ -220,6 +220,10 @@
   /* True if the loop is part of an oacc kernels region.  */
   unsigned in_oacc_kernels_region : 1;
 
+  /* If this loop was inlined the main clique of the callee which does
+     not need remapping when copying the loop body.  */
+  unsigned short owned_clique;
+
   /* For SIMD loops, this is a unique identifier of the loop, referenced
      by IFN_GOMP_SIMD_VF, IFN_GOMP_SIMD_LANE and IFN_GOMP_SIMD_LAST_LANE
      builtins.  */
Index: gcc/config.gcc
===================================================================
--- a/src/gcc/config.gcc	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config.gcc	(.../branches/gcc-7-branch)
@@ -616,7 +616,7 @@
 # Common parts for widely ported systems.
 case ${target} in
 *-*-darwin*)
-  tmake_file="t-darwin ${cpu_type}/t-darwin"
+  tmake_file="t-darwin "
   tm_file="${tm_file} darwin.h"
   case ${target} in
   *-*-darwin9*)
@@ -1440,16 +1440,25 @@
 		dwarf2=no
 	fi
 	;;
+i[34567]86-*-darwin1[89]*)
+	echo "Error: 32bit target is not supported after Darwin17" 1>&2
+	;;
 i[34567]86-*-darwin*)
 	need_64bit_isa=yes
 	# Baseline choice for a machine that allows m64 support.
 	with_cpu=${with_cpu:-core2}
+	tmake_file="${tmake_file} ${cpu_type}/t-darwin32-biarch t-slibgcc"
+	tm_file="${tm_file} ${cpu_type}/darwin32-biarch.h"
+	;;
+x86_64-*-darwin1[89]* | x86_64-*-darwin2[01]*)
+	# Only 64b from now
+	with_cpu=${with_cpu:-core2}
 	tmake_file="${tmake_file} t-slibgcc"
 	;;
 x86_64-*-darwin*)
 	with_cpu=${with_cpu:-core2}
-	tmake_file="${tmake_file} ${cpu_type}/t-darwin64 t-slibgcc"
-	tm_file="${tm_file} ${cpu_type}/darwin64.h"
+	tmake_file="${tmake_file} ${cpu_type}/t-darwin64-biarch t-slibgcc"
+	tm_file="${tm_file} ${cpu_type}/darwin64-biarch.h"
 	;;
 i[34567]86-*-elfiamcu)
 	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h newlib-stdint.h i386/iamcu.h"
@@ -2346,26 +2355,31 @@
 #	extra_headers=
 #	;;
 powerpc-*-darwin*)
-	extra_options="${extra_options} rs6000/darwin.opt"
+	extra_options="${extra_options} ${cpu_type}/darwin.opt"
 	case ${target} in
-	  *-darwin1[0-9]* | *-darwin[8-9]*)
-	    tmake_file="${tmake_file} rs6000/t-darwin8"
-	    tm_file="${tm_file} rs6000/darwin8.h"
+	  *-darwin1[0-9]* | *-darwin9*)
+	    tmake_file="${tmake_file} ${cpu_type}/t-darwin32-biarch"
+	    tm_file="${tm_file} ${cpu_type}/darwin32-biarch.h"
 	    ;;
+	  *-darwin8*)
+	    tmake_file="${tmake_file} ${cpu_type}/t-darwin32-biarch"
+	    tm_file="${tm_file} ${cpu_type}/darwin32-biarch.h"
+	    tm_file="${tm_file} ${cpu_type}/darwin8.h"
+	    ;;
 	  *-darwin7*)
-	    tm_file="${tm_file} rs6000/darwin7.h"
+	    tm_file="${tm_file} ${cpu_type}/darwin7.h"
 	    ;;
-	  *-darwin[0-6]*)
+	  *-darwin[456]*)
+	    # Earlier - single arch, with 32b only
+	    # OS X 10.0, the first edition is Darwin4
 	    ;;
 	esac
 	tmake_file="${tmake_file} t-slibgcc"
-	extra_headers=altivec.h
 	;;
 powerpc64-*-darwin*)
 	extra_options="${extra_options} ${cpu_type}/darwin.opt"
-	tmake_file="${tmake_file} ${cpu_type}/t-darwin64 t-slibgcc"
-	tm_file="${tm_file} ${cpu_type}/darwin8.h ${cpu_type}/darwin64.h"
-	extra_headers=altivec.h
+	tmake_file="${tmake_file} ${cpu_type}/t-darwin64-biarch t-slibgcc"
+	tm_file="${tm_file} ${cpu_type}/darwin64-biarch.h"
 	;;
 powerpc*-*-freebsd*)
 	tm_file="${tm_file} dbxelf.h elfos.h ${fbsd_tm_file} rs6000/sysv4.h"
@@ -4316,14 +4330,12 @@
 			 echo "#undef  LINK_OS_EXTRA_SPEC32"
 			 echo "#define LINK_OS_EXTRA_SPEC32" \
 			      "\"%(link_os_new_dtags)" \
-			      "-rpath $prefix/lib -rpath $at/lib" \
-			      "-L $prefix/lib -L $at/lib\""
+			      "-rpath $prefix/lib -rpath $at/lib\""
 			 echo
 			 echo "#undef  LINK_OS_EXTRA_SPEC64"
 			 echo "#define LINK_OS_EXTRA_SPEC64" \
 			      "\"%(link_os_new_dtags)" \
-			      "-rpath $prefix/lib64 -rpath $at/lib64" \
-			      "-L $prefix/lib64 -L $at/lib64\""
+			      "-rpath $prefix/lib64 -rpath $at/lib64\""
 			 echo
 			 echo "#undef  LINK_OS_NEW_DTAGS_SPEC"
 			 echo "#define LINK_OS_NEW_DTAGS_SPEC" \
@@ -4336,7 +4348,10 @@
 			 echo "#define MD_EXEC_PREFIX \"$at/bin/\""
 			 echo
 			 echo "#undef  MD_STARTFILE_PREFIX"
-			 echo "#define MD_STARTFILE_PREFIX \"$at/lib/\"") \
+			 echo "#define MD_STARTFILE_PREFIX \"$prefix/lib/\""
+			 echo
+			 echo "#undef  MD_STARTFILE_PREFIX_1"
+			 echo "#define MD_STARTFILE_PREFIX_1 \"$at/lib/\"") \
 			    > advance-toolchain.h
 		    else
 			echo "Unknown advance-toolchain $with_advance_toolchain"
Index: gcc/opts-global.c
===================================================================
--- a/src/gcc/opts-global.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/opts-global.c	(.../branches/gcc-7-branch)
@@ -100,10 +100,14 @@
 	   text, bad_lang);
   else if (lang_mask == CL_DRIVER)
     gcc_unreachable ();
-  else
+  else if (ok_langs[0] != '\0')
     /* Eventually this should become a hard error IMO.  */
     warning (0, "command line option %qs is valid for %s but not for %s",
 	     text, ok_langs, bad_lang);
+  else
+    /* Happens for -Werror=warning_name.  */
+    warning (0, "%<-Werror=%> argument %qs is not valid for %s",
+	     text, bad_lang);
 
   free (ok_langs);
   free (bad_lang);
Index: gcc/gimple.c
===================================================================
--- a/src/gcc/gimple.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/gimple.c	(.../branches/gcc-7-branch)
@@ -1613,7 +1613,7 @@
       gimple *new_stmt = gimple_alloc (gimple_code (stmt), new_rhs_ops + 1);
       memcpy (new_stmt, stmt, gimple_size (gimple_code (stmt)));
       gimple_init_singleton (new_stmt);
-      gsi_replace (gsi, new_stmt, true);
+      gsi_replace (gsi, new_stmt, false);
       stmt = new_stmt;
 
       /* The LHS needs to be reset as this also changes the SSA name
Index: gcc/tree-ssa-structalias.c
===================================================================
--- a/src/gcc/tree-ssa-structalias.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssa-structalias.c	(.../branches/gcc-7-branch)
@@ -6322,7 +6322,7 @@
 	      && bitmap_bit_p (escaped_vi->solution, i)))
 	{
 	  pt->vars_contains_escaped = true;
-	  pt->vars_contains_escaped_heap = vi->is_heap_var;
+	  pt->vars_contains_escaped_heap |= vi->is_heap_var;
 	}
 
       if (vi->is_restrict_var)
@@ -7365,7 +7365,11 @@
       if (MR_DEPENDENCE_CLIQUE (ref) == 0)
 	{
 	  if (clique == 0)
-	    clique = ++cfun->last_clique;
+	    {
+	      if (cfun->last_clique == 0)
+		cfun->last_clique = 1;
+	      clique = 1;
+	    }
 	  if (restrict_var->ruid == 0)
 	    restrict_var->ruid = ++last_ruid;
 	  MR_DEPENDENCE_CLIQUE (ref) = clique;
@@ -7376,6 +7380,23 @@
   return false;
 }
 
+/* Clear dependence info for the clique DATA.  */
+
+static bool
+clear_dependence_clique (gimple *, tree base, tree, void *data)
+{
+  unsigned short clique = (uintptr_t)data;
+  if ((TREE_CODE (base) == MEM_REF
+       || TREE_CODE (base) == TARGET_MEM_REF)
+      && MR_DEPENDENCE_CLIQUE (base) == clique)
+    {
+      MR_DEPENDENCE_CLIQUE (base) = 0;
+      MR_DEPENDENCE_BASE (base) = 0;
+    }
+
+  return false;
+}
+
 /* Compute the set of independend memory references based on restrict
    tags and their conservative propagation to the points-to sets.  */
 
@@ -7382,6 +7403,19 @@
 static void
 compute_dependence_clique (void)
 {
+  /* First clear the special "local" clique.  */
+  basic_block bb;
+  if (cfun->last_clique != 0)
+    FOR_EACH_BB_FN (bb, cfun)
+      for (gimple_stmt_iterator gsi = gsi_start_bb (bb);
+	   !gsi_end_p (gsi); gsi_next (&gsi))
+	{
+	  gimple *stmt = gsi_stmt (gsi);
+	  walk_stmt_load_store_ops (stmt, (void *)(uintptr_t) 1,
+				    clear_dependence_clique,
+				    clear_dependence_clique);
+	}
+
   unsigned short clique = 0;
   unsigned short last_ruid = 0;
   bitmap rvars = BITMAP_ALLOC (NULL);
@@ -7456,7 +7490,10 @@
 	    }
 	  if (used)
 	    {
-	      bitmap_set_bit (rvars, restrict_var->id);
+	      /* Add all subvars to the set of restrict pointed-to set. */
+	      for (unsigned sv = restrict_var->head; sv != 0;
+		   sv = get_varinfo (sv)->next)
+		bitmap_set_bit (rvars, sv);
 	      varinfo_t escaped = get_varinfo (find (escaped_id));
 	      if (bitmap_bit_p (escaped->solution, restrict_var->id))
 		escaped_p = true;
Index: gcc/gimple.h
===================================================================
--- a/src/gcc/gimple.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/gimple.h	(.../branches/gcc-7-branch)
@@ -136,6 +136,7 @@
 enum gf_mask {
     GF_ASM_INPUT		= 1 << 0,
     GF_ASM_VOLATILE		= 1 << 1,
+    GF_ASM_INLINE		= 1 << 2,
     GF_CALL_FROM_THUNK		= 1 << 0,
     GF_CALL_RETURN_SLOT_OPT	= 1 << 1,
     GF_CALL_TAILCALL		= 1 << 2,
@@ -3909,7 +3910,7 @@
 }
 
 
-/* Return true ASM_STMT ASM_STMT is an asm statement marked volatile.  */
+/* Return true if ASM_STMT is marked volatile.  */
 
 static inline bool
 gimple_asm_volatile_p (const gasm *asm_stmt)
@@ -3918,7 +3919,7 @@
 }
 
 
-/* If VOLATLE_P is true, mark asm statement ASM_STMT as volatile.  */
+/* If VOLATILE_P is true, mark asm statement ASM_STMT as volatile.  */
 
 static inline void
 gimple_asm_set_volatile (gasm *asm_stmt, bool volatile_p)
@@ -3930,6 +3931,27 @@
 }
 
 
+/* Return true if ASM_STMT is marked inline.  */
+
+static inline bool
+gimple_asm_inline_p (const gasm *asm_stmt)
+{
+  return (asm_stmt->subcode & GF_ASM_INLINE) != 0;
+}
+
+
+/* If INLINE_P is true, mark asm statement ASM_STMT as inline.  */
+
+static inline void
+gimple_asm_set_inline (gasm *asm_stmt, bool inline_p)
+{
+  if (inline_p)
+    asm_stmt->subcode |= GF_ASM_INLINE;
+  else
+    asm_stmt->subcode &= ~GF_ASM_INLINE;
+}
+
+
 /* If INPUT_P is true, mark asm ASM_STMT as an ASM_INPUT.  */
 
 static inline void
Index: gcc/tree-core.h
===================================================================
--- a/src/gcc/tree-core.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-core.h	(.../branches/gcc-7-branch)
@@ -977,7 +977,9 @@
        expression trees and specify known data non-dependences.  For
        two memory references in a function they are known to not
        alias if dependence_info.clique are equal and dependence_info.base
-       are distinct.  */
+       are distinct.  Clique number zero means there is no information,
+       clique number one is populated from function global information
+       and thus needs no remapping on transforms like loop unrolling.  */
     struct {
       unsigned short clique;
       unsigned short base;
@@ -1138,6 +1140,9 @@
        OMP_CLAUSE_LINEAR_VARIABLE_STRIDE in
 	   OMP_CLAUSE_LINEAR
 
+       ASM_INLINE_P in
+	   ASM_EXPR
+
    side_effects_flag:
 
        TREE_SIDE_EFFECTS in
@@ -1611,6 +1616,7 @@
   /* In a VAR_DECL and PARM_DECL, this is DECL_READ_P.  */
   unsigned decl_read_flag : 1;
   /* In a VAR_DECL or RESULT_DECL, this is DECL_NONSHAREABLE.  */
+  /* In a PARM_DECL, this is DECL_HIDDEN_STRING_LENGTH.  */
   unsigned decl_nonshareable_flag : 1;
 
   /* DECL_OFFSET_ALIGN, used only for FIELD_DECLs.  */
Index: gcc/tree-cfg.c
===================================================================
--- a/src/gcc/tree-cfg.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-cfg.c	(.../branches/gcc-7-branch)
@@ -2170,7 +2170,7 @@
 		}
 
 	      new_bb = bb->prev_bb;
-	      new_gsi = gsi_start_bb (new_bb);
+	      new_gsi = gsi_after_labels (new_bb);
 	      gsi_remove (&i, false);
 	      gsi_insert_before (&new_gsi, stmt, GSI_NEW_STMT);
 	    }
@@ -5989,7 +5989,7 @@
    preserve SSA form.  */
 
 static basic_block
-gimple_duplicate_bb (basic_block bb)
+gimple_duplicate_bb (basic_block bb, copy_bb_data *id)
 {
   basic_block new_bb;
   gimple_stmt_iterator gsi_tgt;
@@ -6053,6 +6053,39 @@
 	      && (!VAR_P (base) || !DECL_HAS_VALUE_EXPR_P (base)))
 	    DECL_NONSHAREABLE (base) = 1;
 	}
+ 
+      /* If requested remap dependence info of cliques brought in
+         via inlining.  */
+      if (id)
+	for (unsigned i = 0; i < gimple_num_ops (copy); ++i)
+	  {
+	    tree op = gimple_op (copy, i);
+	    if (!op)
+	      continue;
+	    if (TREE_CODE (op) == ADDR_EXPR
+		|| TREE_CODE (op) == WITH_SIZE_EXPR)
+	      op = TREE_OPERAND (op, 0);
+	    while (handled_component_p (op))
+	      op = TREE_OPERAND (op, 0);
+	    if ((TREE_CODE (op) == MEM_REF
+		 || TREE_CODE (op) == TARGET_MEM_REF)
+		&& MR_DEPENDENCE_CLIQUE (op) > 1
+		&& MR_DEPENDENCE_CLIQUE (op) != bb->loop_father->owned_clique)
+	      {
+		if (!id->dependence_map)
+		  id->dependence_map = new hash_map<dependence_hash,
+						    unsigned short>;
+		bool existed;
+		unsigned short &newc = id->dependence_map->get_or_insert
+		    (MR_DEPENDENCE_CLIQUE (op), &existed);
+		if (!existed)
+		  {
+		    gcc_assert (MR_DEPENDENCE_CLIQUE (op) <= cfun->last_clique);
+		    newc = ++cfun->last_clique;
+		  }
+		MR_DEPENDENCE_CLIQUE (op) = newc;
+	      }
+	  }
 
       /* Create new names for all the definitions created by COPY and
 	 add replacement mappings for each new name.  */
@@ -6914,7 +6947,14 @@
       if (virtual_operand_p (op))
 	{
 	  /* Remove the phi nodes for virtual operands (alias analysis will be
-	     run for the new function, anyway).  */
+	     run for the new function, anyway).  But replace all uses that
+	     might be outside of the region we move.  */
+	  use_operand_p use_p;
+	  imm_use_iterator iter;
+	  gimple *use_stmt;
+	  FOR_EACH_IMM_USE_STMT (use_stmt, iter, op)
+	    FOR_EACH_IMM_USE_ON_STMT (use_p, iter)
+	      SET_USE (use_p, SSA_NAME_VAR (op));
           remove_phi_node (&psi, true);
 	  continue;
 	}
@@ -7002,11 +7042,14 @@
 }
 
 /* Examine the statements in BB (which is in SRC_CFUN); find and return
-   the outermost EH region.  Use REGION as the incoming base EH region.  */
+   the outermost EH region.  Use REGION as the incoming base EH region.
+   If there is no single outermost region, return NULL and set *ALL to
+   true.  */
 
 static eh_region
 find_outermost_region_in_block (struct function *src_cfun,
-				basic_block bb, eh_region region)
+				basic_block bb, eh_region region,
+				bool *all)
 {
   gimple_stmt_iterator si;
 
@@ -7025,7 +7068,11 @@
 	  else if (stmt_region != region)
 	    {
 	      region = eh_region_outermost (src_cfun, stmt_region, region);
-	      gcc_assert (region != NULL);
+	      if (region == NULL)
+		{
+		  *all = true;
+		  return NULL;
+		}
 	    }
 	}
     }
@@ -7319,12 +7366,17 @@
   if (saved_cfun->eh)
     {
       eh_region region = NULL;
+      bool all = false;
 
       FOR_EACH_VEC_ELT (bbs, i, bb)
-	region = find_outermost_region_in_block (saved_cfun, bb, region);
+	{
+	  region = find_outermost_region_in_block (saved_cfun, bb, region, &all);
+	  if (all)
+	    break;
+	}
 
       init_eh_for_function ();
-      if (region != NULL)
+      if (region != NULL || all)
 	{
 	  new_label_map = htab_create (17, tree_map_hash, tree_map_eq, free);
 	  eh_map = duplicate_eh_regions (saved_cfun, region, 0,
Index: gcc/tree-ssa-reassoc.c
===================================================================
--- a/src/gcc/tree-ssa-reassoc.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssa-reassoc.c	(.../branches/gcc-7-branch)
@@ -1012,7 +1012,7 @@
 		    fprintf (dump_file, "Found * 0, removing all other ops\n");
 
 		  reassociate_stats.ops_eliminated += ops->length () - 1;
-		  ops->truncate (1);
+		  ops->truncate (0);
 		  ops->quick_push (oelast);
 		  return;
 		}
@@ -2140,7 +2140,8 @@
 	  exp_type = boolean_type_node;
 	}
 
-      if (TREE_CODE (arg0) != SSA_NAME)
+      if (TREE_CODE (arg0) != SSA_NAME
+	  || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (arg0))
 	break;
       loc = gimple_location (stmt);
       switch (code)
@@ -4593,6 +4594,7 @@
       else
 	{
 	  stmts[i] = build_and_add_sum (TREE_TYPE (last_rhs1), op1, op2, opcode);
+	  gimple_set_visited (stmts[i], true);
 	}
       if (dump_file && (dump_flags & TDF_DETAILS))
 	{
Index: gcc/config/nvptx/nvptx.c
===================================================================
--- a/src/gcc/config/nvptx/nvptx.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/nvptx/nvptx.c	(.../branches/gcc-7-branch)
@@ -1354,7 +1354,7 @@
       fputs (";\n", file);
       if (!CONST_INT_P (size) || UINTVAL (align) > GET_MODE_SIZE (DImode))
 	fprintf (file,
-		 "\t\tand.u%d %%r%d, %%r%d, -" HOST_WIDE_INT_PRINT_DEC ";\n",
+		 "\t\tand.b%d %%r%d, %%r%d, -" HOST_WIDE_INT_PRINT_DEC ";\n",
 		 bits, regno, regno, UINTVAL (align));
     }
   if (cfun->machine->has_softstack)
Index: gcc/config/alpha/alpha.c
===================================================================
--- a/src/gcc/config/alpha/alpha.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/alpha/alpha.c	(.../branches/gcc-7-branch)
@@ -6357,9 +6357,41 @@
   offset = get_initialized_tmp_var (t, pre_p, NULL);
 
   indirect = pass_by_reference (NULL, TYPE_MODE (type), type, false);
+
   if (indirect)
-    type = build_pointer_type_for_mode (type, ptr_mode, true);
+    {
+      if (TREE_CODE (type) == COMPLEX_TYPE
+	  && targetm.calls.split_complex_arg (type))
+	{
+	  tree real_part, imag_part, real_temp;
 
+	  tree ptr_type = build_pointer_type_for_mode (TREE_TYPE (type),
+						       ptr_mode, true);
+
+	  real_part = alpha_gimplify_va_arg_1 (ptr_type, base,
+					       offset, pre_p);
+	  real_part = build_va_arg_indirect_ref (real_part);
+
+	  /* Copy the value into a new temporary, lest the formal temporary
+	     be reused out from under us.  */
+	  real_temp = get_initialized_tmp_var (real_part, pre_p, NULL);
+
+	  imag_part = alpha_gimplify_va_arg_1 (ptr_type, base,
+					       offset, pre_p);
+	  imag_part = build_va_arg_indirect_ref (imag_part);
+
+	  r = build2 (COMPLEX_EXPR, type, real_temp, imag_part);
+
+	  /* Stuff the offset temporary back into its field.  */
+	  gimplify_assign (unshare_expr (offset_field),
+			   fold_convert (TREE_TYPE (offset_field), offset),
+			   pre_p);
+	  return r;
+	}
+      else
+	type = build_pointer_type_for_mode (type, ptr_mode, true);
+    }
+
   /* Find the value.  Note that this will be a stable indirection, or
      a composite of stable indirections in the case of complex.  */
   r = alpha_gimplify_va_arg_1 (type, base, offset, pre_p);
Index: gcc/config/s390/s390.md
===================================================================
--- a/src/gcc/config/s390/s390.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/s390/s390.md	(.../branches/gcc-7-branch)
@@ -1332,10 +1332,11 @@
 ; (TF|DF|SF|TD|DD|SD) instructions
 
 
-; load and test instructions turn SNaN into QNaN what is not
+; FIXME: load and test instructions turn SNaN into QNaN what is not
 ; acceptable if the target will be used afterwards.  On the other hand
 ; they are quite convenient for implementing comparisons with 0.0. So
-; try to enable them via splitter if the value isn't needed anymore.
+; try to enable them via splitter/peephole if the value isn't needed anymore.
+; See testcases: load-and-test-fp-1.c and load-and-test-fp-2.c
 
 ; ltxbr, ltdbr, ltebr, ltxtr, ltdtr
 (define_insn "*cmp<mode>_ccs_0"
@@ -1348,22 +1349,6 @@
    [(set_attr "op_type" "RRE")
     (set_attr "type"  "fsimp<mode>")])
 
-(define_split
-  [(set (match_operand 0 "cc_reg_operand")
-	(compare (match_operand:FP 1 "register_operand")
-		 (match_operand:FP 2 "const0_operand")))]
-  "TARGET_HARD_FLOAT && REG_P (operands[1]) && dead_or_set_p (insn, operands[1])"
-  [(parallel
-    [(set (match_dup 0) (match_dup 3))
-     (clobber (match_dup 1))])]
- {
-   /* s390_match_ccmode requires the compare to have the same CC mode
-      as the CC destination register.  */
-   operands[3] = gen_rtx_COMPARE (GET_MODE (operands[0]),
-				  operands[1], operands[2]);
- })
-
-
 ; VX: TFmode in FPR pairs: use cxbr instead of wfcxb
 ; cxtr, cdtr, cxbr, cdbr, cebr, cdb, ceb, wfcsb, wfcdb
 (define_insn "*cmp<mode>_ccs"
Index: gcc/config/s390/vector.md
===================================================================
--- a/src/gcc/config/s390/vector.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/s390/vector.md	(.../branches/gcc-7-branch)
@@ -933,7 +933,7 @@
 	(VEC_SHIFTS:VI (match_operand:VI 1 "register_operand"   "v")
 		       (match_operand:SI 2 "nonmemory_operand" "an")))]
   "TARGET_VX"
-  "<vec_shifts_mnem><bhfgq>\t%v0,%v1,%Y2"
+  "<vec_shifts_mnem><bhfgq>\t%v0,%v1,<addr_style_op_ops>"
   [(set_attr "op_type" "VRS")])
 
 ; Shift each element by corresponding vector element
Index: gcc/config/s390/s390.c
===================================================================
--- a/src/gcc/config/s390/s390.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/s390/s390.c	(.../branches/gcc-7-branch)
@@ -15498,6 +15498,7 @@
     }
   return ret;
 }
+#endif
 
 /* Set VAL to correct enum value according to the indirect-branch or
    function-return attribute in ATTR.  */
@@ -15572,6 +15573,7 @@
 }
 
 
+#if S390_USE_TARGET_ATTRIBUTE
 /* Restore targets globals from NEW_TREE and invalidate s390_previous_fndecl
    cache.  */
 
@@ -15587,6 +15589,7 @@
     TREE_TARGET_GLOBALS (new_tree) = save_target_globals_default_opts ();
   s390_previous_fndecl = NULL_TREE;
 }
+#endif
 
 /* Establish appropriate back-end context for processing the function
    FNDECL.  The argument might be NULL to indicate processing at top
@@ -15594,6 +15597,7 @@
 static void
 s390_set_current_function (tree fndecl)
 {
+#if S390_USE_TARGET_ATTRIBUTE
   /* Only change the context if the function changes.  This hook is called
      several times in the course of compiling a function, and we don't want to
      slow things down too much or call target_reinit when it isn't safe.  */
@@ -15625,10 +15629,9 @@
   if (old_tree != new_tree)
     s390_activate_target_options (new_tree);
   s390_previous_fndecl = fndecl;
-
+#endif
   s390_indirect_branch_settings (fndecl);
 }
-#endif
 
 /* Implement TARGET_USE_BY_PIECES_INFRASTRUCTURE_P.  */
 
@@ -16333,10 +16336,10 @@
 #undef TARGET_ASM_FILE_END
 #define TARGET_ASM_FILE_END s390_asm_file_end
 
-#if S390_USE_TARGET_ATTRIBUTE
 #undef TARGET_SET_CURRENT_FUNCTION
 #define TARGET_SET_CURRENT_FUNCTION s390_set_current_function
 
+#if S390_USE_TARGET_ATTRIBUTE
 #undef TARGET_OPTION_VALID_ATTRIBUTE_P
 #define TARGET_OPTION_VALID_ATTRIBUTE_P s390_valid_target_attribute_p
 #endif
Index: gcc/config/s390/s390-builtins.def
===================================================================
--- a/src/gcc/config/s390/s390-builtins.def	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/s390/s390-builtins.def	(.../branches/gcc-7-branch)
@@ -2804,8 +2804,8 @@
 B_DEF      (s390_vfsqdb,                sqrtv2df2,          0,                  B_VX,               0,                  BT_FN_V2DF_V2DF)
 
 OB_DEF     (s390_vec_double,            s390_vec_double_s64,s390_vec_double_u64,B_VX,               BT_FN_OV4SI_OV4SI)
-OB_DEF_VAR (s390_vec_double_s64,        s390_vcdgb,         0,                  0,                  BT_OV_V2DF_V2DI)
-OB_DEF_VAR (s390_vec_double_u64,        s390_vcdlgb,        0,                  0,                  BT_OV_V2DF_UV2DI)
+OB_DEF_VAR (s390_vec_double_s64,        s390_vec_double_s64,0,                  0,                  BT_OV_V2DF_V2DI)
+OB_DEF_VAR (s390_vec_double_u64,        s390_vec_double_u64,0,                  0,                  BT_OV_V2DF_UV2DI)
 
 B_DEF      (s390_vec_double_s64,        vec_double_s64,     0,                  B_INT | B_VX,       0,                  BT_FN_V2DF_V2DI)  /* vcdgb */
 B_DEF      (s390_vec_double_u64,        vec_double_u64,     0,                  B_INT | B_VX,       0,                  BT_FN_V2DF_UV2DI) /* vcdlgb */
Index: gcc/config/s390/vx-builtins.md
===================================================================
--- a/src/gcc/config/s390/vx-builtins.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/s390/vx-builtins.md	(.../branches/gcc-7-branch)
@@ -1607,7 +1607,7 @@
 (define_expand "vec_ctd_s64"
   [(set (match_operand:V2DF               0 "register_operand" "")
 	(unspec:V2DF [(match_operand:V2DI 1 "register_operand" "")
-		      (const_int 4) ; inexact suppressed
+		      (const_int VEC_NOINEXACT)
 		      (const_int VEC_RND_CURRENT)]
 		     UNSPEC_VEC_VCDGB))
    (use (match_operand:QI 2 "const_int_operand" ""))
@@ -1638,7 +1638,7 @@
 (define_expand "vec_ctd_u64"
   [(set (match_operand:V2DF               0 "register_operand" "")
 	(unspec:V2DF [(match_operand:V2DI 1 "register_operand" "")
-		      (const_int 4) ; inexact suppressed
+		      (const_int VEC_NOINEXACT)
 		      (const_int VEC_RND_CURRENT)]
 		     UNSPEC_VEC_VCDLGB))
    (use (match_operand:QI 2 "const_int_operand" ""))
@@ -1672,7 +1672,7 @@
 				 (match_dup 3)))
    (set (match_operand:V2DI 0 "register_operand" "")
 	(unspec:V2DI [(match_dup 4)
-		      (const_int 4) ; inexact suppressed
+		      (const_int VEC_NOINEXACT)
 		      (const_int VEC_RND_CURRENT)]
 		     UNSPEC_VEC_VCGDB))]
   "TARGET_VX"
@@ -1705,7 +1705,7 @@
 				 (match_dup 3)))
    (set (match_operand:V2DI 0 "register_operand" "")
 	(unspec:V2DI [(match_dup 4)
-		      (const_int 4) ; inexact suppressed
+		      (const_int VEC_NOINEXACT)
 		      (const_int VEC_RND_CURRENT)]
 		     UNSPEC_VEC_VCLGDB))]
   "TARGET_VX"
@@ -2026,7 +2026,7 @@
 (define_expand "vec_double_s64"
   [(set (match_operand:V2DF               0 "register_operand")
 	(unspec:V2DF [(match_operand:V2DI 1 "register_operand")
-		      (const_int 0)  ; inexact suppression disabled
+		      (const_int VEC_INEXACT)
 		      (const_int VEC_RND_CURRENT)]
 		     UNSPEC_VEC_VCDGB))]
   "TARGET_VX")
@@ -2034,7 +2034,7 @@
 (define_expand "vec_double_u64"
   [(set (match_operand:V2DF               0 "register_operand")
 	(unspec:V2DF [(match_operand:V2DI 1 "register_operand")
-		      (const_int 0)  ; inexact suppression disabled
+		      (const_int VEC_INEXACT)
 		      (const_int VEC_RND_CURRENT)]
 		     UNSPEC_VEC_VCDLGB))]
   "TARGET_VX")
Index: gcc/config/sparc/sparc.md
===================================================================
--- a/src/gcc/config/sparc/sparc.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/sparc/sparc.md	(.../branches/gcc-7-branch)
@@ -7961,158 +7961,112 @@
 
 ;; TLS support instructions.
 
-(define_insn "tgd_hi22"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-        (high:SI (unspec:SI [(match_operand 1 "tgd_symbolic_operand" "")]
-			    UNSPEC_TLSGD)))]
+(define_insn "tgd_hi22<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+        (high:P (unspec:P [(match_operand 1 "tgd_symbolic_operand" "")]
+			  UNSPEC_TLSGD)))]
   "TARGET_TLS"
   "sethi\\t%%tgd_hi22(%a1), %0")
 
-(define_insn "tgd_lo10"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
-		   (unspec:SI [(match_operand 2 "tgd_symbolic_operand" "")]
-			      UNSPEC_TLSGD)))]
+(define_insn "tgd_lo10<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(lo_sum:P (match_operand:P 1 "register_operand" "r")
+		  (unspec:P [(match_operand 2 "tgd_symbolic_operand" "")]
+			    UNSPEC_TLSGD)))]
   "TARGET_TLS"
   "add\\t%1, %%tgd_lo10(%a2), %0")
 
-(define_insn "tgd_add32"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(plus:SI (match_operand:SI 1 "register_operand" "r")
-		 (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-			     (match_operand 3 "tgd_symbolic_operand" "")]
-			    UNSPEC_TLSGD)))]
-  "TARGET_TLS && TARGET_ARCH32"
+(define_insn "tgd_add<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(plus:P (match_operand:P 1 "register_operand" "r")
+		(unspec:P [(match_operand:P 2 "register_operand" "r")
+			   (match_operand 3 "tgd_symbolic_operand" "")]
+			  UNSPEC_TLSGD)))]
+  "TARGET_TLS"
   "add\\t%1, %2, %0, %%tgd_add(%a3)")
 
-(define_insn "tgd_add64"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(plus:DI (match_operand:DI 1 "register_operand" "r")
-		 (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-			     (match_operand 3 "tgd_symbolic_operand" "")]
-			    UNSPEC_TLSGD)))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "add\\t%1, %2, %0, %%tgd_add(%a3)")
-
-(define_insn "tgd_call32"
+(define_insn "tgd_call<P:mode>"
   [(set (match_operand 0 "register_operand" "=r")
-	(call (mem:SI (unspec:SI [(match_operand:SI 1 "symbolic_operand" "s")
-				  (match_operand 2 "tgd_symbolic_operand" "")]
-				 UNSPEC_TLSGD))
+	(call (mem:P (unspec:P [(match_operand:P 1 "symbolic_operand" "s")
+				(match_operand 2 "tgd_symbolic_operand" "")]
+			       UNSPEC_TLSGD))
 	      (match_operand 3 "" "")))
-   (clobber (reg:SI O7_REG))]
-  "TARGET_TLS && TARGET_ARCH32"
+   (clobber (reg:P O7_REG))]
+  "TARGET_TLS"
   "call\t%a1, %%tgd_call(%a2)%#"
   [(set_attr "type" "call")])
 
-(define_insn "tgd_call64"
-  [(set (match_operand 0 "register_operand" "=r")
-	(call (mem:DI (unspec:DI [(match_operand:DI 1 "symbolic_operand" "s")
-				  (match_operand 2 "tgd_symbolic_operand" "")]
-				 UNSPEC_TLSGD))
-	      (match_operand 3 "" "")))
-   (clobber (reg:DI O7_REG))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "call\t%a1, %%tgd_call(%a2)%#"
-  [(set_attr "type" "call")])
-
-(define_insn "tldm_hi22"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-        (high:SI (unspec:SI [(const_int 0)] UNSPEC_TLSLDM)))]
+(define_insn "tldm_hi22<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+        (high:P (unspec:P [(const_int 0)] UNSPEC_TLSLDM)))]
   "TARGET_TLS"
   "sethi\\t%%tldm_hi22(%&), %0")
 
-(define_insn "tldm_lo10"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
-		    (unspec:SI [(const_int 0)] UNSPEC_TLSLDM)))]
+(define_insn "tldm_lo10<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(lo_sum:P (match_operand:P 1 "register_operand" "r")
+		  (unspec:P [(const_int 0)] UNSPEC_TLSLDM)))]
   "TARGET_TLS"
   "add\\t%1, %%tldm_lo10(%&), %0")
 
-(define_insn "tldm_add32"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(plus:SI (match_operand:SI 1 "register_operand" "r")
-		 (unspec:SI [(match_operand:SI 2 "register_operand" "r")]
-			    UNSPEC_TLSLDM)))]
-  "TARGET_TLS && TARGET_ARCH32"
+(define_insn "tldm_add<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(plus:P (match_operand:P 1 "register_operand" "r")
+		(unspec:P [(match_operand:P 2 "register_operand" "r")]
+			  UNSPEC_TLSLDM)))]
+  "TARGET_TLS"
   "add\\t%1, %2, %0, %%tldm_add(%&)")
 
-(define_insn "tldm_add64"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(plus:DI (match_operand:DI 1 "register_operand" "r")
-		 (unspec:DI [(match_operand:SI 2 "register_operand" "r")]
-			    UNSPEC_TLSLDM)))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "add\\t%1, %2, %0, %%tldm_add(%&)")
-
-(define_insn "tldm_call32"
+(define_insn "tldm_call<P:mode>"
   [(set (match_operand 0 "register_operand" "=r")
-	(call (mem:SI (unspec:SI [(match_operand:SI 1 "symbolic_operand" "s")]
-				 UNSPEC_TLSLDM))
+	(call (mem:P (unspec:P [(match_operand:P 1 "symbolic_operand" "s")]
+			       UNSPEC_TLSLDM))
 	      (match_operand 2 "" "")))
-   (clobber (reg:SI O7_REG))]
-  "TARGET_TLS && TARGET_ARCH32"
+   (clobber (reg:P O7_REG))]
+  "TARGET_TLS"
   "call\t%a1, %%tldm_call(%&)%#"
   [(set_attr "type" "call")])
 
-(define_insn "tldm_call64"
-  [(set (match_operand 0 "register_operand" "=r")
-	(call (mem:DI (unspec:DI [(match_operand:DI 1 "symbolic_operand" "s")]
-				 UNSPEC_TLSLDM))
-	      (match_operand 2 "" "")))
-   (clobber (reg:DI O7_REG))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "call\t%a1, %%tldm_call(%&)%#"
-  [(set_attr "type" "call")])
-
-(define_insn "tldo_hix22"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-        (high:SI (unspec:SI [(match_operand 1 "tld_symbolic_operand" "")]
-			    UNSPEC_TLSLDO)))]
+(define_insn "tldo_hix22<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+        (high:P (unspec:P [(match_operand 1 "tld_symbolic_operand" "")]
+			  UNSPEC_TLSLDO)))]
   "TARGET_TLS"
   "sethi\\t%%tldo_hix22(%a1), %0")
 
-(define_insn "tldo_lox10"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
-		   (unspec:SI [(match_operand 2 "tld_symbolic_operand" "")]
-			      UNSPEC_TLSLDO)))]
+(define_insn "tldo_lox10<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(lo_sum:P (match_operand:P 1 "register_operand" "r")
+		  (unspec:P [(match_operand 2 "tld_symbolic_operand" "")]
+			    UNSPEC_TLSLDO)))]
   "TARGET_TLS"
   "xor\\t%1, %%tldo_lox10(%a2), %0")
 
-(define_insn "tldo_add32"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(plus:SI (match_operand:SI 1 "register_operand" "r")
-		 (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-			     (match_operand 3 "tld_symbolic_operand" "")]
-			    UNSPEC_TLSLDO)))]
-  "TARGET_TLS && TARGET_ARCH32"
+(define_insn "tldo_add<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(plus:P (match_operand:P 1 "register_operand" "r")
+		(unspec:P [(match_operand:P 2 "register_operand" "r")
+			   (match_operand 3 "tld_symbolic_operand" "")]
+			  UNSPEC_TLSLDO)))]
+  "TARGET_TLS"
   "add\\t%1, %2, %0, %%tldo_add(%a3)")
 
-(define_insn "tldo_add64"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(plus:DI (match_operand:DI 1 "register_operand" "r")
-		 (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-			     (match_operand 3 "tld_symbolic_operand" "")]
-			    UNSPEC_TLSLDO)))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "add\\t%1, %2, %0, %%tldo_add(%a3)")
-
-(define_insn "tie_hi22"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-        (high:SI (unspec:SI [(match_operand 1 "tie_symbolic_operand" "")]
-			    UNSPEC_TLSIE)))]
+(define_insn "tie_hi22<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+        (high:P (unspec:P [(match_operand 1 "tie_symbolic_operand" "")]
+			  UNSPEC_TLSIE)))]
   "TARGET_TLS"
   "sethi\\t%%tie_hi22(%a1), %0")
 
-(define_insn "tie_lo10"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
-		   (unspec:SI [(match_operand 2 "tie_symbolic_operand" "")]
-			      UNSPEC_TLSIE)))]
+(define_insn "tie_lo10<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(lo_sum:P (match_operand:P 1 "register_operand" "r")
+		  (unspec:P [(match_operand 2 "tie_symbolic_operand" "")]
+			    UNSPEC_TLSIE)))]
   "TARGET_TLS"
   "add\\t%1, %%tie_lo10(%a2), %0")
 
+; Note the %%tie_ld operator
 (define_insn "tie_ld32"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(unspec:SI [(match_operand:SI 1 "register_operand" "r")
@@ -8124,10 +8078,11 @@
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")])
 
+; Note the %%tie_ldx operator
 (define_insn "tie_ld64"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(unspec:DI [(match_operand:DI 1 "register_operand" "r")
-		    (match_operand:SI 2 "register_operand" "r")
+		    (match_operand:DI 2 "register_operand" "r")
 		    (match_operand 3 "tie_symbolic_operand" "")]
 		   UNSPEC_TLSIE))]
   "TARGET_TLS && TARGET_ARCH64"
@@ -8135,159 +8090,97 @@
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")])
 
-(define_insn "tie_add32"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(plus:SI (match_operand:SI 1 "register_operand" "r")
-		 (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-			     (match_operand 3 "tie_symbolic_operand" "")]
-			    UNSPEC_TLSIE)))]
-  "TARGET_SUN_TLS && TARGET_ARCH32"
+(define_insn "tie_add<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(plus:P (match_operand:P 1 "register_operand" "r")
+		(unspec:P [(match_operand:P 2 "register_operand" "r")
+			   (match_operand 3 "tie_symbolic_operand" "")]
+			  UNSPEC_TLSIE)))]
+  "TARGET_SUN_TLS"
   "add\\t%1, %2, %0, %%tie_add(%a3)")
 
-(define_insn "tie_add64"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(plus:DI (match_operand:DI 1 "register_operand" "r")
-		 (unspec:DI [(match_operand:DI 2 "register_operand" "r")
-			     (match_operand 3 "tie_symbolic_operand" "")]
-			    UNSPEC_TLSIE)))]
-  "TARGET_SUN_TLS && TARGET_ARCH64"
-  "add\\t%1, %2, %0, %%tie_add(%a3)")
-
-(define_insn "tle_hix22_sp32"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-        (high:SI (unspec:SI [(match_operand 1 "tle_symbolic_operand" "")]
-			    UNSPEC_TLSLE)))]
-  "TARGET_TLS && TARGET_ARCH32"
+(define_insn "tle_hix22<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+        (high:P (unspec:P [(match_operand 1 "tle_symbolic_operand" "")]
+			  UNSPEC_TLSLE)))]
+  "TARGET_TLS"
   "sethi\\t%%tle_hix22(%a1), %0")
 
-(define_insn "tle_lox10_sp32"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
-		   (unspec:SI [(match_operand 2 "tle_symbolic_operand" "")]
-			      UNSPEC_TLSLE)))]
-  "TARGET_TLS && TARGET_ARCH32"
-  "xor\\t%1, %%tle_lox10(%a2), %0")
-
-(define_insn "tle_hix22_sp64"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-        (high:DI (unspec:DI [(match_operand 1 "tle_symbolic_operand" "")]
+(define_insn "tle_lox10<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(lo_sum:P (match_operand:P 1 "register_operand" "r")
+		  (unspec:P [(match_operand 2 "tle_symbolic_operand" "")]
 			    UNSPEC_TLSLE)))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "sethi\\t%%tle_hix22(%a1), %0")
-
-(define_insn "tle_lox10_sp64"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(lo_sum:DI (match_operand:DI 1 "register_operand" "r")
-		   (unspec:DI [(match_operand 2 "tle_symbolic_operand" "")]
-			      UNSPEC_TLSLE)))]
-  "TARGET_TLS && TARGET_ARCH64"
+  "TARGET_TLS"
   "xor\\t%1, %%tle_lox10(%a2), %0")
 
-;; Now patterns combining tldo_add{32,64} with some integer loads or stores
-(define_insn "*tldo_ldub_sp32"
+;; Now patterns combining tldo_add with some integer loads or stores
+(define_insn "*tldo_ldub<P:mode>"
   [(set (match_operand:QI 0 "register_operand" "=r")
-	(mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:SI 1 "register_operand" "r"))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	(mem:QI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				   (match_operand 3 "tld_symbolic_operand" "")]
+				  UNSPEC_TLSLDO)
+			(match_operand:P 1 "register_operand" "r"))))]
+  "TARGET_TLS"
   "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_ldub1_sp32"
+(define_insn "*tldo_ldub1<P:mode>"
   [(set (match_operand:HI 0 "register_operand" "=r")
 	(zero_extend:HI
-	  (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:SI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	  (mem:QI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			  (match_operand:P 1 "register_operand" "r")))))]
+  "TARGET_TLS"
   "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_ldub2_sp32"
+(define_insn "*tldo_ldub2<P:mode>"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(zero_extend:SI
-	  (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:SI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	  (mem:QI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			  (match_operand:P 1 "register_operand" "r")))))]
+  "TARGET_TLS"
   "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_ldsb1_sp32"
+(define_insn "*tldo_ldsb1<P:mode>"
   [(set (match_operand:HI 0 "register_operand" "=r")
 	(sign_extend:HI
-	  (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:SI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	  (mem:QI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			  (match_operand:P 1 "register_operand" "r")))))]
+  "TARGET_TLS"
   "ldsb\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "sload")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_ldsb2_sp32"
+(define_insn "*tldo_ldsb2<P:mode>"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(sign_extend:SI
-	  (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:SI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	  (mem:QI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			  (match_operand:P 1 "register_operand" "r")))))]
+  "TARGET_TLS"
   "ldsb\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "sload")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_ldub_sp64"
-  [(set (match_operand:QI 0 "register_operand" "=r")
-	(mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:DI 1 "register_operand" "r"))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "load")
-   (set_attr "subtype" "regular")
-   (set_attr "us3load_type" "3cycle")])
-
-(define_insn "*tldo_ldub1_sp64"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(zero_extend:HI
-	  (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:DI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "load")
-   (set_attr "subtype" "regular")
-   (set_attr "us3load_type" "3cycle")])
-
-(define_insn "*tldo_ldub2_sp64"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(zero_extend:SI
-	  (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:DI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "load")
-   (set_attr "subtype" "regular")
-   (set_attr "us3load_type" "3cycle")])
-
 (define_insn "*tldo_ldub3_sp64"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(zero_extend:DI
-	  (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+	  (mem:QI (plus:DI (unspec:DI [(match_operand:DI 2 "register_operand" "r")
 				       (match_operand 3 "tld_symbolic_operand" "")]
 				      UNSPEC_TLSLDO)
 			   (match_operand:DI 1 "register_operand" "r")))))]
@@ -8297,34 +8190,10 @@
    (set_attr "subtype" "regular")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_ldsb1_sp64"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(sign_extend:HI
-	  (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:DI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "ldsb\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "sload")
-   (set_attr "us3load_type" "3cycle")])
-
-(define_insn "*tldo_ldsb2_sp64"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(sign_extend:SI
-	  (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:DI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "ldsb\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "sload")
-   (set_attr "us3load_type" "3cycle")])
-
 (define_insn "*tldo_ldsb3_sp64"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(sign_extend:DI
-	  (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+	  (mem:QI (plus:DI (unspec:DI [(match_operand:DI 2 "register_operand" "r")
 				       (match_operand 3 "tld_symbolic_operand" "")]
 				      UNSPEC_TLSLDO)
 			   (match_operand:DI 1 "register_operand" "r")))))]
@@ -8333,72 +8202,47 @@
   [(set_attr "type" "sload")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_lduh_sp32"
+(define_insn "*tldo_lduh<P:mode>"
   [(set (match_operand:HI 0 "register_operand" "=r")
-	(mem:HI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:SI 1 "register_operand" "r"))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	(mem:HI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				   (match_operand 3 "tld_symbolic_operand" "")]
+				  UNSPEC_TLSLDO)
+			(match_operand:P 1 "register_operand" "r"))))]
+  "TARGET_TLS"
   "lduh\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_lduh1_sp32"
+(define_insn "*tldo_lduh1<P:mode>"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(zero_extend:SI
-	  (mem:HI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:SI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	  (mem:HI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			  (match_operand:P 1 "register_operand" "r")))))]
+  "TARGET_TLS"
   "lduh\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_ldsh1_sp32"
+(define_insn "*tldo_ldsh1<P:mode>"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(sign_extend:SI
-	  (mem:HI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:SI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	  (mem:HI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			  (match_operand:P 1 "register_operand" "r")))))]
+  "TARGET_TLS"
   "ldsh\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "sload")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_lduh_sp64"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:DI 1 "register_operand" "r"))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "lduh\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "load")
-   (set_attr "subtype" "regular")
-   (set_attr "us3load_type" "3cycle")])
-
-(define_insn "*tldo_lduh1_sp64"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(zero_extend:SI
-	  (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:DI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "lduh\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "load")
-   (set_attr "subtype" "regular")
-   (set_attr "us3load_type" "3cycle")])
-
 (define_insn "*tldo_lduh2_sp64"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(zero_extend:DI
-	  (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+	  (mem:HI (plus:DI (unspec:DI [(match_operand:DI 2 "register_operand" "r")
 				       (match_operand 3 "tld_symbolic_operand" "")]
 				      UNSPEC_TLSLDO)
 			   (match_operand:DI 1 "register_operand" "r")))))]
@@ -8408,22 +8252,10 @@
    (set_attr "subtype" "regular")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_ldsh1_sp64"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(sign_extend:SI
-	  (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:DI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "ldsh\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "sload")
-   (set_attr "us3load_type" "3cycle")])
-
 (define_insn "*tldo_ldsh2_sp64"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(sign_extend:DI
-	  (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+	  (mem:HI (plus:DI (unspec:DI [(match_operand:DI 2 "register_operand" "r")
 				       (match_operand 3 "tld_symbolic_operand" "")]
 				      UNSPEC_TLSLDO)
 			   (match_operand:DI 1 "register_operand" "r")))))]
@@ -8432,32 +8264,21 @@
   [(set_attr "type" "sload")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_lduw_sp32"
+(define_insn "*tldo_lduw<P:mode>"
   [(set (match_operand:SI 0 "register_operand" "=r")
-	(mem:SI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:SI 1 "register_operand" "r"))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	(mem:SI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				   (match_operand 3 "tld_symbolic_operand" "")]
+				  UNSPEC_TLSLDO)
+			(match_operand:P 1 "register_operand" "r"))))]
+  "TARGET_TLS"
   "ld\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")])
 
-(define_insn "*tldo_lduw_sp64"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(mem:SI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:DI 1 "register_operand" "r"))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "lduw\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "load")
-   (set_attr "subtype" "regular")])
-
 (define_insn "*tldo_lduw1_sp64"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(zero_extend:DI
-	  (mem:SI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+	  (mem:SI (plus:DI (unspec:DI [(match_operand:DI 2 "register_operand" "r")
 				       (match_operand 3 "tld_symbolic_operand" "")]
 				      UNSPEC_TLSLDO)
 			   (match_operand:DI 1 "register_operand" "r")))))]
@@ -8469,8 +8290,8 @@
 (define_insn "*tldo_ldsw1_sp64"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(sign_extend:DI
-	  (mem:SI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-					(match_operand 3 "tld_symbolic_operand" "")]
+	  (mem:SI (plus:DI (unspec:DI [(match_operand:DI 2 "register_operand" "r")
+				       (match_operand 3 "tld_symbolic_operand" "")]
 				      UNSPEC_TLSLDO)
 			   (match_operand:DI 1 "register_operand" "r")))))]
   "TARGET_TLS && TARGET_ARCH64"
@@ -8480,7 +8301,7 @@
 
 (define_insn "*tldo_ldx_sp64"
   [(set (match_operand:DI 0 "register_operand" "=r")
-	(mem:DI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+	(mem:DI (plus:DI (unspec:DI [(match_operand:DI 2 "register_operand" "r")
 				     (match_operand 3 "tld_symbolic_operand" "")]
 				    UNSPEC_TLSLDO)
 			 (match_operand:DI 1 "register_operand" "r"))))]
@@ -8489,68 +8310,38 @@
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")])
 
-(define_insn "*tldo_stb_sp32"
-  [(set (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:SI 1 "register_operand" "r")))
+(define_insn "*tldo_stb<P:mode>"
+  [(set (mem:QI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				   (match_operand 3 "tld_symbolic_operand" "")]
+				  UNSPEC_TLSLDO)
+			(match_operand:P 1 "register_operand" "r")))
 	(match_operand:QI 0 "register_operand" "r"))]
-  "TARGET_TLS && TARGET_ARCH32"
+  "TARGET_TLS"
   "stb\t%0, [%1 + %2], %%tldo_add(%3)"
   [(set_attr "type" "store")])
 
-(define_insn "*tldo_stb_sp64"
-  [(set (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:DI 1 "register_operand" "r")))
-	(match_operand:QI 0 "register_operand" "r"))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "stb\t%0, [%1 + %2], %%tldo_add(%3)"
-  [(set_attr "type" "store")])
-
-(define_insn "*tldo_sth_sp32"
-  [(set (mem:HI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:SI 1 "register_operand" "r")))
+(define_insn "*tldo_sth<P:mode>"
+  [(set (mem:HI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				   (match_operand 3 "tld_symbolic_operand" "")]
+				   UNSPEC_TLSLDO)
+			(match_operand:P 1 "register_operand" "r")))
 	(match_operand:HI 0 "register_operand" "r"))]
-  "TARGET_TLS && TARGET_ARCH32"
+  "TARGET_TLS"
   "sth\t%0, [%1 + %2], %%tldo_add(%3)"
   [(set_attr "type" "store")])
 
-(define_insn "*tldo_sth_sp64"
-  [(set (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:DI 1 "register_operand" "r")))
-	(match_operand:HI 0 "register_operand" "r"))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "sth\t%0, [%1 + %2], %%tldo_add(%3)"
-  [(set_attr "type" "store")])
-
-(define_insn "*tldo_stw_sp32"
-  [(set (mem:SI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:SI 1 "register_operand" "r")))
+(define_insn "*tldo_stw<P:mode>"
+  [(set (mem:SI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				   (match_operand 3 "tld_symbolic_operand" "")]
+				  UNSPEC_TLSLDO)
+			(match_operand:P 1 "register_operand" "r")))
 	(match_operand:SI 0 "register_operand" "r"))]
-  "TARGET_TLS && TARGET_ARCH32"
+  "TARGET_TLS"
   "st\t%0, [%1 + %2], %%tldo_add(%3)"
   [(set_attr "type" "store")])
 
-(define_insn "*tldo_stw_sp64"
-  [(set (mem:SI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:DI 1 "register_operand" "r")))
-	(match_operand:SI 0 "register_operand" "r"))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "stw\t%0, [%1 + %2], %%tldo_add(%3)"
-  [(set_attr "type" "store")])
-
 (define_insn "*tldo_stx_sp64"
-  [(set (mem:DI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+  [(set (mem:DI (plus:DI (unspec:DI [(match_operand:DI 2 "register_operand" "r")
 				     (match_operand 3 "tld_symbolic_operand" "")]
 				    UNSPEC_TLSLDO)
 			 (match_operand:DI 1 "register_operand" "r")))
Index: gcc/config/sparc/sparc.c
===================================================================
--- a/src/gcc/config/sparc/sparc.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/sparc/sparc.c	(.../branches/gcc-7-branch)
@@ -4531,30 +4531,38 @@
   gcc_assert (can_create_pseudo_p ());
 
   if (GET_CODE (addr) == SYMBOL_REF)
+    /* Although the various sethi/or sequences generate SImode values, many of
+       them can be transformed by the linker when relaxing and, if relaxing to
+       local-exec, will become a sethi/xor pair, which is signed and therefore
+       a full DImode value in 64-bit mode.  Thus we must use Pmode, lest these
+       values be spilled onto the stack in 64-bit mode.  */
     switch (SYMBOL_REF_TLS_MODEL (addr))
       {
       case TLS_MODEL_GLOBAL_DYNAMIC:
 	start_sequence ();
-	temp1 = gen_reg_rtx (SImode);
-	temp2 = gen_reg_rtx (SImode);
+	temp1 = gen_reg_rtx (Pmode);
+	temp2 = gen_reg_rtx (Pmode);
 	ret = gen_reg_rtx (Pmode);
 	o0 = gen_rtx_REG (Pmode, 8);
 	got = sparc_tls_got ();
-	emit_insn (gen_tgd_hi22 (temp1, addr));
-	emit_insn (gen_tgd_lo10 (temp2, temp1, addr));
 	if (TARGET_ARCH32)
 	  {
-	    emit_insn (gen_tgd_add32 (o0, got, temp2, addr));
-	    insn = emit_call_insn (gen_tgd_call32 (o0, sparc_tls_get_addr (),
+	    emit_insn (gen_tgd_hi22si (temp1, addr));
+	    emit_insn (gen_tgd_lo10si (temp2, temp1, addr));
+	    emit_insn (gen_tgd_addsi (o0, got, temp2, addr));
+	    insn = emit_call_insn (gen_tgd_callsi (o0, sparc_tls_get_addr (),
 						   addr, const1_rtx));
 	  }
 	else
 	  {
-	    emit_insn (gen_tgd_add64 (o0, got, temp2, addr));
-	    insn = emit_call_insn (gen_tgd_call64 (o0, sparc_tls_get_addr (),
+	    emit_insn (gen_tgd_hi22di (temp1, addr));
+	    emit_insn (gen_tgd_lo10di (temp2, temp1, addr));
+	    emit_insn (gen_tgd_adddi (o0, got, temp2, addr));
+	    insn = emit_call_insn (gen_tgd_calldi (o0, sparc_tls_get_addr (),
 						   addr, const1_rtx));
 	  }
 	use_reg (&CALL_INSN_FUNCTION_USAGE (insn), o0);
+	RTL_CONST_CALL_P (insn) = 1;
 	insn = get_insns ();
 	end_sequence ();
 	emit_libcall_block (insn, ret, o0, addr);
@@ -4562,61 +4570,78 @@
 
       case TLS_MODEL_LOCAL_DYNAMIC:
 	start_sequence ();
-	temp1 = gen_reg_rtx (SImode);
-	temp2 = gen_reg_rtx (SImode);
+	temp1 = gen_reg_rtx (Pmode);
+	temp2 = gen_reg_rtx (Pmode);
 	temp3 = gen_reg_rtx (Pmode);
 	ret = gen_reg_rtx (Pmode);
 	o0 = gen_rtx_REG (Pmode, 8);
 	got = sparc_tls_got ();
-	emit_insn (gen_tldm_hi22 (temp1));
-	emit_insn (gen_tldm_lo10 (temp2, temp1));
 	if (TARGET_ARCH32)
 	  {
-	    emit_insn (gen_tldm_add32 (o0, got, temp2));
-	    insn = emit_call_insn (gen_tldm_call32 (o0, sparc_tls_get_addr (),
+	    emit_insn (gen_tldm_hi22si (temp1));
+	    emit_insn (gen_tldm_lo10si (temp2, temp1));
+	    emit_insn (gen_tldm_addsi (o0, got, temp2));
+	    insn = emit_call_insn (gen_tldm_callsi (o0, sparc_tls_get_addr (),
 						    const1_rtx));
 	  }
 	else
 	  {
-	    emit_insn (gen_tldm_add64 (o0, got, temp2));
-	    insn = emit_call_insn (gen_tldm_call64 (o0, sparc_tls_get_addr (),
+	    emit_insn (gen_tldm_hi22di (temp1));
+	    emit_insn (gen_tldm_lo10di (temp2, temp1));
+	    emit_insn (gen_tldm_adddi (o0, got, temp2));
+	    insn = emit_call_insn (gen_tldm_calldi (o0, sparc_tls_get_addr (),
 						    const1_rtx));
 	  }
 	use_reg (&CALL_INSN_FUNCTION_USAGE (insn), o0);
+	RTL_CONST_CALL_P (insn) = 1;
 	insn = get_insns ();
 	end_sequence ();
+	/* Attach a unique REG_EQUAL, to allow the RTL optimizers to
+	  share the LD_BASE result with other LD model accesses.  */
 	emit_libcall_block (insn, temp3, o0,
 			    gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),
 					    UNSPEC_TLSLD_BASE));
-	temp1 = gen_reg_rtx (SImode);
-	temp2 = gen_reg_rtx (SImode);
-	emit_insn (gen_tldo_hix22 (temp1, addr));
-	emit_insn (gen_tldo_lox10 (temp2, temp1, addr));
+	temp1 = gen_reg_rtx (Pmode);
+	temp2 = gen_reg_rtx (Pmode);
 	if (TARGET_ARCH32)
-	  emit_insn (gen_tldo_add32 (ret, temp3, temp2, addr));
+	  {
+	    emit_insn (gen_tldo_hix22si (temp1, addr));
+	    emit_insn (gen_tldo_lox10si (temp2, temp1, addr));
+	    emit_insn (gen_tldo_addsi (ret, temp3, temp2, addr));
+	  }
 	else
-	  emit_insn (gen_tldo_add64 (ret, temp3, temp2, addr));
+	  {
+	    emit_insn (gen_tldo_hix22di (temp1, addr));
+	    emit_insn (gen_tldo_lox10di (temp2, temp1, addr));
+	    emit_insn (gen_tldo_adddi (ret, temp3, temp2, addr));
+	  }
 	break;
 
       case TLS_MODEL_INITIAL_EXEC:
-	temp1 = gen_reg_rtx (SImode);
-	temp2 = gen_reg_rtx (SImode);
+	temp1 = gen_reg_rtx (Pmode);
+	temp2 = gen_reg_rtx (Pmode);
 	temp3 = gen_reg_rtx (Pmode);
 	got = sparc_tls_got ();
-	emit_insn (gen_tie_hi22 (temp1, addr));
-	emit_insn (gen_tie_lo10 (temp2, temp1, addr));
 	if (TARGET_ARCH32)
-	  emit_insn (gen_tie_ld32 (temp3, got, temp2, addr));
+	  {
+	    emit_insn (gen_tie_hi22si (temp1, addr));
+	    emit_insn (gen_tie_lo10si (temp2, temp1, addr));
+	    emit_insn (gen_tie_ld32 (temp3, got, temp2, addr));
+	  }
 	else
-	  emit_insn (gen_tie_ld64 (temp3, got, temp2, addr));
+	  {
+	    emit_insn (gen_tie_hi22di (temp1, addr));
+	    emit_insn (gen_tie_lo10di (temp2, temp1, addr));
+	    emit_insn (gen_tie_ld64 (temp3, got, temp2, addr));
+	  }
         if (TARGET_SUN_TLS)
 	  {
 	    ret = gen_reg_rtx (Pmode);
 	    if (TARGET_ARCH32)
-	      emit_insn (gen_tie_add32 (ret, gen_rtx_REG (Pmode, 7),
+	      emit_insn (gen_tie_addsi (ret, gen_rtx_REG (Pmode, 7),
 					temp3, addr));
 	    else
-	      emit_insn (gen_tie_add64 (ret, gen_rtx_REG (Pmode, 7),
+	      emit_insn (gen_tie_adddi (ret, gen_rtx_REG (Pmode, 7),
 					temp3, addr));
 	  }
 	else
@@ -4628,13 +4653,13 @@
 	temp2 = gen_reg_rtx (Pmode);
 	if (TARGET_ARCH32)
 	  {
-	    emit_insn (gen_tle_hix22_sp32 (temp1, addr));
-	    emit_insn (gen_tle_lox10_sp32 (temp2, temp1, addr));
+	    emit_insn (gen_tle_hix22si (temp1, addr));
+	    emit_insn (gen_tle_lox10si (temp2, temp1, addr));
 	  }
 	else
 	  {
-	    emit_insn (gen_tle_hix22_sp64 (temp1, addr));
-	    emit_insn (gen_tle_lox10_sp64 (temp2, temp1, addr));
+	    emit_insn (gen_tle_hix22di (temp1, addr));
+	    emit_insn (gen_tle_lox10di (temp2, temp1, addr));
 	  }
 	ret = gen_rtx_PLUS (Pmode, gen_rtx_REG (Pmode, 7), temp2);
 	break;
Index: gcc/config/darwin-c.c
===================================================================
--- a/src/gcc/config/darwin-c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/darwin-c.c	(.../branches/gcc-7-branch)
@@ -463,41 +463,32 @@
 /* Register the GNU objective-C runtime include path if STDINC.  */
 
 void
-darwin_register_objc_includes (const char *sysroot, const char *iprefix,
-			       int stdinc)
+darwin_register_objc_includes (const char *sysroot ATTRIBUTE_UNUSED,
+			       const char *iprefix, int stdinc)
 {
-  const char *fname;
-  size_t len;
-  /* We do not do anything if we do not want the standard includes. */
-  if (!stdinc)
-    return;
+  /* If we want standard includes;  Register the GNU OBJC runtime include
+     path if we are compiling OBJC with GNU-runtime.
+     This path is compiler-relative, we don't want to prepend the sysroot
+     since it's not expected to find the headers there.  */
 
-  fname = GCC_INCLUDE_DIR "-gnu-runtime";
-
-  /* Register the GNU OBJC runtime include path if we are compiling  OBJC
-    with GNU-runtime.  */
-
-  if (c_dialect_objc () && !flag_next_runtime)
+  if (stdinc && c_dialect_objc () && !flag_next_runtime)
     {
+      const char *fname = GCC_INCLUDE_DIR "-gnu-runtime";
       char *str;
-      /* See if our directory starts with the standard prefix.
+      size_t len;
+
+     /* See if our directory starts with the standard prefix.
 	 "Translate" them, i.e. replace /usr/local/lib/gcc... with
 	 IPREFIX and search them first.  */
-      if (iprefix && (len = cpp_GCC_INCLUDE_DIR_len) != 0 && !sysroot
+      if (iprefix && (len = cpp_GCC_INCLUDE_DIR_len) != 0
 	  && !strncmp (fname, cpp_GCC_INCLUDE_DIR, len))
 	{
 	  str = concat (iprefix, fname + len, NULL);
-          /* FIXME: wrap the headers for C++awareness.  */
-	  add_path (str, SYSTEM, /*c++aware=*/false, false);
+	  add_path (str, SYSTEM, /*c++aware=*/true, false);
 	}
 
-      /* Should this directory start with the sysroot?  */
-      if (sysroot)
-	str = concat (sysroot, fname, NULL);
-      else
-	str = update_path (fname, "");
-
-      add_path (str, SYSTEM, /*c++aware=*/false, false);
+      str = update_path (fname, "");
+      add_path (str, SYSTEM, /*c++aware=*/true, false);
     }
 }
 
Index: gcc/config/darwin.opt
===================================================================
--- a/src/gcc/config/darwin.opt	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/darwin.opt	(.../branches/gcc-7-branch)
@@ -18,241 +18,383 @@
 ; along with GCC; see the file COPYING3.  If not see
 ; <http://www.gnu.org/licenses/>.
 
-; Various linker options have a -Z added so that they can get to specs
-; processing without interference.  Note that an option name with a
-; prefix that matches another option name, that also takes an
-; argument, being mapped to a -Z linker option, needs to be modified
-; so the prefix is different, otherwise a '*' after the shorter option
-; will match with the longer one.
+; We have a lot of Driver options, many of which are obsolete or very very
+; rarely used so, to keep this file easier to manage:
 
+; Please place all Non-driver options first (in alphabetical order), followed
+; by Driver-only options.
+
+; Non-driver options.
+
+dependency-file
+C ObjC C++ ObjC++ Separate Alias(MF) MissingArgError(missing filename after %qs)
+
+fapple-kext
+Target Report C++ Var(flag_apple_kext)
+Generate code for darwin loadable kernel extensions.
+
+iframework
+Target RejectNegative C ObjC C++ ObjC++ Joined Separate
+-iframework <dir>	Add <dir> to the end of the system framework include path.
+
+mconstant-cfstrings
+Target Report Var(darwin_constant_cfstrings) Init(1)
+Generate compile-time CFString objects.
+
+Wnonportable-cfstrings
+Target Report Var(darwin_warn_nonportable_cfstrings) Init(1) Warning
+Warn if constant CFString objects contain non-portable characters.
+
+; Use new-style pic stubs if this is true, x86 only so far.
+matt-stubs
+Target Report Var(darwin_macho_att_stub) Init(1)
+Generate AT&T-style stubs for Mach-O.
+
+mdynamic-no-pic
+Target Common Report Mask(MACHO_DYNAMIC_NO_PIC)
+Generate code suitable for executables (NOT shared libs).
+
+mfix-and-continue
+Target Report Var(darwin_fix_and_continue)
+Generate code suitable for fast turn around debugging.
+
+mkernel
+Target Report Var(flag_mkernel)
+Generate code for the kernel or loadable kernel extensions.
+
+; The Init here is for the convenience of GCC developers, so that cc1
+; and cc1plus don't crash if no -mmacosx-version-min is passed.  The
+; driver will always pass a -mmacosx-version-min, so in normal use the
+; Init is never used.
+mmacosx-version-min=
+Target RejectNegative Joined Report Var(darwin_macosx_version_min) Init(DEF_MIN_OSX_VERSION)
+The earliest MacOS X version on which this program will run.
+
+; Really, only relevant to PowerPC which has a 4 byte bool by default.
+mone-byte-bool
+Target RejectNegative Report Var(darwin_one_byte_bool)
+Set sizeof(bool) to 1.
+
+msymbol-stubs
+Target Report Var(darwin_symbol_stubs) Init(0)
+Force generation of external symbol indirection stubs.
+
+; Some code-gen may be improved / adjusted if the linker is sufficiently modern.
+mtarget-linker=
+Target RejectNegative Joined Report Alias(mtarget-linker)
+
+mtarget-linker
+Target RejectNegative Joined Separate Report Var(darwin_target_linker) Init(LD64_VERSION)
+The version of ld64 in use for this toolchain.
+
+; Driver options.
+
 all_load
-Driver Alias(Zall_load)
+Driver RejectNegative Alias(Zall_load)
+Loads all members of archive libraries
 
 allowable_client
-Driver Separate Alias(Zallowable_client)
+Driver RejectNegative Separate Alias(Zallowable_client)
+-allowable_client <name>	The output dylib is private to the client(s) named
 
 arch
 Driver RejectNegative Separate
+-arch <name>	Specify that the output file should be generated for architecture  \"name\"
 
 arch_errors_fatal
-Driver Alias(Zarch_errors_fatal)
+Driver RejectNegative Alias(Zarch_errors_fatal)
+Mismatches between file architecture and the \"-arch\" are errors instead of warnings
 
 asm_macosx_version_min=
 Driver RejectNegative Joined
+The earliest MacOS X version on which this program will run (formatted for the assembler)
 
 bind_at_load
-Driver Alias(Zbind_at_load)
+Driver RejectNegative Alias(Zbind_at_load)
+Produce an output file that will bind symbols on load, rather than lazily.
 
 bundle
-Driver Alias(Zbundle)
+Driver RejectNegative Alias(Zbundle)
+Produce a Mach-O bundle (file type MH_BUNDLE)
 
 bundle_loader
-Driver Separate Alias(Zbundle_loader)
+Driver RejectNegative Separate Alias(Zbundle_loader)
+-bundle_loader <executable>	Treat \"executable\" (that will be loading this bundle) as if it was one of the dynamic libraries the bundle is linked against for symbol resolution
 
+client_name
+Driver RejectNegative Separate
+-client_name <name>	Enable the executable being built to link against a private dylib (using allowable_client)
+
+compatibility_version
+Driver RejectNegative Separate
+-compatibility_version <number>	Set the minimum version for the client interface.  Clients must record a greater number than this or the binding will fail at runtime
+
+current_version
+Driver RejectNegative Separate
+-current_version <number>	Set the current version for the library.
+
 dead_strip
-Driver Alias(Zdead_strip)
+Driver RejectNegative Alias(Zdead_strip)
+Remove code and data that is unreachable from any exported symbol (including the entry point)
 
-dependency-file
-C ObjC C++ ObjC++ Separate Alias(MF) MissingArgError(missing filename after %qs)
-
 dylib_file
 Driver Separate Alias(Zdylib_file)
 
 dylinker
-Driver
+Driver RejectNegative
+Produce a Mach-O dylinker (file type MH_DYLINKER), only used for building dyld.
 
+dylinker_install_name
+Driver RejectNegative Separate
+-dylinker_install_name <path>	Only used for building dyld.
+
 dynamic
-Driver Alias(Zdynamic)
+Driver RejectNegative Alias(Zdynamic)
+The default (and opposite of -static), implied by user mode executables, shared libraries and bundles.
 
 dynamiclib
-Driver Alias(Zdynamiclib)
+Driver RejectNegative Alias(Zdynamiclib)
+Produce a Mach-O shared library (file type MH_DYLIB), synonym for -shared
 
 exported_symbols_list
-Driver Separate Alias(Zexported_symbols_list)
+Driver RejectNegative Separate Alias(Zexported_symbols_list)
+-exported_symbols_list <filename>	Global symbols in \"filename\" will be exported from the linked output file, any symbols not mentioned will be treated as hidden.
 
 filelist
 Driver RejectNegative Separate
+Supply a list of objects to be linked from a file, rather than the command line
 
 findirect-virtual-calls
 Driver RejectNegative
+Used for generating code for some older kernel revisions.
 
 flat_namespace
 Driver RejectNegative Alias(Zflat_namespace)
+Ignore the normal two-level namespace; resolve symbols in command line order and do not record which library provided the resolved symbol.
 
 force_cpusubtype_ALL
 Driver RejectNegative Alias(Zforce_cpusubtype_ALL)
+For the assembler (and linker) permit any architecture sub-variant to be used without error.
 
 force_flat_namespace
 Driver RejectNegative Alias(Zforce_flat_namespace)
+Set the output object such that, on loading, dyld  will ignore any two-level information and resolve symbols in the discovery order for loaded libs.
 
 framework
 Driver RejectNegative Separate
+-framework <name>	The linker should search for the named framework in the framework search path.
 
 fterminated-vtables
 Driver RejectNegative
+Used for generating code for some older kernel revisions.
 
 gfull
 Driver
+Abbreviation for \"-g -fno-eliminate-unused-debug-symbols\"
 
 gused
-Driver
+Driver RejectNegative
+Abbreviation for \"-g -feliminate-unused-debug-symbols\"
 
 headerpad_max_install_names
-Driver
+Driver RejectNegative
+Automatically adds space for longer path names in load commands (up to MAXPATHLEN)
 
 image_base
-Driver Separate Alias(Zimage_base)
+Driver RejectNegative Separate Alias(Zimage_base)
+-image_base <address>	Choose a base address for a dylib or bundle.
 
 init
-Driver Separate Alias(Zinit)
+Driver RejectNegative Separate Alias(Zinit)
+-init <symbol_name>	The symbol \"symbol_name\" will be used as the first initialiser for a dylib.
 
 install_name
-Driver Separate Alias(Zinstall_name)
+Driver RejectNegative Separate Alias(Zinstall_name)
+-install_name <name>	Set the install name for a dylib.
 
 keep_private_externs
-Driver
+Driver RejectNegative
+Usually \"private extern\" (hidden) symbols are made local when linking, this command suppresses that such that they remain exported.
 
-mconstant-cfstrings
-Target Report Var(darwin_constant_cfstrings) Init(1)
-Generate compile-time CFString objects.
-
 multi_module
 Driver RejectNegative Alias(Zmulti_module)
+(Obsolete after 10.4) Multi modules are ignored at runtime since MacOS 10.4
 
 multiply_defined
 Driver RejectNegative Separate Alias(Zmultiply_defined)
+(Obsolete after 10.4) -multiply_defined <treatment> Provided a mechanism for warning about symbols defined in multiple dylibs.
 
 multiply_defined_unused
 Driver RejectNegative Separate Alias(Zmultiplydefinedunused)
+(Obsolete after 10.4) -multiply_defined_unused <treatment>	Provided a mechanism for warning about symbols defined in the current executable also being defined in linked dylibs.
 
 no_dead_strip_inits_and_terms
-Driver Alias(Zno_dead_strip_inits_and_terms)
+Driver RejectNegative Alias(Zno_dead_strip_inits_and_terms)
+(Obsolete) The linker never dead strips these items, so the option is not needed.
 
 nofixprebinding
-Driver
+Driver RejectNegative
+(Obsolete after 10.3.9) Set MH_NOPREFIXBINDING, in an exectuable.
 
 nomultidefs
-Driver
+Driver RejectNegative
+(Obsolete after 10.4)	Set MH_NOMULTIDEFS in an umbrella framework.
 
 noprebind
-Driver
+Driver RejectNegative Negative(prebind)
+(Obsolete) LD_PREBIND is no longer supported.
 
 noseglinkedit
-Driver
+Driver RejectNegative Negative(seglinkedit)
+(Obsolete) This is the default.
 
 object
-Driver
+Driver RejectNegative
 
+pagezero_size
+Driver RejectNegative Separate
+-pagezero_size size	Allows setting the page 0 size to 4kb for certain special cases.
+
 prebind
-Driver
+Driver RejectNegative Negative(noprebind)
+(Obsolete) LD_PREBIND is no longer supported.
 
 prebind_all_twolevel_modules
-Driver
+Driver RejectNegative
+(Obsolete) LD_PREBIND is no longer supported.
 
 preload
-Driver
+Driver RejectNegative
+Produces a Mach-O file suitable for embedded/ROM use.
 
 private_bundle
-Driver
+Driver RejectNegative
+(Obsolete) Allowed linking to proceed with \"-flat_namespace\" when a linked bundle contained a symbol also exported from the main executable.
 
 pthread
-Driver
+Driver RejectNegative
 
 rdynamic
-Driver
+Driver RejectNegative
+Synonym for \"-export-dynamic\" for linker versions that support it.
 
+read_only_relocs
+Driver RejectNegative Separate
+-read_only_relocs <treatment>	This will allow relocs in read-only pages (not advisable).
+
+sectalign
+Driver RejectNegative Separate Args(3)
+-sectalign <segname> <sectname> <value>	Set section \"sectname\" in segment \"segname\" to have alignment \"value\" which must be an integral power of two expressed in hexadecimal form.
+
+sectcreate
+Driver RejectNegative Separate Args(3)
+-sectcreate <segname> <sectname> <file>	Create section \"sectname\" in segment \"segname\" from the contents of \"file\".
+
+sectobjectsymbols
+Driver RejectNegative Separate Args(2)
+(Obsolete) -sectobjectsymbols <segname> <sectname>	Setting a local symbol at the start of a section is no longer supported.
+
+sectorder
+Driver RejectNegative Separate Args(3)
+(Obsolete) -sectorder <segname> <sectname> orderfile	Replaced by a more general option \"-order_file\".
+
 seg_addr_table
-Driver Separate Alias(Zseg_addr_table)
+Driver RejectNegative Separate Alias(Zseg_addr_table)
+-seg_addr_table <file>	Specify the base addresses for dynamic libraries, \"file\" contains a line for each library.
 
+; This is only usable by the ld_classic linker.
 seg_addr_table_filename
-Driver Separate Alias(Zfn_seg_addr_table_filename)
+Driver RejectNegative Separate Alias(Zfn_seg_addr_table_filename)
+(Obsolete, ld_classic only) -seg_addr_table_filename <path>
 
+seg1addr
+Driver RejectNegative Separate
+Synonym for \"image_base\"
+
 segaddr
-Driver Separate Args(2) Alias(Zsegaddr)
+Driver RejectNegative Separate Args(2) Alias(Zsegaddr)
+-segaddr <name> <address>	Set the base address of segment \"name\" to \"address\" which must be aligned to a page boundary (currently 4kb).
 
+; This is only usable by the ld_classic linker.
+segcreate
+Driver RejectNegative Separate Args(3)
+(Obsolete, ld_classic only) -sectcreate segname sectname file
+
 seglinkedit
-Driver
+Driver RejectNegative Negative(noseglinkedit)
+(Obsolete) Object files with LINKEDIT sections are no longer supported.
 
+segprot
+Driver RejectNegative Separate Args(3)
+-segprot <segname> max_prot init_prot	The protection values are \"r\", \"w\", \"x\" or \"-\" the latter meaning \"no access\".
+
 segs_read_only_addr
-Driver Separate Alias(Zsegs_read_only_addr)
+Driver RejectNegative Separate Alias(Zsegs_read_only_addr)
+-segs_read_only_addr address 	Allows specifying the address of the read only portion of a dylib.
 
 segs_read_write_addr
-Driver Separate Alias(Zsegs_read_write_addr)
+Driver RejectNegative Separate Alias(Zsegs_read_write_addr)
+-segs_read_write_addr address 	Allows specifying the address of the read/write portion of a dylib.
 
 single_module
-Driver Alias(Zsingle_module)
+Driver RejectNegative Alias(Zsingle_module)
+(Obsolete)	This is the default.
 
+sub_library
+Driver RejectNegative Separate
+-sub_library <name>	Library named \"name\" will be re-exported (only useful for dylibs).
+
+sub_umbrella
+Driver RejectNegative Separate
+-sub_umbrella <name>	Framework named \"name\" will be re-exported (only useful for dylibs).
+
 twolevel_namespace
-Driver
+Driver RejectNegative
+This is the default
 
 twolevel_namespace_hints
-Driver
+Driver RejectNegative
+Specifies content that can speed up dynamic loading when the binaries are unchanged.
 
 umbrella
-Driver Separate Alias(Zumbrella)
+Driver RejectNegative Separate Alias(Zumbrella)
+-umbrella <framework>	The specified framework will be re-exported.
 
+undefined
+Driver RejectNegative Separate
+-undefined <treatment>	Specify the handling for undefined symbols (default is error).
+
 unexported_symbols_list
-Driver Separate Alias(Zunexported_symbols_list)
+Driver RejectNegative Separate Alias(Zunexported_symbols_list)
+-unexported_symbols_list <filename>	Don't export global symbols listed in filename.
 
 weak_reference_mismatches
-Driver Separate Alias(Zweak_reference_mismatches)
+Driver RejectNegative Separate Alias(Zweak_reference_mismatches)
+-weak_reference_mismatches <treatment>	Specifies what to do if a symbol import conflicts between file (weak in one and not in another) the default is to treat the symbol as non-weak.
 
 whatsloaded
-Driver
+Driver RejectNegative
+Logs the object files the linker loads
 
 whyload
-Driver
+Driver RejectNegative
+Logs which symbol(s) caused an object to be loaded.
 
+;(Obsolete, ignored)	Strip symbols starting with "L", this is the default.
+X
+Driver RejectNegative
+
 y
-Driver Joined
+Driver RejectNegative Joined
+(Obsolete, ignored)	Old support similar to whyload.
 
 Mach
-Driver
+Driver RejectNegative
+(Obsolete and unhandled by ld64, ignored)	ld should produce an executable (only handled by ld_classic).
 
-Wnonportable-cfstrings
-Target Report Var(darwin_warn_nonportable_cfstrings) Init(1) Warning
-Warn if constant CFString objects contain non-portable characters.
+;; These are not "real" options, but placeholders used to hide the real options
+;; from generic options processing... FIXME: they can be eliminated now.
 
-; Use new-style pic stubs if this is true, x86 only so far.
-matt-stubs
-Target Report Var(darwin_macho_att_stub) Init(1)
-Generate AT&T-style stubs for Mach-O.
-
-mdynamic-no-pic
-Target Common Report Mask(MACHO_DYNAMIC_NO_PIC)
-Generate code suitable for executables (NOT shared libs).
-
-mfix-and-continue
-Target Report Var(darwin_fix_and_continue)
-Generate code suitable for fast turn around debugging.
-
-; The Init here is for the convenience of GCC developers, so that cc1
-; and cc1plus don't crash if no -mmacosx-version-min is passed.  The
-; driver will always pass a -mmacosx-version-min, so in normal use the
-; Init is never used.
-mmacosx-version-min=
-Target Joined Report Var(darwin_macosx_version_min) Init(DEF_MIN_OSX_VERSION)
-The earliest MacOS X version on which this program will run.
-
-mone-byte-bool
-Target RejectNegative Report Var(darwin_one_byte_bool)
-Set sizeof(bool) to 1.
-
-fapple-kext
-Target Report C++ Var(flag_apple_kext)
-Generate code for darwin loadable kernel extensions.
-
-mkernel
-Target Report Var(flag_mkernel)
-Generate code for the kernel or loadable kernel extensions.
-
-iframework
-Target RejectNegative C ObjC C++ ObjC++ Joined Separate 
--iframework <dir>	Add <dir> to the end of the system framework include path.
-
-X
-Driver
-
 Zall_load
 Driver
 
@@ -343,62 +485,3 @@
 Zweak_reference_mismatches
 Driver Separate
 
-client_name
-Driver Separate
-
-compatibility_version
-Driver Separate
-
-current_version
-Driver Separate
-
-dylinker_install_name
-Driver Separate
-
-pagezero_size
-Driver Separate
-
-read_only_relocs
-Driver Separate
-
-sectalign
-Driver Separate Args(3)
-
-sectcreate
-Driver Separate Args(3)
-
-sectobjectsymbols
-Driver Separate Args(2)
-
-sectorder
-Driver Separate Args(3)
-
-seg1addr
-Driver Separate
-
-segcreate
-Driver Separate Args(3)
-
-segprot
-Driver Separate Args(3)
-
-segs_read_only_addr
-Driver Separate
-
-segs_read_write_addr
-Driver Separate
-
-sub_library
-Driver Separate
-
-sub_umbrella
-Driver Separate
-
-; Certain aspects of code-gen may be improved / adjusted if the version of ld64
-; is sufficiently modern.
-mtarget-linker
-Target RejectNegative Joined Separate Report Var(darwin_target_linker) Init(LD64_VERSION)
-The version of ld64 in use for this toolchain.
-
-undefined
-Driver Separate
Index: gcc/config/i386/t-darwin
===================================================================
--- a/src/gcc/config/i386/t-darwin	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/i386/t-darwin	(.../branches/gcc-7-branch)
@@ -1,2 +0,0 @@
-MULTILIB_OPTIONS = m64
-MULTILIB_DIRNAMES = x86_64
Index: gcc/config/i386/darwin64.h
===================================================================
--- a/src/gcc/config/i386/darwin64.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/i386/darwin64.h	(.../branches/gcc-7-branch)
@@ -1,32 +0,0 @@
-/* Target definitions for x86_64 running Darwin.
-   Copyright (C) 2006-2017 Free Software Foundation, Inc.
-   Contributed by Apple Computer Inc.
-
-This file is part of GCC.
-
-GCC is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 3, or (at your option)
-any later version.
-
-GCC is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with GCC; see the file COPYING3.  If not see
-<http://www.gnu.org/licenses/>.  */
-
-#undef  DARWIN_ARCH_SPEC
-#define DARWIN_ARCH_SPEC "%{m32:i386;:x86_64}"
-
-#undef  DARWIN_SUBARCH_SPEC
-#define DARWIN_SUBARCH_SPEC DARWIN_ARCH_SPEC
-
-#undef SUBTARGET_EXTRA_SPECS
-#define SUBTARGET_EXTRA_SPECS                                   \
-  DARWIN_EXTRA_SPECS                                            \
-  { "darwin_arch", DARWIN_ARCH_SPEC },                          \
-  { "darwin_crt2", "" },                                        \
-  { "darwin_subarch", DARWIN_SUBARCH_SPEC },
Index: gcc/config/i386/t-darwin64
===================================================================
--- a/src/gcc/config/i386/t-darwin64	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/i386/t-darwin64	(.../branches/gcc-7-branch)
@@ -1,2 +0,0 @@
-MULTILIB_OPTIONS = m32
-MULTILIB_DIRNAMES = i386
Index: gcc/config/i386/i386.h
===================================================================
--- a/src/gcc/config/i386/i386.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/i386/i386.h	(.../branches/gcc-7-branch)
@@ -590,7 +590,7 @@
 /* Replace MACH-O, ifdefs by in-line tests, where possible. 
    (a) Macros defined in config/i386/darwin.h  */
 #define TARGET_MACHO 0
-#define TARGET_MACHO_BRANCH_ISLANDS 0
+#define TARGET_MACHO_SYMBOL_STUBS 0
 #define MACHOPIC_ATT_STUB 0
 /* (b) Macros defined in config/darwin.h  */
 #define MACHO_DYNAMIC_NO_PIC_P 0
Index: gcc/config/i386/t-darwin64-biarch
===================================================================
--- a/src/gcc/config/i386/t-darwin64-biarch	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/i386/t-darwin64-biarch	(.../branches/gcc-7-branch)
@@ -0,0 +1,2 @@
+MULTILIB_OPTIONS = m32
+MULTILIB_DIRNAMES = i386
Index: gcc/config/i386/i386.md
===================================================================
--- a/src/gcc/config/i386/i386.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/i386/i386.md	(.../branches/gcc-7-branch)
@@ -8268,7 +8268,24 @@
   [(parallel [(set (match_dup 0)
 		   (zero_extend:DI (and:SI (match_dup 1) (match_dup 2))))
 	      (clobber (reg:CC FLAGS_REG))])]
-  "operands[2] = gen_lowpart (SImode, operands[2]);")
+{
+  if (GET_CODE (operands[2]) == SYMBOL_REF
+      || GET_CODE (operands[2]) == LABEL_REF)
+    {
+      operands[2] = shallow_copy_rtx (operands[2]);
+      PUT_MODE (operands[2], SImode);
+    }
+  else if (GET_CODE (operands[2]) == CONST)
+    {
+      /* (const:DI (plus:DI (symbol_ref:DI ("...")) (const_int N))) */
+      operands[2] = copy_rtx (operands[2]);
+      PUT_MODE (operands[2], SImode);
+      PUT_MODE (XEXP (operands[2], 0), SImode);
+      PUT_MODE (XEXP (XEXP (operands[2], 0), 0), SImode);
+    }    
+  else
+    operands[2] = gen_lowpart (SImode, operands[2]);
+})
 
 ;; See comment for addsi_1_zext why we do use nonimmediate_operand
 (define_insn "*andsi_1_zext"
Index: gcc/config/i386/avx2intrin.h
===================================================================
--- a/src/gcc/config/i386/avx2intrin.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/i386/avx2intrin.h	(.../branches/gcc-7-branch)
@@ -258,7 +258,7 @@
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
 _mm256_cmpgt_epi8 (__m256i __A, __m256i __B)
 {
-  return (__m256i) ((__v32qi)__A > (__v32qi)__B);
+  return (__m256i) ((__v32qs)__A > (__v32qs)__B);
 }
 
 extern __inline __m256i
Index: gcc/config/i386/t-darwin32-biarch
===================================================================
--- a/src/gcc/config/i386/t-darwin32-biarch	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/i386/t-darwin32-biarch	(.../branches/gcc-7-branch)
@@ -0,0 +1,2 @@
+MULTILIB_OPTIONS = m64
+MULTILIB_DIRNAMES = x86_64
Index: gcc/config/i386/cpuid.h
===================================================================
--- a/src/gcc/config/i386/cpuid.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/i386/cpuid.h	(.../branches/gcc-7-branch)
@@ -167,10 +167,27 @@
 #define signature_VORTEX_ecx	0x436f5320
 #define signature_VORTEX_edx	0x36387865
 
+#ifndef __x86_64__
+/* At least one cpu (Winchip 2) does not set %ebx and %ecx
+   for cpuid leaf 1. Forcibly zero the two registers before
+   calling cpuid as a precaution.  */
 #define __cpuid(level, a, b, c, d)			\
+  do {							\
+    if (__builtin_constant_p (level) && (level) != 1)	\
+      __asm__ ("cpuid\n\t"				\
+	      : "=a" (a), "=b" (b), "=c" (c), "=d" (d)	\
+	      : "0" (level));				\
+    else						\
+      __asm__ ("cpuid\n\t"				\
+	      : "=a" (a), "=b" (b), "=c" (c), "=d" (d)	\
+	      : "0" (level), "1" (0), "2" (0));		\
+  } while (0)
+#else
+#define __cpuid(level, a, b, c, d)			\
   __asm__ ("cpuid\n\t"					\
 	   : "=a" (a), "=b" (b), "=c" (c), "=d" (d)	\
 	   : "0" (level))
+#endif
 
 #define __cpuid_count(level, count, a, b, c, d)		\
   __asm__ ("cpuid\n\t"					\
Index: gcc/config/i386/darwin32-biarch.h
===================================================================
--- a/src/gcc/config/i386/darwin32-biarch.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/i386/darwin32-biarch.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,58 @@
+/* Target definitions for i386 running Darwin with a 32b host and supporting
+   a 64b multilib.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#undef DARWIN_ARCH_SPEC
+#define DARWIN_ARCH_SPEC "%{m64:x86_64;:i386}"
+
+/* WORKAROUND pr80556:
+   For x86_64 Darwin10 and later, the unwinder is in libunwind (redirected
+   from libSystem).  This doesn't use the keymgr (see keymgr.c) and therefore
+   the calls that libgcc makes to obtain the KEYMGR_GCC3_DW2_OBJ_LIST are not
+   updated to include new images, and might not even be valid for a single
+   image.
+   Therefore, for 64b exes at least, we must use the libunwind implementation,
+   even when static-libgcc is specified.  We put libSystem first so that
+   unwinder symbols are satisfied from there. */
+#undef REAL_LIBGCC_SPEC
+#define REAL_LIBGCC_SPEC						   \
+   "%{static-libgcc|static: 						   \
+      %{m64:%:version-compare(>= 10.6 mmacosx-version-min= -lSystem)}	   \
+        -lgcc_eh -lgcc;							   \
+      shared-libgcc|fexceptions|fgnu-runtime:				   \
+       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_s.10.4)	   \
+       %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
+       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)	   \
+       %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)	   \
+       -lgcc ;								   \
+      :%:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_s.10.4) \
+       %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
+       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)	   \
+       %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)	   \
+       -lgcc }"
+
+#undef  DARWIN_SUBARCH_SPEC
+#define DARWIN_SUBARCH_SPEC DARWIN_ARCH_SPEC
+
+#undef SUBTARGET_EXTRA_SPECS
+#define SUBTARGET_EXTRA_SPECS                                   \
+  DARWIN_EXTRA_SPECS                                            \
+  { "darwin_arch", DARWIN_ARCH_SPEC },                          \
+  { "darwin_crt2", "" },                                        \
+  { "darwin_subarch", DARWIN_SUBARCH_SPEC },
Index: gcc/config/i386/darwin64-biarch.h
===================================================================
--- a/src/gcc/config/i386/darwin64-biarch.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/i386/darwin64-biarch.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,59 @@
+/* Target definitions for x86_64 running Darwin with a 64b host supporting a
+   32b multilib.
+   Copyright (C) 2006-2019 Free Software Foundation, Inc.
+   Contributed by Apple Computer Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#undef  DARWIN_ARCH_SPEC
+#define DARWIN_ARCH_SPEC "%{m32:i386;:x86_64}"
+
+/* WORKAROUND pr80556:
+   For x86_64 Darwin10 and later, the unwinder is in libunwind (redirected
+   from libSystem).  This doesn't use the keymgr (see keymgr.c) and therefore
+   the calls that libgcc makes to obtain the KEYMGR_GCC3_DW2_OBJ_LIST are not
+   updated to include new images, and might not even be valid for a single
+   image.
+   Therefore, for 64b exes at least, we must use the libunwind implementation,
+   even when static-libgcc is specified.  We put libSystem first so that
+   unwinder symbols are satisfied from there. */
+#undef REAL_LIBGCC_SPEC
+#define REAL_LIBGCC_SPEC						   \
+   "%{static-libgcc|static: 						   \
+      %{!m32:%:version-compare(>= 10.6 mmacosx-version-min= -lSystem)}	   \
+        -lgcc_eh -lgcc;							   \
+      shared-libgcc|fexceptions|fgnu-runtime:				   \
+       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_s.10.4)	   \
+       %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
+       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)	   \
+       %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)	   \
+       -lgcc ;								   \
+      :%:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_s.10.4) \
+       %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
+       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)	   \
+       %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)	   \
+       -lgcc }"
+
+#undef  DARWIN_SUBARCH_SPEC
+#define DARWIN_SUBARCH_SPEC DARWIN_ARCH_SPEC
+
+#undef SUBTARGET_EXTRA_SPECS
+#define SUBTARGET_EXTRA_SPECS                                   \
+  DARWIN_EXTRA_SPECS                                            \
+  { "darwin_arch", DARWIN_ARCH_SPEC },                          \
+  { "darwin_crt2", "" },                                        \
+  { "darwin_subarch", DARWIN_SUBARCH_SPEC },
Index: gcc/config/i386/sse.md
===================================================================
--- a/src/gcc/config/i386/sse.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/i386/sse.md	(.../branches/gcc-7-branch)
@@ -1777,7 +1777,7 @@
   [(set (match_operand:VF1_128_256 0 "register_operand")
 	(unspec:VF1_128_256
 	  [(match_operand:VF1_128_256 1 "vector_operand")] UNSPEC_RSQRT))]
-  "TARGET_SSE_MATH"
+  "TARGET_SSE && TARGET_SSE_MATH"
 {
   ix86_emit_swsqrtsf (operands[0], operands[1], <MODE>mode, true);
   DONE;
@@ -4601,37 +4601,49 @@
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
 (define_insn "sse2_cvtpi2pd"
-  [(set (match_operand:V2DF 0 "register_operand" "=x,x")
-	(float:V2DF (match_operand:V2SI 1 "nonimmediate_operand" "y,m")))]
+  [(set (match_operand:V2DF 0 "register_operand" "=v,x")
+	(float:V2DF (match_operand:V2SI 1 "nonimmediate_operand" "vBm,?!y")))]
   "TARGET_SSE2"
-  "cvtpi2pd\t{%1, %0|%0, %1}"
+  "@
+   %vcvtdq2pd\t{%1, %0|%0, %1}
+   cvtpi2pd\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssecvt")
-   (set_attr "unit" "mmx,*")
-   (set_attr "prefix_data16" "1,*")
+   (set_attr "unit" "*,mmx")
+   (set_attr "prefix_data16" "*,1")
+   (set_attr "prefix" "maybe_vex,*")
    (set_attr "mode" "V2DF")])
 
 (define_insn "sse2_cvtpd2pi"
-  [(set (match_operand:V2SI 0 "register_operand" "=y")
-	(unspec:V2SI [(match_operand:V2DF 1 "nonimmediate_operand" "xm")]
+  [(set (match_operand:V2SI 0 "register_operand" "=v,?!y")
+	(unspec:V2SI [(match_operand:V2DF 1 "nonimmediate_operand" "vBm,xm")]
 		     UNSPEC_FIX_NOTRUNC))]
   "TARGET_SSE2"
-  "cvtpd2pi\t{%1, %0|%0, %1}"
+  "@
+   * return TARGET_AVX ? \"vcvtpd2dq{x}\t{%1, %0|%0, %1}\" : \"cvtpd2dq\t{%1, %0|%0, %1}\";
+   cvtpd2pi\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssecvt")
-   (set_attr "unit" "mmx")
+   (set_attr "unit" "*,mmx")
+   (set_attr "amdfam10_decode" "double")
+   (set_attr "athlon_decode" "vector")
    (set_attr "bdver1_decode" "double")
-   (set_attr "btver2_decode" "direct")
-   (set_attr "prefix_data16" "1")
-   (set_attr "mode" "DI")])
+   (set_attr "prefix_data16" "*,1")
+   (set_attr "prefix" "maybe_vex,*")
+   (set_attr "mode" "TI")])
 
 (define_insn "sse2_cvttpd2pi"
-  [(set (match_operand:V2SI 0 "register_operand" "=y")
-	(fix:V2SI (match_operand:V2DF 1 "nonimmediate_operand" "xm")))]
+  [(set (match_operand:V2SI 0 "register_operand" "=v,?!y")
+	(fix:V2SI (match_operand:V2DF 1 "nonimmediate_operand" "vBm,xm")))]
   "TARGET_SSE2"
-  "cvttpd2pi\t{%1, %0|%0, %1}"
+  "@
+   * return TARGET_AVX ? \"vcvttpd2dq{x}\t{%1, %0|%0, %1}\" : \"cvttpd2dq\t{%1, %0|%0, %1}\";
+   cvttpd2pi\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssecvt")
-   (set_attr "unit" "mmx")
+   (set_attr "unit" "*,mmx")
+   (set_attr "amdfam10_decode" "double")
+   (set_attr "athlon_decode" "vector")
    (set_attr "bdver1_decode" "double")
-   (set_attr "prefix_data16" "1")
+   (set_attr "prefix_data16" "*,1")
+   (set_attr "prefix" "maybe_vex,*")
    (set_attr "mode" "TI")])
 
 (define_insn "sse2_cvtsi2sd"
@@ -12684,13 +12696,15 @@
 	  (vec_concat:<ssedoublemode>
 	    (match_operand:VI8F_256 1 "register_operand" "v")
 	    (match_operand:VI8F_256 2 "nonimmediate_operand" "vm"))
-	  (parallel [(match_operand 3  "const_0_to_3_operand")
-		     (match_operand 4  "const_0_to_3_operand")
-		     (match_operand 5  "const_4_to_7_operand")
-		     (match_operand 6  "const_4_to_7_operand")])))]
+	  (parallel [(match_operand 3 "const_0_to_3_operand")
+		     (match_operand 4 "const_0_to_3_operand")
+		     (match_operand 5 "const_4_to_7_operand")
+		     (match_operand 6 "const_4_to_7_operand")])))]
   "TARGET_AVX512VL
-   && (INTVAL (operands[3]) == (INTVAL (operands[4]) - 1)
-       && INTVAL (operands[5]) == (INTVAL (operands[6]) - 1))"
+   && (INTVAL (operands[3]) & 1) == 0
+   && INTVAL (operands[3]) == INTVAL (operands[4]) - 1
+   && (INTVAL (operands[5]) & 1) == 0
+   && INTVAL (operands[5]) == INTVAL (operands[6]) - 1"
 {
   int mask;
   mask = INTVAL (operands[3]) / 2;
@@ -12733,19 +12747,23 @@
 	  (vec_concat:<ssedoublemode>
 	    (match_operand:V8FI 1 "register_operand" "v")
 	    (match_operand:V8FI 2 "nonimmediate_operand" "vm"))
-	  (parallel [(match_operand 3  "const_0_to_7_operand")
-		     (match_operand 4  "const_0_to_7_operand")
-		     (match_operand 5  "const_0_to_7_operand")
-		     (match_operand 6  "const_0_to_7_operand")
-		     (match_operand 7  "const_8_to_15_operand")
-		     (match_operand 8  "const_8_to_15_operand")
-		     (match_operand 9  "const_8_to_15_operand")
-		     (match_operand 10  "const_8_to_15_operand")])))]
+	  (parallel [(match_operand 3 "const_0_to_7_operand")
+		     (match_operand 4 "const_0_to_7_operand")
+		     (match_operand 5 "const_0_to_7_operand")
+		     (match_operand 6 "const_0_to_7_operand")
+		     (match_operand 7 "const_8_to_15_operand")
+		     (match_operand 8 "const_8_to_15_operand")
+		     (match_operand 9 "const_8_to_15_operand")
+		     (match_operand 10 "const_8_to_15_operand")])))]
   "TARGET_AVX512F
-   && (INTVAL (operands[3]) == (INTVAL (operands[4]) - 1)
-       && INTVAL (operands[5]) == (INTVAL (operands[6]) - 1)
-       && INTVAL (operands[7]) == (INTVAL (operands[8]) - 1)
-       && INTVAL (operands[9]) == (INTVAL (operands[10]) - 1))"
+   && (INTVAL (operands[3]) & 1) == 0
+   && INTVAL (operands[3]) == INTVAL (operands[4]) - 1
+   && (INTVAL (operands[5]) & 1) == 0
+   && INTVAL (operands[5]) == INTVAL (operands[6]) - 1
+   && (INTVAL (operands[7]) & 1) == 0
+   && INTVAL (operands[7]) == INTVAL (operands[8]) - 1
+   && (INTVAL (operands[9]) & 1) == 0
+   && INTVAL (operands[9]) == INTVAL (operands[10]) - 1"
 {
   int mask;
   mask = INTVAL (operands[3]) / 2;
@@ -12791,21 +12809,23 @@
 	  (vec_concat:<ssedoublemode>
 	    (match_operand:VI4F_256 1 "register_operand" "v")
 	    (match_operand:VI4F_256 2 "nonimmediate_operand" "vm"))
-	  (parallel [(match_operand 3  "const_0_to_7_operand")
-		     (match_operand 4  "const_0_to_7_operand")
-		     (match_operand 5  "const_0_to_7_operand")
-		     (match_operand 6  "const_0_to_7_operand")
-		     (match_operand 7  "const_8_to_15_operand")
-		     (match_operand 8  "const_8_to_15_operand")
-		     (match_operand 9  "const_8_to_15_operand")
+	  (parallel [(match_operand 3 "const_0_to_7_operand")
+		     (match_operand 4 "const_0_to_7_operand")
+		     (match_operand 5 "const_0_to_7_operand")
+		     (match_operand 6 "const_0_to_7_operand")
+		     (match_operand 7 "const_8_to_15_operand")
+		     (match_operand 8 "const_8_to_15_operand")
+		     (match_operand 9 "const_8_to_15_operand")
 		     (match_operand 10 "const_8_to_15_operand")])))]
   "TARGET_AVX512VL
-   && (INTVAL (operands[3]) == (INTVAL (operands[4]) - 1)
-       && INTVAL (operands[3]) == (INTVAL (operands[5]) - 2)
-       && INTVAL (operands[3]) == (INTVAL (operands[6]) - 3)
-       && INTVAL (operands[7]) == (INTVAL (operands[8]) - 1)
-       && INTVAL (operands[7]) == (INTVAL (operands[9]) - 2)
-       && INTVAL (operands[7]) == (INTVAL (operands[10]) - 3))"
+   && (INTVAL (operands[3]) & 3) == 0
+   && INTVAL (operands[3]) == INTVAL (operands[4]) - 1
+   && INTVAL (operands[3]) == INTVAL (operands[5]) - 2
+   && INTVAL (operands[3]) == INTVAL (operands[6]) - 3
+   && (INTVAL (operands[7]) & 3) == 0
+   && INTVAL (operands[7]) == INTVAL (operands[8]) - 1
+   && INTVAL (operands[7]) == INTVAL (operands[9]) - 2
+   && INTVAL (operands[7]) == INTVAL (operands[10]) - 3"
 {
   int mask;
   mask = INTVAL (operands[3]) / 4;
@@ -12857,35 +12877,39 @@
 	  (vec_concat:<ssedoublemode>
 	    (match_operand:V16FI 1 "register_operand" "v")
 	    (match_operand:V16FI 2 "nonimmediate_operand" "vm"))
-	  (parallel [(match_operand 3  "const_0_to_15_operand")
-		     (match_operand 4  "const_0_to_15_operand")
-		     (match_operand 5  "const_0_to_15_operand")
-		     (match_operand 6  "const_0_to_15_operand")
-		     (match_operand 7  "const_0_to_15_operand")
-		     (match_operand 8  "const_0_to_15_operand")
-		     (match_operand 9  "const_0_to_15_operand")
-		     (match_operand 10  "const_0_to_15_operand")
-		     (match_operand 11  "const_16_to_31_operand")
-		     (match_operand 12  "const_16_to_31_operand")
-		     (match_operand 13  "const_16_to_31_operand")
-		     (match_operand 14  "const_16_to_31_operand")
-		     (match_operand 15  "const_16_to_31_operand")
-		     (match_operand 16  "const_16_to_31_operand")
-		     (match_operand 17  "const_16_to_31_operand")
-		     (match_operand 18  "const_16_to_31_operand")])))]
+	  (parallel [(match_operand 3 "const_0_to_15_operand")
+		     (match_operand 4 "const_0_to_15_operand")
+		     (match_operand 5 "const_0_to_15_operand")
+		     (match_operand 6 "const_0_to_15_operand")
+		     (match_operand 7 "const_0_to_15_operand")
+		     (match_operand 8 "const_0_to_15_operand")
+		     (match_operand 9 "const_0_to_15_operand")
+		     (match_operand 10 "const_0_to_15_operand")
+		     (match_operand 11 "const_16_to_31_operand")
+		     (match_operand 12 "const_16_to_31_operand")
+		     (match_operand 13 "const_16_to_31_operand")
+		     (match_operand 14 "const_16_to_31_operand")
+		     (match_operand 15 "const_16_to_31_operand")
+		     (match_operand 16 "const_16_to_31_operand")
+		     (match_operand 17 "const_16_to_31_operand")
+		     (match_operand 18 "const_16_to_31_operand")])))]
   "TARGET_AVX512F
-   && (INTVAL (operands[3]) == (INTVAL (operands[4]) - 1)
-       && INTVAL (operands[3]) == (INTVAL (operands[5]) - 2)
-       && INTVAL (operands[3]) == (INTVAL (operands[6]) - 3)
-       && INTVAL (operands[7]) == (INTVAL (operands[8]) - 1)
-       && INTVAL (operands[7]) == (INTVAL (operands[9]) - 2)
-       && INTVAL (operands[7]) == (INTVAL (operands[10]) - 3)
-       && INTVAL (operands[11]) == (INTVAL (operands[12]) - 1)
-       && INTVAL (operands[11]) == (INTVAL (operands[13]) - 2)
-       && INTVAL (operands[11]) == (INTVAL (operands[14]) - 3)
-       && INTVAL (operands[15]) == (INTVAL (operands[16]) - 1)
-       && INTVAL (operands[15]) == (INTVAL (operands[17]) - 2)
-       && INTVAL (operands[15]) == (INTVAL (operands[18]) - 3))"
+   && (INTVAL (operands[3]) & 3) == 0
+   && INTVAL (operands[3]) == INTVAL (operands[4]) - 1
+   && INTVAL (operands[3]) == INTVAL (operands[5]) - 2
+   && INTVAL (operands[3]) == INTVAL (operands[6]) - 3
+   && (INTVAL (operands[7]) & 3) == 0
+   && INTVAL (operands[7]) == INTVAL (operands[8]) - 1
+   && INTVAL (operands[7]) == INTVAL (operands[9]) - 2
+   && INTVAL (operands[7]) == INTVAL (operands[10]) - 3
+   && (INTVAL (operands[11]) & 3) == 0
+   && INTVAL (operands[11]) == INTVAL (operands[12]) - 1
+   && INTVAL (operands[11]) == INTVAL (operands[13]) - 2
+   && INTVAL (operands[11]) == INTVAL (operands[14]) - 3
+   && (INTVAL (operands[15]) & 3) == 0
+   && INTVAL (operands[15]) == INTVAL (operands[16]) - 1
+   && INTVAL (operands[15]) == INTVAL (operands[17]) - 2
+   && INTVAL (operands[15]) == INTVAL (operands[18]) - 3"
 {
   int mask;
   mask = INTVAL (operands[3]) / 4;
@@ -14918,7 +14942,7 @@
     }
 })
 
-(define_insn "abs<mode>2"
+(define_insn "ssse3_abs<mode>2"
   [(set (match_operand:MMXMODEI 0 "register_operand" "=y")
 	(abs:MMXMODEI
 	  (match_operand:MMXMODEI 1 "nonimmediate_operand" "ym")))]
@@ -16015,9 +16039,9 @@
   switch (INTVAL (operands[4]))
     {
     case 3:
-      return "vgatherpf0<ssemodesuffix>ps\t{%5%{%0%}|%5%{%0%}}";
+      return "%M2vgatherpf0<ssemodesuffix>ps\t{%5%{%0%}|%5%{%0%}}";
     case 2:
-      return "vgatherpf1<ssemodesuffix>ps\t{%5%{%0%}|%5%{%0%}}";
+      return "%M2vgatherpf1<ssemodesuffix>ps\t{%5%{%0%}|%5%{%0%}}";
     default:
       gcc_unreachable ();
     }
@@ -16060,9 +16084,9 @@
   switch (INTVAL (operands[4]))
     {
     case 3:
-      return "vgatherpf0<ssemodesuffix>pd\t{%5%{%0%}|%5%{%0%}}";
+      return "%M2vgatherpf0<ssemodesuffix>pd\t{%5%{%0%}|%5%{%0%}}";
     case 2:
-      return "vgatherpf1<ssemodesuffix>pd\t{%5%{%0%}|%5%{%0%}}";
+      return "%M2vgatherpf1<ssemodesuffix>pd\t{%5%{%0%}|%5%{%0%}}";
     default:
       gcc_unreachable ();
     }
@@ -16106,10 +16130,10 @@
     {
     case 3:
     case 7:
-      return "vscatterpf0<ssemodesuffix>ps\t{%5%{%0%}|%5%{%0%}}";
+      return "%M2vscatterpf0<ssemodesuffix>ps\t{%5%{%0%}|%5%{%0%}}";
     case 2:
     case 6:
-      return "vscatterpf1<ssemodesuffix>ps\t{%5%{%0%}|%5%{%0%}}";
+      return "%M2vscatterpf1<ssemodesuffix>ps\t{%5%{%0%}|%5%{%0%}}";
     default:
       gcc_unreachable ();
     }
@@ -16153,10 +16177,10 @@
     {
     case 3:
     case 7:
-      return "vscatterpf0<ssemodesuffix>pd\t{%5%{%0%}|%5%{%0%}}";
+      return "%M2vscatterpf0<ssemodesuffix>pd\t{%5%{%0%}|%5%{%0%}}";
     case 2:
     case 6:
-      return "vscatterpf1<ssemodesuffix>pd\t{%5%{%0%}|%5%{%0%}}";
+      return "%M2vscatterpf1<ssemodesuffix>pd\t{%5%{%0%}|%5%{%0%}}";
     default:
       gcc_unreachable ();
     }
@@ -19020,7 +19044,7 @@
 	  UNSPEC_GATHER))
    (clobber (match_scratch:VEC_GATHER_MODE 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherd<ssemodesuffix>\t{%1, %7, %0|%0, %7, %1}"
+  "%M3v<sseintprefix>gatherd<ssemodesuffix>\t{%1, %7, %0|%0, %7, %1}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19040,7 +19064,7 @@
 	  UNSPEC_GATHER))
    (clobber (match_scratch:VEC_GATHER_MODE 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherd<ssemodesuffix>\t{%1, %6, %0|%0, %6, %1}"
+  "%M2v<sseintprefix>gatherd<ssemodesuffix>\t{%1, %6, %0|%0, %6, %1}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19081,7 +19105,7 @@
 	  UNSPEC_GATHER))
    (clobber (match_scratch:VEC_GATHER_MODE 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %7, %2|%2, %7, %5}"
+  "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %7, %2|%2, %7, %5}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19103,8 +19127,8 @@
   "TARGET_AVX2"
 {
   if (<MODE>mode != <VEC_GATHER_SRCDI>mode)
-    return "v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %x0|%x0, %6, %4}";
-  return "v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %0|%0, %6, %4}";
+    return "%M2v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %x0|%x0, %6, %4}";
+  return "%M2v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %0|%0, %6, %4}";
 }
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
@@ -19128,7 +19152,7 @@
 		     (const_int 2) (const_int 3)])))
    (clobber (match_scratch:VI4F_256 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %7, %0|%0, %7, %5}"
+  "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %7, %0|%0, %7, %5}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19151,7 +19175,7 @@
 		     (const_int 2) (const_int 3)])))
    (clobber (match_scratch:VI4F_256 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %0|%0, %6, %4}"
+  "%M2v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %0|%0, %6, %4}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19195,7 +19219,7 @@
 	  UNSPEC_GATHER))
    (clobber (match_scratch:<avx512fmaskmode> 2 "=&Yk"))]
   "TARGET_AVX512F"
-  "v<sseintprefix>gatherd<ssemodesuffix>\t{%6, %0%{%2%}|%0%{%2%}, %<xtg_mode>6}"
+  "%M4v<sseintprefix>gatherd<ssemodesuffix>\t{%6, %0%{%2%}|%0%{%2%}, %<xtg_mode>6}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19214,7 +19238,7 @@
 	  UNSPEC_GATHER))
    (clobber (match_scratch:<avx512fmaskmode> 1 "=&Yk"))]
   "TARGET_AVX512F"
-  "v<sseintprefix>gatherd<ssemodesuffix>\t{%5, %0%{%1%}|%0%{%1%}, %<xtg_mode>5}"
+  "%M3v<sseintprefix>gatherd<ssemodesuffix>\t{%5, %0%{%1%}|%0%{%1%}, %<xtg_mode>5}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19254,7 +19278,7 @@
    (clobber (match_scratch:QI 2 "=&Yk"))]
   "TARGET_AVX512F"
 {
-  return "v<sseintprefix>gatherq<ssemodesuffix>\t{%6, %1%{%2%}|%1%{%2%}, %<gatherq_mode>6}";
+  return "%M4v<sseintprefix>gatherq<ssemodesuffix>\t{%6, %1%{%2%}|%1%{%2%}, %<gatherq_mode>6}";
 }
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
@@ -19278,11 +19302,11 @@
   if (<MODE>mode != <VEC_GATHER_SRCDI>mode)
     {
       if (<MODE_SIZE> != 64)
-	return "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %x0%{%1%}|%x0%{%1%}, %<gatherq_mode>5}";
+	return "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %x0%{%1%}|%x0%{%1%}, %<gatherq_mode>5}";
       else
-	return "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %t0%{%1%}|%t0%{%1%}, %t5}";
+	return "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %t0%{%1%}|%t0%{%1%}, %t5}";
     }
-  return "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %0%{%1%}|%0%{%1%}, %<gatherq_mode>5}";
+  return "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %0%{%1%}|%0%{%1%}, %<gatherq_mode>5}";
 }
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
@@ -19319,7 +19343,7 @@
 	  UNSPEC_SCATTER))
    (clobber (match_scratch:<avx512fmaskmode> 1 "=&Yk"))]
   "TARGET_AVX512F"
-  "v<sseintprefix>scatterd<ssemodesuffix>\t{%3, %5%{%1%}|%5%{%1%}, %3}"
+  "%M0v<sseintprefix>scatterd<ssemodesuffix>\t{%3, %5%{%1%}|%5%{%1%}, %3}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19357,8 +19381,8 @@
   "TARGET_AVX512F"
 {
   if (GET_MODE_SIZE (GET_MODE_INNER (<MODE>mode)) == 8)
-    return "v<sseintprefix>scatterq<ssemodesuffix>\t{%3, %5%{%1%}|%5%{%1%}, %3}";
-  return "v<sseintprefix>scatterq<ssemodesuffix>\t{%3, %5%{%1%}|%t5%{%1%}, %3}";
+    return "%M0v<sseintprefix>scatterq<ssemodesuffix>\t{%3, %5%{%1%}|%5%{%1%}, %3}";
+  return "%M0v<sseintprefix>scatterq<ssemodesuffix>\t{%3, %5%{%1%}|%t5%{%1%}, %3}";
 }
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
Index: gcc/config/i386/i386-builtin.def
===================================================================
--- a/src/gcc/config/i386/i386-builtin.def	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/i386/i386-builtin.def	(.../branches/gcc-7-branch)
@@ -766,11 +766,11 @@
 
 /* SSSE3 */
 BDESC (OPTION_MASK_ISA_SSSE3, CODE_FOR_absv16qi2, "__builtin_ia32_pabsb128", IX86_BUILTIN_PABSB128, UNKNOWN, (int) V16QI_FTYPE_V16QI)
-BDESC (OPTION_MASK_ISA_SSSE3, CODE_FOR_absv8qi2, "__builtin_ia32_pabsb", IX86_BUILTIN_PABSB, UNKNOWN, (int) V8QI_FTYPE_V8QI)
+BDESC (OPTION_MASK_ISA_SSSE3, CODE_FOR_ssse3_absv8qi2, "__builtin_ia32_pabsb", IX86_BUILTIN_PABSB, UNKNOWN, (int) V8QI_FTYPE_V8QI)
 BDESC (OPTION_MASK_ISA_SSSE3, CODE_FOR_absv8hi2, "__builtin_ia32_pabsw128", IX86_BUILTIN_PABSW128, UNKNOWN, (int) V8HI_FTYPE_V8HI)
-BDESC (OPTION_MASK_ISA_SSSE3, CODE_FOR_absv4hi2, "__builtin_ia32_pabsw", IX86_BUILTIN_PABSW, UNKNOWN, (int) V4HI_FTYPE_V4HI)
+BDESC (OPTION_MASK_ISA_SSSE3, CODE_FOR_ssse3_absv4hi2, "__builtin_ia32_pabsw", IX86_BUILTIN_PABSW, UNKNOWN, (int) V4HI_FTYPE_V4HI)
 BDESC (OPTION_MASK_ISA_SSSE3, CODE_FOR_absv4si2, "__builtin_ia32_pabsd128", IX86_BUILTIN_PABSD128, UNKNOWN, (int) V4SI_FTYPE_V4SI)
-BDESC (OPTION_MASK_ISA_SSSE3, CODE_FOR_absv2si2, "__builtin_ia32_pabsd", IX86_BUILTIN_PABSD, UNKNOWN, (int) V2SI_FTYPE_V2SI)
+BDESC (OPTION_MASK_ISA_SSSE3, CODE_FOR_ssse3_absv2si2, "__builtin_ia32_pabsd", IX86_BUILTIN_PABSD, UNKNOWN, (int) V2SI_FTYPE_V2SI)
 
 BDESC (OPTION_MASK_ISA_SSSE3, CODE_FOR_ssse3_phaddwv8hi3, "__builtin_ia32_phaddw128", IX86_BUILTIN_PHADDW128, UNKNOWN, (int) V8HI_FTYPE_V8HI_V8HI)
 BDESC (OPTION_MASK_ISA_SSSE3, CODE_FOR_ssse3_phaddwv4hi3, "__builtin_ia32_phaddw", IX86_BUILTIN_PHADDW, UNKNOWN, (int) V4HI_FTYPE_V4HI_V4HI)
Index: gcc/config/i386/darwin.h
===================================================================
--- a/src/gcc/config/i386/darwin.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/i386/darwin.h	(.../branches/gcc-7-branch)
@@ -39,6 +39,33 @@
 #endif
 #endif
 
+/* WORKAROUND pr80556:
+   For x86_64 Darwin10 and later, the unwinder is in libunwind (redirected
+   from libSystem).  This doesn't use the keymgr (see keymgr.c) and therefore
+   the calls that libgcc makes to obtain the KEYMGR_GCC3_DW2_OBJ_LIST are not
+   updated to include new images, and might not even be valid for a single
+   image.
+   Therefore, for 64b exes at least, we must use the libunwind implementation,
+   even when static-libgcc is specified.  We put libSystem first so that
+   unwinder symbols are satisfied from there.
+   We default to 64b for single-arch builds, so apply this unconditionally. */
+#undef REAL_LIBGCC_SPEC
+#define REAL_LIBGCC_SPEC						   \
+   "%{static-libgcc|static: 						   \
+       %:version-compare(>= 10.6 mmacosx-version-min= -lSystem)		   \
+       -lgcc_eh -lgcc;							   \
+      shared-libgcc|fexceptions|fgnu-runtime:				   \
+       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_s.10.4)	   \
+       %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
+       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)	   \
+       %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)	   \
+       -lgcc ;								   \
+      :%:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_s.10.4) \
+       %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
+       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)	   \
+       %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)	   \
+       -lgcc }"
+
 /* Size of the Obj-C jump buffer.  */
 #define OBJC_JBLEN ((TARGET_64BIT) ? ((9 * 2) + 3 + 16) : (18))
 
@@ -62,14 +89,12 @@
 #undef WCHAR_TYPE_SIZE
 #define WCHAR_TYPE_SIZE 32
 
-/* Generate branch islands stubs if this is true.  */
-extern int darwin_emit_branch_islands;
+/* Generate pic symbol indirection stubs if this is true.  */
+#undef TARGET_MACHO_SYMBOL_STUBS
+#define TARGET_MACHO_SYMBOL_STUBS (darwin_symbol_stubs)
 
-#undef TARGET_MACHO_BRANCH_ISLANDS
-#define TARGET_MACHO_BRANCH_ISLANDS darwin_emit_branch_islands
-
 /* For compatibility with OSX system tools, use the new style of pic stub
-   if this is set.  */
+   if this is set (default).  */
 #undef  MACHOPIC_ATT_STUB
 #define MACHOPIC_ATT_STUB (darwin_macho_att_stub)
 
@@ -85,9 +110,6 @@
 /* On Darwin, the stack is 128-bit aligned at the point of every call.
    Failure to ensure this will lead to a crash in the system libraries
    or dynamic loader.  */
-#undef STACK_BOUNDARY
-#define STACK_BOUNDARY \
-  ((profile_flag || TARGET_64BIT_MS_ABI) ? 128 : BITS_PER_WORD)
 
 #undef MAIN_STACK_BOUNDARY
 #define MAIN_STACK_BOUNDARY 128
@@ -107,7 +129,8 @@
 #undef CC1_SPEC
 #define CC1_SPEC "%(cc1_cpu) \
   %{!mkernel:%{!static:%{!mdynamic-no-pic:-fPIC}}} \
-  %{g: %{!fno-eliminate-unused-debug-symbols: -feliminate-unused-debug-symbols }} " \
+  %{g: %{!fno-eliminate-unused-debug-symbols: -feliminate-unused-debug-symbols }} \
+  %{mx32:%eDarwin is not an mx32 platform}" \
   DARWIN_CC1_SPEC
 
 #undef ASM_SPEC
@@ -115,9 +138,6 @@
   " ASM_OPTIONS " -force_cpusubtype_ALL \
   %{static}" ASM_MMACOSX_VERSION_MIN_SPEC
 
-#define DARWIN_ARCH_SPEC "%{m64:x86_64;:i386}"
-#define DARWIN_SUBARCH_SPEC DARWIN_ARCH_SPEC
-
 #undef ENDFILE_SPEC
 #define ENDFILE_SPEC \
   "%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \
@@ -125,12 +145,15 @@
    %{mpc64:crtprec64.o%s} \
    %{mpc80:crtprec80.o%s}" TM_DESTRUCTOR
 
+/* We default to x86_64 for single-arch builds, bi-arch overrides.  */
+#define DARWIN_ARCH_SPEC "x86_64"
+
 #undef SUBTARGET_EXTRA_SPECS
 #define SUBTARGET_EXTRA_SPECS                                   \
   DARWIN_EXTRA_SPECS                                            \
-  { "darwin_arch", DARWIN_ARCH_SPEC },                          \
+  { "darwin_arch", DARWIN_ARCH_SPEC },				\
   { "darwin_crt2", "" },                                        \
-  { "darwin_subarch", DARWIN_SUBARCH_SPEC },
+  { "darwin_subarch", DARWIN_ARCH_SPEC },
 
 /* The Darwin assembler mostly follows AT&T syntax.  */
 #undef ASSEMBLER_DIALECT
@@ -196,19 +219,36 @@
         }				\
     } while (0)
 
+#ifdef HAVE_GAS_MAX_SKIP_P2ALIGN
+#define ASM_OUTPUT_MAX_SKIP_ALIGN(FILE,LOG,MAX_SKIP)                    \
+  do {                                                                  \
+    if ((LOG) != 0) {                                                   \
+      if ((MAX_SKIP) == 0 || (MAX_SKIP) >= (1 << (LOG)) - 1)            \
+        fprintf ((FILE), "\t.p2align %d\n", (LOG));                     \
+      else                                                              \
+        fprintf ((FILE), "\t.p2align %d,,%d\n", (LOG), (MAX_SKIP));     \
+    }                                                                   \
+  } while (0)
+#endif
+
+/* Darwin x86 assemblers support the .ident directive.  */
+
+#undef TARGET_ASM_OUTPUT_IDENT
+#define TARGET_ASM_OUTPUT_IDENT default_asm_output_ident_directive
+
 /* Darwin profiling -- call mcount.  */
 #undef FUNCTION_PROFILER
 #define FUNCTION_PROFILER(FILE, LABELNO)				\
-    do {								\
-      if (TARGET_MACHO_BRANCH_ISLANDS 					\
-	   && MACHOPIC_INDIRECT && !TARGET_64BIT)			\
-	{								\
-	  const char *name = machopic_mcount_stub_name ();		\
-	  fprintf (FILE, "\tcall %s\n", name+1);  /*  skip '&'  */	\
-	  machopic_validate_stub_or_non_lazy_ptr (name);		\
-	}								\
-      else fprintf (FILE, "\tcall mcount\n");				\
-    } while (0)
+  do {									\
+    if (TARGET_MACHO_SYMBOL_STUBS 					\
+	&& MACHOPIC_INDIRECT && !TARGET_64BIT)				\
+      {									\
+	const char *name = machopic_mcount_stub_name ();		\
+	fprintf (FILE, "\tcall %s\n", name+1);  /*  skip '&'  */	\
+	machopic_validate_stub_or_non_lazy_ptr (name);			\
+      }									\
+    else fprintf (FILE, "\tcall mcount\n");				\
+  } while (0)
 
 #define C_COMMON_OVERRIDE_OPTIONS					\
   do {									\
@@ -281,10 +321,8 @@
         }                                                                       \
     }
 
-/* This needs to move since i386 uses the first flag and other flags are
-   used in Mach-O.  */
-#undef MACHO_SYMBOL_FLAG_VARIABLE
-#define MACHO_SYMBOL_FLAG_VARIABLE ((SYMBOL_FLAG_MACH_DEP) << 3)
+/* First available SYMBOL flag bit for use by subtargets.  */
+#define SYMBOL_FLAG_SUBT_DEP (SYMBOL_FLAG_MACH_DEP << 5)
 
 #undef MACHOPIC_NL_SYMBOL_PTR_SECTION
 #define MACHOPIC_NL_SYMBOL_PTR_SECTION \
Index: gcc/config/i386/emmintrin.h
===================================================================
--- a/src/gcc/config/i386/emmintrin.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/i386/emmintrin.h	(.../branches/gcc-7-branch)
@@ -1296,7 +1296,7 @@
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpeq_epi8 (__m128i __A, __m128i __B)
 {
-  return (__m128i) ((__v16qs)__A == (__v16qs)__B);
+  return (__m128i) ((__v16qi)__A == (__v16qi)__B);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
Index: gcc/config/i386/avxintrin.h
===================================================================
--- a/src/gcc/config/i386/avxintrin.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/i386/avxintrin.h	(.../branches/gcc-7-branch)
@@ -47,6 +47,7 @@
 typedef short __v16hi __attribute__ ((__vector_size__ (32)));
 typedef unsigned short __v16hu __attribute__ ((__vector_size__ (32)));
 typedef char __v32qi __attribute__ ((__vector_size__ (32)));
+typedef signed char __v32qs __attribute__ ((__vector_size__ (32)));
 typedef unsigned char __v32qu __attribute__ ((__vector_size__ (32)));
 
 /* The Intel API is flexible enough that we must allow aliasing with other
Index: gcc/config/i386/i386.c
===================================================================
--- a/src/gcc/config/i386/i386.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/i386/i386.c	(.../branches/gcc-7-branch)
@@ -6282,6 +6282,12 @@
     target_option_default_node = target_option_current_node
       = build_target_option_node (opts);
 
+  /* PR86952: jump table usage with retpolines is slow.
+     The PR provides some numbers about the slowness.  */
+  if (ix86_indirect_branch != indirect_branch_keep
+      && !opts_set->x_flag_jump_tables)
+    opts->x_flag_jump_tables = 0;
+
   return true;
 }
 
@@ -12788,10 +12794,16 @@
   /* 64-bit MS ABI seem to require stack alignment to be always 16,
      except for function prologues, leaf functions and when the defult
      incoming stack boundary is overriden at command line or via
-     force_align_arg_pointer attribute.  */
-  if ((TARGET_64BIT_MS_ABI && crtl->preferred_stack_boundary < 128)
+     force_align_arg_pointer attribute.
+
+     Darwin's ABI specifies 128b alignment for both 32 and  64 bit variants
+     at call sites, including profile function calls.
+ */
+  if (((TARGET_64BIT_MS_ABI || TARGET_MACHO)
+        && crtl->preferred_stack_boundary < 128)
       && (!crtl->is_leaf || cfun->calls_alloca != 0
 	  || ix86_current_function_calls_tls_descriptor
+	  || (TARGET_MACHO && crtl->profile)
 	  || ix86_incoming_stack_boundary < 128))
     {
       crtl->preferred_stack_boundary = 128;
@@ -14493,8 +14505,9 @@
 	}
       m->fs.sp_offset += allocate;
 
-      /* Use stack_pointer_rtx for relative addressing so that code
-	 works for realigned stack, too.  */
+      /* Use stack_pointer_rtx for relative addressing so that code works for
+	 realigned stack.  But this means that we need a blockage to prevent
+	 stores based on the frame pointer from being scheduled before.  */
       if (r10_live && eax_live)
         {
 	  t = gen_rtx_PLUS (Pmode, stack_pointer_rtx, eax);
@@ -14503,6 +14516,7 @@
 	  t = plus_constant (Pmode, t, UNITS_PER_WORD);
 	  emit_move_insn (gen_rtx_REG (word_mode, AX_REG),
 			  gen_frame_mem (word_mode, t));
+	  emit_insn (gen_memory_blockage ());
 	}
       else if (eax_live || r10_live)
 	{
@@ -14510,6 +14524,7 @@
 	  emit_move_insn (gen_rtx_REG (word_mode,
 				       (eax_live ? AX_REG : R10_REG)),
 			  gen_frame_mem (word_mode, t));
+	  emit_insn (gen_memory_blockage ());
 	}
     }
   gcc_assert (m->fs.sp_offset == frame.stack_pointer_offset);
@@ -17379,7 +17394,7 @@
       break;
 
     case SYMBOL_REF:
-      if (TARGET_64BIT || ! TARGET_MACHO_BRANCH_ISLANDS)
+      if (TARGET_64BIT || ! TARGET_MACHO_SYMBOL_STUBS)
 	output_addr_const (file, x);
       else
 	{
@@ -18164,6 +18179,7 @@
    ~ -- print "i" if TARGET_AVX2, "f" otherwise.
    @ -- print a segment register of thread base pointer load
    ^ -- print addr32 prefix if TARGET_64BIT and Pmode != word_mode
+   M -- print addr32 prefix for TARGET_X32 with VSIB address.
    ! -- print MPX prefix for jxx/call/ret instructions if required.
  */
 
@@ -18723,6 +18739,26 @@
 	  putc (TARGET_AVX2 ? 'i' : 'f', file);
 	  return;
 
+	case 'M':
+	  if (TARGET_X32)
+	    {
+	      /* NB: 32-bit indices in VSIB address are sign-extended
+		 to 64 bits. In x32, if 32-bit address 0xf7fa3010 is
+		 sign-extended to 0xfffffffff7fa3010 which is invalid
+		 address.  Add addr32 prefix if there is no base
+		 register nor symbol.  */
+	      bool ok;
+	      struct ix86_address parts;
+	      ok = ix86_decompose_address (x, &parts);
+	      gcc_assert (ok && parts.index == NULL_RTX);
+	      if (parts.base == NULL_RTX
+		  && (parts.disp == NULL_RTX
+		      || !symbolic_operand (parts.disp,
+					    GET_MODE (parts.disp))))
+		fputs ("addr32 ", file);
+	    }
+	  return;
+
 	case '^':
 	  if (TARGET_64BIT && Pmode != word_mode)
 	    fputs ("addr32 ", file);
@@ -24111,6 +24147,8 @@
   else
     {
       code = is_min ? SMIN : SMAX;
+      if (MEM_P (if_true) && MEM_P (if_false))
+	if_true = force_reg (mode, if_true);
       tmp = gen_rtx_fmt_ee (code, mode, if_true, if_false);
     }
 
@@ -24118,7 +24156,7 @@
   return true;
 }
 
-/* Expand an sse vector comparison.  Return the register with the result.  */
+/* Expand an SSE comparison.  Return the register with the result.  */
 
 static rtx
 ix86_expand_sse_cmp (rtx dest, enum rtx_code code, rtx cmp_op0, rtx cmp_op1,
@@ -24144,9 +24182,12 @@
   else
     cmp_mode = cmp_ops_mode;
 
+  cmp_op0 = force_reg (cmp_ops_mode, cmp_op0);
 
-  cmp_op0 = force_reg (cmp_ops_mode, cmp_op0);
-  if (!nonimmediate_operand (cmp_op1, cmp_ops_mode))
+  int (*op1_predicate)(rtx, machine_mode)
+    = VECTOR_MODE_P (cmp_ops_mode) ? vector_operand : nonimmediate_operand;
+
+  if (!op1_predicate (cmp_op1, cmp_ops_mode))
     cmp_op1 = force_reg (cmp_ops_mode, cmp_op1);
 
   if (optimize
@@ -24266,7 +24307,7 @@
       rtx (*gen) (rtx, rtx, rtx, rtx) = NULL;
       rtx d = dest;
 
-      if (!nonimmediate_operand (op_true, mode))
+      if (!vector_operand (op_true, mode))
 	op_true = force_reg (mode, op_true);
 
       op_false = force_reg (mode, op_false);
@@ -28821,6 +28862,25 @@
   return false;
 }
 
+/* Helper to output the jmp/call.  */
+static void
+ix86_output_jmp_thunk_or_indirect (const char *thunk_name,
+				   bool need_bnd_p,
+				   const int regno)
+{
+  if (thunk_name != NULL)
+    {
+      if (need_bnd_p)
+	fprintf (asm_out_file, "\tbnd jmp\t");
+      else
+	fprintf (asm_out_file, "\tjmp\t");
+      assemble_name (asm_out_file, thunk_name);
+      putc ('\n', asm_out_file);
+    }
+  else
+    output_indirect_thunk (need_bnd_p, regno);
+}
+
 /* Output indirect branch via a call and return thunk.  CALL_OP is a
    register which contains the branch target.  XASM is the assembly
    template for CALL_OP.  Branch is a tail call if SIBCALL_P is true.
@@ -28861,25 +28921,17 @@
     thunk_name = NULL;
 
   if (sibcall_p)
-    {
-      if (thunk_name != NULL)
-	{
-	  if (need_bnd_p)
-	    fprintf (asm_out_file, "\tbnd jmp\t%s\n", thunk_name);
-	  else
-	    fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
-	}
-      else
-	output_indirect_thunk (need_bnd_p, regno);
-    }
+    ix86_output_jmp_thunk_or_indirect (thunk_name, need_bnd_p, regno);
   else
     {
       if (thunk_name != NULL)
 	{
 	  if (need_bnd_p)
-	    fprintf (asm_out_file, "\tbnd call\t%s\n", thunk_name);
+	    fprintf (asm_out_file, "\tbnd call\t");
 	  else
-	    fprintf (asm_out_file, "\tcall\t%s\n", thunk_name);
+	    fprintf (asm_out_file, "\tcall\t");
+	  assemble_name (asm_out_file, thunk_name);
+	  putc ('\n', asm_out_file);
 	  return;
 	}
 
@@ -28903,15 +28955,7 @@
 
       ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, indirectlabel1);
 
-      if (thunk_name != NULL)
-	{
-	  if (need_bnd_p)
-	    fprintf (asm_out_file, "\tbnd jmp\t%s\n", thunk_name);
-	  else
-	    fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
-	}
-      else
-	output_indirect_thunk (need_bnd_p, regno);
+      ix86_output_jmp_thunk_or_indirect (thunk_name, need_bnd_p, regno);
 
       ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, indirectlabel2);
 
@@ -28975,15 +29019,7 @@
   if (sibcall_p)
     {
       output_asm_insn (push_buf, &call_op);
-      if (thunk_name != NULL)
-	{
-	  if (need_bnd_p)
-	    fprintf (asm_out_file, "\tbnd jmp\t%s\n", thunk_name);
-	  else
-	    fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
-	}
-      else
-	output_indirect_thunk (need_bnd_p, regno);
+      ix86_output_jmp_thunk_or_indirect (thunk_name, need_bnd_p, regno);
     }
   else
     {
@@ -29042,15 +29078,7 @@
 
       output_asm_insn (push_buf, &call_op);
 
-      if (thunk_name != NULL)
-	{
-	  if (need_bnd_p)
-	    fprintf (asm_out_file, "\tbnd jmp\t%s\n", thunk_name);
-	  else
-	    fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
-	}
-      else
-	output_indirect_thunk (need_bnd_p, regno);
+      ix86_output_jmp_thunk_or_indirect (thunk_name, need_bnd_p, regno);
 
       ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, indirectlabel2);
 
@@ -29118,13 +29146,15 @@
 	  if (need_bnd_p)
 	    {
 	      indirect_return_bnd_needed |= need_thunk;
-	      fprintf (asm_out_file, "\tbnd jmp\t%s\n", thunk_name);
+	      fprintf (asm_out_file, "\tbnd jmp\t");
 	    }
 	  else
 	    {
 	      indirect_return_needed |= need_thunk;
-	      fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
+	      fprintf (asm_out_file, "\tjmp\t");
 	    }
+	  assemble_name (asm_out_file, thunk_name);
+	  putc ('\n', asm_out_file);
 	}
       else
 	output_indirect_thunk (need_bnd_p, INVALID_REGNUM);
@@ -29164,7 +29194,7 @@
 		  indirect_return_via_cx_bnd = true;
 		  indirect_thunks_bnd_used |= 1 << CX_REG;
 		}
-	      fprintf (asm_out_file, "\tbnd jmp\t%s\n", thunk_name);
+	      fprintf (asm_out_file, "\tbnd jmp\t");
 	    }
 	  else
 	    {
@@ -29173,8 +29203,10 @@
 		  indirect_return_via_cx = true;
 		  indirect_thunks_used |= 1 << CX_REG;
 		}
-	      fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
+	      fprintf (asm_out_file, "\tjmp\t");
 	    }
+	  assemble_name (asm_out_file, thunk_name);
+	  putc ('\n', asm_out_file);
 	}
       else
 	output_indirect_thunk (need_bnd_p, regno);
@@ -38388,6 +38420,16 @@
           unsigned char lsb_index = INTVAL (op1) & 0xFF;
           op1 = GEN_INT (length);
           op2 = GEN_INT (lsb_index);
+
+	  mode1 = insn_data[icode].operand[1].mode;
+	  if (!insn_data[icode].operand[1].predicate (op0, mode1))
+	    op0 = copy_to_mode_reg (mode1, op0);
+
+	  mode0 = insn_data[icode].operand[0].mode;
+	  if (target == 0
+	      || !register_operand (target, mode0))
+	    target = gen_reg_rtx (mode0);
+
           pat = GEN_FCN (icode) (target, op0, op1, op2);
           if (pat)
             emit_insn (pat);
@@ -40478,7 +40520,7 @@
 static bool
 use_rsqrt_p ()
 {
-  return (TARGET_SSE_MATH
+  return (TARGET_SSE && TARGET_SSE_MATH
 	  && flag_finite_math_only
 	  && !flag_trapping_math
 	  && flag_unsafe_math_optimizations);
@@ -46176,8 +46218,10 @@
           x2 -= 1;
      Compensate.  Ceil:
         if (x2 < x)
-          x2 -= -1;
-        return x2;
+          x2 += 1;
+	if (HONOR_SIGNED_ZEROS (mode))
+	  x2 = copysign (x2, x);
+	return x2;
    */
   machine_mode mode = GET_MODE (operand0);
   rtx xa, TWO52, tmp, one, res, mask;
@@ -46203,17 +46247,16 @@
   /* xa = copysign (xa, operand1) */
   ix86_sse_copysign_to_positive (xa, xa, res, mask);
 
-  /* generate 1.0 or -1.0 */
-  one = force_reg (mode,
-	           const_double_from_real_value (do_floor
-						 ? dconst1 : dconstm1, mode));
+  /* generate 1.0 */
+  one = force_reg (mode, const_double_from_real_value (dconst1, mode));
 
   /* Compensate: xa = xa - (xa > operand1 ? 1 : 0) */
   tmp = ix86_expand_sse_compare_mask (UNGT, xa, res, !do_floor);
   emit_insn (gen_rtx_SET (tmp, gen_rtx_AND (mode, one, tmp)));
-  /* We always need to subtract here to preserve signed zero.  */
-  tmp = expand_simple_binop (mode, MINUS,
+  tmp = expand_simple_binop (mode, do_floor ? MINUS : PLUS,
 			     xa, tmp, NULL_RTX, 0, OPTAB_DIRECT);
+  if (!do_floor && HONOR_SIGNED_ZEROS (mode))
+    ix86_sse_copysign_to_positive (tmp, tmp, res, mask);
   emit_move_insn (res, tmp);
 
   emit_label (label);
@@ -46772,7 +46815,8 @@
 expand_vec_perm_blend (struct expand_vec_perm_d *d)
 {
   machine_mode mmode, vmode = d->vmode;
-  unsigned i, mask, nelt = d->nelt;
+  unsigned i, nelt = d->nelt;
+  unsigned HOST_WIDE_INT mask;
   rtx target, op0, op1, maskop, x;
   rtx rperm[32], vperm;
 
@@ -46826,7 +46870,7 @@
     case V16SImode:
     case V8DImode:
       for (i = 0; i < nelt; ++i)
-	mask |= (d->perm[i] >= nelt) << i;
+	mask |= ((unsigned HOST_WIDE_INT) (d->perm[i] >= nelt)) << i;
       break;
 
     case V2DImode:
@@ -51694,7 +51738,9 @@
       case DFmode:
       /* case SCmode: */
       /* case DCmode: */
-	break;
+	if (!AGGREGATE_TYPE_P (ret_type))
+	  break;
+	/* FALLTHRU */
       default:
 	warning_at (DECL_SOURCE_LOCATION (node->decl), 0,
 		    "unsupported return type %qT for simd\n", ret_type);
@@ -51703,25 +51749,34 @@
 
   tree t;
   int i;
+  tree type_arg_types = TYPE_ARG_TYPES (TREE_TYPE (node->decl));
+  bool decl_arg_p = (node->definition || type_arg_types == NULL_TREE);
 
-  for (t = DECL_ARGUMENTS (node->decl), i = 0; t; t = DECL_CHAIN (t), i++)
-    /* FIXME: Shouldn't we allow such arguments if they are uniform?  */
-    switch (TYPE_MODE (TREE_TYPE (t)))
-      {
-      case QImode:
-      case HImode:
-      case SImode:
-      case DImode:
-      case SFmode:
-      case DFmode:
-      /* case SCmode: */
-      /* case DCmode: */
-	break;
-      default:
-	warning_at (DECL_SOURCE_LOCATION (node->decl), 0,
-		    "unsupported argument type %qT for simd\n", TREE_TYPE (t));
-	return 0;
-      }
+  for (t = (decl_arg_p ? DECL_ARGUMENTS (node->decl) : type_arg_types), i = 0;
+       t && t != void_list_node; t = TREE_CHAIN (t), i++)
+    {
+      tree arg_type = decl_arg_p ? TREE_TYPE (t) : TREE_VALUE (t);
+      switch (TYPE_MODE (arg_type))
+	{
+	case QImode:
+	case HImode:
+	case SImode:
+	case DImode:
+	case SFmode:
+	case DFmode:
+	/* case SCmode: */
+	/* case DCmode: */
+	  if (!AGGREGATE_TYPE_P (arg_type))
+	    break;
+	  /* FALLTHRU */
+	default:
+	  if (clonei->args[i].arg_type == SIMD_CLONE_ARG_TYPE_UNIFORM)
+	    break;
+	  warning_at (DECL_SOURCE_LOCATION (node->decl), 0,
+		      "unsupported argument type %qT for simd\n", arg_type);
+	  return 0;
+	}
+    }
 
   if (clonei->cilk_elemental)
     {
@@ -51933,7 +51988,7 @@
      there is no adddf3 pattern (since x87 floating point only has
      XFmode operations) so the default hook implementation gets this
      wrong.  */
-  return TARGET_80387 || TARGET_SSE_MATH;
+  return TARGET_80387 || (TARGET_SSE && TARGET_SSE_MATH);
 }
 
 /* Implement TARGET_ATOMIC_ASSIGN_EXPAND_FENV.  */
@@ -51941,7 +51996,7 @@
 static void
 ix86_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
 {
-  if (!TARGET_80387 && !TARGET_SSE_MATH)
+  if (!TARGET_80387 && !(TARGET_SSE && TARGET_SSE_MATH))
     return;
   tree exceptions_var = create_tmp_var_raw (integer_type_node);
   if (TARGET_80387)
@@ -51976,7 +52031,7 @@
       tree update_fldenv = build_call_expr (fldenv, 1, fenv_addr);
       *update = build2 (COMPOUND_EXPR, void_type_node, *update, update_fldenv);
     }
-  if (TARGET_SSE_MATH)
+  if (TARGET_SSE && TARGET_SSE_MATH)
     {
       tree mxcsr_orig_var = create_tmp_var_raw (unsigned_type_node);
       tree mxcsr_mod_var = create_tmp_var_raw (unsigned_type_node);
@@ -52301,10 +52356,8 @@
   rtx rem = assign_386_stack_local (mode, SLOT_TEMP);
 
   rtx quot = emit_library_call_value (libfunc, NULL_RTX, LCT_NORMAL,
-				    mode, 3,
-				    op0, GET_MODE (op0),
-				    op1, GET_MODE (op1),
-				    XEXP (rem, 0), Pmode);
+				      mode, 3, op0, mode, op1, mode,
+				      XEXP (rem, 0), Pmode);
   *quot_p = quot;
   *rem_p = rem;
 }
@@ -52335,7 +52388,7 @@
 	  return FLT_EVAL_METHOD_PROMOTE_TO_FLOAT;
 	else if (!TARGET_MIX_SSE_I387)
 	  {
-	    if (!TARGET_SSE_MATH)
+	    if (!(TARGET_SSE && TARGET_SSE_MATH))
 	      return FLT_EVAL_METHOD_PROMOTE_TO_LONG_DOUBLE;
 	    else if (TARGET_SSE2)
 	      return FLT_EVAL_METHOD_PROMOTE_TO_FLOAT;
Index: gcc/config/darwin-protos.h
===================================================================
--- a/src/gcc/config/darwin-protos.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/darwin-protos.h	(.../branches/gcc-7-branch)
@@ -53,8 +53,6 @@
 
 #endif /* TREE_CODE */
 
-extern void machopic_finish (FILE *);
-
 extern int machopic_reloc_rw_mask (void);
 extern section *machopic_select_section (tree, int, unsigned HOST_WIDE_INT);
 
Index: gcc/config/sh/sh.c
===================================================================
--- a/src/gcc/config/sh/sh.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/sh/sh.c	(.../branches/gcc-7-branch)
@@ -713,7 +713,7 @@
     {
       if (tokens[i] == "strict")
 	ret.strict = true;
-      else if (tokens[i].find ("gbr-offset=") == 0)
+      else if (!tokens[i].compare (0, strlen ("gbr-offset="), "gbr-offset="))
 	{
 	  std::string offset_str = tokens[i].substr (strlen ("gbr-offset="));
 	  ret.tcb_gbr_offset = integral_argument (offset_str.c_str ());
@@ -934,11 +934,13 @@
   if (flag_unsafe_math_optimizations)
     {
       /* Enable fsca insn for SH4A if not otherwise specified by the user.  */
-      if (global_options_set.x_TARGET_FSCA == 0 && TARGET_SH4A_FP)
+      if (global_options_set.x_TARGET_FSCA == 0
+	  && (TARGET_SH4A_FP || TARGET_FPU_SH4_300))
 	TARGET_FSCA = 1;
 
       /* Enable fsrra insn for SH4A if not otherwise specified by the user.  */
-      if (global_options_set.x_TARGET_FSRRA == 0 && TARGET_SH4A_FP)
+      if (global_options_set.x_TARGET_FSRRA == 0
+	  && (TARGET_SH4A_FP || TARGET_FPU_SH4_300))
 	TARGET_FSRRA = 1;
     }
 
@@ -10814,12 +10816,6 @@
 	  emit_insn (gen_add2_insn (scratch0, GEN_INT (vcall_offset)));
 	  offset_addr = scratch0;
 	}
-      else if (scratch0 != scratch1)
-	{
-	  emit_move_insn (scratch1, GEN_INT (vcall_offset));
-	  emit_insn (gen_add2_insn (scratch0, scratch1));
-	  offset_addr = scratch0;
-	}
       else
 	gcc_unreachable (); /* FIXME */
       emit_load_ptr (scratch0, offset_addr);
@@ -12014,9 +12010,11 @@
 	rtx r = gen_reg_rtx (SImode);
 	rtx_insn* i0;
 	if (from_mode == QImode)
-	  i0 = emit_insn_after (gen_extendqisi2 (r, set_src), insn);
+	  i0 = sh_check_add_incdec_notes (
+			emit_insn_after (gen_extendqisi2 (r, set_src), insn));
 	else if (from_mode == HImode)
-	  i0 = emit_insn_after (gen_extendhisi2 (r, set_src), insn);
+	  i0 = sh_check_add_incdec_notes (
+			emit_insn_after (gen_extendhisi2 (r, set_src), insn));
 	else
 	  gcc_unreachable ();
 
@@ -12434,7 +12432,7 @@
 sh_emit_mode_set (int entity ATTRIBUTE_UNUSED, int mode,
 		  int prev_mode, HARD_REG_SET regs_live ATTRIBUTE_UNUSED)
 {
-  if ((TARGET_SH4A_FP || TARGET_SH4_300)
+  if ((TARGET_SH4A_FP || TARGET_FPU_SH4_300)
       && prev_mode != FP_MODE_NONE && prev_mode != mode)
     {
       emit_insn (gen_toggle_pr ());
Index: gcc/config/sh/sh.h
===================================================================
--- a/src/gcc/config/sh/sh.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/sh/sh.h	(.../branches/gcc-7-branch)
@@ -69,6 +69,8 @@
    FPU is disabled (which makes it compatible with SH4al-dsp).  */
 #define TARGET_SH4A_FP (TARGET_SH4A && TARGET_FPU_ANY)
 
+/* True if the FPU is a SH4-300 variant.  */
+#define TARGET_FPU_SH4_300 (TARGET_FPU_ANY && TARGET_SH4_300)
 
 /* This is not used by the SH2E calling convention  */
 #define TARGET_VARARGS_PRETEND_ARGS(FUN_DECL) \
Index: gcc/config/sh/sh.md
===================================================================
--- a/src/gcc/config/sh/sh.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/sh/sh.md	(.../branches/gcc-7-branch)
@@ -9161,7 +9161,7 @@
 	(xor:SI (reg:SI FPSCR_REG) (const_int FPSCR_PR)))
    (set (reg:SI FPSCR_MODES_REG)
 	(unspec_volatile:SI [(const_int 0)] UNSPECV_FPSCR_MODES))]
-  "TARGET_SH4A_FP"
+  "TARGET_SH4A_FP || TARGET_FPU_SH4_300"
   "fpchg"
   [(set_attr "type" "fpscr_toggle")])
 
@@ -9389,15 +9389,31 @@
 (define_expand "negsf2"
   [(set (match_operand:SF 0 "fp_arith_reg_operand")
 	(neg:SF (match_operand:SF 1 "fp_arith_reg_operand")))]
-  "TARGET_SH2E")
+  "TARGET_FPU_ANY"
+{
+  if (TARGET_FPU_SH4_300)
+    emit_insn (gen_negsf2_fpscr (operands[0], operands[1]));
+  else
+    emit_insn (gen_negsf2_no_fpscr (operands[0], operands[1]));
+  DONE;
+})
 
-(define_insn "*negsf2_i"
+(define_insn "negsf2_no_fpscr"
   [(set (match_operand:SF 0 "fp_arith_reg_operand" "=f")
 	(neg:SF (match_operand:SF 1 "fp_arith_reg_operand" "0")))]
-  "TARGET_SH2E"
+  "TARGET_FPU_ANY && !TARGET_FPU_SH4_300"
   "fneg	%0"
   [(set_attr "type" "fmove")])
 
+(define_insn "negsf2_fpscr"
+  [(set (match_operand:SF 0 "fp_arith_reg_operand" "=f")
+	(neg:SF (match_operand:SF 1 "fp_arith_reg_operand" "0")))
+   (use (reg:SI FPSCR_MODES_REG))]
+  "TARGET_FPU_SH4_300"
+  "fneg	%0"
+  [(set_attr "type" "fmove")
+   (set_attr "fp_mode" "single")])
+
 (define_expand "sqrtsf2"
   [(set (match_operand:SF 0 "fp_arith_reg_operand" "")
 	(sqrt:SF (match_operand:SF 1 "fp_arith_reg_operand" "")))]
@@ -9487,15 +9503,31 @@
 (define_expand "abssf2"
   [(set (match_operand:SF 0 "fp_arith_reg_operand")
 	(abs:SF (match_operand:SF 1 "fp_arith_reg_operand")))]
-  "TARGET_SH2E")
+  "TARGET_FPU_ANY"
+{
+  if (TARGET_FPU_SH4_300)
+    emit_insn (gen_abssf2_fpscr (operands[0], operands[1]));
+  else
+    emit_insn (gen_abssf2_no_fpscr (operands[0], operands[1]));
+  DONE;
+})
 
-(define_insn "*abssf2_i"
+(define_insn "abssf2_no_fpscr"
   [(set (match_operand:SF 0 "fp_arith_reg_operand" "=f")
 	(abs:SF (match_operand:SF 1 "fp_arith_reg_operand" "0")))]
-  "TARGET_SH2E"
+  "TARGET_FPU_ANY && !TARGET_FPU_SH4_300"
   "fabs	%0"
   [(set_attr "type" "fmove")])
 
+(define_insn "abssf2_fpscr"
+  [(set (match_operand:SF 0 "fp_arith_reg_operand" "=f")
+	(abs:SF (match_operand:SF 1 "fp_arith_reg_operand" "0")))
+   (use (reg:SI FPSCR_MODES_REG))]
+  "TARGET_FPU_SH4_300"
+  "fabs	%0"
+  [(set_attr "type" "fmove")
+   (set_attr "fp_mode" "single")])
+
 (define_expand "adddf3"
   [(set (match_operand:DF 0 "fp_arith_reg_operand" "")
 	(plus:DF (match_operand:DF 1 "fp_arith_reg_operand" "")
@@ -9671,12 +9703,28 @@
 (define_expand "negdf2"
   [(set (match_operand:DF 0 "fp_arith_reg_operand")
 	(neg:DF (match_operand:DF 1 "fp_arith_reg_operand")))]
-  "TARGET_FPU_DOUBLE")
+  "TARGET_FPU_DOUBLE"
+{
+  if (TARGET_FPU_SH4_300)
+    emit_insn (gen_negdf2_fpscr (operands[0], operands[1]));
+  else
+    emit_insn (gen_negdf2_no_fpscr (operands[0], operands[1]));
+  DONE;
+})
 
-(define_insn "*negdf2_i"
+(define_insn "negdf2_fpscr"
   [(set (match_operand:DF 0 "fp_arith_reg_operand" "=f")
+	(neg:DF (match_operand:DF 1 "fp_arith_reg_operand" "0")))
+   (use (reg:SI FPSCR_MODES_REG))]
+  "TARGET_FPU_SH4_300"
+  "fneg	%0"
+  [(set_attr "type" "fmove")
+   (set_attr "fp_mode" "double")])
+
+(define_insn "negdf2_no_fpscr"
+  [(set (match_operand:DF 0 "fp_arith_reg_operand" "=f")
 	(neg:DF (match_operand:DF 1 "fp_arith_reg_operand" "0")))]
-  "TARGET_FPU_DOUBLE"
+  "TARGET_FPU_DOUBLE && !TARGET_FPU_SH4_300"
   "fneg	%0"
   [(set_attr "type" "fmove")])
 
@@ -9702,15 +9750,31 @@
 (define_expand "absdf2"
   [(set (match_operand:DF 0 "fp_arith_reg_operand")
 	(abs:DF (match_operand:DF 1 "fp_arith_reg_operand")))]
-  "TARGET_FPU_DOUBLE")
+  "TARGET_FPU_DOUBLE"
+{
+  if (TARGET_FPU_SH4_300)
+    emit_insn (gen_absdf2_fpscr (operands[0], operands[1]));
+  else
+    emit_insn (gen_absdf2_no_fpscr (operands[0], operands[1]));
+  DONE;
+})
 
-(define_insn "*absdf2_i"
+(define_insn "absdf2_no_fpscr"
   [(set (match_operand:DF 0 "fp_arith_reg_operand" "=f")
 	(abs:DF (match_operand:DF 1 "fp_arith_reg_operand" "0")))]
-  "TARGET_FPU_DOUBLE"
+  "TARGET_FPU_DOUBLE && !TARGET_FPU_SH4_300"
   "fabs	%0"
   [(set_attr "type" "fmove")])
 
+(define_insn "absdf2_fpscr"
+  [(set (match_operand:DF 0 "fp_arith_reg_operand" "=f")
+	(abs:DF (match_operand:DF 1 "fp_arith_reg_operand" "0")))
+   (use (reg:SI FPSCR_MODES_REG))]
+  "TARGET_FPU_SH4_300"
+  "fabs	%0"
+  [(set_attr "type" "fmove")
+   (set_attr "fp_mode" "double")])
+
 (define_expand "extendsfdf2"
   [(set (match_operand:DF 0 "fp_arith_reg_operand" "")
 	(float_extend:DF (match_operand:SF 1 "fpul_operand" "")))]
Index: gcc/config/avr/avr.c
===================================================================
--- a/src/gcc/config/avr/avr.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/avr/avr.c	(.../branches/gcc-7-branch)
@@ -3579,13 +3579,14 @@
           gcc_unreachable();
 
         case 1:
-          return avr_asm_len ("%4lpm %0,%a2", xop, plen, 1);
+          avr_asm_len ("%4lpm %0,%a2", xop, plen, 1);
+          break;
 
         case 2:
           if (REGNO (dest) == REG_Z)
-            return avr_asm_len ("%4lpm %5,%a2+" CR_TAB
-                                "%4lpm %B0,%a2" CR_TAB
-                                "mov %A0,%5", xop, plen, 3);
+            avr_asm_len ("%4lpm %5,%a2+" CR_TAB
+                         "%4lpm %B0,%a2" CR_TAB
+                         "mov %A0,%5", xop, plen, 3);
           else
             {
               avr_asm_len ("%4lpm %A0,%a2+" CR_TAB
@@ -3614,9 +3615,9 @@
                        "%4lpm %B0,%a2+", xop, plen, 2);
 
           if (REGNO (dest) == REG_Z - 2)
-            return avr_asm_len ("%4lpm %5,%a2+" CR_TAB
-                                "%4lpm %C0,%a2" CR_TAB
-                                "mov %D0,%5", xop, plen, 3);
+            avr_asm_len ("%4lpm %5,%a2+" CR_TAB
+                         "%4lpm %C0,%a2" CR_TAB
+                         "mov %D0,%5", xop, plen, 3);
           else
             {
               avr_asm_len ("%4lpm %C0,%a2+" CR_TAB
Index: gcc/config/xtensa/xtensa.c
===================================================================
--- a/src/gcc/config/xtensa/xtensa.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/xtensa/xtensa.c	(.../branches/gcc-7-branch)
@@ -2802,7 +2802,8 @@
 			    gen_rtx_SET (mem, reg));
 	    }
 	}
-      if (total_size > 1024)
+      if (total_size > 1024
+	  || (!callee_save_size && total_size > 128))
 	{
 	  rtx tmp_reg = gen_rtx_REG (Pmode, A9_REG);
 	  emit_move_insn (tmp_reg, GEN_INT (total_size -
Index: gcc/config/aarch64/cortex-a57-fma-steering.c
===================================================================
--- a/src/gcc/config/aarch64/cortex-a57-fma-steering.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/aarch64/cortex-a57-fma-steering.c	(.../branches/gcc-7-branch)
@@ -404,7 +404,7 @@
 
   /* Update root nodes' pointer to forest.  */
   for (other_root_iter = other_roots->begin ();
-       other_root_iter != other_roots->end (); other_root_iter++)
+       other_root_iter != other_roots->end (); ++other_root_iter)
     (*other_root_iter)->set_forest (this);
 
   /* Remove other_forest from the list of forests and move its tree roots in
@@ -845,14 +845,13 @@
 			void (*process_node) (fma_forest *, fma_node *),
 			bool free)
 {
-  vec<fma_node *> to_process;
+  auto_vec<fma_node *> to_process;
+  auto_vec<fma_node *> to_free;
   std::list<fma_forest *>::iterator forest_iter;
 
-  to_process.create (0);
-
   /* For each forest.  */
   for (forest_iter = this->m_fma_forests.begin ();
-       forest_iter != this->m_fma_forests.end (); forest_iter++)
+       forest_iter != this->m_fma_forests.end (); ++forest_iter)
     {
       std::list<fma_root_node *>::iterator root_iter;
 
@@ -861,7 +860,7 @@
 
       /* For each tree root in this forest.  */
       for (root_iter = (*forest_iter)->get_roots ()->begin ();
-	   root_iter != (*forest_iter)->get_roots ()->end (); root_iter++)
+	   root_iter != (*forest_iter)->get_roots ()->end (); ++root_iter)
 	{
 	  if (process_root)
 	    process_root (*forest_iter, *root_iter);
@@ -879,17 +878,23 @@
 	  if (process_node)
 	    process_node (*forest_iter, node);
 
-	  /* Absence of children might indicate an alternate root of a *chain*.
-	     It's ok to skip it here as the chain will be renamed when
-	     processing the canonical root for that chain.  */
-	  if (node->get_children ()->empty ())
-	    continue;
-
 	  for (child_iter = node->get_children ()->begin ();
-	       child_iter != node->get_children ()->end (); child_iter++)
+	       child_iter != node->get_children ()->end (); ++child_iter)
 	    to_process.safe_push (*child_iter);
+
+	  /* Defer freeing so that the process_node callback can access the
+	     parent and children of the node being processed.  */
 	  if (free)
+	    to_free.safe_push (node);
+	}
+
+      if (free)
+	{
+	  delete *forest_iter;
+
+	  while (!to_free.is_empty ())
 	    {
+	      fma_node *node = to_free.pop ();
 	      if (node->root_p ())
 		delete static_cast<fma_root_node *> (node);
 	      else
@@ -896,11 +901,7 @@
 		delete node;
 	    }
 	}
-      if (free)
-	delete *forest_iter;
     }
-
-  to_process.release ();
 }
 
 /* Build the dependency trees of FMUL and FMADD/FMSUB instructions.  */
Index: gcc/config/aarch64/iterators.md
===================================================================
--- a/src/gcc/config/aarch64/iterators.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/aarch64/iterators.md	(.../branches/gcc-7-branch)
@@ -438,7 +438,8 @@
 (define_mode_attr sizen [(QI "8") (HI "16") (SI "32") (DI "64")])
 
 ;; Give the ordinal of the MSB in the mode
-(define_mode_attr sizem1 [(QI "#7") (HI "#15") (SI "#31") (DI "#63")])
+(define_mode_attr sizem1 [(QI "#7") (HI "#15") (SI "#31") (DI "#63")
+			  (HF "#15") (SF "#31") (DF "#63")])
 
 ;; Attribute to describe constants acceptable in logical operations
 (define_mode_attr lconst [(SI "K") (DI "L")])
@@ -507,7 +508,7 @@
 			  (V8HF "16b") (V2SF  "8b")
 			  (V4SF "16b") (V2DF  "16b")
 			  (DI   "8b")  (DF    "8b")
-			  (SI   "8b")])
+			  (SI   "8b")  (SF    "8b")])
 
 ;; Define element mode for each vector mode.
 (define_mode_attr VEL [(V8QI "QI") (V16QI "QI")
@@ -648,6 +649,9 @@
 ;; Double vector types for ALLX.
 (define_mode_attr Vallxd [(QI "8b") (HI "4h") (SI "2s")])
 
+;; Mode with floating-point values replaced by like-sized integers.
+(define_mode_attr V_INT_EQUIV [(DF "DI") (SF "SI")])
+
 ;; Mode of result of comparison operations.
 (define_mode_attr V_cmp_result [(V8QI "V8QI") (V16QI "V16QI")
 				(V4HI "V4HI") (V8HI  "V8HI")
Index: gcc/config/aarch64/aarch64.md
===================================================================
--- a/src/gcc/config/aarch64/aarch64.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/aarch64/aarch64.md	(.../branches/gcc-7-branch)
@@ -140,6 +140,7 @@
     UNSPEC_RSQRTS
     UNSPEC_NZCV
     UNSPEC_XPACLRI
+    UNSPEC_COPYSIGN
 ])
 
 (define_c_enum "unspecv" [
@@ -5003,45 +5004,45 @@
 ;;   LDR d2, #(1 << 63)
 ;;   BSL v2.8b, [y], [x]
 ;;
-;; or another, equivalent, sequence using one of BSL/BIT/BIF.
-;; aarch64_simd_bsldf will select the best suited of these instructions
-;; to generate based on register allocation, and knows how to partially
-;; constant fold based on the values of X and Y, so expand through that.
+;; or another, equivalent, sequence using one of BSL/BIT/BIF.  Because
+;; we expect these operations to nearly always operate on
+;; floating-point values, we do not want the operation to be
+;; simplified into a bit-field insert operation that operates on the
+;; integer side, since typically that would involve three inter-bank
+;; register copies.  As we do not expect copysign to be followed by
+;; other logical operations on the result, it seems preferable to keep
+;; this as an unspec operation, rather than exposing the underlying
+;; logic to the compiler.
 
-(define_expand "copysigndf3"
-  [(match_operand:DF 0 "register_operand")
-   (match_operand:DF 1 "register_operand")
-   (match_operand:DF 2 "register_operand")]
+(define_expand "copysign<GPF:mode>3"
+  [(match_operand:GPF 0 "register_operand")
+   (match_operand:GPF 1 "register_operand")
+   (match_operand:GPF 2 "register_operand")]
   "TARGET_FLOAT && TARGET_SIMD"
 {
-  rtx mask = gen_reg_rtx (DImode);
-  emit_move_insn (mask, GEN_INT (HOST_WIDE_INT_1U << 63));
-  emit_insn (gen_aarch64_simd_bsldf (operands[0], mask,
-				     operands[2], operands[1]));
+  rtx bitmask = gen_reg_rtx (<V_INT_EQUIV>mode);
+  emit_move_insn (bitmask, GEN_INT (HOST_WIDE_INT_M1U
+				<< (GET_MODE_BITSIZE (<MODE>mode) - 1)));
+  emit_insn (gen_copysign<mode>3_insn (operands[0], operands[1], operands[2],
+				       bitmask));
   DONE;
 }
 )
 
-;; As above, but we must first get to a 64-bit value if we wish to use
-;; aarch64_simd_bslv2sf.
-
-(define_expand "copysignsf3"
-  [(match_operand:SF 0 "register_operand")
-   (match_operand:SF 1 "register_operand")
-   (match_operand:SF 2 "register_operand")]
+(define_insn "copysign<GPF:mode>3_insn"
+  [(set (match_operand:GPF 0 "register_operand" "=w,w,w,r")
+	(unspec:GPF [(match_operand:GPF 1 "register_operand" "w,0,w,r")
+		     (match_operand:GPF 2 "register_operand" "w,w,0,0")
+		     (match_operand:<V_INT_EQUIV> 3 "register_operand"
+		     "0,w,w,X")]
+	 UNSPEC_COPYSIGN))]
   "TARGET_FLOAT && TARGET_SIMD"
-{
-  rtx mask = gen_reg_rtx (DImode);
-
-  /* Juggle modes to get us in to a vector mode for BSL.  */
-  rtx op1 = lowpart_subreg (V2SFmode, operands[1], SFmode);
-  rtx op2 = lowpart_subreg (V2SFmode, operands[2], SFmode);
-  rtx tmp = gen_reg_rtx (V2SFmode);
-  emit_move_insn (mask, GEN_INT (HOST_WIDE_INT_1U << 31));
-  emit_insn (gen_aarch64_simd_bslv2sf (tmp, mask, op2, op1));
-  emit_move_insn (operands[0], lowpart_subreg (SFmode, tmp, V2SFmode));
-  DONE;
-}
+  "@
+   bsl\\t%0.<Vbtype>, %2.<Vbtype>, %1.<Vbtype>
+   bit\\t%0.<Vbtype>, %2.<Vbtype>, %3.<Vbtype>
+   bif\\t%0.<Vbtype>, %1.<Vbtype>, %3.<Vbtype>
+   bfxil\\t%<w1>0, %<w1>1, #0, <sizem1>"
+  [(set_attr "type" "neon_bsl<q>,neon_bsl<q>,neon_bsl<q>,bfm")]
 )
 
 ;; -------------------------------------------------------------------
Index: gcc/config/aarch64/aarch64-c.c
===================================================================
--- a/src/gcc/config/aarch64/aarch64-c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/aarch64/aarch64-c.c	(.../branches/gcc-7-branch)
@@ -134,6 +134,8 @@
   aarch64_def_or_undef (TARGET_CRYPTO, "__ARM_FEATURE_CRYPTO", pfile);
   aarch64_def_or_undef (TARGET_SIMD_RDMA, "__ARM_FEATURE_QRDMX", pfile);
 
+  aarch64_def_or_undef (TARGET_LSE, "__ARM_FEATURE_ATOMICS", pfile);
+
   /* Not for ACLE, but required to keep "float.h" correct if we switch
      target between implementations that do or do not support ARMv8.2-A
      16-bit floating-point extensions.  */
Index: gcc/config/rs6000/darwin64.h
===================================================================
--- a/src/gcc/config/rs6000/darwin64.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/darwin64.h	(.../branches/gcc-7-branch)
@@ -1,32 +0,0 @@
-/* Target definitions for PowerPC running Darwin (Mac OS X).
-   Copyright (C) 2006-2017 Free Software Foundation, Inc.
-   Contributed by Apple Computer Inc.
-
-   This file is part of GCC.
-
-   GCC is free software; you can redistribute it and/or modify it
-   under the terms of the GNU General Public License as published
-   by the Free Software Foundation; either version 3, or (at your
-   option) any later version.
-
-   GCC is distributed in the hope that it will be useful, but WITHOUT
-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-   License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with GCC; see the file COPYING3.  If not see
-   <http://www.gnu.org/licenses/>.  */
-
-#undef  TARGET_DEFAULT
-#define TARGET_DEFAULT (MASK_POWERPC64 | MASK_64BIT \
-			| MASK_MULTIPLE | MASK_PPC_GFXOPT)
-
-#undef DARWIN_ARCH_SPEC
-#define DARWIN_ARCH_SPEC "%{m32:ppc;:ppc64}"
-
-#undef DARWIN_SUBARCH_SPEC
-#define DARWIN_SUBARCH_SPEC DARWIN_ARCH_SPEC
-
-#undef DARWIN_CRT2_SPEC
-#define DARWIN_CRT2_SPEC ""
Index: gcc/config/rs6000/t-darwin64
===================================================================
--- a/src/gcc/config/rs6000/t-darwin64	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/t-darwin64	(.../branches/gcc-7-branch)
@@ -1,2 +0,0 @@
-MULTILIB_OPTIONS = m32
-MULTILIB_DIRNAMES = ppc
Index: gcc/config/rs6000/t-darwin8
===================================================================
--- a/src/gcc/config/rs6000/t-darwin8	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/t-darwin8	(.../branches/gcc-7-branch)
@@ -1,3 +0,0 @@
-# 64-bit libraries can only be built in Darwin 8.x or later.
-MULTILIB_OPTIONS = m64
-MULTILIB_DIRNAMES = ppc64
Index: gcc/config/rs6000/t-darwin64-biarch
===================================================================
--- a/src/gcc/config/rs6000/t-darwin64-biarch	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/t-darwin64-biarch	(.../branches/gcc-7-branch)
@@ -0,0 +1,2 @@
+MULTILIB_OPTIONS = m32
+MULTILIB_DIRNAMES = ppc
Index: gcc/config/rs6000/darwin.md
===================================================================
--- a/src/gcc/config/rs6000/darwin.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/darwin.md	(.../branches/gcc-7-branch)
@@ -139,38 +139,6 @@
   [(set_attr "type" "store")
    (set_attr "length" "4")])
 
-;; 64-bit MachO load/store support
-(define_insn "movdi_low"
-  [(set (match_operand:DI 0 "gpc_reg_operand" "=r,*!d")
-        (mem:DI (lo_sum:DI (match_operand:DI 1 "gpc_reg_operand" "b,b")
-                           (match_operand 2 "" ""))))]
-  "TARGET_MACHO && TARGET_64BIT"
-  "@
-   ld %0,lo16(%2)(%1)
-   lfd %0,lo16(%2)(%1)"
-  [(set_attr "type" "load")
-   (set_attr "length" "4")])
-
-(define_insn "movsi_low_st"
-  [(set (mem:SI (lo_sum:SI (match_operand:SI 1 "gpc_reg_operand" "b")
-                           (match_operand 2 "" "")))
-	(match_operand:SI 0 "gpc_reg_operand" "r"))]
-  "TARGET_MACHO && ! TARGET_64BIT"
-  "stw %0,lo16(%2)(%1)"
-  [(set_attr "type" "store")
-   (set_attr "length" "4")])
-
-(define_insn "movdi_low_st"
-  [(set (mem:DI (lo_sum:DI (match_operand:DI 1 "gpc_reg_operand" "b,b")
-                           (match_operand 2 "" "")))
-	(match_operand:DI 0 "gpc_reg_operand" "r,*!d"))]
-  "TARGET_MACHO && TARGET_64BIT"
-  "@
-   std %0,lo16(%2)(%1)
-   stfd %0,lo16(%2)(%1)"
-  [(set_attr "type" "store")
-   (set_attr "length" "4")])
-
 ;; Mach-O PIC trickery.
 (define_expand "macho_high"
   [(set (match_operand 0 "" "")
Index: gcc/config/rs6000/t-darwin32-biarch
===================================================================
--- a/src/gcc/config/rs6000/t-darwin32-biarch	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/t-darwin32-biarch	(.../branches/gcc-7-branch)
@@ -0,0 +1,3 @@
+# 64-bit libraries can only be built in Darwin 8.x or later.
+MULTILIB_OPTIONS = m64
+MULTILIB_DIRNAMES = ppc64
Index: gcc/config/rs6000/darwin7.h
===================================================================
--- a/src/gcc/config/rs6000/darwin7.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/darwin7.h	(.../branches/gcc-7-branch)
@@ -28,5 +28,10 @@
   %:version-compare(!< 10.3 mmacosx-version-min= -lmx)\
   -lSystem}"
 
+/* This generation of tools (specifically the archive tool) did not
+   export weak symbols from the TOC. */
+#undef TARGET_WEAK_NOT_IN_ARCHIVE_TOC
+#define TARGET_WEAK_NOT_IN_ARCHIVE_TOC 1
+
 #undef DEF_MIN_OSX_VERSION
 #define DEF_MIN_OSX_VERSION "10.3.9"
Index: gcc/config/rs6000/t-linux
===================================================================
--- a/src/gcc/config/rs6000/t-linux	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/t-linux	(.../branches/gcc-7-branch)
@@ -5,9 +5,9 @@
 MULTILIB_OSDIRNAMES := .=../lib64$(call if_multiarch,:powerpc64-linux-gnu)
 else
 ifneq (,$(findstring spe,$(target)))
-MULTIARCH_DIRNAME := powerpc-linux-gnuspe$(if $(findstring 8548,$(with_cpu)),,v1)
+MULTIARCH_DIRNAME := $(call if_multiarch,powerpc-linux-gnuspe$(if $(findstring 8548,$(with_cpu)),,v1))
 else
-MULTIARCH_DIRNAME := powerpc-linux-gnu
+MULTIARCH_DIRNAME := $(call if_multiarch,powerpc-linux-gnu)
 endif
 endif
 ifneq (,$(findstring powerpcle,$(target)))
Index: gcc/config/rs6000/darwin32-biarch.h
===================================================================
--- a/src/gcc/config/rs6000/darwin32-biarch.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/darwin32-biarch.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,49 @@
+/* Target definitions for PowerPC running Darwin (Mac OS X) for a 32b host
+   with a 64b miultilib.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#undef DARWIN_ARCH_SPEC
+#define DARWIN_ARCH_SPEC "%{m64:ppc64;:ppc}"
+
+#undef DARWIN_SUBARCH_SPEC
+#define DARWIN_SUBARCH_SPEC "			\
+ %{m64: ppc64}					\
+ %{!m64:					\
+ %{mcpu=601:ppc601;				\
+   mcpu=603:ppc603;				\
+   mcpu=603e:ppc603;				\
+   mcpu=604:ppc604;				\
+   mcpu=604e:ppc604e;				\
+   mcpu=740:ppc750;				\
+   mcpu=750:ppc750;				\
+   mcpu=G3:ppc750;				\
+   mcpu=7400:ppc7400;				\
+   mcpu=G4:ppc7400;				\
+   mcpu=7450:ppc7450;				\
+   mcpu=970:ppc970;				\
+   mcpu=power4:ppc970;				\
+   mcpu=G5:ppc970;				\
+   :ppc}}"
+
+#undef SUBTARGET_EXTRA_SPECS
+#define SUBTARGET_EXTRA_SPECS			\
+  DARWIN_EXTRA_SPECS                            \
+  { "darwin_arch", DARWIN_ARCH_SPEC },		\
+  { "darwin_crt2", DARWIN_CRT2_SPEC },		\
+  { "darwin_subarch", DARWIN_SUBARCH_SPEC },
Index: gcc/config/rs6000/darwin64-biarch.h
===================================================================
--- a/src/gcc/config/rs6000/darwin64-biarch.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/darwin64-biarch.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,38 @@
+/* Target definitions for PowerPC64 running Darwin (Mac OS X) for a 64b host
+   supporting a 32b multilib.
+   Copyright (C) 2006-2019 Free Software Foundation, Inc.
+   Contributed by Apple Computer Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#undef  TARGET_DEFAULT
+#define TARGET_DEFAULT (MASK_POWERPC64 | MASK_64BIT \
+			| MASK_MULTIPLE | MASK_PPC_GFXOPT)
+
+#undef DARWIN_ARCH_SPEC
+#define DARWIN_ARCH_SPEC "%{m32:ppc;:ppc64}"
+
+/* Actually, there's really only 970 as an active option.  */
+#undef DARWIN_SUBARCH_SPEC
+#define DARWIN_SUBARCH_SPEC DARWIN_ARCH_SPEC
+
+#undef SUBTARGET_EXTRA_SPECS
+#define SUBTARGET_EXTRA_SPECS			\
+  DARWIN_EXTRA_SPECS                            \
+  { "darwin_arch", DARWIN_ARCH_SPEC },		\
+  { "darwin_crt2", "" },			\
+  { "darwin_subarch", DARWIN_SUBARCH_SPEC },
Index: gcc/config/rs6000/rs6000-builtin.def
===================================================================
--- a/src/gcc/config/rs6000/rs6000-builtin.def	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/rs6000-builtin.def	(.../branches/gcc-7-branch)
@@ -1000,6 +1000,7 @@
 BU_ALTIVEC_3 (VSLDOI_16QI,    "vsldoi_16qi",    CONST, 	altivec_vsldoi_v16qi)
 BU_ALTIVEC_3 (VSLDOI_8HI,     "vsldoi_8hi",     CONST, 	altivec_vsldoi_v8hi)
 BU_ALTIVEC_3 (VSLDOI_4SI,     "vsldoi_4si",     CONST, 	altivec_vsldoi_v4si)
+BU_ALTIVEC_3 (VSLDOI_2DI,     "vsldoi_2di",     CONST, 	altivec_vsldoi_v2di)
 BU_ALTIVEC_3 (VSLDOI_4SF,     "vsldoi_4sf",     CONST, 	altivec_vsldoi_v4sf)
 BU_ALTIVEC_3 (VSLDOI_2DF,     "vsldoi_2df",     CONST, 	altivec_vsldoi_v2df)
 
@@ -1988,6 +1989,9 @@
 
 BU_P9V_OVERLOAD_1 (REVB,	"revb")
 
+BU_P9V_OVERLOAD_1 (VEXTRACT_FP_FROM_SHORTH, "vextract_fp_from_shorth")
+BU_P9V_OVERLOAD_1 (VEXTRACT_FP_FROM_SHORTL, "vextract_fp_from_shortl")
+
 /* ISA 3.0 vector scalar overloaded 2 argument functions.  */
 BU_P9V_OVERLOAD_2 (VSIEDP,	"scalar_insert_exp")
 
@@ -2005,6 +2009,8 @@
 BU_P9V_VSX_1 (VEESP, "extract_exp_sp", CONST, xvxexpsp)
 BU_P9V_VSX_1 (VESDP, "extract_sig_dp", CONST, xvxsigdp)
 BU_P9V_VSX_1 (VESSP, "extract_sig_sp", CONST, xvxsigsp)
+BU_P9V_VSX_1 (VEXTRACT_FP_FROM_SHORTH, "vextract_fp_from_shorth", CONST, vextract_fp_from_shorth)
+BU_P9V_VSX_1 (VEXTRACT_FP_FROM_SHORTL, "vextract_fp_from_shortl", CONST, vextract_fp_from_shortl)
 
 /* 2 argument vsx vector functions added in ISA 3.0 (power9).  */
 BU_P9V_VSX_2 (VIEDP, "insert_exp_dp", CONST, xviexpdp)
@@ -2233,13 +2239,22 @@
 BU_FLOAT128_2 (COPYSIGNQ,	"copysignq",   CONST, copysignkf3)
 
 /* 1 argument crypto functions.  */
-BU_CRYPTO_1 (VSBOX,		"vsbox",	  CONST, crypto_vsbox)
+BU_CRYPTO_1 (VSBOX,		"vsbox",	  CONST, crypto_vsbox_v2di)
+BU_CRYPTO_1 (VSBOX_BE,		"vsbox_be",	  CONST, crypto_vsbox_v16qi)
 
 /* 2 argument crypto functions.  */
-BU_CRYPTO_2 (VCIPHER,		"vcipher",	  CONST, crypto_vcipher)
-BU_CRYPTO_2 (VCIPHERLAST,	"vcipherlast",	  CONST, crypto_vcipherlast)
-BU_CRYPTO_2 (VNCIPHER,		"vncipher",	  CONST, crypto_vncipher)
-BU_CRYPTO_2 (VNCIPHERLAST,	"vncipherlast",	  CONST, crypto_vncipherlast)
+BU_CRYPTO_2 (VCIPHER,		"vcipher",	  CONST, crypto_vcipher_v2di)
+BU_CRYPTO_2 (VCIPHER_BE,	"vcipher_be",	  CONST, crypto_vcipher_v16qi)
+BU_CRYPTO_2 (VCIPHERLAST,	"vcipherlast",
+	     CONST, crypto_vcipherlast_v2di)
+BU_CRYPTO_2 (VCIPHERLAST_BE,	"vcipherlast_be",
+	     CONST, crypto_vcipherlast_v16qi)
+BU_CRYPTO_2 (VNCIPHER,		"vncipher",	  CONST, crypto_vncipher_v2di)
+BU_CRYPTO_2 (VNCIPHER_BE,	"vncipher_be",	  CONST, crypto_vncipher_v16qi)
+BU_CRYPTO_2 (VNCIPHERLAST,	"vncipherlast",
+	     CONST, crypto_vncipherlast_v2di)
+BU_CRYPTO_2 (VNCIPHERLAST_BE,	"vncipherlast_be",
+	     CONST, crypto_vncipherlast_v16qi)
 BU_CRYPTO_2A (VPMSUMB,		"vpmsumb",	  CONST, crypto_vpmsumb)
 BU_CRYPTO_2A (VPMSUMH,		"vpmsumh",	  CONST, crypto_vpmsumh)
 BU_CRYPTO_2A (VPMSUMW,		"vpmsumw",	  CONST, crypto_vpmsumw)
Index: gcc/config/rs6000/rs6000-c.c
===================================================================
--- a/src/gcc/config/rs6000/rs6000-c.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/rs6000-c.c	(.../branches/gcc-7-branch)
@@ -910,6 +910,8 @@
     RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V4SI, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_UNPACKH, ALTIVEC_BUILTIN_VUPKHPX,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_pixel_V8HI, 0, 0 },
+  { ALTIVEC_BUILTIN_VEC_UNPACKH, ALTIVEC_BUILTIN_VUPKHPX,
+    RS6000_BTI_V2DF, RS6000_BTI_V4SF, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_VUPKHSH, ALTIVEC_BUILTIN_VUPKHSH,
     RS6000_BTI_V4SI, RS6000_BTI_V8HI, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_VUPKHSH, ALTIVEC_BUILTIN_VUPKHSH,
@@ -940,6 +942,8 @@
     RS6000_BTI_V2DI, RS6000_BTI_V4SI, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_UNPACKL, P8V_BUILTIN_VUPKLSW,
     RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V4SI, 0, 0 },
+  { ALTIVEC_BUILTIN_VEC_UNPACKL, ALTIVEC_BUILTIN_VUPKLPX,
+    RS6000_BTI_V2DF, RS6000_BTI_V4SF, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_VUPKLPX, ALTIVEC_BUILTIN_VUPKLPX,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V8HI, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_VUPKLPX, ALTIVEC_BUILTIN_VUPKLPX,
@@ -1185,6 +1189,8 @@
   { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+    RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
     RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, 0 },
   { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
     RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_V4SI, 0 },
@@ -1518,12 +1524,19 @@
     RS6000_BTI_V2DF, RS6000_BTI_unsigned_V2DI, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DF,
     RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_V2DF, 0 },
+  { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DF,
+    RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_double, 0 },
   { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DI,
+    RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_long_long, 0 },
+  { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DI,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI,
     ~RS6000_BTI_unsigned_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_long_long, 0 },
+  { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DI,
     RS6000_BTI_bool_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V4SF,
     RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF, 0 },
@@ -2535,6 +2548,18 @@
     RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_unsigned_V8HI, 0 },
   { ALTIVEC_BUILTIN_VEC_SLL, ALTIVEC_BUILTIN_VSL,
     RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
+
+  { ALTIVEC_BUILTIN_VEC_SLL, ALTIVEC_BUILTIN_VSL,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SLL, ALTIVEC_BUILTIN_VSL,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SLL, ALTIVEC_BUILTIN_VSL,
+    RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SLL, ALTIVEC_BUILTIN_VSL,
+    RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SLL, ALTIVEC_BUILTIN_VSL,
+    RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V8HI, 0 },
+
   { ALTIVEC_BUILTIN_VEC_SLO, ALTIVEC_BUILTIN_VSLO,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V16QI, 0 },
   { ALTIVEC_BUILTIN_VEC_SLO, ALTIVEC_BUILTIN_VSLO,
@@ -2735,6 +2760,10 @@
     RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_unsigned_V8HI, 0 },
   { ALTIVEC_BUILTIN_VEC_SRL, ALTIVEC_BUILTIN_VSR,
     RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SRL, ALTIVEC_BUILTIN_VSR,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SRL, ALTIVEC_BUILTIN_VSR,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V16QI, 0 },
   { ALTIVEC_BUILTIN_VEC_SRO, ALTIVEC_BUILTIN_VSRO,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V16QI, 0 },
   { ALTIVEC_BUILTIN_VEC_SRO, ALTIVEC_BUILTIN_VSRO,
@@ -2767,6 +2796,15 @@
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_V16QI, 0 },
   { ALTIVEC_BUILTIN_VEC_SRO, ALTIVEC_BUILTIN_VSRO,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SRO, ALTIVEC_BUILTIN_VSRO,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SRO, ALTIVEC_BUILTIN_VSRO,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SRO, ALTIVEC_BUILTIN_VSRO,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SRO, ALTIVEC_BUILTIN_VSRO,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V16QI, 0 },
+
   { ALTIVEC_BUILTIN_VEC_SUB, ALTIVEC_BUILTIN_VSUBUBM,
     RS6000_BTI_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_V16QI, 0 },
   { ALTIVEC_BUILTIN_VEC_SUB, ALTIVEC_BUILTIN_VSUBUBM,
@@ -3438,16 +3476,36 @@
     RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_NOT_OPAQUE },
   { ALTIVEC_BUILTIN_VEC_SLD, ALTIVEC_BUILTIN_VSLDOI_2DF,
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_NOT_OPAQUE },
+  { ALTIVEC_BUILTIN_VEC_SLD, ALTIVEC_BUILTIN_VSLDOI_2DI,
+    RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_NOT_OPAQUE },
+  { ALTIVEC_BUILTIN_VEC_SLD, ALTIVEC_BUILTIN_VSLDOI_2DI,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_NOT_OPAQUE },
+  { ALTIVEC_BUILTIN_VEC_SLD, ALTIVEC_BUILTIN_VSLDOI_2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_NOT_OPAQUE },
+
   { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DF,
     RS6000_BTI_void, RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_V2DF },
+  { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DF,
+    RS6000_BTI_void, RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_double },
   { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DI,
     RS6000_BTI_void, RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_V2DI },
   { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DI,
+    RS6000_BTI_void, RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_long_long },
+  { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DI,
     RS6000_BTI_void, RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI,
     ~RS6000_BTI_unsigned_V2DI },
   { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DI,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_long_long },
+  { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DI,
     RS6000_BTI_void, RS6000_BTI_bool_V2DI, RS6000_BTI_INTSI,
     ~RS6000_BTI_bool_V2DI },
+  { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DI,
+    RS6000_BTI_void, RS6000_BTI_bool_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_long_long },
+  { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DI,
+    RS6000_BTI_void, RS6000_BTI_bool_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_long_long },
   { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V4SF,
     RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF },
   { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V4SF,
@@ -5050,6 +5108,11 @@
   { P9V_BUILTIN_VEC_EXTRACT4B, P9V_BUILTIN_EXTRACT4B,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, 0 },
 
+  { P9V_BUILTIN_VEC_VEXTRACT_FP_FROM_SHORTH, P9V_BUILTIN_VEXTRACT_FP_FROM_SHORTH,
+    RS6000_BTI_V4SF, RS6000_BTI_unsigned_V8HI, 0, 0 },
+  { P9V_BUILTIN_VEC_VEXTRACT_FP_FROM_SHORTL, P9V_BUILTIN_VEXTRACT_FP_FROM_SHORTL,
+    RS6000_BTI_V4SF, RS6000_BTI_unsigned_V8HI, 0, 0 },
+
   { P9V_BUILTIN_VEC_VEXTULX, P9V_BUILTIN_VEXTUBLX,
     RS6000_BTI_INTQI, RS6000_BTI_UINTSI,
     RS6000_BTI_V16QI, 0 },
@@ -5958,11 +6021,15 @@
 	  tree call = NULL_TREE;
 	  int nunits = GET_MODE_NUNITS (mode);
 
-	  /* If the second argument is an integer constant, if the value is in
-	     the expected range, generate the built-in code if we can.  We need
-	     64-bit and direct move to extract the small integer vectors.  */
-	  if (TREE_CODE (arg2) == INTEGER_CST && wi::ltu_p (arg2, nunits))
+	  /* If the second argument is an integer constant, generate
+	     the built-in code if we can.  We need 64-bit and direct
+	     move to extract the small integer vectors.  */
+	  if (TREE_CODE (arg2) == INTEGER_CST)
 	    {
+	      wide_int selector
+		= wi::to_wide (arg2, TYPE_PRECISION (TREE_TYPE (arg2)));
+	      selector = wi::umod_trunc (selector, nunits);
+	      arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);
 	      switch (mode)
 		{
 		default:
@@ -6037,7 +6104,13 @@
 	    }
 
 	  if (call)
-	    return build_call_expr (call, 2, arg1, arg2);
+	    {
+	      tree result = build_call_expr (call, 2, arg1, arg2);
+	      /* Coerce the result to vector element type.  May be no-op.  */
+	      arg1_inner_type = TREE_TYPE (arg1_type);
+	      result = fold_convert (arg1_inner_type, result);
+	      return result;
+	    }
 	}
 
       /* Build *(((arg1_inner_type*)&(vector type){arg1})+arg2). */
@@ -6131,11 +6204,14 @@
       /* If we can use the VSX xxpermdi instruction, use that for insert.  */
       mode = TYPE_MODE (arg1_type);
       if ((mode == V2DFmode || mode == V2DImode) && VECTOR_UNIT_VSX_P (mode)
-	  && TREE_CODE (arg2) == INTEGER_CST
-	  && wi::ltu_p (arg2, 2))
+	  && TREE_CODE (arg2) == INTEGER_CST)
 	{
+	  wide_int selector
+	    = wi::to_wide (arg2, TYPE_PRECISION (TREE_TYPE (arg2)));
+	  selector = wi::umod_trunc (selector, 2);
 	  tree call = NULL_TREE;
 
+	  arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);
 	  if (mode == V2DFmode)
 	    call = rs6000_builtin_decls[VSX_BUILTIN_VEC_SET_V2DF];
 	  else if (mode == V2DImode)
@@ -6147,11 +6223,12 @@
 	    return build_call_expr (call, 3, arg1, arg0, arg2);
 	}
       else if (mode == V1TImode && VECTOR_UNIT_VSX_P (mode)
-	       && TREE_CODE (arg2) == INTEGER_CST
-	       && wi::eq_p (arg2, 0))
+	       && TREE_CODE (arg2) == INTEGER_CST)
 	{
 	  tree call = rs6000_builtin_decls[VSX_BUILTIN_VEC_SET_V1TI];
+	  wide_int selector = wi::zero(32);
 
+	  arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);
 	  /* Note, __builtin_vec_insert_<xxx> has vector and scalar types
 	     reversed.  */
 	  return build_call_expr (call, 3, arg1, arg0, arg2);
@@ -6159,10 +6236,13 @@
 
       /* Build *(((arg1_inner_type*)&(vector type){arg1})+arg2) = arg0. */
       arg1_inner_type = TREE_TYPE (arg1_type);
-      arg2 = build_binary_op (loc, BIT_AND_EXPR, arg2,
-			      build_int_cst (TREE_TYPE (arg2),
-					     TYPE_VECTOR_SUBPARTS (arg1_type)
-					     - 1), 0);
+      if (TYPE_VECTOR_SUBPARTS (arg1_type) == 1)
+	arg2 = build_int_cst (TREE_TYPE (arg2), 0);
+      else
+	arg2 = build_binary_op (loc, BIT_AND_EXPR, arg2,
+				build_int_cst (TREE_TYPE (arg2),
+					       TYPE_VECTOR_SUBPARTS (arg1_type)
+					       - 1), 0);
       decl = build_decl (loc, VAR_DECL, NULL_TREE, arg1_type);
       DECL_EXTERNAL (decl) = 0;
       TREE_PUBLIC (decl) = 0;
Index: gcc/config/rs6000/darwin.h
===================================================================
--- a/src/gcc/config/rs6000/darwin.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/darwin.h	(.../branches/gcc-7-branch)
@@ -53,17 +53,28 @@
 #define TARGET_OS_CPP_BUILTINS()			\
   do							\
     {							\
-      if (!TARGET_64BIT) builtin_define ("__ppc__");	\
-      if (TARGET_64BIT) builtin_define ("__ppc64__");	\
       builtin_define ("__POWERPC__");			\
+      builtin_define ("__PPC__");			\
+      if (TARGET_64BIT)					\
+	{						\
+	  builtin_define ("__ppc64__");			\
+	  builtin_define ("__PPC64__");			\
+	  builtin_define ("__powerpc64__");		\
+	  builtin_assert ("cpu=powerpc64");		\
+	  builtin_assert ("machine=powerpc64");		\
+	}						\
+      else						\
+	{						\
+	  builtin_define ("__ppc__");			\
+	  builtin_define_std ("PPC");			\
+	  builtin_assert ("cpu=powerpc");		\
+	  builtin_assert ("machine=powerpc");		\
+	}						\
       builtin_define ("__NATURAL_ALIGNMENT__");		\
       darwin_cpp_builtins (pfile);			\
     }							\
   while (0)
 
-/* Generate branch islands stubs if this is true.  */
-extern int darwin_emit_branch_islands;
-
 #define SUBTARGET_OVERRIDE_OPTIONS darwin_rs6000_override_options ()
 
 #define C_COMMON_OVERRIDE_OPTIONS do {					\
@@ -98,11 +109,10 @@
   %<faltivec %<fno-altivec " \
   DARWIN_CC1_SPEC
 
-#define DARWIN_ARCH_SPEC "%{m64:ppc64;:ppc}"
+/* Default to PPC for single arch builds.  */
+#define DARWIN_ARCH_SPEC "ppc"
 
 #define DARWIN_SUBARCH_SPEC "			\
- %{m64: ppc64}					\
- %{!m64:					\
  %{mcpu=601:ppc601;				\
    mcpu=603:ppc603;				\
    mcpu=603e:ppc603;				\
@@ -117,12 +127,40 @@
    mcpu=970:ppc970;				\
    mcpu=power4:ppc970;				\
    mcpu=G5:ppc970;				\
-   :ppc}}"
+   :ppc}"
 
-/* crt2.o is at least partially required for 10.3.x and earlier.  */
+/* We need to jam the crt to 10.5 for 10.6 (Rosetta) use.  */
+#undef DARWIN_CRT1_SPEC
+#define DARWIN_CRT1_SPEC						\
+  "%:version-compare(!> 10.5 mmacosx-version-min= -lcrt1.o)		\
+   %:version-compare(>< 10.5 10.7 mmacosx-version-min= -lcrt1.10.5.o)	\
+   %{fgnu-tm: -lcrttms.o}"
+
+/* crt2.o is at least partially required for 10.3.x and earlier.
+   It deals with registration of the unwind frames, where this is not
+   automatically provided by the system.  So we need it for any case that
+   might use exceptions.  */
+#undef DARWIN_CRT2_SPEC
 #define DARWIN_CRT2_SPEC \
-  "%{!m64:%:version-compare(!> 10.4 mmacosx-version-min= crt2.o%s)}"
+"%{!m64:%{shared-libgcc|static-libstdc++|fexceptions|fobjc-exceptions|fgnu-runtime: \
+   %:version-compare(!> 10.4 mmacosx-version-min= crt2.o%s) \
+  }}"
 
+/* crt3 deals with providing cxa_atexit on earlier systems (or fixing it up,
+   for broken versions).  It's only needed for c++ code, so we can make it
+   conditional on shared-libgcc since that's forced on for c++.  */
+#undef DARWIN_CRT3_SPEC
+#define DARWIN_CRT3_SPEC \
+"%{!m64:%{shared-libgcc|static-libstdc++:							\
+   %:version-compare(>< 10.4 10.5 mmacosx-version-min= crt3.o%s) \
+   %:version-compare(!> 10.4 mmacosx-version-min= crt3_2.o%s) \
+  }}"
+
+/* The PPC regs save/restore functions are leaves and could, conceivably
+   be used by the tm destructor.  */
+#undef ENDFILE_SPEC
+#define ENDFILE_SPEC TM_DESTRUCTOR " -lef_ppc"
+
 #undef SUBTARGET_EXTRA_SPECS
 #define SUBTARGET_EXTRA_SPECS			\
   DARWIN_EXTRA_SPECS                            \
@@ -244,9 +282,9 @@
 /* This is supported in cctools 465 and later.  The macro test
    above prevents using it in earlier build environments.  */
 #define ASM_OUTPUT_MAX_SKIP_ALIGN(FILE,LOG,MAX_SKIP)          \
-  if ((LOG) != 0)                                             \
+  if ((LOG) > 0)                                             \
     {                                                         \
-      if ((MAX_SKIP) == 0)                                    \
+      if ((MAX_SKIP) <= 0)                                    \
         fprintf ((FILE), "\t.p2align %d\n", (LOG));           \
       else                                                    \
         fprintf ((FILE), "\t.p2align %d,,%d\n", (LOG), (MAX_SKIP)); \
@@ -358,6 +396,7 @@
   do \
     { \
       DARWIN_REGISTER_TARGET_PRAGMAS(); \
+      targetm.target_option.pragma_parse = rs6000_pragma_target_parse; \
       targetm.resolve_overloaded_builtin = altivec_resolve_overloaded_builtin; \
     } \
   while (0)
@@ -417,6 +456,9 @@
    this will need to be modified similar to the x86 case.  */
 #define TARGET_FOLD_BUILTIN SUBTARGET_FOLD_BUILTIN
 
+/* First available SYMBOL flag bit for use by subtargets.  */
+#define SYMBOL_FLAG_SUBT_DEP (SYMBOL_FLAG_MACH_DEP)
+
 /* Use standard DWARF numbering for DWARF debugging information.  */
 #define RS6000_USE_DWARF_NUMBERING
 
Index: gcc/config/rs6000/rs6000.c
===================================================================
--- a/src/gcc/config/rs6000/rs6000.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/rs6000.c	(.../branches/gcc-7-branch)
@@ -3834,10 +3834,22 @@
       rs6000_isa_flags |= OPTION_MASK_POWERPC64;
       warning (0, "-m64 requires PowerPC64 architecture, enabling");
     }
+
+  /* The linkers [ld64] that support 64Bit do not need the JBSR longcall
+     optimisation, and will not work with the most generic case (where the
+     symbol is undefined external, but there is no symbl stub).  */
+  if (TARGET_64BIT)
+    rs6000_default_long_calls = 0;
+
+  /* ld_classic is (so far) still used for kernel (static) code, and supports
+     the JBSR longcall / branch islands.  */
   if (flag_mkernel)
     {
       rs6000_default_long_calls = 1;
-      rs6000_isa_flags |= OPTION_MASK_SOFT_FLOAT;
+
+      /* Allow a kext author to do -mkernel -mhard-float.  */
+      if (! (rs6000_isa_flags_explicit & OPTION_MASK_SOFT_FLOAT))
+        rs6000_isa_flags |= OPTION_MASK_SOFT_FLOAT;
     }
 
   /* Make -m64 imply -maltivec.  Darwin's 64-bit ABI includes
@@ -4829,6 +4841,13 @@
       else
 	rs6000_long_double_type_size = RS6000_DEFAULT_LONG_DOUBLE_SIZE;
     }
+  else if (global_options_set.x_rs6000_ieeequad)
+    {
+      if (global_options.x_rs6000_ieeequad)
+	error ("%qs requires %qs", "-mabi=ieeelongdouble", "-mlong-double-128");
+      else
+	error ("%qs requires %qs", "-mabi=ibmlongdouble", "-mlong-double-128");
+    }
 
   /* Set -mabi=ieeelongdouble on some old targets.  Note, AIX and Darwin
      explicitly redefine TARGET_IEEEQUAD to 0, so those systems will not
@@ -4838,6 +4857,11 @@
     rs6000_ieeequad = 1;
 #endif
 
+  if (global_options_set.x_rs6000_ieeequad
+      && global_options.x_rs6000_ieeequad
+      && (!TARGET_POPCNTD || !TARGET_VSX))
+    error ("%qs requires full ISA 2.06 support", "-mabi=ieeelongdouble");
+
   /* Enable the default support for IEEE 128-bit floating point on Linux VSX
      sytems, but don't enable the __float128 keyword.  */
   if (TARGET_VSX && TARGET_LONG_DOUBLE_128
@@ -7643,7 +7667,6 @@
 	default:
 	  break;
 	case V1TImode:
-	  gcc_assert (INTVAL (elt) == 0 && inner_mode == TImode);
 	  emit_move_insn (target, gen_lowpart (TImode, vec));
 	  break;
 	case V2DFmode:
@@ -7694,6 +7717,10 @@
 
       switch (mode)
 	{
+	case V1TImode:
+	  emit_move_insn (target, gen_lowpart (TImode, vec));
+	  return;
+
 	case V2DFmode:
 	  emit_insn (gen_vsx_extract_v2df_var (target, vec, elt));
 	  return;
@@ -7723,18 +7750,32 @@
 	}
     }
 
-  gcc_assert (CONST_INT_P (elt));
-
   /* Allocate mode-sized buffer.  */
   mem = assign_stack_temp (mode, GET_MODE_SIZE (mode));
 
   emit_move_insn (mem, vec);
+  if (CONST_INT_P (elt))
+    {
+      int modulo_elt = INTVAL (elt) % GET_MODE_NUNITS (mode);
 
-  /* Add offset to field within buffer matching vector element.  */
-  mem = adjust_address_nv (mem, inner_mode,
-			   INTVAL (elt) * GET_MODE_SIZE (inner_mode));
+      /* Add offset to field within buffer matching vector element.  */
+      mem = adjust_address_nv (mem, inner_mode,
+			       modulo_elt * GET_MODE_SIZE (inner_mode));
+      emit_move_insn (target, adjust_address_nv (mem, inner_mode, 0));
+    }
+  else
+    {
+      unsigned int ele_size = GET_MODE_SIZE (inner_mode);
+      rtx num_ele_m1 = GEN_INT (GET_MODE_NUNITS (mode) - 1);
+      rtx new_addr = gen_reg_rtx (Pmode);
 
-  emit_move_insn (target, adjust_address_nv (mem, inner_mode, 0));
+      elt = gen_rtx_AND (Pmode, elt, num_ele_m1);
+      if (ele_size > 1)
+	elt = gen_rtx_MULT (Pmode, elt, GEN_INT (ele_size));
+      new_addr = gen_rtx_PLUS (Pmode, XEXP (mem, 0), elt);
+      new_addr = change_address (mem, inner_mode, new_addr);
+      emit_move_insn (target, new_addr);
+    }
 }
 
 /* Helper function to return the register number of a RTX.  */
@@ -7915,7 +7956,7 @@
 			      rtx tmp_altivec)
 {
   machine_mode mode = GET_MODE (src);
-  machine_mode scalar_mode = GET_MODE (dest);
+  machine_mode scalar_mode = GET_MODE_INNER (GET_MODE (src));
   unsigned scalar_size = GET_MODE_SIZE (scalar_mode);
   int byte_shift = exact_log2 (scalar_size);
 
@@ -7926,6 +7967,10 @@
      systems.  */
   if (MEM_P (src))
     {
+      int num_elements = GET_MODE_NUNITS (mode);
+      rtx num_ele_m1 = GEN_INT (num_elements - 1);
+
+      emit_insn (gen_anddi3 (element, element, num_ele_m1));
       gcc_assert (REG_P (tmp_gpr));
       emit_move_insn (dest, rs6000_adjust_vec_address (dest, src, element,
 						       tmp_gpr, scalar_mode));
@@ -7934,7 +7979,9 @@
 
   else if (REG_P (src) || SUBREG_P (src))
     {
-      int bit_shift = byte_shift + 3;
+      int num_elements = GET_MODE_NUNITS (mode);
+      int bits_in_element = GET_MODE_BITSIZE (GET_MODE_INNER (mode));
+      int bit_shift = 7 - exact_log2 (num_elements);
       rtx element2;
       int dest_regno = regno_or_subregno (dest);
       int src_regno = regno_or_subregno (src);
@@ -8010,7 +8057,7 @@
 	{
 	  if (!VECTOR_ELT_ORDER_BIG)
 	    {
-	      rtx num_ele_m1 = GEN_INT (GET_MODE_NUNITS (mode) - 1);
+	      rtx num_ele_m1 = GEN_INT (num_elements - 1);
 
 	      emit_insn (gen_anddi3 (tmp_gpr, element, num_ele_m1));
 	      emit_insn (gen_subdi3 (tmp_gpr, num_ele_m1, tmp_gpr));
@@ -8068,8 +8115,8 @@
 	    emit_insn (gen_vsx_vslo_v2di (tmp_altivec_di, src_v2di,
 					  tmp_altivec));
 	    emit_move_insn (tmp_gpr_di, tmp_altivec_di);
-	    emit_insn (gen_ashrdi3 (tmp_gpr_di, tmp_gpr_di,
-				    GEN_INT (64 - (8 * scalar_size))));
+	    emit_insn (gen_lshrdi3 (tmp_gpr_di, tmp_gpr_di,
+				    GEN_INT (64 - bits_in_element)));
 	    return;
 	  }
 
@@ -8538,6 +8585,101 @@
   return NULL_RTX;
 }
 
+/* This tests that a lo_sum {constant, symbol, symbol+offset} is valid for
+   the mode.  If we can't find (or don't know) the alignment of the symbol
+   we assume (optimistically) that it's sufficiently aligned [??? maybe we
+   should be pessimistic].  Offsets are validated in the same way as for
+   reg + offset.  */
+static bool
+darwin_rs6000_legitimate_lo_sum_const_p (rtx x, machine_mode mode)
+{
+  if (GET_CODE (x) == CONST)
+    x = XEXP (x, 0);
+
+  if (GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_MACHOPIC_OFFSET)
+    x =  XVECEXP (x, 0, 0);
+
+  rtx sym = NULL_RTX;
+  unsigned HOST_WIDE_INT offset = 0;
+
+  if (GET_CODE (x) == PLUS)
+    {
+      sym = XEXP (x, 0);
+      if (! SYMBOL_REF_P (sym))
+	return false;
+      if (!CONST_INT_P (XEXP (x, 1)))
+	return false;
+      offset = INTVAL (XEXP (x, 1));
+    }
+  else if (SYMBOL_REF_P (x))
+    sym = x;
+  else if (CONST_INT_P (x))
+    offset = INTVAL (x);
+  else if (GET_CODE (x) == LABEL_REF)
+    offset = 0; // We assume code labels are Pmode aligned
+  else
+    return false; // not sure what we have here.
+
+  /* If we don't know the alignment of the thing to which the symbol refers,
+     we assume optimistically it is "enough".
+     ??? maybe we should be pessimistic instead.  */
+  unsigned align = 0;
+
+  if (sym)
+    {
+      tree decl = SYMBOL_REF_DECL (sym);
+#if TARGET_MACHO
+      if (MACHO_SYMBOL_INDIRECTION_P (sym))
+      /* The decl in an indirection symbol is the original one, which might
+	 be less aligned than the indirection.  Our indirections are always
+	 pointer-aligned.  */
+	;
+      else
+#endif
+      if (decl && DECL_ALIGN (decl))
+	align = DECL_ALIGN_UNIT (decl);
+   }
+
+  unsigned int extra = 0;
+  switch (mode)
+    {
+    case DFmode:
+    case DDmode:
+    case DImode:
+      /* If we are using VSX scalar loads, restrict ourselves to reg+reg
+	 addressing.  */
+      if (VECTOR_MEM_VSX_P (mode))
+	return false;
+
+      if (!TARGET_POWERPC64)
+	extra = 4;
+      else if ((offset & 3) || (align & 3))
+	return false;
+      break;
+
+    case TFmode:
+    case IFmode:
+    case KFmode:
+    case TDmode:
+    case TImode:
+    case PTImode:
+      extra = 8;
+      if (!TARGET_POWERPC64)
+	extra = 12;
+      else if ((offset & 3) || (align & 3))
+	return false;
+      break;
+
+    default:
+      break;
+    }
+
+  /* We only care if the access(es) would cause a change to the high part.  */
+  offset = ((offset & 0xffff) ^ 0x8000) - 0x8000;
+  return IN_RANGE (offset, -(HOST_WIDE_INT_1 << 15),
+                            (HOST_WIDE_INT_1 << 15) - 1 - extra);
+}
+
 /* Return true if the MEM operand is a memory operand suitable for use
    with a (full width, possibly multiple) gpr load/store.  On
    powerpc64 this means the offset must be divisible by 4.
@@ -8572,7 +8714,13 @@
       && legitimate_indirect_address_p (XEXP (addr, 0), false))
     return true;
 
-  /* Don't allow non-offsettable addresses.  See PRs 83969 and 84279.  */
+  /* We need to look through Mach-O PIC unspecs to determine if a lo_sum is
+     really OK.  Doing this early avoids teaching all the other machinery
+     about them.  */
+  if (TARGET_MACHO && GET_CODE (addr) == LO_SUM)
+    return darwin_rs6000_legitimate_lo_sum_const_p (XEXP (addr, 1), mode);
+
+  /* Only allow offsettable addresses.  See PRs 83969 and 84279.  */
   if (!rs6000_offsettable_memref_p (op, mode, false))
     return false;
 
@@ -13109,7 +13257,9 @@
       if (elt_mode == TDmode && (cum->fregno % 2) == 1)
 	cum->fregno++;
 
-      if (USE_FP_FOR_ARG_P (cum, elt_mode))
+      if (USE_FP_FOR_ARG_P (cum, elt_mode)
+	  && !(TARGET_AIX && !TARGET_ELF
+	       && type != NULL && AGGREGATE_TYPE_P (type)))
 	{
 	  rtx rvec[GP_ARG_NUM_REG + AGGR_ARG_NUM_REG + 1];
 	  rtx r, off;
@@ -13245,7 +13395,9 @@
 
   align_words = rs6000_parm_start (mode, type, cum->words);
 
-  if (USE_FP_FOR_ARG_P (cum, elt_mode))
+  if (USE_FP_FOR_ARG_P (cum, elt_mode)
+      && !(TARGET_AIX && !TARGET_ELF
+	   && type != NULL && AGGREGATE_TYPE_P (type)))
     {
       unsigned long n_fpreg = (GET_MODE_SIZE (elt_mode) + 7) >> 3;
 
@@ -16146,9 +16298,17 @@
   op0 = expand_normal (arg0);
   op1 = expand_normal (arg1);
 
-  /* Call get_element_number to validate arg1 if it is a constant.  */
   if (TREE_CODE (arg1) == INTEGER_CST)
-    (void) get_element_number (TREE_TYPE (arg0), arg1);
+    {
+      unsigned HOST_WIDE_INT elt;
+      unsigned HOST_WIDE_INT size = TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0));
+      unsigned int truncated_selector;
+      /* Even if !tree_fits_uhwi_p (arg1)), TREE_INT_CST_LOW (arg0)
+	 returns low-order bits of INTEGER_CST for modulo indexing.  */
+      elt = TREE_INT_CST_LOW (arg1);
+      truncated_selector = elt % size;
+      op1 = GEN_INT (truncated_selector);
+    }
 
   tmode = TYPE_MODE (TREE_TYPE (TREE_TYPE (arg0)));
   mode0 = TYPE_MODE (TREE_TYPE (arg0));
@@ -18806,6 +18966,7 @@
     {
       /* unsigned 1 argument functions.  */
     case CRYPTO_BUILTIN_VSBOX:
+    case CRYPTO_BUILTIN_VSBOX_BE:
     case P8V_BUILTIN_VGBBD:
     case MISC_BUILTIN_CDTBCD:
     case MISC_BUILTIN_CBCDTD:
@@ -18819,9 +18980,13 @@
     case ALTIVEC_BUILTIN_VMULOUB:
     case ALTIVEC_BUILTIN_VMULOUH:
     case CRYPTO_BUILTIN_VCIPHER:
+    case CRYPTO_BUILTIN_VCIPHER_BE:
     case CRYPTO_BUILTIN_VCIPHERLAST:
+    case CRYPTO_BUILTIN_VCIPHERLAST_BE:
     case CRYPTO_BUILTIN_VNCIPHER:
+    case CRYPTO_BUILTIN_VNCIPHER_BE:
     case CRYPTO_BUILTIN_VNCIPHERLAST:
+    case CRYPTO_BUILTIN_VNCIPHERLAST_BE:
     case CRYPTO_BUILTIN_VPMSUMB:
     case CRYPTO_BUILTIN_VPMSUMH:
     case CRYPTO_BUILTIN_VPMSUMW:
@@ -23931,7 +24096,7 @@
 	{
 	  const char *name = XSTR (x, 0);
 #if TARGET_MACHO
-	  if (darwin_emit_branch_islands
+	  if (darwin_symbol_stubs
 	      && MACHOPIC_INDIRECT
 	      && machopic_classify_symbol (x) == MACHOPIC_UNDEFINED_FUNCTION)
 	    name = machopic_indirection_name (x, /*stub_p=*/true);
@@ -26714,27 +26879,35 @@
 static bool
 rs6000_reg_live_or_pic_offset_p (int reg)
 {
-  /* We need to mark the PIC offset register live for the same conditions
-     as it is set up, or otherwise it won't be saved before we clobber it.  */
-
   if (reg == RS6000_PIC_OFFSET_TABLE_REGNUM && !TARGET_SINGLE_PIC_BASE)
     {
+      /* When calling eh_return, we must return true for all the cases
+	 where conditional_register_usage marks the PIC offset reg
+	 call used or fixed.  */
+      if (crtl->calls_eh_return
+	  && ((DEFAULT_ABI == ABI_V4 && flag_pic)
+	      || (DEFAULT_ABI == ABI_DARWIN && flag_pic)
+	      || (TARGET_TOC && TARGET_MINIMAL_TOC)))
+	return true;
+
+      /* We need to mark the PIC offset register live for the same
+	 conditions as it is set up in rs6000_emit_prologue, or
+	 otherwise it won't be saved before we clobber it.  */
       if (TARGET_TOC && TARGET_MINIMAL_TOC
-	  && (crtl->calls_eh_return
-	      || df_regs_ever_live_p (reg)
-	      || !constant_pool_empty_p ()))
+	  && !constant_pool_empty_p ())
 	return true;
 
-      if ((DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_DARWIN)
-	  && flag_pic)
+      if (DEFAULT_ABI == ABI_V4
+	  && (flag_pic == 1 || (flag_pic && TARGET_SECURE_PLT))
+	  && df_regs_ever_live_p (RS6000_PIC_OFFSET_TABLE_REGNUM))
 	return true;
+
+      if (DEFAULT_ABI == ABI_DARWIN
+	  && flag_pic && crtl->uses_pic_offset_table)
+	return true;
     }
 
-  /* If the function calls eh_return, claim used all the registers that would
-     be checked for liveness otherwise.  */
-
-  return ((crtl->calls_eh_return || df_regs_ever_live_p (reg))
-	  && !call_used_regs[reg]);
+  return !call_used_regs[reg] && df_regs_ever_live_p (reg);
 }
 
 /* Return the first fixed-point register that is required to be
@@ -35852,7 +36025,7 @@
 	     int cookie_operand_number)
 {
   static char buf[256];
-  if (darwin_emit_branch_islands
+  if (darwin_symbol_stubs
       && GET_CODE (operands[dest_operand_number]) == SYMBOL_REF
       && (INTVAL (operands[cookie_operand_number]) & CALL_LONG))
     {
@@ -36409,6 +36582,10 @@
 			   rs6000_xcoff_output_readwrite_section_asm_op,
 			   &xcoff_private_data_section_name);
 
+  read_only_private_data_section
+    = get_unnamed_section (0, rs6000_xcoff_output_readonly_section_asm_op,
+			   &xcoff_private_rodata_section_name);
+
   tls_data_section
     = get_unnamed_section (SECTION_TLS,
 			   rs6000_xcoff_output_tls_section_asm_op,
@@ -36419,10 +36596,6 @@
 			   rs6000_xcoff_output_tls_section_asm_op,
 			   &xcoff_private_data_section_name);
 
-  read_only_private_data_section
-    = get_unnamed_section (0, rs6000_xcoff_output_readonly_section_asm_op,
-			   &xcoff_private_data_section_name);
-
   toc_section
     = get_unnamed_section (0, rs6000_xcoff_output_toc_section_asm_op, NULL);
 
@@ -36603,6 +36776,8 @@
 			   main_input_filename, ".bss_");
   rs6000_gen_section_name (&xcoff_private_data_section_name,
 			   main_input_filename, ".rw_");
+  rs6000_gen_section_name (&xcoff_private_rodata_section_name,
+			   main_input_filename, ".rop_");
   rs6000_gen_section_name (&xcoff_read_only_section_name,
 			   main_input_filename, ".ro_");
   rs6000_gen_section_name (&xcoff_tls_data_section_name,
@@ -41934,6 +42109,11 @@
 	  case UNSPEC_REDUC_PLUS:
 	  case UNSPEC_REDUC:
 	    return 1;
+	  case UNSPEC_VPMSUM:
+	    /* vpmsumd is not swappable, but vpmsum[bhw] are.  */
+	    if (GET_MODE (op) == V2DImode)
+	      return 0;
+	    break;
 	  }
       }
 
@@ -43013,6 +43193,14 @@
   /* Pre-pass to recombine lvx and stvx patterns so we don't lose info.  */
   recombine_lvx_stvx_patterns (fun);
 
+  /* Rebuild ud- and du-chains.  */                                            
+  df_remove_problem (df_chain);
+  df_process_deferred_rescans ();
+  df_set_flags (DF_RD_PRUNE_DEAD_DEFS);
+  df_chain_add_problem (DF_DU_CHAIN | DF_UD_CHAIN);
+  df_analyze ();
+  df_set_flags (DF_DEFER_INSN_RESCAN);
+
   /* Allocate structure to represent webs of insns.  */
   insn_entry = XCNEWVEC (swap_web_entry, get_max_uid ());
 
Index: gcc/config/rs6000/vsx.md
===================================================================
--- a/src/gcc/config/rs6000/vsx.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/vsx.md	(.../branches/gcc-7-branch)
@@ -339,6 +339,7 @@
    UNSPEC_VSX_CVDPSXWS
    UNSPEC_VSX_CVDPUXWS
    UNSPEC_VSX_CVSPDP
+   UNSPEC_VSX_CVHPSP
    UNSPEC_VSX_CVSPDPN
    UNSPEC_VSX_CVDPSPN
    UNSPEC_VSX_CVSXWDP
@@ -353,6 +354,8 @@
    UNSPEC_VSX_ROUND_I
    UNSPEC_VSX_ROUND_IC
    UNSPEC_VSX_SLDWI
+   UNSPEC_VSX_XXPERM
+
    UNSPEC_VSX_XXSPLTW
    UNSPEC_VSX_XXSPLTD
    UNSPEC_VSX_DIVSD
@@ -370,6 +373,8 @@
    UNSPEC_VSX_SIEXPDP
    UNSPEC_VSX_SCMPEXPDP
    UNSPEC_VSX_STSTDC
+   UNSPEC_VSX_VEXTRACT_FP_FROM_SHORTH
+   UNSPEC_VSX_VEXTRACT_FP_FROM_SHORTL
    UNSPEC_VSX_VXEXP
    UNSPEC_VSX_VXSIG
    UNSPEC_VSX_VIEXP
@@ -1779,6 +1784,15 @@
   "xscvspdp %x0,%x1"
   [(set_attr "type" "fp")])
 
+;; Generate xvcvhpsp instruction
+(define_insn "vsx_xvcvhpsp"
+  [(set (match_operand:V4SF 0 "vsx_register_operand" "=wa")
+	(unspec:V4SF [(match_operand: V16QI 1 "vsx_register_operand" "wa")]
+		     UNSPEC_VSX_CVHPSP))]
+  "TARGET_P9_VECTOR"
+  "xvcvhpsp %x0,%x1"
+  [(set_attr "type" "vecfloat")])
+
 ;; xscvdpsp used for splat'ing a scalar to V4SF, knowing that the internal SF
 ;; format of scalars is actually DF.
 (define_insn "vsx_xscvdpsp_scalar"
@@ -2438,7 +2452,7 @@
 	 (match_operand:VSX_D 1 "memory_operand" "m,m")
 	 (parallel [(match_operand:QI 2 "const_0_to_1_operand" "n,n")])))
    (clobber (match_scratch:P 3 "=&b,&b"))]
-  "VECTOR_MEM_VSX_P (<VSX_D:MODE>mode)"
+  "TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<VSX_D:MODE>mode)"
   "#"
   "&& reload_completed"
   [(set (match_dup 0) (match_dup 4))]
@@ -2947,9 +2961,9 @@
   DONE;
 })
 
-(define_insn_and_split "*vsx_extract_<VSX_EXTRACT_I:mode>_<SDI:mode>_var"
-  [(set (match_operand:SDI 0 "gpc_reg_operand" "=r,r,r")
-	(zero_extend:SDI
+(define_insn_and_split "*vsx_extract_<mode>_<VS_scalar>mode_var"
+  [(set (match_operand:<VS_scalar> 0 "gpc_reg_operand" "=r,r,r")
+	(zero_extend:<VS_scalar>
 	 (unspec:<VSX_EXTRACT_I:VS_scalar>
 	  [(match_operand:VSX_EXTRACT_I 1 "input_operand" "wK,v,m")
 	   (match_operand:DI 2 "gpc_reg_operand" "r,r,r")]
@@ -2961,7 +2975,7 @@
   "&& reload_completed"
   [(const_int 0)]
 {
-  machine_mode smode = <VSX_EXTRACT_I:MODE>mode;
+  machine_mode smode = <VS_scalar>mode;
   rs6000_split_vec_extract_var (gen_rtx_REG (smode, REGNO (operands[0])),
 				operands[1], operands[2],
 				operands[3], operands[4]);
@@ -3585,7 +3599,7 @@
 	  (match_dup 1))
 	 (parallel [(const_int 1)])))
    (clobber (match_scratch:DF 2 "=0,0,&wd,&wa"))]
-  "VECTOR_UNIT_VSX_P (V2DFmode)"
+  "BYTES_BIG_ENDIAN && VECTOR_UNIT_VSX_P (V2DFmode)"
   "#"
   ""
   [(const_int 0)]
@@ -3613,7 +3627,7 @@
    (clobber (match_scratch:V4SF 2 "=&wf,&wa"))
    (clobber (match_scratch:V4SF 3 "=&wf,&wa"))
    (clobber (match_scratch:V4SF 4 "=0,0"))]
-  "VECTOR_UNIT_VSX_P (V4SFmode)"
+  "BYTES_BIG_ENDIAN && VECTOR_UNIT_VSX_P (V4SFmode)"
   "#"
   ""
   [(const_int 0)]
@@ -4180,7 +4194,65 @@
 }
   [(set_attr "type" "vecperm")])
 
-
+;; Generate vector extract four float 32 values from left four elements
+;; of eight element vector of float 16 values.
+(define_expand "vextract_fp_from_shorth"
+  [(set (match_operand:V4SF 0 "register_operand" "=wa")
+	(unspec:V4SF [(match_operand:V8HI 1 "register_operand" "wa")]
+   UNSPEC_VSX_VEXTRACT_FP_FROM_SHORTH))]
+  "TARGET_P9_VECTOR"
+{
+  int vals[16] = {15, 14, 0, 0, 13, 12, 0, 0, 11, 10, 0, 0, 9, 8, 0, 0};
+  int i;
+
+  rtx rvals[16];
+  rtx mask = gen_reg_rtx (V16QImode);
+  rtx tmp = gen_reg_rtx (V16QImode);
+  rtvec v;
+
+  for (i = 0; i < 16; i++)
+    rvals[i] = GEN_INT (vals[i]);
+
+  /* xvcvhpsp - vector convert F16 to vector F32 requires the four F16
+     inputs in half words 1,3,5,7 (IBM numbering).  Use xxperm to move
+     src half words 0,1,2,3 for the conversion instruction.  */
+  v = gen_rtvec_v (16, rvals);
+  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));
+  emit_insn (gen_altivec_vperm_v8hiv16qi (tmp, operands[1],
+					  operands[1], mask));
+  emit_insn (gen_vsx_xvcvhpsp (operands[0], tmp));
+  DONE;
+})
+
+;; Generate vector extract four float 32 values from right four elements
+;; of eight element vector of float 16 values.
+(define_expand "vextract_fp_from_shortl"
+  [(set (match_operand:V4SF 0 "register_operand" "=wa")
+	(unspec:V4SF [(match_operand:V8HI 1 "register_operand" "wa")]
+	UNSPEC_VSX_VEXTRACT_FP_FROM_SHORTL))]
+  "TARGET_P9_VECTOR"
+{
+  int vals[16] = {7, 6, 0, 0, 5, 4, 0, 0, 3, 2, 0, 0, 1, 0, 0, 0};
+  int i;
+  rtx rvals[16];
+  rtx mask = gen_reg_rtx (V16QImode);
+  rtx tmp = gen_reg_rtx (V16QImode);
+  rtvec v;
+
+  for (i = 0; i < 16; i++)
+    rvals[i] = GEN_INT (vals[i]);
+
+  /* xvcvhpsp - vector convert F16 to vector F32 requires the four F16
+     inputs in half words 1,3,5,7 (IBM numbering).  Use xxperm to move
+     src half words 4,5,6,7 for the conversion instruction.  */
+  v = gen_rtvec_v (16, rvals);
+  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));
+  emit_insn (gen_altivec_vperm_v8hiv16qi (tmp, operands[1],
+					  operands[1], mask));
+  emit_insn (gen_vsx_xvcvhpsp (operands[0], tmp));
+  DONE;
+})
+
 ;; Support for ISA 3.0 vector byte reverse
 
 ;; Swap all bytes with in a vector
Index: gcc/config/rs6000/altivec.md
===================================================================
--- a/src/gcc/config/rs6000/altivec.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/altivec.md	(.../branches/gcc-7-branch)
@@ -154,9 +154,6 @@
    UNSPEC_BCDADD
    UNSPEC_BCDSUB
    UNSPEC_BCD_OVERFLOW
-   UNSPEC_CMPRB
-   UNSPEC_CMPRB2
-   UNSPEC_CMPEQB
    UNSPEC_VRLMI
    UNSPEC_VRLNM
 ])
@@ -3787,223 +3784,6 @@
   [(set_attr "length" "4")
    (set_attr "type" "vecsimple")])
 
-(define_insn "darn_32"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-        (unspec:SI [(const_int 0)] UNSPEC_DARN_32))]
-  "TARGET_P9_MISC"
-  "darn %0,0"
-  [(set_attr "type" "integer")])
-
-(define_insn "darn_raw"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-        (unspec:DI [(const_int 0)] UNSPEC_DARN_RAW))]
-  "TARGET_P9_MISC && TARGET_64BIT"
-  "darn %0,2"
-  [(set_attr "type" "integer")])
-
-(define_insn "darn"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-        (unspec:DI [(const_int 0)] UNSPEC_DARN))]
-  "TARGET_P9_MISC && TARGET_64BIT"
-  "darn %0,1"
-  [(set_attr "type" "integer")])
-
-;; Test byte within range.
-;;
-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
-;; represents a byte whose value is ignored in this context and
-;; vv, the least significant byte, holds the byte value that is to
-;; be tested for membership within the range specified by operand 2.
-;; The bytes of operand 2 are organized as xx:xx:hi:lo.
-;;
-;; Return in target register operand 0 a value of 1 if lo <= vv and
-;; vv <= hi.  Otherwise, set register operand 0 to 0.
-;;
-;; Though the instructions to which this expansion maps operate on
-;; 64-bit registers, the current implementation only operates on
-;; SI-mode operands as the high-order bits provide no information
-;; that is not already available in the low-order bits.  To avoid the
-;; costs of data widening operations, future enhancements might allow
-;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.
-(define_expand "cmprb"
-  [(set (match_dup 3)
-	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
-		    (match_operand:SI 2 "gpc_reg_operand" "r")]
-	 UNSPEC_CMPRB))
-   (set (match_operand:SI 0 "gpc_reg_operand" "=r")
-	(if_then_else:SI (lt (match_dup 3)
-			     (const_int 0))
-			 (const_int -1)
-			 (if_then_else (gt (match_dup 3)
-					   (const_int 0))
-				       (const_int 1)
-				       (const_int 0))))]
-  "TARGET_P9_MISC"
-{
-  operands[3] = gen_reg_rtx (CCmode);
-})
-
-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
-;; represents a byte whose value is ignored in this context and
-;; vv, the least significant byte, holds the byte value that is to
-;; be tested for membership within the range specified by operand 2.
-;; The bytes of operand 2 are organized as xx:xx:hi:lo.
-;;
-;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if
-;; lo <= vv and vv <= hi.  Otherwise, set the GT bit to 0.  The other
-;; 3 bits of the target CR register are all set to 0.
-(define_insn "*cmprb_internal"
-  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
-	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
-		    (match_operand:SI 2 "gpc_reg_operand" "r")]
-	 UNSPEC_CMPRB))]
-  "TARGET_P9_MISC"
-  "cmprb %0,0,%1,%2"
-  [(set_attr "type" "logical")])
-
-;; Set operand 0 register to -1 if the LT bit (0x8) of condition
-;; register operand 1 is on.  Otherwise, set operand 0 register to 1
-;; if the GT bit (0x4) of condition register operand 1 is on.
-;; Otherwise, set operand 0 to 0.  Note that the result stored into
-;; register operand 0 is non-zero iff either the LT or GT bits are on
-;; within condition register operand 1.
-(define_insn "setb_signed"
-   [(set (match_operand:SI 0 "gpc_reg_operand" "=r")
-	 (if_then_else:SI (lt (match_operand:CC 1 "cc_reg_operand" "y")
-			      (const_int 0))
-			  (const_int -1)
-			  (if_then_else (gt (match_dup 1)
-					    (const_int 0))
-					(const_int 1)
-					(const_int 0))))]
-  "TARGET_P9_MISC"
-  "setb %0,%1"
-  [(set_attr "type" "logical")])
-
-(define_insn "setb_unsigned"
-   [(set (match_operand:SI 0 "gpc_reg_operand" "=r")
-	 (if_then_else:SI (ltu (match_operand:CCUNS 1 "cc_reg_operand" "y")
-			      (const_int 0))
-			  (const_int -1)
-			  (if_then_else (gtu (match_dup 1)
-					    (const_int 0))
-					(const_int 1)
-					(const_int 0))))]
-  "TARGET_P9_MISC"
-  "setb %0,%1"
-  [(set_attr "type" "logical")])
-
-;; Test byte within two ranges.
-;;
-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
-;; represents a byte whose value is ignored in this context and
-;; vv, the least significant byte, holds the byte value that is to
-;; be tested for membership within the range specified by operand 2.
-;; The bytes of operand 2 are organized as hi_1:lo_1:hi_2:lo_2.
-;;
-;; Return in target register operand 0 a value of 1 if (lo_1 <= vv and
-;; vv <= hi_1) or if (lo_2 <= vv and vv <= hi_2).  Otherwise, set register
-;; operand 0 to 0.
-;;
-;; Though the instructions to which this expansion maps operate on
-;; 64-bit registers, the current implementation only operates on
-;; SI-mode operands as the high-order bits provide no information
-;; that is not already available in the low-order bits.  To avoid the
-;; costs of data widening operations, future enhancements might allow
-;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.
-(define_expand "cmprb2"
-  [(set (match_dup 3)
-	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
-		    (match_operand:SI 2 "gpc_reg_operand" "r")]
-	 UNSPEC_CMPRB2))
-   (set (match_operand:SI 0 "gpc_reg_operand" "=r")
-	(if_then_else:SI (lt (match_dup 3)
-			     (const_int 0))
-			 (const_int -1)
-			 (if_then_else (gt (match_dup 3)
-					   (const_int 0))
-				       (const_int 1)
-				       (const_int 0))))]
-  "TARGET_P9_MISC"
-{
-  operands[3] = gen_reg_rtx (CCmode);
-})
-
-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
-;; represents a byte whose value is ignored in this context and
-;; vv, the least significant byte, holds the byte value that is to
-;; be tested for membership within the ranges specified by operand 2.
-;; The bytes of operand 2 are organized as hi_1:lo_1:hi_2:lo_2.
-;;
-;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if
-;; (lo_1 <= vv and vv <= hi_1) or if (lo_2 <= vv and vv <= hi_2).
-;; Otherwise, set the GT bit to 0.  The other 3 bits of the target
-;; CR register are all set to 0.
-(define_insn "*cmprb2_internal"
-  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
-	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
-		    (match_operand:SI 2 "gpc_reg_operand" "r")]
-	 UNSPEC_CMPRB2))]
-  "TARGET_P9_MISC"
-  "cmprb %0,1,%1,%2"
-  [(set_attr "type" "logical")])
-
-;; Test byte membership within set of 8 bytes.
-;;
-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
-;; represents a byte whose value is ignored in this context and
-;; vv, the least significant byte, holds the byte value that is to
-;; be tested for membership within the set specified by operand 2.
-;; The bytes of operand 2 are organized as e0:e1:e2:e3:e4:e5:e6:e7.
-;;
-;; Return in target register operand 0 a value of 1 if vv equals one
-;; of the values e0, e1, e2, e3, e4, e5, e6, or e7.  Otherwise, set
-;; register operand 0 to 0.  Note that the 8 byte values held within
-;; operand 2 need not be unique.
-;;
-;; Though the instructions to which this expansion maps operate on
-;; 64-bit registers, the current implementation requires that operands
-;; 0 and 1 have mode SI as the high-order bits provide no information
-;; that is not already available in the low-order bits.  To avoid the
-;; costs of data widening operations, future enhancements might allow
-;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.
-(define_expand "cmpeqb"
-  [(set (match_dup 3)
-	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
-		    (match_operand:DI 2 "gpc_reg_operand" "r")]
-	 UNSPEC_CMPEQB))
-   (set (match_operand:SI 0 "gpc_reg_operand" "=r")
-	(if_then_else:SI (lt (match_dup 3)
-			     (const_int 0))
-			 (const_int -1)
-			 (if_then_else (gt (match_dup 3)
-					   (const_int 0))
-				       (const_int 1)
-				       (const_int 0))))]
-  "TARGET_P9_MISC && TARGET_64BIT"
-{
-  operands[3] = gen_reg_rtx (CCmode);
-})
-
-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
-;; represents a byte whose value is ignored in this context and
-;; vv, the least significant byte, holds the byte value that is to
-;; be tested for membership within the set specified by operand 2.
-;; The bytes of operand 2 are organized as e0:e1:e2:e3:e4:e5:e6:e7.
-;;
-;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if vv
-;; equals one of the values e0, e1, e2, e3, e4, e5, e6, or e7.  Otherwise,
-;; set the GT bit to zero.  The other 3 bits of the target CR register
-;; are all set to 0.
-(define_insn "*cmpeqb_internal"
-  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
-	 (unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
-		     (match_operand:DI 2 "gpc_reg_operand" "r")]
-	  UNSPEC_CMPEQB))]
-  "TARGET_P9_MISC && TARGET_64BIT"
-  "cmpeqb %0,%1,%2"
-  [(set_attr "type" "logical")])
-
 (define_expand "bcd<bcd_add_sub>_<code>"
   [(parallel [(set (reg:CCFP CR6_REGNO)
 		   (compare:CCFP
Index: gcc/config/rs6000/crypto.md
===================================================================
--- a/src/gcc/config/rs6000/crypto.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/crypto.md	(.../branches/gcc-7-branch)
@@ -48,6 +48,9 @@
 ;; Iterator for VSHASIGMAD/VSHASIGMAW
 (define_mode_iterator CR_hash [V4SI V2DI])
 
+;; Iterator for VSBOX/VCIPHER/VNCIPHER/VCIPHERLAST/VNCIPHERLAST
+(define_mode_iterator CR_vqdi [V16QI V2DI])
+
 ;; Iterator for the other crypto functions
 (define_int_iterator CR_code   [UNSPEC_VCIPHER
 				UNSPEC_VNCIPHER
@@ -60,10 +63,10 @@
 			  (UNSPEC_VNCIPHERLAST "vncipherlast")])
 
 ;; 2 operand crypto instructions
-(define_insn "crypto_<CR_insn>"
-  [(set (match_operand:V2DI 0 "register_operand" "=v")
-	(unspec:V2DI [(match_operand:V2DI 1 "register_operand" "v")
-		      (match_operand:V2DI 2 "register_operand" "v")]
+(define_insn "crypto_<CR_insn>_<mode>"
+  [(set (match_operand:CR_vqdi 0 "register_operand" "=v")
+	(unspec:CR_vqdi [(match_operand:CR_vqdi 1 "register_operand" "v")
+		      (match_operand:CR_vqdi 2 "register_operand" "v")]
 		     CR_code))]
   "TARGET_CRYPTO"
   "<CR_insn> %0,%1,%2"
@@ -90,9 +93,9 @@
   [(set_attr "type" "vecperm")])
 
 ;; 1 operand crypto instruction
-(define_insn "crypto_vsbox"
-  [(set (match_operand:V2DI 0 "register_operand" "=v")
-	(unspec:V2DI [(match_operand:V2DI 1 "register_operand" "v")]
+(define_insn "crypto_vsbox_<mode>"
+  [(set (match_operand:CR_vqdi 0 "register_operand" "=v")
+	(unspec:CR_vqdi [(match_operand:CR_vqdi 1 "register_operand" "v")]
 		     UNSPEC_VSBOX))]
   "TARGET_CRYPTO"
   "vsbox %0,%1"
Index: gcc/config/rs6000/rs6000.md
===================================================================
--- a/src/gcc/config/rs6000/rs6000.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/rs6000.md	(.../branches/gcc-7-branch)
@@ -141,6 +141,9 @@
    UNSPEC_LSQ
    UNSPEC_FUSION_GPR
    UNSPEC_STACK_CHECK
+   UNSPEC_CMPRB
+   UNSPEC_CMPRB2
+   UNSPEC_CMPEQB
    UNSPEC_FUSION_P9
    UNSPEC_FUSION_ADDIS
    UNSPEC_ROUND_TO_ODD
@@ -161,6 +164,9 @@
    UNSPECV_EH_RR		; eh_reg_restore
    UNSPECV_ISYNC		; isync instruction
    UNSPECV_MFTB			; move from time base
+   UNSPECV_DARN			; darn 1 (deliver a random number)
+   UNSPECV_DARN_32		; darn 2
+   UNSPECV_DARN_RAW		; darn 0
    UNSPECV_NLGR			; non-local goto receiver
    UNSPECV_MFFS			; Move from FPSCR
    UNSPECV_MTFSF		; Move to FPSCR Fields
@@ -6740,14 +6746,6 @@
 ;; do the load 16-bits at a time.  We could do this by loading from memory,
 ;; and this is even supposed to be faster, but it is simpler not to get
 ;; integers in the TOC.
-(define_insn "movsi_low"
-  [(set (match_operand:SI 0 "gpc_reg_operand" "=r")
-        (mem:SI (lo_sum:SI (match_operand:SI 1 "gpc_reg_operand" "b")
-                           (match_operand 2 "" ""))))]
-  "TARGET_MACHO && ! TARGET_64BIT"
-  "lwz %0,lo16(%2)(%1)"
-  [(set_attr "type" "load")
-   (set_attr "length" "4")])
 
 ;;		MR           LA           LWZ          LFIWZX       LXSIWZX
 ;;		STW          STFIWX       STXSIWX      LI           LIS
@@ -8564,16 +8562,16 @@
 
 (define_insn "*movdi_internal32"
   [(set (match_operand:DI 0 "rs6000_nonimmediate_operand"
-         "=Y,        r,         r,         ^m,        ^d,         ^d,
-          r,         ^wY,       $Z,        ^wb,       $wv,        ^wi,
+         "=Y,        r,         r,         m,         ^d,         ^d,
+          r,         wY,        Z,         ^wb,       $wv,        ^wi,
           *wo,       *wo,       *wv,       *wi,       *wi,        *wv,
           *wv")
 
 	(match_operand:DI 1 "input_operand"
-          "r,        Y,         r,         d,         m,          d,
-           IJKnGHF,  wb,        wv,        wY,        Z,          wi,
-           Oj,       wM,        OjwM,      Oj,        wM,         wS,
-           wB"))]
+         "r,         Y,         r,         ^d,        m,          ^d,
+          IJKnGHF,   ^wb,       $wv,       wY,        Z,          ^wi,
+          Oj,        wM,        OjwM,      Oj,        wM,         wS,
+          wB"))]
 
   "! TARGET_POWERPC64
    && (gpc_reg_operand (operands[0], DImode)
@@ -8641,17 +8639,17 @@
 (define_insn "*movdi_internal64"
   [(set (match_operand:DI 0 "nonimmediate_operand"
                "=YZ,       r,         r,         r,         r,          r,
-                ^m,        ^d,        ^d,        ^wY,       $Z,         $wb,
+                m,         ^d,        ^d,        wY,        Z,          $wb,
                 $wv,       ^wi,       *wo,       *wo,       *wv,        *wi,
                 *wi,       *wv,       *wv,       r,         *h,         *h,
                 ?*r,       ?*wg,      ?*r,       ?*wj")
 
 	(match_operand:DI 1 "input_operand"
-                "r,        YZ,        r,         I,         L,          nF,
-                 d,        m,         d,         wb,        wv,         wY,
-                 Z,        wi,        Oj,        wM,        OjwM,       Oj,
-                 wM,       wS,        wB,        *h,        r,          0,
-                 wg,       r,         wj,        r"))]
+               "r,         YZ,        r,         I,         L,          nF,
+                ^d,        m,         ^d,        ^wb,       $wv,        wY,
+                Z,         ^wi,       Oj,        wM,        OjwM,       Oj,
+                wM,        wS,        wB,        *h,        r,          0,
+                wg,        r,         wj,        r"))]
 
   "TARGET_POWERPC64
    && (gpc_reg_operand (operands[0], DImode)
@@ -14945,7 +14943,225 @@
    "xscmpuqp %0,%1,%2"
   [(set_attr "type" "veccmp")
    (set_attr "size" "128")])
+
+;; Miscellaneous ISA 3.0 (power9) instructions
 
+(define_insn "darn_32"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (unspec_volatile:SI [(const_int 0)] UNSPECV_DARN_32))]
+  "TARGET_P9_MISC"
+  "darn %0,0"
+  [(set_attr "type" "integer")])
+
+(define_insn "darn_raw"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+        (unspec_volatile:DI [(const_int 0)] UNSPECV_DARN_RAW))]
+  "TARGET_P9_MISC && TARGET_64BIT"
+  "darn %0,2"
+  [(set_attr "type" "integer")])
+
+(define_insn "darn"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+        (unspec_volatile:DI [(const_int 0)] UNSPECV_DARN))]
+  "TARGET_P9_MISC && TARGET_64BIT"
+  "darn %0,1"
+  [(set_attr "type" "integer")])
+
+;; Test byte within range.
+;;
+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
+;; represents a byte whose value is ignored in this context and
+;; vv, the least significant byte, holds the byte value that is to
+;; be tested for membership within the range specified by operand 2.
+;; The bytes of operand 2 are organized as xx:xx:hi:lo.
+;;
+;; Return in target register operand 0 a value of 1 if lo <= vv and
+;; vv <= hi.  Otherwise, set register operand 0 to 0.
+;;
+;; Though the instructions to which this expansion maps operate on
+;; 64-bit registers, the current implementation only operates on
+;; SI-mode operands as the high-order bits provide no information
+;; that is not already available in the low-order bits.  To avoid the
+;; costs of data widening operations, future enhancements might allow
+;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.
+(define_expand "cmprb"
+  [(set (match_dup 3)
+	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
+		    (match_operand:SI 2 "gpc_reg_operand" "r")]
+	 UNSPEC_CMPRB))
+   (set (match_operand:SI 0 "gpc_reg_operand" "=r")
+	(if_then_else:SI (lt (match_dup 3)
+			     (const_int 0))
+			 (const_int -1)
+			 (if_then_else (gt (match_dup 3)
+					   (const_int 0))
+				       (const_int 1)
+				       (const_int 0))))]
+  "TARGET_P9_MISC"
+{
+  operands[3] = gen_reg_rtx (CCmode);
+})
+
+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
+;; represents a byte whose value is ignored in this context and
+;; vv, the least significant byte, holds the byte value that is to
+;; be tested for membership within the range specified by operand 2.
+;; The bytes of operand 2 are organized as xx:xx:hi:lo.
+;;
+;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if
+;; lo <= vv and vv <= hi.  Otherwise, set the GT bit to 0.  The other
+;; 3 bits of the target CR register are all set to 0.
+(define_insn "*cmprb_internal"
+  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
+	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
+		    (match_operand:SI 2 "gpc_reg_operand" "r")]
+	 UNSPEC_CMPRB))]
+  "TARGET_P9_MISC"
+  "cmprb %0,0,%1,%2"
+  [(set_attr "type" "logical")])
+
+;; Set operand 0 register to -1 if the LT bit (0x8) of condition
+;; register operand 1 is on.  Otherwise, set operand 0 register to 1
+;; if the GT bit (0x4) of condition register operand 1 is on.
+;; Otherwise, set operand 0 to 0.  Note that the result stored into
+;; register operand 0 is non-zero iff either the LT or GT bits are on
+;; within condition register operand 1.
+(define_insn "setb_signed"
+   [(set (match_operand:SI 0 "gpc_reg_operand" "=r")
+	 (if_then_else:SI (lt (match_operand:CC 1 "cc_reg_operand" "y")
+			      (const_int 0))
+			  (const_int -1)
+			  (if_then_else (gt (match_dup 1)
+					    (const_int 0))
+					(const_int 1)
+					(const_int 0))))]
+  "TARGET_P9_MISC"
+  "setb %0,%1"
+  [(set_attr "type" "logical")])
+
+(define_insn "setb_unsigned"
+   [(set (match_operand:SI 0 "gpc_reg_operand" "=r")
+	 (if_then_else:SI (ltu (match_operand:CCUNS 1 "cc_reg_operand" "y")
+			      (const_int 0))
+			  (const_int -1)
+			  (if_then_else (gtu (match_dup 1)
+					    (const_int 0))
+					(const_int 1)
+					(const_int 0))))]
+  "TARGET_P9_MISC"
+  "setb %0,%1"
+  [(set_attr "type" "logical")])
+
+;; Test byte within two ranges.
+;;
+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
+;; represents a byte whose value is ignored in this context and
+;; vv, the least significant byte, holds the byte value that is to
+;; be tested for membership within the range specified by operand 2.
+;; The bytes of operand 2 are organized as hi_1:lo_1:hi_2:lo_2.
+;;
+;; Return in target register operand 0 a value of 1 if (lo_1 <= vv and
+;; vv <= hi_1) or if (lo_2 <= vv and vv <= hi_2).  Otherwise, set register
+;; operand 0 to 0.
+;;
+;; Though the instructions to which this expansion maps operate on
+;; 64-bit registers, the current implementation only operates on
+;; SI-mode operands as the high-order bits provide no information
+;; that is not already available in the low-order bits.  To avoid the
+;; costs of data widening operations, future enhancements might allow
+;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.
+(define_expand "cmprb2"
+  [(set (match_dup 3)
+	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
+		    (match_operand:SI 2 "gpc_reg_operand" "r")]
+	 UNSPEC_CMPRB2))
+   (set (match_operand:SI 0 "gpc_reg_operand" "=r")
+	(if_then_else:SI (lt (match_dup 3)
+			     (const_int 0))
+			 (const_int -1)
+			 (if_then_else (gt (match_dup 3)
+					   (const_int 0))
+				       (const_int 1)
+				       (const_int 0))))]
+  "TARGET_P9_MISC"
+{
+  operands[3] = gen_reg_rtx (CCmode);
+})
+
+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
+;; represents a byte whose value is ignored in this context and
+;; vv, the least significant byte, holds the byte value that is to
+;; be tested for membership within the ranges specified by operand 2.
+;; The bytes of operand 2 are organized as hi_1:lo_1:hi_2:lo_2.
+;;
+;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if
+;; (lo_1 <= vv and vv <= hi_1) or if (lo_2 <= vv and vv <= hi_2).
+;; Otherwise, set the GT bit to 0.  The other 3 bits of the target
+;; CR register are all set to 0.
+(define_insn "*cmprb2_internal"
+  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
+	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
+		    (match_operand:SI 2 "gpc_reg_operand" "r")]
+	 UNSPEC_CMPRB2))]
+  "TARGET_P9_MISC"
+  "cmprb %0,1,%1,%2"
+  [(set_attr "type" "logical")])
+
+;; Test byte membership within set of 8 bytes.
+;;
+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
+;; represents a byte whose value is ignored in this context and
+;; vv, the least significant byte, holds the byte value that is to
+;; be tested for membership within the set specified by operand 2.
+;; The bytes of operand 2 are organized as e0:e1:e2:e3:e4:e5:e6:e7.
+;;
+;; Return in target register operand 0 a value of 1 if vv equals one
+;; of the values e0, e1, e2, e3, e4, e5, e6, or e7.  Otherwise, set
+;; register operand 0 to 0.  Note that the 8 byte values held within
+;; operand 2 need not be unique.
+;;
+;; Though the instructions to which this expansion maps operate on
+;; 64-bit registers, the current implementation requires that operands
+;; 0 and 1 have mode SI as the high-order bits provide no information
+;; that is not already available in the low-order bits.  To avoid the
+;; costs of data widening operations, future enhancements might allow
+;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.
+(define_expand "cmpeqb"
+  [(set (match_dup 3)
+	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
+		    (match_operand:DI 2 "gpc_reg_operand" "r")]
+	 UNSPEC_CMPEQB))
+   (set (match_operand:SI 0 "gpc_reg_operand" "=r")
+	(if_then_else:SI (lt (match_dup 3)
+			     (const_int 0))
+			 (const_int -1)
+			 (if_then_else (gt (match_dup 3)
+					   (const_int 0))
+				       (const_int 1)
+				       (const_int 0))))]
+  "TARGET_P9_MISC && TARGET_64BIT"
+{
+  operands[3] = gen_reg_rtx (CCmode);
+})
+
+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
+;; represents a byte whose value is ignored in this context and
+;; vv, the least significant byte, holds the byte value that is to
+;; be tested for membership within the set specified by operand 2.
+;; The bytes of operand 2 are organized as e0:e1:e2:e3:e4:e5:e6:e7.
+;;
+;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if vv
+;; equals one of the values e0, e1, e2, e3, e4, e5, e6, or e7.  Otherwise,
+;; set the GT bit to zero.  The other 3 bits of the target CR register
+;; are all set to 0.
+(define_insn "*cmpeqb_internal"
+  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
+	 (unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
+		     (match_operand:DI 2 "gpc_reg_operand" "r")]
+	  UNSPEC_CMPEQB))]
+  "TARGET_P9_MISC && TARGET_64BIT"
+  "cmpeqb %0,%1,%2"
+  [(set_attr "type" "logical")])
 
 
 (include "sync.md")
Index: gcc/config/rs6000/altivec.h
===================================================================
--- a/src/gcc/config/rs6000/altivec.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/rs6000/altivec.h	(.../branches/gcc-7-branch)
@@ -388,6 +388,11 @@
 #define vec_vsubuqm __builtin_vec_vsubuqm
 #define vec_vupkhsw __builtin_vec_vupkhsw
 #define vec_vupklsw __builtin_vec_vupklsw
+#define vec_sbox_be __builtin_crypto_vsbox_be
+#define vec_cipher_be __builtin_crypto_vcipher_be
+#define vec_cipherlast_be __builtin_crypto_vcipherlast_be
+#define vec_ncipher_be __builtin_crypto_vncipher_be
+#define vec_ncipherlast_be __builtin_crypto_vncipherlast_be
 #endif
 
 #ifdef __POWER9_VECTOR__
@@ -421,6 +426,11 @@
 #define vec_insert_exp __builtin_vec_insert_exp
 #define vec_test_data_class __builtin_vec_test_data_class
 
+#define vec_extract_fp_from_shorth __builtin_vec_vextract_fp_from_shorth
+#define vec_extract_fp_from_shortl __builtin_vec_vextract_fp_from_shortl
+#define vec_extract_fp32_from_shorth __builtin_vec_vextract_fp_from_shorth
+#define vec_extract_fp32_from_shortl __builtin_vec_vextract_fp_from_shortl
+
 #define scalar_extract_exp __builtin_vec_scalar_extract_exp
 #define scalar_extract_sig __builtin_vec_scalar_extract_sig
 #define scalar_insert_exp __builtin_vec_scalar_insert_exp
Index: gcc/config/darwin.c
===================================================================
--- a/src/gcc/config/darwin.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/darwin.c	(.../branches/gcc-7-branch)
@@ -71,15 +71,9 @@
    setting the second word in the .non_lazy_symbol_pointer data
    structure to symbol.  See indirect_data for the code that handles
    the extra indirection, and machopic_output_indirection and its use
-   of MACHO_SYMBOL_STATIC for the code that handles @code{static}
+   of MACHO_SYMBOL_FLAG_STATIC for the code that handles @code{static}
    symbol indirection.  */
 
-/* For darwin >= 9  (OSX 10.5) the linker is capable of making the necessary
-   branch islands and we no longer need to emit darwin stubs.
-   However, if we are generating code for earlier systems (or for use in the 
-   kernel) the stubs might still be required, and this will be set true.  */
-int darwin_emit_branch_islands = false;
-
 typedef struct GTY(()) cdtor_record {
   rtx symbol;
   int priority;		/* [con/de]structor priority */
@@ -101,6 +95,10 @@
    for weak or single-definition items.  */
 static bool ld_uses_coal_sects = false;
 
+/* Very old (ld_classic) linkers need a symbol to mark the start of
+   each FDE.  */
+static bool ld_needs_eh_markers = false;
+
 /* Section names.  */
 section * darwin_sections[NUM_DARWIN_SECTIONS];
 
@@ -246,7 +244,7 @@
 int
 machopic_symbol_defined_p (rtx sym_ref)
 {
-  if (SYMBOL_REF_FLAGS (sym_ref) & MACHO_SYMBOL_FLAG_DEFINED)
+  if (MACHO_SYMBOL_DEFINED_P (sym_ref))
     return true;
 
   /* If a symbol references local and is not an extern to this
@@ -255,7 +253,7 @@
     {
       /* If the symbol references a variable and the variable is a
 	 common symbol, then this symbol is not defined.  */
-      if (SYMBOL_REF_FLAGS (sym_ref) & MACHO_SYMBOL_FLAG_VARIABLE)
+      if (MACHO_SYMBOL_VARIABLE_P (sym_ref))
 	{
 	  tree decl = SYMBOL_REF_DECL (sym_ref);
 	  if (!decl)
@@ -451,6 +449,13 @@
   bool stub_p;
   /* True iff this stub or pointer has been referenced.  */
   bool used;
+  /* True iff a non-lazy symbol pointer should be emitted into the .data
+     section, rather than the non-lazy symbol pointers section.  The cases
+     for which this occurred seem to have been unintentional, and later
+     toolchains emit all of the indirections to the 'usual' section.  We
+     are keeping this in case it is necessary to preserve compatibility with
+     older toolchains.  */
+  bool nlsp_in_data_section;
 } machopic_indirection;
 
 struct indirection_hasher : ggc_ptr_hash<machopic_indirection>
@@ -485,7 +490,7 @@
 /* Return the name of the non-lazy pointer (if STUB_P is false) or
    stub (if STUB_B is true) corresponding to the given name.
 
-  If we have a situation like:
+  PR71767 - If we have a situation like:
 
 global_weak_symbol:
   ....
@@ -494,36 +499,22 @@
 
   ld64 will be unable to split this into two atoms (because the "L" makes
   the second symbol 'invisible').  This means that legitimate direct accesses
-  to the second symbol will appear to be non-allowed direct accesses to an
-  atom of type weak, global which are not allowed.
+  to the second symbol will appear to be direct accesses to an atom of type
+  weak, global which are not allowed.
 
-  To avoid this, we make the indirections have a leading 'l' (lower-case L)
-  which has a special meaning: linker can see this and use it to determine
-  atoms, but it is not placed into the final symbol table.
+  To avoid this, we make any data-section indirections have a leading 'l'
+  (lower-case L) which has a special meaning: linker can see this and use
+  it to determine  atoms, but it is not placed into the final symbol table.
 
-  The implementation here is somewhat heavy-handed in that it will also mark
-  indirections to the __IMPORT,__pointers section the same way which is
-  really unnecessary, since ld64 _can_ split those into atoms as they are
-  fixed size.  FIXME: determine if this is a penalty worth extra code to
-  fix.
-
+  Symbols in the non-lazy symbol pointers section (or stubs) do not have this
+  problem because ld64 already knows the size of each entry.
 */
 
 const char *
 machopic_indirection_name (rtx sym_ref, bool stub_p)
 {
-  char *buffer;
   const char *name = XSTR (sym_ref, 0);
-  size_t namelen = strlen (name);
-  machopic_indirection *p;
-  bool needs_quotes;
-  const char *suffix;
-  char L_or_l = 'L';
-  const char *prefix = user_label_prefix;
-  const char *quote = "";
-  tree id;
-
-  id = maybe_get_identifier (name);
+  tree id = maybe_get_identifier (name);
   if (id)
     {
       tree id_orig = id;
@@ -531,43 +522,47 @@
       while (IDENTIFIER_TRANSPARENT_ALIAS (id))
 	id = TREE_CHAIN (id);
       if (id != id_orig)
-	{
-	  name = IDENTIFIER_POINTER (id);
-	  namelen = strlen (name);
-	}
+	name = IDENTIFIER_POINTER (id);
     }
 
+  const char *prefix = user_label_prefix;
+  /* If we are emitting the label 'verbatim' then omit the U_L_P and count
+     the name without the leading '*'.  */
   if (name[0] == '*')
     {
       prefix = "";
       ++name;
-      --namelen;
     }
 
-  needs_quotes = name_needs_quotes (name);
-  if (needs_quotes)
-    {
-      quote = "\"";
-    }
+  /* Here we are undoing a number of causes that placed some indirections
+     (apparently erroneously) into the .data section.  Specifically, some
+     symbols that are ABI mandated indirections and some hidden symbols
+     were being placed there - which cause difficulties with later
+     versions of ld64.  Iff (after these checks) some symbol still gets an
+     indirection in the data section, we want to adjust the indirection
+     name to be linker visible to deal with PR71767 (notes above).  */
+  bool nlsp_in_data_section =
+       ! MACHO_SYMBOL_MUST_INDIRECT_P (sym_ref)
+    && ! MACHO_SYMBOL_HIDDEN_VIS_P (sym_ref)
+    && (machopic_symbol_defined_p (sym_ref) || SYMBOL_REF_LOCAL_P (sym_ref))
+    && ! indirect_data (sym_ref);
 
-  if (stub_p)
-    suffix = STUB_SUFFIX;
-  else
-    {
-      suffix = NON_LAZY_POINTER_SUFFIX;
-      /* Let the linker see this.  */
-      L_or_l = 'l';
-    }
+  const char *suffix = stub_p ? STUB_SUFFIX : NON_LAZY_POINTER_SUFFIX;
+  /* If the indirection is in the data section, let the linker see it.  */
+  char L_or_l = (!stub_p && nlsp_in_data_section) ? 'l' : 'L';
+  /* We have mangled symbols with spaces and punctuation which typically
+     need surrounding in quotes for the assembler to consume them.  */
+  const char *quote = name_needs_quotes (name) ? "\"" : "";
+  char *buffer = XALLOCAVEC (char, 2  /* strlen ("&L") or ("&l") */
+			     + strlen (prefix)
+			     + strlen (name)
+			     + strlen (suffix)
+			     + 2 * strlen (quote)
+			     + 1 /* '\0' */);
 
-  buffer = XALLOCAVEC (char, 2  /* strlen ("&L") or ("&l") */
-		   + strlen (prefix)
-		   + namelen
-		   + strlen (suffix)
-		   + 2 * strlen (quote)
-		   + 1 /* '\0' */);
-
   /* Construct the name of the non-lazy pointer or stub.  */
-  sprintf (buffer, "&%s%c%s%s%s%s", quote, L_or_l, prefix, name, suffix, quote);
+  sprintf (buffer, "&%s%c%s%s%s%s", quote, L_or_l, prefix, name,
+	   suffix, quote);
 
   if (!machopic_indirections)
     machopic_indirections = hash_table<indirection_hasher>::create_ggc (37);
@@ -576,10 +571,9 @@
     = machopic_indirections->find_slot_with_hash (buffer,
 						  htab_hash_string (buffer),
 						  INSERT);
+  machopic_indirection *p;
   if (*slot)
-    {
-      p = *slot;
-    }
+    p = *slot;
   else
     {
       p = ggc_alloc<machopic_indirection> ();
@@ -587,6 +581,7 @@
       p->ptr_name = xstrdup (buffer);
       p->stub_p = stub_p;
       p->used = false;
+      p->nlsp_in_data_section = nlsp_in_data_section;
       *slot = p;
     }
 
@@ -662,7 +657,7 @@
 	   /* some other cpu -- writeme!  */
 	   gcc_unreachable ();
 	}
-      else if (defined)
+      else if (defined && ! MACHO_SYMBOL_MUST_INDIRECT_P (orig))
 	{
 	  rtx offset = NULL;
 	  if (DARWIN_PPC || HAVE_lo_sum)
@@ -704,6 +699,7 @@
 		  machopic_indirection_name (orig, /*stub_p=*/false)));
 
       SYMBOL_REF_DATA (ptr_ref) = SYMBOL_REF_DATA (orig);
+      SYMBOL_REF_FLAGS (ptr_ref) |= MACHO_SYMBOL_FLAG_INDIRECTION;
 
       ptr_ref = gen_const_mem (Pmode, ptr_ref);
       machopic_define_symbol (ptr_ref);
@@ -786,7 +782,7 @@
 rtx
 machopic_indirect_call_target (rtx target)
 {
-  if (! darwin_emit_branch_islands)
+  if (! darwin_symbol_stubs)
     return target;
 
   if (GET_CODE (target) != MEM)
@@ -794,8 +790,7 @@
 
   if (MACHOPIC_INDIRECT
       && GET_CODE (XEXP (target, 0)) == SYMBOL_REF
-      && !(SYMBOL_REF_FLAGS (XEXP (target, 0))
-	   & MACHO_SYMBOL_FLAG_DEFINED))
+      && ! MACHO_SYMBOL_DEFINED_P (XEXP (target, 0)))
     {
       rtx sym_ref = XEXP (target, 0);
       const char *stub_name = machopic_indirection_name (sym_ref,
@@ -804,6 +799,7 @@
 
       XEXP (target, 0) = gen_rtx_SYMBOL_REF (mode, stub_name);
       SYMBOL_REF_DATA (XEXP (target, 0)) = SYMBOL_REF_DATA (sym_ref);
+      SYMBOL_REF_FLAGS (XEXP (target, 0)) |= MACHO_SYMBOL_FLAG_INDIRECTION;
       MEM_READONLY_P (target) = 1;
       MEM_NOTRAP_P (target) = 1;
     }
@@ -841,7 +837,7 @@
 	{
 	  if (reg == 0)
 	    {
-	      gcc_assert (!reload_in_progress);
+	      gcc_assert (!lra_in_progress);
 	      reg = gen_reg_rtx (Pmode);
 	    }
 
@@ -925,7 +921,7 @@
 	      emit_use (gen_rtx_REG (Pmode, PIC_OFFSET_TABLE_REGNUM));
 #endif
 
-	      if (reload_in_progress)
+	      if (lra_in_progress)
 		df_set_regs_ever_live (REGNO (pic), true);
 	      pic_ref = gen_rtx_PLUS (Pmode, pic,
 				      machopic_gen_offset (XEXP (orig, 0)));
@@ -949,7 +945,7 @@
 
 	      if (reg == 0)
 		{
-		  gcc_assert (!reload_in_progress);
+		  gcc_assert (!lra_in_progress);
 		  reg = gen_reg_rtx (Pmode);
 		}
 
@@ -995,7 +991,7 @@
 #if 0
 		  emit_use (pic_offset_table_rtx);
 #endif
-		  if (reload_in_progress)
+		  if (lra_in_progress)
 		    df_set_regs_ever_live (REGNO (pic), true);
 		  pic_ref = gen_rtx_PLUS (Pmode,
 					  pic,
@@ -1072,129 +1068,160 @@
   return pic_ref;
 }
 
-/* Output the stub or non-lazy pointer in *SLOT, if it has been used.
-   DATA is the FILE* for assembly output.  Called from
-   htab_traverse.  */
+/* Callbacks to output the stub or non-lazy pointers.
+   Each works on the item in *SLOT,if it has been used.
+   DATA is the FILE* for assembly output.
+   Called from htab_traverses, invoked from machopic_finish().  */
 
 int
-machopic_output_indirection (machopic_indirection **slot, FILE *asm_out_file)
+machopic_output_data_section_indirection (machopic_indirection **slot,
+					  FILE *asm_out_file)
 {
   machopic_indirection *p = *slot;
-  rtx symbol;
-  const char *sym_name;
-  const char *ptr_name;
 
-  if (!p->used)
+  if (!p->used || !p->nlsp_in_data_section)
     return 1;
 
-  symbol = p->symbol;
-  sym_name = XSTR (symbol, 0);
-  ptr_name = p->ptr_name;
+  rtx symbol = p->symbol;
+  /* The original symbol name.  */
+  const char *sym_name = XSTR (symbol, 0);
+  /* The name of the indirection symbol.  */
+  const char *ptr_name = p->ptr_name;
 
-  if (p->stub_p)
-    {
-      char *sym;
-      char *stub;
-      tree id;
+  switch_to_section (data_section);
+  assemble_align (GET_MODE_ALIGNMENT (Pmode));
+  assemble_label (asm_out_file, ptr_name);
+  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, sym_name),
+		    GET_MODE_SIZE (Pmode),
+		    GET_MODE_ALIGNMENT (Pmode), 1);
 
-      id = maybe_get_identifier (sym_name);
-      if (id)
-	{
-	  tree id_orig = id;
+  return 1;
+}
 
-	  while (IDENTIFIER_TRANSPARENT_ALIAS (id))
-	    id = TREE_CHAIN (id);
-	  if (id != id_orig)
-	    sym_name = IDENTIFIER_POINTER (id);
-	}
+int
+machopic_output_stub_indirection (machopic_indirection **slot,
+				  FILE *asm_out_file)
+{
+  machopic_indirection *p = *slot;
 
-      sym = XALLOCAVEC (char, strlen (sym_name) + 2);
-      if (sym_name[0] == '*' || sym_name[0] == '&')
-	strcpy (sym, sym_name + 1);
-      else if (sym_name[0] == '-' || sym_name[0] == '+')
-	strcpy (sym, sym_name);
-      else
-	sprintf (sym, "%s%s", user_label_prefix, sym_name);
+  if (!p->used || !p->stub_p)
+    return 1;
 
-      stub = XALLOCAVEC (char, strlen (ptr_name) + 2);
-      if (ptr_name[0] == '*' || ptr_name[0] == '&')
-	strcpy (stub, ptr_name + 1);
-      else
-	sprintf (stub, "%s%s", user_label_prefix, ptr_name);
+  rtx symbol = p->symbol;
+  /* The original symbol name.  */
+  const char *sym_name = XSTR (symbol, 0);
+  /* The name of the stub symbol.  */
+  const char *ptr_name = p->ptr_name;
 
-      machopic_output_stub (asm_out_file, sym, stub);
-    }
-  else if (! indirect_data (symbol)
-	   && (machopic_symbol_defined_p (symbol)
-	       || SYMBOL_REF_LOCAL_P (symbol)))
+  tree id = maybe_get_identifier (sym_name);
+  if (id)
     {
-      switch_to_section (data_section);
-      assemble_align (GET_MODE_ALIGNMENT (Pmode));
-      assemble_label (asm_out_file, ptr_name);
-      assemble_integer (gen_rtx_SYMBOL_REF (Pmode, sym_name),
-			GET_MODE_SIZE (Pmode),
-			GET_MODE_ALIGNMENT (Pmode), 1);
+      tree id_orig = id;
+
+      while (IDENTIFIER_TRANSPARENT_ALIAS (id))
+	id = TREE_CHAIN (id);
+      if (id != id_orig)
+	sym_name = IDENTIFIER_POINTER (id);
     }
+
+  char *sym = XALLOCAVEC (char, strlen (sym_name) + 2);
+  if (sym_name[0] == '*' || sym_name[0] == '&')
+    strcpy (sym, sym_name + 1);
+  else if (sym_name[0] == '-' || sym_name[0] == '+')
+    strcpy (sym, sym_name);
   else
-    {
-      rtx init = const0_rtx;
+    sprintf (sym, "%s%s", user_label_prefix, sym_name);
 
-      switch_to_section (darwin_sections[machopic_nl_symbol_ptr_section]);
+  char *stub = XALLOCAVEC (char, strlen (ptr_name) + 2);
+  if (ptr_name[0] == '*' || ptr_name[0] == '&')
+    strcpy (stub, ptr_name + 1);
+  else
+    sprintf (stub, "%s%s", user_label_prefix, ptr_name);
 
-      /* Mach-O symbols are passed around in code through indirect
-	 references and the original symbol_ref hasn't passed through
-	 the generic handling and reference-catching in
-	 output_operand, so we need to manually mark weak references
-	 as such.  */
-      if (SYMBOL_REF_WEAK (symbol))
-	{
-	  tree decl = SYMBOL_REF_DECL (symbol);
-	  gcc_assert (DECL_P (decl));
+  machopic_output_stub (asm_out_file, sym, stub);
 
-	  if (decl != NULL_TREE
-	      && DECL_EXTERNAL (decl) && TREE_PUBLIC (decl)
-	      /* Handle only actual external-only definitions, not
-		 e.g. extern inline code or variables for which
-		 storage has been allocated.  */
-	      && !TREE_STATIC (decl))
-	    {
-	      fputs ("\t.weak_reference ", asm_out_file);
-	      assemble_name (asm_out_file, sym_name);
-	      fputc ('\n', asm_out_file);
-	    }
-	}
+  return 1;
+}
 
-      assemble_name (asm_out_file, ptr_name);
-      fprintf (asm_out_file, ":\n");
+int
+machopic_output_indirection (machopic_indirection **slot, FILE *asm_out_file)
+{
+  machopic_indirection *p = *slot;
 
-      fprintf (asm_out_file, "\t.indirect_symbol ");
-      assemble_name (asm_out_file, sym_name);
-      fprintf (asm_out_file, "\n");
+  if (!p->used || p->stub_p || p->nlsp_in_data_section)
+    return 1;
 
-      /* Variables that are marked with MACHO_SYMBOL_STATIC need to
-	 have their symbol name instead of 0 in the second entry of
-	 the non-lazy symbol pointer data structure when they are
-	 defined.  This allows the runtime to rebind newer instances
-	 of the translation unit with the original instance of the
-	 symbol.  */
+  rtx symbol = p->symbol;
+  /* The original symbol name.  */
+  const char *sym_name = XSTR (symbol, 0);
+  /* The nonlazy-stub symbol name.  */
+  const char *ptr_name = p->ptr_name;
 
-      if ((SYMBOL_REF_FLAGS (symbol) & MACHO_SYMBOL_STATIC)
-	  && machopic_symbol_defined_p (symbol))
-	init = gen_rtx_SYMBOL_REF (Pmode, sym_name);
+  switch_to_section (darwin_sections[machopic_nl_symbol_ptr_section]);
 
-      assemble_integer (init, GET_MODE_SIZE (Pmode),
-			GET_MODE_ALIGNMENT (Pmode), 1);
+  /* Mach-O symbols are passed around in code through indirect references and
+     the original symbol_ref hasn't passed through the generic handling and
+     reference-catching in output_operand, so we need to manually mark weak
+     references as such.  */
+
+  if (SYMBOL_REF_WEAK (symbol))
+    {
+      tree decl = SYMBOL_REF_DECL (symbol);
+      gcc_checking_assert (DECL_P (decl));
+
+      if (decl != NULL_TREE
+	  && DECL_EXTERNAL (decl) && TREE_PUBLIC (decl)
+	  /* Handle only actual external-only definitions, not
+	     e.g. extern inline code or variables for which
+	     storage has been allocated.  */
+	  && !TREE_STATIC (decl))
+	{
+	  fputs ("\t.weak_reference ", asm_out_file);
+	  assemble_name (asm_out_file, sym_name);
+	  fputc ('\n', asm_out_file);
+	}
     }
 
+  assemble_name (asm_out_file, ptr_name);
+  fprintf (asm_out_file, ":\n");
+
+  fprintf (asm_out_file, "\t.indirect_symbol ");
+  assemble_name (asm_out_file, sym_name);
+  fprintf (asm_out_file, "\n");
+
+  /* Variables that are marked with MACHO_SYMBOL_FLAG_STATIC need to
+     have their symbol name instead of 0 in the second entry of
+     the non-lazy symbol pointer data structure when they are
+     defined.  This allows the runtime to rebind newer instances
+     of the translation unit with the original instance of the
+     symbol.  */
+
+  rtx init = const0_rtx;
+  if (MACHO_SYMBOL_STATIC_P (symbol) && machopic_symbol_defined_p (symbol))
+    init = gen_rtx_SYMBOL_REF (Pmode, sym_name);
+
+  assemble_integer (init, GET_MODE_SIZE (Pmode),
+		    GET_MODE_ALIGNMENT (Pmode), 1);
+
   return 1;
 }
 
-void
+static void
 machopic_finish (FILE *asm_out_file)
 {
-  if (machopic_indirections)
-    machopic_indirections
-      ->traverse_noresize<FILE *, machopic_output_indirection> (asm_out_file);
+  if (!machopic_indirections)
+    return;
+
+  /* First output an symbol indirections that have been placed into .data
+     (we don't expect these now).  */
+  machopic_indirections->traverse_noresize
+    <FILE *, machopic_output_data_section_indirection> (asm_out_file);
+
+  machopic_indirections->traverse_noresize
+    <FILE *, machopic_output_stub_indirection> (asm_out_file);
+
+  machopic_indirections->traverse_noresize
+    <FILE *, machopic_output_indirection> (asm_out_file);
 }
 
 int
@@ -1209,25 +1236,51 @@
 	    && XINT (XEXP (op, 0), 1) == UNSPEC_MACHOPIC_OFFSET);
 }
 
-/* This function records whether a given name corresponds to a defined
-   or undefined function or variable, for machopic_classify_ident to
-   use later.  */
+/* This function:
+   computes and caches a series of flags that characterise the symbol's
+   properties that affect Mach-O code gen (including accidental cases
+   from older toolchains).
 
+   TODO:
+   Here we also need to do enough analysis to determine if a symbol's
+   name needs to be made linker-visible.  This is more tricky - since
+   it depends on whether we've previously seen a global weak definition
+   in the same section.
+   */
+
 void
-darwin_encode_section_info (tree decl, rtx rtl, int first ATTRIBUTE_UNUSED)
+darwin_encode_section_info (tree decl, rtx rtl, int first)
 {
-  rtx sym_ref;
+  /* Careful not to prod global register variables.  */
+  if (!MEM_P (rtl))
+    return;
 
-  /* Do the standard encoding things first.  */
+  /* Do the standard encoding things first; this sets:
+     SYMBOL_FLAG_FUNCTION,
+     SYMBOL_FLAG_LOCAL, (binds_local_p)
+     TLS_MODEL, SYMBOL_FLAG_SMALL
+     SYMBOL_FLAG_EXTERNAL.  */
   default_encode_section_info (decl, rtl, first);
 
-  if (TREE_CODE (decl) != FUNCTION_DECL && TREE_CODE (decl) != VAR_DECL)
+  if (! VAR_OR_FUNCTION_DECL_P (decl))
     return;
 
-  sym_ref = XEXP (rtl, 0);
-  if (TREE_CODE (decl) == VAR_DECL)
+  rtx sym_ref = XEXP (rtl, 0);
+  if (VAR_P (decl))
     SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_FLAG_VARIABLE;
 
+  /* Only really common if there's no initialiser.  */
+  bool really_common_p = (DECL_COMMON (decl)
+			  && (DECL_INITIAL (decl) == NULL
+			      || (!in_lto_p
+				  && DECL_INITIAL (decl) == error_mark_node)));
+
+  /* For Darwin, if we have specified visibility and it's not the default
+     that's counted 'hidden'.  */
+  if (DECL_VISIBILITY_SPECIFIED (decl)
+      && DECL_VISIBILITY (decl) != VISIBILITY_DEFAULT)
+    SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_FLAG_HIDDEN_VIS;
+
   if (!DECL_EXTERNAL (decl)
       && (!TREE_PUBLIC (decl) || !DECL_WEAK (decl))
       && ! lookup_attribute ("weakref", DECL_ATTRIBUTES (decl))
@@ -1238,7 +1291,13 @@
     SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_FLAG_DEFINED;
 
   if (! TREE_PUBLIC (decl))
-    SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_STATIC;
+    SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_FLAG_STATIC;
+
+  /* Short cut check for Darwin 'must indirect' rules.  */
+  if (really_common_p
+      || (DECL_WEAK (decl) && ! MACHO_SYMBOL_HIDDEN_VIS_P (sym_ref))
+      || lookup_attribute ("weakref", DECL_ATTRIBUTES (decl)))
+     SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_FLAG_MUST_INDIRECT;
 }
 
 void
@@ -1255,12 +1314,13 @@
 }
 
 static section *
-darwin_rodata_section (int use_coal, bool zsize)
+darwin_rodata_section (int use_coal, bool zsize, int reloc)
 {
   return (use_coal
 	  ? darwin_sections[const_coal_section]
 	  : (zsize ? darwin_sections[zobj_const_section]
-		   : darwin_sections[const_section]));
+		   : reloc ? darwin_sections[const_data_section]
+			   : darwin_sections[const_section]));
 }
 
 static section *
@@ -1553,7 +1613,7 @@
 
     case SECCAT_RODATA:
     case SECCAT_SRODATA:
-      base_section = darwin_rodata_section (use_coal, zsize);
+      base_section = darwin_rodata_section (use_coal, zsize, reloc);
       break;
 
     case SECCAT_RODATA_MERGE_STR:
@@ -2082,11 +2142,11 @@
   static int invok_count = 0;
   static tree last_fun_decl = NULL_TREE;
   
-  /* We use the linker to emit the .eh labels for Darwin 9 and above.  */
-  if (! for_eh || generating_for_darwin_version >= 9)
+  /* Modern linkers can produce distinct FDEs without compiler support.  */
+  if (! for_eh || ! ld_needs_eh_markers)
     return;
 
-  /* FIXME: This only works when the eh for all sections of a function is 
+  /* FIXME: This only works when the eh for all sections of a function are
      emitted at the same time.  If that changes, we would need to use a lookup
      table of some form to determine what to do.  Also, we should emit the
      unadorned label for the partition containing the public label for a
@@ -2908,12 +2968,10 @@
       if (flag_objc_abi >= 2)
 	{
 	  flags = 16;
-	  output_section_asm_op
-	    (darwin_sections[objc2_image_info_section]->unnamed.data);
+          switch_to_section (darwin_sections[objc2_image_info_section]);
 	}
       else
-	output_section_asm_op
-	  (darwin_sections[objc_image_info_section]->unnamed.data);
+	switch_to_section (darwin_sections[objc_image_info_section]);
 
       ASM_OUTPUT_ALIGN (asm_out_file, 2);
       fputs ("L_OBJC_ImageInfo:\n", asm_out_file);
@@ -3119,17 +3177,19 @@
 				: (generating_for_darwin_version >= 9) ? 1
 								       : 0);
 
-  /* Objective-C family ABI 2 is only valid for next/m64 at present.  */
   if (global_options_set.x_flag_objc_abi && flag_next_runtime)
     {
-      if (TARGET_64BIT && global_options.x_flag_objc_abi < 2)
-	error_at (UNKNOWN_LOCATION, "%<-fobjc-abi-version%> >= 2 must be"
-				    " used for %<-m64%> targets with"
-				    " %<-fnext-runtime%>");
-      if (!TARGET_64BIT && global_options.x_flag_objc_abi >= 2)
-	error_at (UNKNOWN_LOCATION, "%<-fobjc-abi-version%> >= 2 is not"
-				    " supported on %<-m32%> targets with"
-				    " %<-fnext-runtime%>");
+      if (TARGET_64BIT && global_options.x_flag_objc_abi != 2)
+	/* The Objective-C family ABI 2 is the only valid version NeXT/m64.  */
+	error_at (UNKNOWN_LOCATION,
+		  "%<-fobjc-abi-version%> 2 must be used for 64 bit targets"
+		  " with %<-fnext-runtime%>");
+      else if (!TARGET_64BIT && global_options.x_flag_objc_abi >= 2)
+	/* ABI versions 0 and 1 are the only valid versions NeXT/m32.  */
+	error_at (UNKNOWN_LOCATION,
+		  "%<-fobjc-abi-version%> %d is not supported for 32 bit"
+		  " targets with %<-fnext-runtime%>",
+		  global_options.x_flag_objc_abi);
     }
 
   /* Don't emit DWARF3/4 unless specifically selected.  This is a 
@@ -3197,8 +3257,6 @@
       /* so no tables either.. */
       flag_unwind_tables = 0;
       flag_asynchronous_unwind_tables = 0;
-      /* We still need to emit branch islands for kernel context.  */
-      darwin_emit_branch_islands = true;
     }
 
   if (flag_var_tracking_uninit == 0
@@ -3208,6 +3266,8 @@
       && write_symbols == DWARF2_DEBUG)
     flag_var_tracking_uninit = flag_var_tracking;
 
+  /* Final check on PCI options; for Darwin these are not dependent on the PIE
+     ones, although PIE does require PIC to support it.  */
   if (MACHO_DYNAMIC_NO_PIC_P)
     {
       if (flag_pic)
@@ -3216,18 +3276,53 @@
 		 " %<-fpie%> or %<-fPIE%>");
       flag_pic = 0;
     }
-  else if (flag_pic == 1)
+  else if (flag_pic == 1
+	   || (flag_pic == 0 && !(flag_mkernel || flag_apple_kext)))
     {
-      /* Darwin's -fpic is -fPIC.  */
+      /* Darwin's -fpic is -fPIC.
+	 We only support "static" code in the kernel and kernel exts.  */
       flag_pic = 2;
     }
 
-  /* It is assumed that branch island stubs are needed for earlier systems.  */
-  if (generating_for_darwin_version < 9)
-    darwin_emit_branch_islands = true;
-  else
-    emit_aligned_common = true; /* Later systems can support aligned common.  */
+  /* Linkers >= ld64-62.1 (at least) are capable of making the necessary PIC
+     indirections and we no longer need to emit pic symbol stubs.
+     However, if we are generating code for earlier ones (or for use in the
+     kernel) the stubs might still be required, and this will be set true.
+     If the user sets it on or off - then that takes precedence.
 
+     Linkers that don't need stubs, don't need the EH symbol markers either.
+  */
+
+  if (!global_options_set.x_darwin_symbol_stubs)
+    {
+      if (darwin_target_linker)
+	{
+	  if (strverscmp (darwin_target_linker, MIN_LD64_OMIT_STUBS) < 0)
+	    {
+	      darwin_symbol_stubs = true;
+	      ld_needs_eh_markers = true;
+	    }
+	}
+      else if (generating_for_darwin_version < 9)
+	{
+	  /* If we don't know the linker version and we're targeting an old
+	     system, we know no better than to assume the use of an earlier
+	     linker.  */
+	  darwin_symbol_stubs = true;
+	  ld_needs_eh_markers = true;
+	}
+    }
+  else if (DARWIN_X86 && darwin_symbol_stubs && TARGET_64BIT)
+    {
+      inform (input_location,
+	      "%<-msymbol-stubs%> is not required for 64b code (ignored)");
+      darwin_symbol_stubs = false;
+    }
+
+  if (generating_for_darwin_version >= 9)
+    /* Later systems can support aligned common.  */
+    emit_aligned_common = true;
+
   /* The c_dialect...() macros are not available to us here.  */
   darwin_running_cxx = (strstr (lang_hooks.name, "C++") != 0);
 }
Index: gcc/config/darwin.h
===================================================================
--- a/src/gcc/config/darwin.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/darwin.h	(.../branches/gcc-7-branch)
@@ -127,6 +127,24 @@
   "%{fapple-kext|mkernel:-static}",				\
   "%{shared:-Zdynamiclib} %<shared"
 
+#if LD64_HAS_EXPORT_DYNAMIC
+#define DARWIN_RDYNAMIC "%{rdynamic:-export_dynamic}"
+#else
+#define DARWIN_RDYNAMIC "%{rdynamic:%nrdynamic is not supported}"
+#endif
+
+/* FIXME: we should check that the linker supports the -pie and -no_pie.
+   options.  */
+#define DARWIN_PIE_SPEC \
+"%{pie|fpie|fPIE:\
+   %{mdynamic-no-pic: \
+     %n'-mdynamic-no-pic' overrides '-pie', '-fpie' or '-fPIE'; \
+     :%:version-compare(>= 10.5 mmacosx-version-min= -pie) }} "
+
+#define DARWIN_NOPIE_SPEC \
+"%{no-pie|fno-pie|fno-PIE: \
+   %:version-compare(>= 10.7 mmacosx-version-min= -no_pie) }"
+
 #define DARWIN_CC1_SPEC							\
   "%{findirect-virtual-calls: -fapple-kext} %<findirect-virtual-calls " \
   "%{fterminated-vtables: -fapple-kext} %<fterminated-vtables "		\
@@ -157,26 +175,37 @@
 #define CPP_SPEC "%{static:%{!dynamic:-D__STATIC__}}%{!static:-D__DYNAMIC__}" \
 	" %{pthread:-D_REENTRANT}"
 
-/* This is mostly a clone of the standard LINK_COMMAND_SPEC, plus
-   precomp, libtool, and fat build additions.
+/* This is a fix for PR41260 by passing -no_compact_unwind on darwin10 and
+   later until the assembler, linker and libunwind are able to deal with the
+   output from GCC.
 
+   FIXME: we should check that the linker supports the option.
+*/
+
+#define DARWIN_NOCOMPACT_UNWIND \
+" %:version-compare(>= 10.6 mmacosx-version-min= -no_compact_unwind) "
+
+/* In Darwin linker specs we can put -lcrt0.o and ld will search the library
+   path for crt0.o or -lcrtx.a and it will search for for libcrtx.a.  As for
+   other ports, we can also put xxx.{o,a}%s and get the appropriate complete
+   startfile absolute directory.  This latter point is important when we want
+   to override ld's rule of .dylib being found ahead of .a and the user wants
+   the convenience library to be linked.  */
+
+/* The LINK_COMMAND spec is mostly a clone of the standard LINK_COMMAND_SPEC,
+   plus precomp, libtool, and fat build additions.
+
    In general, random Darwin linker flags should go into LINK_SPEC
    instead of LINK_COMMAND_SPEC.  The command spec is better for
    specifying the handling of options understood by generic Unix
    linkers, and for positional arguments like libraries.  */
 
-#if LD64_HAS_EXPORT_DYNAMIC
-#define DARWIN_EXPORT_DYNAMIC " %{rdynamic:-export_dynamic}"
-#else
-#define DARWIN_EXPORT_DYNAMIC " %{rdynamic: %nrdynamic is not supported}"
-#endif
-
 #define LINK_COMMAND_SPEC_A \
    "%{!fdump=*:%{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\
     %(linker)" \
     LINK_PLUGIN_SPEC \
     "%{flto*:%<fcompare-debug*} \
-    %{flto*} \
+     %{flto} %{fno-lto} %{flto=*} \
     %l " LINK_COMPRESS_DEBUG_SPEC \
    "%X %{s} %{t} %{Z} %{u*} \
     %{e*} %{r} \
@@ -192,10 +221,14 @@
       %{%:sanitize(address): -lasan } \
       %{%:sanitize(undefined): -lubsan } \
       %(link_ssp) \
-      " DARWIN_EXPORT_DYNAMIC " %<rdynamic \
       %(link_gcc_c_sequence) \
     }}\
-    %{!nostdlib:%{!nostartfiles:%E}} %{T*} %{F*} }}}}}}}"
+    %{!nostdlib:%{!r:%{!nostartfiles:%E}}} %{T*} %{F*} "\
+    DARWIN_PIE_SPEC \
+    DARWIN_NOPIE_SPEC \
+    DARWIN_RDYNAMIC \
+    DARWIN_NOCOMPACT_UNWIND \
+    "}}}}}}} %<pie %<no-pie %<rdynamic "
 
 #define DSYMUTIL "\ndsymutil"
 
@@ -232,8 +265,6 @@
 #define STANDARD_STARTFILE_PREFIX_1 ""
 #define STANDARD_STARTFILE_PREFIX_2 ""
 
-#define DARWIN_PIE_SPEC "%{fpie|pie|fPIE:}"
-
 /* Please keep the random linker options in alphabetical order (modulo
    'Z' and 'no' prefixes). Note that options taking arguments may appear
    multiple times on a command line with different arguments each time,
@@ -297,7 +328,6 @@
      %:version-compare(< 10.5 mmacosx-version-min= -multiply_defined) \
      %:version-compare(< 10.5 mmacosx-version-min= suppress)}} \
    %{Zmultiplydefinedunused*:-multiply_defined_unused %*} \
-   " DARWIN_PIE_SPEC " \
    %{prebind} %{noprebind} %{nofixprebinding} %{prebind_all_twolevel_modules} \
    %{read_only_relocs} \
    %{sectcreate*} %{sectorder*} %{seg1addr*} %{segprot*} \
@@ -329,43 +359,42 @@
 
 /* Support -mmacosx-version-min by supplying different (stub) libgcc_s.dylib
    libraries to link against, and by not linking against libgcc_s on
-   earlier-than-10.3.9.
+   earlier-than-10.3.9.  If we need exceptions, prior to 10.3.9, then we have
+   to link the static eh lib, since there's no shared version on the system.
 
-   Note that by default, -lgcc_eh is not linked against!  This is
-   because in a future version of Darwin the EH frame information may
-   be in a new format, or the fallback routine might be changed; if
-   you want to explicitly link against the static version of those
-   routines, because you know you don't need to unwind through system
-   libraries, you need to explicitly say -static-libgcc.
+   Note that by default, except as above, -lgcc_eh is not linked against.
+   This is because,in general, we need to unwind through system libraries that
+   are linked with the shared unwinder in libunwind (or libgcc_s for 10.4/5).
 
-   If it is linked against, it has to be before -lgcc, because it may
+   The static version of the current libgcc unwinder (which differs from the
+   implementation in libunwind.dylib on systems Darwin10 [10.6]+) can be used
+   by specifying -static-libgcc.
+
+   If libgcc_eh is linked against, it has to be before -lgcc, because it might
    need symbols from -lgcc.  */
+
 #undef REAL_LIBGCC_SPEC
 #define REAL_LIBGCC_SPEC						   \
    "%{static-libgcc|static: -lgcc_eh -lgcc;				   \
-      shared-libgcc|fexceptions|fgnu-runtime:				   \
-       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_s.10.4)	   \
+      shared-libgcc|fexceptions|fobjc-exceptions|fgnu-runtime:		   \
+       %:version-compare(!> 10.3.9 mmacosx-version-min= -lgcc_eh)	   \
+       %:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_s.10.4) \
        %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
-       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)	   \
+       %:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_ext.10.4) \
        %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)	   \
        -lgcc ;								   \
       :%:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_s.10.4) \
        %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
-       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)	   \
+       %:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_ext.10.4) \
        %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)	   \
        -lgcc }"
 
-/* We specify crt0.o as -lcrt0.o so that ld will search the library path.
+/* We specify crt0.o as -lcrt0.o so that ld will search the library path.  */
 
-   crt3.o provides __cxa_atexit on systems that don't have it.  Since
-   it's only used with C++, which requires passing -shared-libgcc, key
-   off that to avoid unnecessarily adding a destructor to every
-   powerpc program built.  */
-
 #undef  STARTFILE_SPEC
 #define STARTFILE_SPEC							    \
-  "%{Zdynamiclib: %(darwin_dylib1) %{fgnu-tm: -lcrttms.o}}		    \
-   %{!Zdynamiclib:%{Zbundle:%{!static:					    \
+"%{Zdynamiclib: %(darwin_dylib1) %{fgnu-tm: -lcrttms.o}}		    \
+ %{!Zdynamiclib:%{Zbundle:%{!static:					    \
 	%:version-compare(< 10.6 mmacosx-version-min= -lbundle1.o)	    \
 	%{fgnu-tm: -lcrttms.o}}}					    \
      %{!Zbundle:%{pg:%{static:-lgcrt0.o}				    \
@@ -379,7 +408,7 @@
                                 %{!object:%{preload:-lcrt0.o}		    \
                                   %{!preload: %(darwin_crt1)		    \
 					      %(darwin_crt2)}}}}}}	    \
-  %{shared-libgcc:%:version-compare(< 10.5 mmacosx-version-min= crt3.o%s)}"
+ %(darwin_crt3)"
 
 /* We want a destructor last in the list.  */
 #define TM_DESTRUCTOR "%{fgnu-tm: -lcrttme.o}"
@@ -387,12 +416,10 @@
 
 #define DARWIN_EXTRA_SPECS						\
   { "darwin_crt1", DARWIN_CRT1_SPEC },					\
+  { "darwin_crt2", DARWIN_CRT2_SPEC },					\
+  { "darwin_crt3", DARWIN_CRT3_SPEC },					\
   { "darwin_dylib1", DARWIN_DYLIB1_SPEC },
 
-#define DARWIN_DYLIB1_SPEC						\
-  "%:version-compare(!> 10.5 mmacosx-version-min= -ldylib1.o)		\
-   %:version-compare(>< 10.5 10.6 mmacosx-version-min= -ldylib1.10.5.o)"
-
 #define DARWIN_CRT1_SPEC						\
   "%:version-compare(!> 10.5 mmacosx-version-min= -lcrt1.o)		\
    %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lcrt1.10.5.o)	\
@@ -399,6 +426,20 @@
    %:version-compare(>< 10.6 10.8 mmacosx-version-min= -lcrt1.10.6.o)	\
    %{fgnu-tm: -lcrttms.o}"
 
+#define DARWIN_CRT2_SPEC ""
+
+/* crt3.o provides __cxa_atexit on systems that don't have it (and a fix
+   up for faulty versions on 10.4).  Since it's only used with C++, which
+   requires passing -shared-libgcc, key off that to avoid unnecessarily
+   adding a destructor to every program built for 10.4 or earlier.  */
+
+#define DARWIN_CRT3_SPEC \
+"%{shared-libgcc:%:version-compare(< 10.5 mmacosx-version-min= crt3.o%s)}"
+
+#define DARWIN_DYLIB1_SPEC						\
+  "%:version-compare(!> 10.5 mmacosx-version-min= -ldylib1.o)		\
+   %:version-compare(>< 10.5 10.6 mmacosx-version-min= -ldylib1.10.5.o)"
+
 #ifdef HAVE_AS_MMACOSX_VERSION_MIN_OPTION
 /* Emit macosx version (but only major).  */
 #define ASM_MMACOSX_VERSION_MIN_SPEC \
@@ -434,21 +475,30 @@
 
 #define DWARF2_DEBUGGING_INFO 1
 
-#define DEBUG_FRAME_SECTION	"__DWARF,__debug_frame,regular,debug"
-#define DEBUG_INFO_SECTION	"__DWARF,__debug_info,regular,debug"
-#define DEBUG_ABBREV_SECTION	"__DWARF,__debug_abbrev,regular,debug"
-#define DEBUG_ARANGES_SECTION	"__DWARF,__debug_aranges,regular,debug"
-#define DEBUG_MACINFO_SECTION	"__DWARF,__debug_macinfo,regular,debug"
-#define DEBUG_LINE_SECTION	"__DWARF,__debug_line,regular,debug"
-#define DEBUG_LOC_SECTION	"__DWARF,__debug_loc,regular,debug"
-#define DEBUG_PUBNAMES_SECTION	"__DWARF,__debug_pubnames,regular,debug"
-#define DEBUG_PUBTYPES_SECTION	"__DWARF,__debug_pubtypes,regular,debug"
-#define DEBUG_STR_SECTION	"__DWARF,__debug_str,regular,debug"
-#define DEBUG_RANGES_SECTION	"__DWARF,__debug_ranges,regular,debug"
-#define DEBUG_MACRO_SECTION    "__DWARF,__debug_macro,regular,debug"
+#define DEBUG_FRAME_SECTION	  "__DWARF,__debug_frame,regular,debug"
+#define DEBUG_INFO_SECTION	  "__DWARF,__debug_info,regular,debug"
+#define DEBUG_ABBREV_SECTION	  "__DWARF,__debug_abbrev,regular,debug"
+#define DEBUG_ARANGES_SECTION	  "__DWARF,__debug_aranges,regular,debug"
+#define DEBUG_MACINFO_SECTION	  "__DWARF,__debug_macinfo,regular,debug"
+#define DEBUG_LINE_SECTION	  "__DWARF,__debug_line,regular,debug"
+#define DEBUG_LOC_SECTION	  "__DWARF,__debug_loc,regular,debug"
+#define DEBUG_LOCLISTS_SECTION    "__DWARF,__debug_loclists,regular,debug"
 
+#define DEBUG_STR_SECTION	  "__DWARF,__debug_str,regular,debug"
+#define DEBUG_STR_OFFSETS_SECTION "__DWARF,__debug_str_offs,regular,debug"
+#define DEBUG_RANGES_SECTION	  "__DWARF,__debug_ranges,regular,debug"
+#define DEBUG_RNGLISTS_SECTION    "__DWARF,__debug_rnglists,regular,debug"
+#define DEBUG_MACRO_SECTION       "__DWARF,__debug_macro,regular,debug"
+
 #define TARGET_WANT_DEBUG_PUB_SECTIONS true
+#define DEBUG_PUBNAMES_SECTION   ((debug_generate_pub_sections == 2) \
+                               ? "__DWARF,__debug_gnu_pubn,regular,debug" \
+                               : "__DWARF,__debug_pubnames,regular,debug")
 
+#define DEBUG_PUBTYPES_SECTION   ((debug_generate_pub_sections == 2) \
+                               ? "__DWARF,__debug_gnu_pubt,regular,debug" \
+                               : "__DWARF,__debug_pubtypes,regular,debug")
+
 /* When generating stabs debugging, use N_BINCL entries.  */
 
 #define DBX_USE_BINCL
@@ -495,11 +545,6 @@
    links to, so there's no need for weak-ness for that.  */
 #define GTHREAD_USE_WEAK 0
 
-/* The Darwin linker doesn't want coalesced symbols to appear in
-   a static archive's table of contents. */
-#undef TARGET_WEAK_NOT_IN_ARCHIVE_TOC
-#define TARGET_WEAK_NOT_IN_ARCHIVE_TOC 1
-
 /* On Darwin, we don't (at the time of writing) have linkonce sections
    with names, so it's safe to make the class data not comdat.  */
 #define TARGET_CXX_CLASS_DATA_ALWAYS_COMDAT hook_bool_void_false
@@ -751,21 +796,52 @@
 #undef TARGET_ASM_MARK_DECL_PRESERVED
 #define TARGET_ASM_MARK_DECL_PRESERVED darwin_mark_decl_preserved
 
-/* Set on a symbol with SYMBOL_FLAG_FUNCTION or
-   MACHO_SYMBOL_FLAG_VARIABLE to indicate that the function or
-   variable has been defined in this translation unit.
-   When porting Mach-O to new architectures you need to make
-   sure these aren't clobbered by the backend.  */
+/* Any port using this header needs to define the first available
+   subtarget symbol bit: SYMBOL_FLAG_SUBT_DEP.  */
 
-#define MACHO_SYMBOL_FLAG_VARIABLE (SYMBOL_FLAG_MACH_DEP)
-#define MACHO_SYMBOL_FLAG_DEFINED ((SYMBOL_FLAG_MACH_DEP) << 1)
+/* Is a variable. */
+#define MACHO_SYMBOL_FLAG_VARIABLE (SYMBOL_FLAG_SUBT_DEP)
+#define MACHO_SYMBOL_VARIABLE_P(RTX) \
+  ((SYMBOL_REF_FLAGS (RTX) & MACHO_SYMBOL_FLAG_VARIABLE) != 0)
 
+/* Set on a symbol that must be indirected, even when there is a
+   definition in the TU.  The ABI mandates that common symbols are so
+   indirected, as are weak.  If 'fix-and-continue' is operational then
+   data symbols might also be.  */
+
+#define MACHO_SYMBOL_FLAG_MUST_INDIRECT ((SYMBOL_FLAG_SUBT_DEP) << 1)
+#define MACHO_SYMBOL_MUST_INDIRECT_P(RTX) \
+  ((SYMBOL_REF_FLAGS (RTX) & MACHO_SYMBOL_FLAG_MUST_INDIRECT) != 0)
+
+/* Set on a symbol with SYMBOL_FLAG_FUNCTION or MACHO_SYMBOL_FLAG_VARIABLE
+   to indicate that the function or variable is considered defined in this
+   translation unit.  */
+
+#define MACHO_SYMBOL_FLAG_DEFINED ((SYMBOL_FLAG_SUBT_DEP) << 2)
+#define MACHO_SYMBOL_DEFINED_P(RTX) \
+  ((SYMBOL_REF_FLAGS (RTX) & MACHO_SYMBOL_FLAG_DEFINED) != 0)
+
+/* Set on a symbol that has specified non-default visibility.  */
+
+#define MACHO_SYMBOL_FLAG_HIDDEN_VIS ((SYMBOL_FLAG_SUBT_DEP) << 3)
+#define MACHO_SYMBOL_HIDDEN_VIS_P(RTX) \
+  ((SYMBOL_REF_FLAGS (RTX) & MACHO_SYMBOL_FLAG_HIDDEN_VIS) != 0)
+
+/* Set on a symbol that is a pic stub or symbol indirection (i.e. the
+   L_xxxxx${stub,non_lazy_ptr,lazy_ptr}.  */
+
+#define MACHO_SYMBOL_FLAG_INDIRECTION ((SYMBOL_FLAG_SUBT_DEP) << 5)
+#define MACHO_SYMBOL_INDIRECTION_P(RTX) \
+  ((SYMBOL_REF_FLAGS (RTX) & MACHO_SYMBOL_FLAG_INDIRECTION) != 0)
+
 /* Set on a symbol to indicate when fix-and-continue style code
    generation is being used and the symbol refers to a static symbol
    that should be rebound from new instances of a translation unit to
    the original instance of the data.  */
 
-#define MACHO_SYMBOL_STATIC ((SYMBOL_FLAG_MACH_DEP) << 2)
+#define MACHO_SYMBOL_FLAG_STATIC ((SYMBOL_FLAG_SUBT_DEP) << 6)
+#define MACHO_SYMBOL_STATIC_P(RTX) \
+  ((SYMBOL_REF_FLAGS (RTX) & MACHO_SYMBOL_FLAG_STATIC) != 0)
 
 /* Symbolic names for various things we might know about a symbol.  */
 
@@ -958,8 +1034,12 @@
    _tested_ version known to support this so far.  */
 #define MIN_LD64_NO_COAL_SECTS "236.4"
 
+/* From at least version 62.1, ld64 can build symbol indirection stubs as
+   needed, and there is no need for the compiler to emit them.  */
+#define MIN_LD64_OMIT_STUBS "85.2"
+
 #ifndef LD64_VERSION
-#define LD64_VERSION "85.2"
+#define LD64_VERSION "62.1"
 #else
 #define DEF_LD64 LD64_VERSION
 #endif
Index: gcc/config/darwin10.h
===================================================================
--- a/src/gcc/config/darwin10.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/darwin10.h	(.../branches/gcc-7-branch)
@@ -18,17 +18,13 @@
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
-/* Fix PR41260 by passing -no_compact_unwind on darwin10 and later until
-   unwinder in libSystem is fixed to digest new epilog unwinding notes.
+/* Fix PR47558 by linking against libSystem ahead of libgcc_ext. */
 
-   Fix PR47558 by linking against libSystem ahead of libgcc_ext. */
 #undef  LINK_GCC_C_SEQUENCE_SPEC
 #define LINK_GCC_C_SEQUENCE_SPEC \
-"%:version-compare(>= 10.6 mmacosx-version-min= -no_compact_unwind) \
-   %{!static:%{!static-libgcc: \
-      %:version-compare(>= 10.6 mmacosx-version-min= -lSystem) } } \
-   %{fno-pic|fno-PIC|fno-pie|fno-PIE|fapple-kext|mkernel|static|mdynamic-no-pic: \
-      %:version-compare(>= 10.7 mmacosx-version-min= -no_pie) } %G %L"
+"%{!static:%{!static-libgcc: \
+   %:version-compare(>= 10.6 mmacosx-version-min= -lSystem) } } \
+ %G %L"
 
 #undef DEF_MIN_OSX_VERSION
 #define DEF_MIN_OSX_VERSION "10.6"
Index: gcc/config/arm/arm.c
===================================================================
--- a/src/gcc/config/arm/arm.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/arm/arm.c	(.../branches/gcc-7-branch)
@@ -3001,7 +3001,8 @@
 
   /* Thumb2 inline assembly code should always use unified syntax.
      This will apply to ARM and Thumb1 eventually.  */
-  opts->x_inline_asm_unified = TARGET_THUMB2_P (opts->x_target_flags);
+  if (TARGET_THUMB2_P (opts->x_target_flags))
+    opts->x_inline_asm_unified = true;
 
 #ifdef SUBTARGET_OVERRIDE_INTERNAL_OPTIONS
   SUBTARGET_OVERRIDE_INTERNAL_OPTIONS;
@@ -8711,11 +8712,16 @@
 arm_cannot_force_const_mem (machine_mode mode ATTRIBUTE_UNUSED, rtx x)
 {
   rtx base, offset;
+  split_const (x, &base, &offset);
 
-  if (ARM_OFFSETS_MUST_BE_WITHIN_SECTIONS_P)
+  if (SYMBOL_REF_P (base))
     {
-      split_const (x, &base, &offset);
-      if (GET_CODE (base) == SYMBOL_REF
+      /* Function symbols cannot have an offset due to the Thumb bit.  */
+      if ((SYMBOL_REF_FLAGS (base) & SYMBOL_FLAG_FUNCTION)
+	  && INTVAL (offset) != 0)
+	return true;
+
+      if (ARM_OFFSETS_MUST_BE_WITHIN_SECTIONS_P
 	  && !offset_within_block_p (base, INTVAL (offset)))
 	return true;
     }
@@ -11695,8 +11701,7 @@
   else
     {
       n_elts = 1;
-      if (mode == VOIDmode)
-	mode = DImode;
+      gcc_assert (mode != VOIDmode);
     }
 
   innersize = GET_MODE_UNIT_SIZE (mode);
@@ -19211,7 +19216,36 @@
   return save_reg_mask;
 }
 
-/* Compute a bit mask of which registers need to be
+/* Return a mask for the call-clobbered low registers that are unused
+   at the end of the prologue.  */
+static unsigned long
+thumb1_prologue_unused_call_clobbered_lo_regs (void)
+{
+  unsigned long mask = 0;
+
+  for (int reg = 0; reg <= LAST_LO_REGNUM; reg++)
+    if (!callee_saved_reg_p (reg)
+	&& !REGNO_REG_SET_P (df_get_live_out (ENTRY_BLOCK_PTR_FOR_FN (cfun)),
+			     reg))
+      mask |= 1 << reg;
+  return mask;
+}
+
+/* Similarly for the start of the epilogue.  */
+static unsigned long
+thumb1_epilogue_unused_call_clobbered_lo_regs (void)
+{
+  unsigned long mask = 0;
+
+  for (int reg = 0; reg <= LAST_LO_REGNUM; reg++)
+    if (!callee_saved_reg_p (reg)
+	&& !REGNO_REG_SET_P (df_get_live_in (EXIT_BLOCK_PTR_FOR_FN (cfun)),
+			     reg))
+      mask |= 1 << reg;
+  return mask;
+}
+
+/* Compute a bit mask of which core registers need to be
    saved on the stack for the current function.  */
 static unsigned long
 thumb1_compute_save_reg_mask (void)
@@ -19242,10 +19276,19 @@
   if (mask & 0xff || thumb_force_lr_save ())
     mask |= (1 << LR_REGNUM);
 
-  /* Make sure we have a low work register if we need one.
-     We will need one if we are going to push a high register,
-     but we are not currently intending to push a low register.  */
+  bool call_clobbered_scratch
+    = (thumb1_prologue_unused_call_clobbered_lo_regs ()
+       && thumb1_epilogue_unused_call_clobbered_lo_regs ());
+
+  /* Make sure we have a low work register if we need one.  We will
+     need one if we are going to push a high register, but we are not
+     currently intending to push a low register.  However if both the
+     prologue and epilogue have a spare call-clobbered low register,
+     then we won't need to find an additional work register.  It does
+     not need to be the same register in the prologue and
+     epilogue.  */
   if ((mask & 0xff) == 0
+      && !call_clobbered_scratch
       && ((mask & 0x0f00) || TARGET_BACKTRACE))
     {
       /* Use thumb_find_work_register to choose which register
@@ -24434,12 +24477,7 @@
       unsigned long mask = live_regs_mask & 0xff;
       int next_hi_reg;
 
-      /* The available low registers depend on the size of the value we are
-         returning.  */
-      if (size <= 12)
-	mask |=  1 << 3;
-      if (size <= 8)
-	mask |= 1 << 2;
+      mask |= thumb1_epilogue_unused_call_clobbered_lo_regs ();
 
       if (mask == 0)
 	/* Oh dear!  We have no low registers into which we can pop
@@ -24447,7 +24485,7 @@
 	internal_error
 	  ("no low registers available for popping high registers");
 
-      for (next_hi_reg = 8; next_hi_reg < 13; next_hi_reg++)
+      for (next_hi_reg = 12; next_hi_reg > LAST_LO_REGNUM; next_hi_reg--)
 	if (live_regs_mask & (1 << next_hi_reg))
 	  break;
 
@@ -24455,7 +24493,7 @@
 	{
 	  /* Find lo register(s) into which the high register(s) can
              be popped.  */
-	  for (regno = 0; regno <= LAST_LO_REGNUM; regno++)
+	  for (regno = LAST_LO_REGNUM; regno >= 0; regno--)
 	    {
 	      if (mask & (1 << regno))
 		high_regs_pushed--;
@@ -24463,13 +24501,14 @@
 		break;
 	    }
 
-	  mask &= (2 << regno) - 1;	/* A noop if regno == 8 */
+	  if (high_regs_pushed == 0 && regno >= 0)
+	    mask &= ~((1 << regno) - 1);
 
 	  /* Pop the values into the low register(s).  */
 	  thumb_pop (asm_out_file, mask);
 
 	  /* Move the value(s) into the high registers.  */
-	  for (regno = 0; regno <= LAST_LO_REGNUM; regno++)
+	  for (regno = LAST_LO_REGNUM; regno >= 0; regno--)
 	    {
 	      if (mask & (1 << regno))
 		{
@@ -24476,7 +24515,8 @@
 		  asm_fprintf (asm_out_file, "\tmov\t%r, %r\n", next_hi_reg,
 			       regno);
 
-		  for (next_hi_reg++; next_hi_reg < 13; next_hi_reg++)
+		  for (next_hi_reg--; next_hi_reg > LAST_LO_REGNUM;
+		       next_hi_reg--)
 		    if (live_regs_mask & (1 << next_hi_reg))
 		      break;
 		}
@@ -24858,10 +24898,20 @@
 	  break;
 
       /* Here we need to mask out registers used for passing arguments
-	 even if they can be pushed.  This is to avoid using them to stash the high
-	 registers.  Such kind of stash may clobber the use of arguments.  */
+	 even if they can be pushed.  This is to avoid using them to
+	 stash the high registers.  Such kind of stash may clobber the
+	 use of arguments.  */
       pushable_regs = l_mask & (~arg_regs_mask);
-      if (lr_needs_saving)
+      pushable_regs |= thumb1_prologue_unused_call_clobbered_lo_regs ();
+
+      /* Normally, LR can be used as a scratch register once it has been
+	 saved; but if the function examines its own return address then
+	 the value is still live and we need to avoid using it.  */
+      bool return_addr_live
+	= REGNO_REG_SET_P (df_get_live_out (ENTRY_BLOCK_PTR_FOR_FN (cfun)),
+			   LR_REGNUM);
+
+      if (lr_needs_saving || return_addr_live)
 	pushable_regs &= ~(1 << LR_REGNUM);
 
       if (pushable_regs == 0)
@@ -24902,6 +24952,11 @@
 	      push_mask |= 1 << LR_REGNUM;
 	      real_regs_mask |= 1 << LR_REGNUM;
 	      lr_needs_saving = false;
+	      /* If the return address is not live at this point, we
+		 can add LR to the list of registers that we can use
+		 for pushes.  */
+	      if (!return_addr_live)
+		pushable_regs |= 1 << LR_REGNUM;
 	    }
 
 	  insn = thumb1_emit_multi_reg_push (push_mask, real_regs_mask);
Index: gcc/config/arm/arm.h
===================================================================
--- a/src/gcc/config/arm/arm.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/arm/arm.h	(.../branches/gcc-7-branch)
@@ -186,7 +186,7 @@
 /* FPU supports converting between HFmode and DFmode in a single hardware
    step.  */
 #define TARGET_FP16_TO_DOUBLE						\
-  (TARGET_HARD_FLOAT && (TARGET_FP16 && TARGET_VFP5))
+  (TARGET_HARD_FLOAT && TARGET_FP16 && TARGET_VFP5 && TARGET_VFP_DOUBLE)
 
 /* FPU supports fused-multiply-add operations.  */
 #define TARGET_FMA (bitmap_bit_p (arm_active_target.isa, isa_bit_VFPv4))
Index: gcc/config/arm/neon.md
===================================================================
--- a/src/gcc/config/arm/neon.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/arm/neon.md	(.../branches/gcc-7-branch)
@@ -25,14 +25,14 @@
 
 (define_insn "*neon_mov<mode>"
   [(set (match_operand:VDX 0 "nonimmediate_operand"
-	  "=w,Un,w, w,  ?r,?w,?r,?r, ?Us")
+	  "=w,Un,w, w, w,  ?r,?w,?r,?r, ?Us")
 	(match_operand:VDX 1 "general_operand"
-	  " w,w, Dn,Uni, w, r, r, Usi,r"))]
+	  " w,w, Dm,Dn,Uni, w, r, r, Usi,r"))]
   "TARGET_NEON
    && (register_operand (operands[0], <MODE>mode)
        || register_operand (operands[1], <MODE>mode))"
 {
-  if (which_alternative == 2)
+  if (which_alternative == 2 || which_alternative == 3)
     {
       int width, is_valid;
       static char templ[40];
@@ -53,31 +53,32 @@
   switch (which_alternative)
     {
     case 0: return "vmov\t%P0, %P1  @ <mode>";
-    case 1: case 3: return output_move_neon (operands);
-    case 2: gcc_unreachable ();
-    case 4: return "vmov\t%Q0, %R0, %P1  @ <mode>";
-    case 5: return "vmov\t%P0, %Q1, %R1  @ <mode>";
+    case 1: case 4: return output_move_neon (operands);
+    case 2: case 3: gcc_unreachable ();
+    case 5: return "vmov\t%Q0, %R0, %P1  @ <mode>";
+    case 6: return "vmov\t%P0, %Q1, %R1  @ <mode>";
     default: return output_move_double (operands, true, NULL);
     }
 }
  [(set_attr "type" "neon_move<q>,neon_store1_1reg,neon_move<q>,\
-                    neon_load1_1reg, neon_to_gp<q>,neon_from_gp<q>,mov_reg,\
-                    neon_load1_2reg, neon_store1_2reg")
-  (set_attr "length" "4,4,4,4,4,4,8,8,8")
-  (set_attr "arm_pool_range"     "*,*,*,1020,*,*,*,1020,*")
-  (set_attr "thumb2_pool_range"     "*,*,*,1018,*,*,*,1018,*")
-  (set_attr "neg_pool_range" "*,*,*,1004,*,*,*,1004,*")])
+                    neon_move<q>,neon_load1_1reg, neon_to_gp<q>,\
+		    neon_from_gp<q>,mov_reg,neon_load1_2reg,\
+		    neon_store1_2reg")
+  (set_attr "length" "4,4,4,4,4,4,4,8,8,8")
+  (set_attr "arm_pool_range"     "*,*,*,*,1020,*,*,*,1020,*")
+  (set_attr "thumb2_pool_range"     "*,*,*,*,1018,*,*,*,1018,*")
+  (set_attr "neg_pool_range" "*,*,*,*,1004,*,*,*,1004,*")])
 
 (define_insn "*neon_mov<mode>"
   [(set (match_operand:VQXMOV 0 "nonimmediate_operand"
-  	  "=w,Un,w, w,  ?r,?w,?r,?r,  ?Us")
+	  "=w,Un,w, w, w,  ?r,?w,?r,?r,  ?Us")
 	(match_operand:VQXMOV 1 "general_operand"
-	  " w,w, Dn,Uni, w, r, r, Usi, r"))]
+	  " w,w, Dm,DN,Uni, w, r, r, Usi, r"))]
   "TARGET_NEON
    && (register_operand (operands[0], <MODE>mode)
        || register_operand (operands[1], <MODE>mode))"
 {
-  if (which_alternative == 2)
+  if (which_alternative == 2 || which_alternative == 3)
     {
       int width, is_valid;
       static char templ[40];
@@ -98,20 +99,20 @@
   switch (which_alternative)
     {
     case 0: return "vmov\t%q0, %q1  @ <mode>";
-    case 1: case 3: return output_move_neon (operands);
-    case 2: gcc_unreachable ();
-    case 4: return "vmov\t%Q0, %R0, %e1  @ <mode>\;vmov\t%J0, %K0, %f1";
-    case 5: return "vmov\t%e0, %Q1, %R1  @ <mode>\;vmov\t%f0, %J1, %K1";
+    case 1: case 4: return output_move_neon (operands);
+    case 2: case 3: gcc_unreachable ();
+    case 5: return "vmov\t%Q0, %R0, %e1  @ <mode>\;vmov\t%J0, %K0, %f1";
+    case 6: return "vmov\t%e0, %Q1, %R1  @ <mode>\;vmov\t%f0, %J1, %K1";
     default: return output_move_quad (operands);
     }
 }
   [(set_attr "type" "neon_move_q,neon_store2_2reg_q,neon_move_q,\
-                     neon_load2_2reg_q,neon_to_gp_q,neon_from_gp_q,\
-                     mov_reg,neon_load1_4reg,neon_store1_4reg")
-   (set_attr "length" "4,8,4,8,8,8,16,8,16")
-   (set_attr "arm_pool_range" "*,*,*,1020,*,*,*,1020,*")
-   (set_attr "thumb2_pool_range" "*,*,*,1018,*,*,*,1018,*")
-   (set_attr "neg_pool_range" "*,*,*,996,*,*,*,996,*")])
+                     neon_move_q,neon_load2_2reg_q,neon_to_gp_q,\
+                     neon_from_gp_q,mov_reg,neon_load1_4reg,neon_store1_4reg")
+   (set_attr "length" "4,8,4,4,8,8,8,16,8,16")
+   (set_attr "arm_pool_range" "*,*,*,*,1020,*,*,*,1020,*")
+   (set_attr "thumb2_pool_range" "*,*,*,*,1018,*,*,*,1018,*")
+   (set_attr "neg_pool_range" "*,*,*,*,996,*,*,*,996,*")])
 
 (define_expand "movti"
   [(set (match_operand:TI 0 "nonimmediate_operand" "")
@@ -1007,7 +1008,7 @@
 (define_insn "vashl<mode>3"
   [(set (match_operand:VDQIW 0 "s_register_operand" "=w,w")
 	(ashift:VDQIW (match_operand:VDQIW 1 "s_register_operand" "w,w")
-		      (match_operand:VDQIW 2 "imm_lshift_or_reg_neon" "w,Dn")))]
+		      (match_operand:VDQIW 2 "imm_lshift_or_reg_neon" "w,Dm")))]
   "TARGET_NEON"
   {
     switch (which_alternative)
@@ -1026,7 +1027,7 @@
 (define_insn "vashr<mode>3_imm"
   [(set (match_operand:VDQIW 0 "s_register_operand" "=w")
 	(ashiftrt:VDQIW (match_operand:VDQIW 1 "s_register_operand" "w")
-			(match_operand:VDQIW 2 "imm_for_neon_rshift_operand" "Dn")))]
+			(match_operand:VDQIW 2 "imm_for_neon_rshift_operand" "Dm")))]
   "TARGET_NEON"
   {
     return neon_output_shift_immediate ("vshr", 's', &operands[2],
@@ -1039,7 +1040,7 @@
 (define_insn "vlshr<mode>3_imm"
   [(set (match_operand:VDQIW 0 "s_register_operand" "=w")
 	(lshiftrt:VDQIW (match_operand:VDQIW 1 "s_register_operand" "w")
-			(match_operand:VDQIW 2 "imm_for_neon_rshift_operand" "Dn")))]
+			(match_operand:VDQIW 2 "imm_for_neon_rshift_operand" "Dm")))]
   "TARGET_NEON"
   {
     return neon_output_shift_immediate ("vshr", 'u', &operands[2],
Index: gcc/config/arm/constraints.md
===================================================================
--- a/src/gcc/config/arm/constraints.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/arm/constraints.md	(.../branches/gcc-7-branch)
@@ -31,7 +31,8 @@
 ;; 'H' was previously used for FPA.
 
 ;; The following multi-letter normal constraints have been used:
-;; in ARM/Thumb-2 state: Da, Db, Dc, Dd, Dn, Dl, DL, Do, Dv, Dy, Di, Dt, Dp, Dz
+;; in ARM/Thumb-2 state: Da, Db, Dc, Dd, Dn, DN, Dm, Dl, DL, Do, Dv, Dy, Di,
+;;			 Dt, Dp, Dz
 ;; in Thumb-1 state: Pa, Pb, Pc, Pd, Pe
 ;; in Thumb-2 state: Pj, PJ, Ps, Pt, Pu, Pv, Pw, Px, Py
 ;; in all states: Pf
@@ -294,14 +295,28 @@
  (and (match_code "const_double,const_int")
       (match_test "TARGET_32BIT && arm_const_double_by_immediates (op)")))
 
-(define_constraint "Dn"
+(define_constraint "Dm"
  "@internal
-  In ARM/Thumb-2 state a const_vector or const_int which can be loaded with a
-  Neon vmov immediate instruction."
- (and (match_code "const_vector,const_int")
+  In ARM/Thumb-2 state a const_vector which can be loaded with a Neon vmov
+  immediate instruction."
+ (and (match_code "const_vector")
       (match_test "TARGET_32BIT
 		   && imm_for_neon_mov_operand (op, GET_MODE (op))")))
 
+(define_constraint "Dn"
+ "@internal
+  In ARM/Thumb-2 state a DImode const_int which can be loaded with a Neon vmov
+  immediate instruction."
+ (and (match_code "const_int")
+      (match_test "TARGET_32BIT && imm_for_neon_mov_operand (op, DImode)")))
+
+(define_constraint "DN"
+ "@internal
+  In ARM/Thumb-2 state a TImode const_int which can be loaded with a Neon vmov
+  immediate instruction."
+ (and (match_code "const_int")
+      (match_test "TARGET_32BIT && imm_for_neon_mov_operand (op, TImode)")))
+
 (define_constraint "Dl"
  "@internal
   In ARM/Thumb-2 state a const_vector which can be used with a Neon vorr or
Index: gcc/config/arm/t-rtems
===================================================================
--- a/src/gcc/config/arm/t-rtems	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/arm/t-rtems	(.../branches/gcc-7-branch)
@@ -1,7 +1,7 @@
 # Custom RTEMS multilibs for ARM
 
-MULTILIB_OPTIONS  = mbig-endian mthumb march=armv6-m/march=armv7-a/march=armv7-r/march=armv7-m/mcpu=cortex-m7 mfpu=neon/mfpu=vfp/mfpu=vfpv3-d16/mfpu=fpv4-sp-d16/mfpu=fpv5-d16 mfloat-abi=hard
-MULTILIB_DIRNAMES = eb thumb armv6-m armv7-a armv7-r armv7-m cortex-m7 neon vfp vfpv3-d16 fpv4-sp-d16 fpv5-d16 hard
+MULTILIB_OPTIONS  = mbig-endian mthumb march=armv6-m/march=armv7-a/march=armv7-r/mcpu=cortex-m3/mcpu=cortex-m4/mcpu=cortex-m7 mfpu=neon/mfpu=vfp/mfpu=vfpv3-d16/mfpu=fpv4-sp-d16/mfpu=fpv5-d16 mfloat-abi=hard
+MULTILIB_DIRNAMES = eb thumb armv6-m armv7-a armv7-r cortex-m3 cortex-m4 cortex-m7 neon vfp vfpv3-d16 fpv4-sp-d16 fpv5-d16 hard
 
 # Enumeration of multilibs
 
@@ -16,7 +16,8 @@
 MULTILIB_REQUIRED += mthumb/march=armv7-a
 MULTILIB_REQUIRED += mthumb/march=armv7-r/mfpu=vfpv3-d16/mfloat-abi=hard
 MULTILIB_REQUIRED += mthumb/march=armv7-r
-MULTILIB_REQUIRED += mthumb/march=armv7-m/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_REQUIRED += mthumb/mcpu=cortex-m3
+MULTILIB_REQUIRED += mthumb/mcpu=cortex-m4
+MULTILIB_REQUIRED += mthumb/mcpu=cortex-m4/mfpu=fpv4-sp-d16/mfloat-abi=hard
 MULTILIB_REQUIRED += mthumb/mcpu=cortex-m7/mfpu=fpv5-d16/mfloat-abi=hard
-MULTILIB_REQUIRED += mthumb/march=armv7-m
 MULTILIB_REQUIRED += mthumb
Index: gcc/config/arm/arm.md
===================================================================
--- a/src/gcc/config/arm/arm.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/arm/arm.md	(.../branches/gcc-7-branch)
@@ -4486,62 +4486,78 @@
 ; ARMv6+ unaligned load/store instructions (used for packed structure accesses).
 
 (define_insn "unaligned_loadsi"
-  [(set (match_operand:SI 0 "s_register_operand" "=l,r")
-	(unspec:SI [(match_operand:SI 1 "memory_operand" "Uw,m")]
+  [(set (match_operand:SI 0 "s_register_operand" "=l,l,r")
+	(unspec:SI [(match_operand:SI 1 "memory_operand" "m,Uw,m")]
 		   UNSPEC_UNALIGNED_LOAD))]
   "unaligned_access"
-  "ldr%?\t%0, %1\t@ unaligned"
-  [(set_attr "arch" "t2,any")
-   (set_attr "length" "2,4")
-   (set_attr "predicable" "yes")
-   (set_attr "predicable_short_it" "yes,no")
+  "@
+   ldr\t%0, %1\t@ unaligned
+   ldr%?\t%0, %1\t@ unaligned
+   ldr%?\t%0, %1\t@ unaligned"
+  [(set_attr "arch" "t1,t2,32")
+   (set_attr "length" "2,2,4")
+   (set_attr "predicable" "no,yes,yes")
+   (set_attr "predicable_short_it" "no,yes,no")
    (set_attr "type" "load1")])
 
+;; The 16-bit Thumb1 variant of ldrsh requires two registers in the
+;; address (there's no immediate format).  That's tricky to support
+;; here and we don't really need this pattern for that case, so only
+;; enable for 32-bit ISAs.
 (define_insn "unaligned_loadhis"
   [(set (match_operand:SI 0 "s_register_operand" "=r")
 	(sign_extend:SI
 	  (unspec:HI [(match_operand:HI 1 "memory_operand" "Uh")]
 		     UNSPEC_UNALIGNED_LOAD)))]
-  "unaligned_access"
+  "unaligned_access && TARGET_32BIT"
   "ldrsh%?\t%0, %1\t@ unaligned"
   [(set_attr "predicable" "yes")
    (set_attr "type" "load_byte")])
 
 (define_insn "unaligned_loadhiu"
-  [(set (match_operand:SI 0 "s_register_operand" "=l,r")
+  [(set (match_operand:SI 0 "s_register_operand" "=l,l,r")
 	(zero_extend:SI
-	  (unspec:HI [(match_operand:HI 1 "memory_operand" "Uw,m")]
+	  (unspec:HI [(match_operand:HI 1 "memory_operand" "m,Uw,m")]
 		     UNSPEC_UNALIGNED_LOAD)))]
   "unaligned_access"
-  "ldrh%?\t%0, %1\t@ unaligned"
-  [(set_attr "arch" "t2,any")
-   (set_attr "length" "2,4")
-   (set_attr "predicable" "yes")
-   (set_attr "predicable_short_it" "yes,no")
+  "@
+   ldrh\t%0, %1\t@ unaligned
+   ldrh%?\t%0, %1\t@ unaligned
+   ldrh%?\t%0, %1\t@ unaligned"
+  [(set_attr "arch" "t1,t2,32")
+   (set_attr "length" "2,2,4")
+   (set_attr "predicable" "no,yes,yes")
+   (set_attr "predicable_short_it" "no,yes,no")
    (set_attr "type" "load_byte")])
 
 (define_insn "unaligned_storesi"
-  [(set (match_operand:SI 0 "memory_operand" "=Uw,m")
-	(unspec:SI [(match_operand:SI 1 "s_register_operand" "l,r")]
+  [(set (match_operand:SI 0 "memory_operand" "=m,Uw,m")
+	(unspec:SI [(match_operand:SI 1 "s_register_operand" "l,l,r")]
 		   UNSPEC_UNALIGNED_STORE))]
   "unaligned_access"
-  "str%?\t%1, %0\t@ unaligned"
-  [(set_attr "arch" "t2,any")
-   (set_attr "length" "2,4")
-   (set_attr "predicable" "yes")
-   (set_attr "predicable_short_it" "yes,no")
+  "@
+   str\t%1, %0\t@ unaligned
+   str%?\t%1, %0\t@ unaligned
+   str%?\t%1, %0\t@ unaligned"
+  [(set_attr "arch" "t1,t2,32")
+   (set_attr "length" "2,2,4")
+   (set_attr "predicable" "no,yes,yes")
+   (set_attr "predicable_short_it" "no,yes,no")
    (set_attr "type" "store1")])
 
 (define_insn "unaligned_storehi"
-  [(set (match_operand:HI 0 "memory_operand" "=Uw,m")
-	(unspec:HI [(match_operand:HI 1 "s_register_operand" "l,r")]
+  [(set (match_operand:HI 0 "memory_operand" "=m,Uw,m")
+	(unspec:HI [(match_operand:HI 1 "s_register_operand" "l,l,r")]
 		   UNSPEC_UNALIGNED_STORE))]
   "unaligned_access"
-  "strh%?\t%1, %0\t@ unaligned"
-  [(set_attr "arch" "t2,any")
-   (set_attr "length" "2,4")
-   (set_attr "predicable" "yes")
-   (set_attr "predicable_short_it" "yes,no")
+  "@
+   strh\t%1, %0\t@ unaligned
+   strh%?\t%1, %0\t@ unaligned
+   strh%?\t%1, %0\t@ unaligned"
+  [(set_attr "arch" "t1,t2,32")
+   (set_attr "length" "2,2,4")
+   (set_attr "predicable" "no,yes,yes")
+   (set_attr "predicable_short_it" "no,yes,no")
    (set_attr "type" "store1")])
 
 
@@ -5999,52 +6015,29 @@
         }
     }
 
-  if (ARM_OFFSETS_MUST_BE_WITHIN_SECTIONS_P)
+  split_const (operands[1], &base, &offset);
+  if (INTVAL (offset) != 0
+      && targetm.cannot_force_const_mem (SImode, operands[1]))
     {
-      split_const (operands[1], &base, &offset);
-      if (GET_CODE (base) == SYMBOL_REF
-	  && !offset_within_block_p (base, INTVAL (offset)))
-	{
-	  tmp = can_create_pseudo_p () ? gen_reg_rtx (SImode) : operands[0];
-	  emit_move_insn (tmp, base);
-	  emit_insn (gen_addsi3 (operands[0], tmp, offset));
-	  DONE;
-	}
+      tmp = can_create_pseudo_p () ? gen_reg_rtx (SImode) : operands[0];
+      emit_move_insn (tmp, base);
+      emit_insn (gen_addsi3 (operands[0], tmp, offset));
+      DONE;
     }
 
+  tmp = can_create_pseudo_p () ? NULL_RTX : operands[0];
+
   /* Recognize the case where operand[1] is a reference to thread-local
-     data and load its address to a register.  */
+     data and load its address to a register.  Offsets have been split off
+     already.  */
   if (arm_tls_referenced_p (operands[1]))
-    {
-      rtx tmp = operands[1];
-      rtx addend = NULL;
-
-      if (GET_CODE (tmp) == CONST && GET_CODE (XEXP (tmp, 0)) == PLUS)
-        {
-          addend = XEXP (XEXP (tmp, 0), 1);
-          tmp = XEXP (XEXP (tmp, 0), 0);
-        }
-
-      gcc_assert (GET_CODE (tmp) == SYMBOL_REF);
-      gcc_assert (SYMBOL_REF_TLS_MODEL (tmp) != 0);
-
-      tmp = legitimize_tls_address (tmp,
-				    !can_create_pseudo_p () ? operands[0] : 0);
-      if (addend)
-        {
-          tmp = gen_rtx_PLUS (SImode, tmp, addend);
-          tmp = force_operand (tmp, operands[0]);
-        }
-      operands[1] = tmp;
-    }
+    operands[1] = legitimize_tls_address (operands[1], tmp);
   else if (flag_pic
 	   && (CONSTANT_P (operands[1])
 	       || symbol_mentioned_p (operands[1])
 	       || label_mentioned_p (operands[1])))
-      operands[1] = legitimize_pic_address (operands[1], SImode,
-					    (!can_create_pseudo_p ()
-					     ? operands[0]
-					     : 0));
+    operands[1] =
+      legitimize_pic_address (operands[1], SImode, tmp);
   }
   "
 )
Index: gcc/config/darwin-driver.c
===================================================================
--- a/src/gcc/config/darwin-driver.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/darwin-driver.c	(.../branches/gcc-7-branch)
@@ -26,6 +26,91 @@
 #include "opts.h"
 #include "diagnostic-core.h"
 
+/* Validate a version string (either given on the command line or, perhaps
+   as MACOSX_DEPLOYMENT_TARGET).
+
+   The specs %version-compare() function doesn't accept leading '0' on
+   numbers so strip them out.  Do sanity checking here too.
+
+   Return:
+     * original string means it was OK and we didn't want to change it.
+     * new string means it was OK but we rewrote it to avoid possible format
+     problems.
+     * NULL means we didn't like what we saw.
+*/
+
+static const char *
+validate_macosx_version_min (const char *version_str)
+{
+  size_t version_len;
+  unsigned long major, minor, tiny = 0;
+  char *end;
+  const char *old_version = version_str;
+  bool need_rewrite = false;
+
+  version_len = strlen (version_str);
+  if (version_len < 4) /* The minimum would be 10.x  */
+    return NULL;
+
+  /* Version string must consist of digits and periods only.  */
+  if (strspn (version_str, "0123456789.") != version_len)
+    return NULL;
+
+  if (!ISDIGIT (version_str[0]) || !ISDIGIT (version_str[version_len - 1]))
+    return NULL;
+
+  if (version_str[0] == '0')
+    need_rewrite = true;
+
+  major = strtoul (version_str, &end, 10);
+  version_str = end + ((*end == '.') ? 1 : 0);
+
+  if (major != 10) /* So far .. all MacOS 10 ... */
+    return NULL;
+
+  /* Version string components must be present and numeric.  */
+  if (!ISDIGIT (version_str[0]))
+    return NULL;
+
+  /* If we have one or more leading zeros on a component, then rewrite the
+     version string.  */
+  if (version_str[0] == '0' && version_str[1] != '\0'
+      && version_str[1] != '.')
+    need_rewrite = true;
+
+  minor = strtoul (version_str, &end, 10);
+  version_str = end + ((*end == '.') ? 1 : 0);
+  if (minor > 99)
+    return NULL;
+
+  /* If 'tiny' is present it must be numeric.  */
+  if (*end != '\0' && !ISDIGIT (version_str[0]))
+    return NULL;
+
+  /* If we have one or more leading zeros on a component, then rewrite the
+     version string.  */
+  if (*end != '\0' && version_str[0] == '0'
+      && version_str[1] != '\0')
+    need_rewrite = true;
+
+  tiny = strtoul (version_str, &end, 10);
+  if (tiny > 99)
+    return NULL;
+
+  /* Version string must contain no more than three tokens.  */
+  if (*end != '\0')
+    return NULL;
+
+  if (need_rewrite)
+    {
+      char *new_version;
+      asprintf (&new_version, "10.%lu.%lu", minor, tiny);
+      return new_version;
+    }
+
+  return old_version;
+}
+
 #ifndef CROSS_DIRECTORY_STRUCTURE
 #include <sys/sysctl.h>
 #include "xregex.h"
@@ -120,16 +205,39 @@
 
   if (new_flag != NULL)
     {
-      size_t len = strlen (new_flag);
-      if (len > 128) { /* Arbitrary limit, number should be like xx.yy.zz */
-	warning (0, "couldn%'t understand version %s\n", new_flag);
-	return NULL;
-      }
-      new_flag = xstrndup (new_flag, len);
+      const char *checked = validate_macosx_version_min (new_flag);
+      if (checked == NULL)
+	{
+	  warning (0, "couldn%'t understand version %s\n", new_flag);
+	  return NULL;
+	}
+      new_flag = xstrndup (checked, strlen (checked));
     }
   return new_flag;
 }
 
+/* See if we can find the sysroot from the SDKROOT environment variable.  */
+
+static const char *
+maybe_get_sysroot_from_sdkroot ()
+{
+  const char *maybe_sysroot = getenv ("SDKROOT");
+
+  /* We'll use the same rules as the clang driver, for compatibility.
+     1) The path must be absolute
+     2) Ignore "/", that is the default anyway and we do not want the
+	sysroot semantics to be applied to it.
+     3) It must exist (actually, we'll check it's readable too).  */
+
+   if (maybe_sysroot  == NULL
+       || *maybe_sysroot != '/'
+       || strlen (maybe_sysroot) == 1
+       || access (maybe_sysroot, R_OK) == -1)
+    return NULL;
+
+  return xstrndup (maybe_sysroot, strlen (maybe_sysroot));
+}
+
 /* Translate -filelist and -framework options in *DECODED_OPTIONS
    (size *DECODED_OPTIONS_COUNT) to use -Xlinker so that they are
    considered to be linker inputs in the case that no other inputs are
@@ -154,6 +262,7 @@
   bool appendM64 = false;
   const char *vers_string = NULL;
   bool seen_version_min = false;
+  bool seen_sysroot_p = false;
 
   for (i = 1; i < *decoded_options_count; i++)
     {
@@ -181,7 +290,7 @@
 	  if (*decoded_options_count > i) {
 	    memmove (*decoded_options + i,
 		     *decoded_options + i + 1,
-		     ((*decoded_options_count - i)
+		     ((*decoded_options_count - i - 1)
 		      * sizeof (struct cl_decoded_option)));
 	  }
 	  --i;
@@ -215,8 +324,30 @@
 
 	case OPT_mmacosx_version_min_:
 	  seen_version_min = true;
-	  vers_string = xstrndup ((*decoded_options)[i].arg, 32);
+	  vers_string =
+	    validate_macosx_version_min ((*decoded_options)[i].arg);
+	  if (vers_string == NULL)
+	    warning (0, "%qs is not valid for %<mmacosx-version-min%>\n",
+		     (*decoded_options)[i].arg);
+	  else if (vers_string == (*decoded_options)[i].arg)
+	    vers_string = xstrndup ((*decoded_options)[i].arg, 32);
+	  /* Now we've examined it, and verified/re-written, put it to
+	     one side and append later.  */
+	  if (*decoded_options_count > i) {
+	    memmove (*decoded_options + i,
+		     *decoded_options + i + 1,
+		     ((*decoded_options_count - i - 1)
+		      * sizeof (struct cl_decoded_option)));
+	  }
+	  --i;
+	  --*decoded_options_count;
+	  break;
 
+	case OPT__sysroot_:
+	case OPT_isysroot:
+	  seen_sysroot_p = true;
+	  break;
+
 	default:
 	  break;
 	}
@@ -278,26 +409,40 @@
 		       &(*decoded_options)[*decoded_options_count - 1]);
     }
 
-  /* We will need to know the OS X version we're trying to build for here
-     so that we can figure out the mechanism and source for the sysroot to
-     be used.  */
-  if (! seen_version_min && *decoded_options_count > 1)
+  if (! seen_sysroot_p)
     {
-      /* Not set by the User, try to figure it out.  */
-      vers_string = darwin_default_min_version ();
-      if (vers_string != NULL)
+      /* We will pick up an SDKROOT if we didn't specify a sysroot and treat
+	 it as overriding any configure-time --with-sysroot.  */
+       const char *sdkroot = maybe_get_sysroot_from_sdkroot ();
+       if (sdkroot)
 	{
 	  ++*decoded_options_count;
 	  *decoded_options = XRESIZEVEC (struct cl_decoded_option,
 					 *decoded_options,
 					 *decoded_options_count);
-	  generate_option (OPT_mmacosx_version_min_, vers_string, 1, CL_DRIVER,
-			  &(*decoded_options)[*decoded_options_count - 1]);
+	  generate_option (OPT__sysroot_, sdkroot, 1, CL_DRIVER,
+			   &(*decoded_options)[*decoded_options_count - 1]);
 	}
     }
-  /* Create and push the major version for assemblers that need it.  */
+
+  /* We will need to know the OS X version we're trying to build for here
+     so that we can figure out the mechanism and source for the sysroot to
+     be used.  */
+  if (! seen_version_min && *decoded_options_count > 1)
+    /* Not set by the User, try to figure it out.  */
+    vers_string = darwin_default_min_version ();
+
+  /* Create and push a cleaned up version, plus the major version for
+     assemblers and other cases that need it.  */
   if (vers_string != NULL)
     {
+       ++*decoded_options_count;
+       *decoded_options = XRESIZEVEC (struct cl_decoded_option,
+				      *decoded_options,
+				      *decoded_options_count);
+      generate_option (OPT_mmacosx_version_min_, vers_string, 1, CL_DRIVER,
+		       &(*decoded_options)[*decoded_options_count - 1]);
+
       char *asm_major = NULL;
       const char *first_period = strchr(vers_string, '.');
       if (first_period != NULL)
Index: gcc/config/pa/pa.md
===================================================================
--- a/src/gcc/config/pa/pa.md	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/pa/pa.md	(.../branches/gcc-7-branch)
@@ -5319,8 +5319,8 @@
 
 (define_insn "umulsidi3"
   [(set (match_operand:DI 0 "register_operand" "=f")
-	(mult:DI (zero_extend:DI (match_operand:SI 1 "nonimmediate_operand" "f"))
-		 (zero_extend:DI (match_operand:SI 2 "nonimmediate_operand" "f"))))]
+	(mult:DI (zero_extend:DI (match_operand:SI 1 "register_operand" "f"))
+		 (zero_extend:DI (match_operand:SI 2 "register_operand" "f"))))]
   "TARGET_PA_11 && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT"
   "xmpyu %1,%2,%0"
   [(set_attr "type" "fpmuldbl")
@@ -5328,7 +5328,7 @@
 
 (define_insn ""
   [(set (match_operand:DI 0 "register_operand" "=f")
-	(mult:DI (zero_extend:DI (match_operand:SI 1 "nonimmediate_operand" "f"))
+	(mult:DI (zero_extend:DI (match_operand:SI 1 "register_operand" "f"))
 		 (match_operand:DI 2 "uint32_operand" "f")))]
   "TARGET_PA_11 && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT && !TARGET_64BIT"
   "xmpyu %1,%R2,%0"
@@ -5337,7 +5337,7 @@
 
 (define_insn ""
   [(set (match_operand:DI 0 "register_operand" "=f")
-	(mult:DI (zero_extend:DI (match_operand:SI 1 "nonimmediate_operand" "f"))
+	(mult:DI (zero_extend:DI (match_operand:SI 1 "register_operand" "f"))
 		 (match_operand:DI 2 "uint32_operand" "f")))]
   "TARGET_PA_11 && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT && TARGET_64BIT"
   "xmpyu %1,%2R,%0"
@@ -6904,21 +6904,24 @@
   rtx stack = operands[2];
   rtx fp = operands[3];
 
-  lab = copy_to_reg (lab);
-
   emit_clobber (gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (VOIDmode)));
   emit_clobber (gen_rtx_MEM (BLKmode, hard_frame_pointer_rtx));
 
-  /* Restore the frame pointer.  The virtual_stack_vars_rtx is saved
-     instead of the hard_frame_pointer_rtx in the save area.  As a
-     result, an extra instruction is needed to adjust for the offset
+  lab = copy_to_reg (lab);
+
+  /* Restore the stack and frame pointers.  The virtual_stack_vars_rtx
+     is saved instead of the hard_frame_pointer_rtx in the save area.
+     As a result, an extra instruction is needed to adjust for the offset
      of the virtual stack variables and the hard frame pointer.  */
-  if (GET_CODE (fp) != REG)
-    fp = force_reg (Pmode, fp);
+  fp = copy_to_reg (fp);
+  emit_stack_restore (SAVE_NONLOCAL, stack);
+
+  /* Ensure the frame pointer move is not optimized.  */
+  emit_insn (gen_blockage ());
+  emit_clobber (hard_frame_pointer_rtx);
+  emit_clobber (frame_pointer_rtx);
   emit_move_insn (hard_frame_pointer_rtx, plus_constant (Pmode, fp, -8));
 
-  emit_stack_restore (SAVE_NONLOCAL, stack);
-
   emit_use (hard_frame_pointer_rtx);
   emit_use (stack_pointer_rtx);
 
@@ -8695,23 +8698,26 @@
   emit_clobber (gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (VOIDmode)));
   emit_clobber (gen_rtx_MEM (BLKmode, hard_frame_pointer_rtx));
 
-  /* Restore the frame pointer.  The virtual_stack_vars_rtx is saved
-     instead of the hard_frame_pointer_rtx in the save area.  We need
-     to adjust for the offset between these two values.  */
-  if (GET_CODE (fp) != REG)
-    fp = force_reg (Pmode, fp);
+  /* Load the label we are jumping through into r1 so that we know
+     where to look for it when we get back to setjmp's function for
+     restoring the gp.  */
+  emit_move_insn (pv, lab);
+
+  /* Restore the stack and frame pointers.  The virtual_stack_vars_rtx
+     is saved instead of the hard_frame_pointer_rtx in the save area.
+     We need to adjust for the offset between these two values.  */
+  fp = copy_to_reg (fp);
+  emit_stack_restore (SAVE_NONLOCAL, stack);
+
+  /* Ensure the frame pointer move is not optimized.  */
+  emit_insn (gen_blockage ());
+  emit_clobber (hard_frame_pointer_rtx);
+  emit_clobber (frame_pointer_rtx);
   emit_move_insn (hard_frame_pointer_rtx, plus_constant (Pmode, fp, -8));
 
-  /* This bit is the same as expand_builtin_longjmp.  */
-  emit_stack_restore (SAVE_NONLOCAL, stack);
   emit_use (hard_frame_pointer_rtx);
   emit_use (stack_pointer_rtx);
 
-  /* Load the label we are jumping through into r1 so that we know
-     where to look for it when we get back to setjmp's function for
-     restoring the gp.  */
-  emit_move_insn (pv, lab);
-
   /* Prevent the insns above from being scheduled into the delay slot
      of the interspace jump because the space register could change.  */
   emit_insn (gen_blockage ());
Index: gcc/config/pa/pa.c
===================================================================
--- a/src/gcc/config/pa/pa.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/pa/pa.c	(.../branches/gcc-7-branch)
@@ -10001,10 +10001,11 @@
   /* There is no way to load QImode or HImode values directly from memory
      to a FP register.  SImode loads to the FP registers are not zero
      extended.  On the 64-bit target, this conflicts with the definition
-     of LOAD_EXTEND_OP.  Thus, we can't allow changing between modes with
-     different sizes in the floating-point registers.  */
+     of LOAD_EXTEND_OP.  Thus, we reject all mode changes in the FP registers
+     except for DImode to SImode on the 64-bit target.  It is handled by
+     register renaming in pa_print_operand.  */
   if (MAYBE_FP_REG_CLASS_P (rclass))
-    return true;
+    return !(TARGET_64BIT && from == DImode && to == SImode);
 
   /* HARD_REGNO_MODE_OK places modes with sizes larger than a word
      in specific sets of registers.  Thus, we cannot allow changing
@@ -10199,8 +10200,8 @@
     }
 
 #ifdef HAVE_ENABLE_EXECUTE_STACK
- emit_library_call (gen_rtx_SYMBOL_REF (Pmode, "__enable_execute_stack"),
-		 LCT_NORMAL, VOIDmode, 1, XEXP (m_tramp, 0), Pmode);
+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, "__enable_execute_stack"),
+		     LCT_NORMAL, VOIDmode, 1, XEXP (m_tramp, 0), Pmode);
 #endif
 }
 
Index: gcc/config/darwin9.h
===================================================================
--- a/src/gcc/config/darwin9.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/config/darwin9.h	(.../branches/gcc-7-branch)
@@ -35,12 +35,6 @@
 /* Tell collect2 to run dsymutil for us as necessary.  */
 #define COLLECT_RUN_DSYMUTIL 1
 
-#undef DARWIN_PIE_SPEC
-#define DARWIN_PIE_SPEC \
-  "%{fpie|pie|fPIE: \
-     %{mdynamic-no-pic: %n'-mdynamic-no-pic' overrides '-pie', '-fpie' or '-fPIE'; \
-      :-pie}}"
-
 /* Only ask as for debug data if the debug style is stabs (since as doesn't
    yet generate dwarf.)  */
 
Index: gcc/tree-vect-slp.c
===================================================================
--- a/src/gcc/tree-vect-slp.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-vect-slp.c	(.../branches/gcc-7-branch)
@@ -2482,17 +2482,47 @@
       gcc_assert (stmt_info);
       gcc_assert (STMT_SLP_TYPE (stmt_info) != loop_vect);
 
+      /* ???  We have to catch the case late where two first scalar stmts appear
+	 in multiple SLP children with different def type and fail.  Remember
+	 original def types first since SLP_TREE_DEF_TYPE doesn't necessarily
+	 match it when that is vect_internal_def.  */
+      auto_vec<vect_def_type, 4> dt;
+      dt.safe_grow (SLP_TREE_CHILDREN (node).length ());
+      FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)
+	dt[j]
+	  = STMT_VINFO_DEF_TYPE (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (child)[i]));
+
       /* Push SLP node def-type to stmt operands.  */
       FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)
 	if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)
 	  STMT_VINFO_DEF_TYPE (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (child)[i]))
 	    = SLP_TREE_DEF_TYPE (child);
-      res = vect_analyze_stmt (stmt, &dummy, node);
+
+      /* Check everything worked out.  */
+      FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)
+	if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)
+	  {
+	    if (STMT_VINFO_DEF_TYPE
+		  (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (child)[i]))
+		!= SLP_TREE_DEF_TYPE (child))
+	      res = false;
+	  }
+	else if (STMT_VINFO_DEF_TYPE
+		   (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (child)[i])) != dt[j])
+	  res = false;
+      if (!res && dump_enabled_p ())
+	dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
+			 "not vectorized: same operand with different "
+			 "def type in stmt.\n");
+
+      if (res)
+	res = vect_analyze_stmt (stmt, &dummy, node);
+
       /* Restore def-types.  */
       FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)
 	if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)
 	  STMT_VINFO_DEF_TYPE (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (child)[i]))
-	    = vect_internal_def;
+	    = dt[j];
       if (! res)
 	break;
     }
Index: gcc/cfgrtl.c
===================================================================
--- a/src/gcc/cfgrtl.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/cfgrtl.c	(.../branches/gcc-7-branch)
@@ -4204,7 +4204,7 @@
 /* Create a duplicate of the basic block BB.  */
 
 static basic_block
-cfg_layout_duplicate_bb (basic_block bb)
+cfg_layout_duplicate_bb (basic_block bb, copy_bb_data *)
 {
   rtx_insn *insn;
   basic_block new_bb;
@@ -5013,9 +5013,9 @@
 }
 
 static basic_block
-rtl_duplicate_bb (basic_block bb)
+rtl_duplicate_bb (basic_block bb, copy_bb_data *id)
 {
-  bb = cfg_layout_duplicate_bb (bb);
+  bb = cfg_layout_duplicate_bb (bb, id);
   bb->aux = NULL;
   return bb;
 }
Index: gcc/dce.c
===================================================================
--- a/src/gcc/dce.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/dce.c	(.../branches/gcc-7-branch)
@@ -86,7 +86,33 @@
     }
 }
 
+/* Don't delete calls that may throw if we cannot do so.  */
 
+static bool
+can_delete_call (rtx_insn *insn)
+{
+  if (cfun->can_delete_dead_exceptions && can_alter_cfg)
+    return true;
+  if (!insn_nothrow_p (insn))
+    return false;
+  if (can_alter_cfg)
+    return true;
+  /* If we can't alter cfg, even when the call can't throw exceptions, it
+     might have EDGE_ABNORMAL_CALL edges and so we shouldn't delete such
+     calls.  */
+  gcc_assert (CALL_P (insn));
+  if (BLOCK_FOR_INSN (insn) && BB_END (BLOCK_FOR_INSN (insn)) == insn)
+    {
+      edge e;
+      edge_iterator ei;
+
+      FOR_EACH_EDGE (e, ei, BLOCK_FOR_INSN (insn)->succs)
+	if ((e->flags & EDGE_ABNORMAL_CALL) != 0)
+	  return false;
+    }
+  return true;
+}
+
 /* Return true if INSN is a normal instruction that can be deleted by
    the DCE pass.  */
 
@@ -108,7 +134,9 @@
       /* We can delete dead const or pure calls as long as they do not
          infinite loop.  */
       && (RTL_CONST_OR_PURE_CALL_P (insn)
-	  && !RTL_LOOPING_CONST_OR_PURE_CALL_P (insn)))
+	  && !RTL_LOOPING_CONST_OR_PURE_CALL_P (insn))
+      /* Don't delete calls that may throw if we cannot do so.  */
+      && can_delete_call (insn))
     return find_call_stack_args (as_a <rtx_call_insn *> (insn), false,
 				 fast, arg_stores);
 
@@ -200,7 +228,8 @@
 	  && !df_in_progress
 	  && !SIBLING_CALL_P (insn)
 	  && (RTL_CONST_OR_PURE_CALL_P (insn)
-	      && !RTL_LOOPING_CONST_OR_PURE_CALL_P (insn)))
+	      && !RTL_LOOPING_CONST_OR_PURE_CALL_P (insn))
+	  && can_delete_call (insn))
 	find_call_stack_args (as_a <rtx_call_insn *> (insn), true, fast, NULL);
     }
 }
@@ -569,7 +598,12 @@
 	  rtx turn_into_use = NULL_RTX;
 
 	  /* Always delete no-op moves.  */
-	  if (noop_move_p (insn))
+	  if (noop_move_p (insn)
+	      /* Unless the no-op move can throw and we are not allowed
+		 to alter cfg.  */
+	      && (!cfun->can_throw_non_call_exceptions
+		  || (cfun->can_delete_dead_exceptions && can_alter_cfg)
+		  || insn_nothrow_p (insn)))
 	    {
 	      if (RTX_FRAME_RELATED_P (insn))
 		turn_into_use
@@ -612,12 +646,6 @@
 	     for the destination regs in order to avoid dangling notes.  */
 	  remove_reg_equal_equiv_notes_for_defs (insn);
 
-	  /* If a pure or const call is deleted, this may make the cfg
-	     have unreachable blocks.  We rememeber this and call
-	     delete_unreachable_blocks at the end.  */
-	  if (CALL_P (insn))
-	    must_clean = true;
-
 	  if (turn_into_use)
 	    {
 	      /* Don't remove frame related noop moves if they cary
@@ -630,12 +658,15 @@
 	    }
 	  else
 	    /* Now delete the insn.  */
-	    delete_insn_and_edges (insn);
+	    must_clean |= delete_insn_and_edges (insn);
 	}
 
   /* Deleted a pure or const call.  */
   if (must_clean)
-    delete_unreachable_blocks ();
+    {
+      delete_unreachable_blocks ();
+      free_dominance_info (CDI_DOMINATORS);
+    }
 }
 
 
Index: gcc/tree-ssanames.c
===================================================================
--- a/src/gcc/tree-ssanames.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/tree-ssanames.c	(.../branches/gcc-7-branch)
@@ -744,7 +744,12 @@
     {
       /* points-to info is not flow-sensitive.  */
       if (SSA_NAME_PTR_INFO (name))
-	mark_ptr_info_alignment_unknown (SSA_NAME_PTR_INFO (name));
+	{
+	  /* [E]VRP can derive context sensitive alignment info and
+	     non-nullness properties.  We must reset both.  */
+	  mark_ptr_info_alignment_unknown (SSA_NAME_PTR_INFO (name));
+	  SSA_NAME_PTR_INFO (name)->pt.null = 1;
+	}
     }
   else
     SSA_NAME_RANGE_INFO (name) = NULL;
Index: gcc/convert.c
===================================================================
--- a/src/gcc/convert.c	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/convert.c	(.../branches/gcc-7-branch)
@@ -190,12 +190,15 @@
 	  CASE_MATHFN (FABS)
 	  CASE_MATHFN (LOGB)
 #undef CASE_MATHFN
+	    if (call_expr_nargs (expr) != 1
+		|| !SCALAR_FLOAT_TYPE_P (TREE_TYPE (CALL_EXPR_ARG (expr, 0))))
+	      break;
 	    {
 	      tree arg0 = strip_float_extensions (CALL_EXPR_ARG (expr, 0));
 	      tree newtype = type;
 
-	      /* We have (outertype)sqrt((innertype)x).  Choose the wider mode from
-		 the both as the safe type for operation.  */
+	      /* We have (outertype)sqrt((innertype)x).  Choose the wider mode
+		 from the both as the safe type for operation.  */
 	      if (TYPE_PRECISION (TREE_TYPE (arg0)) > TYPE_PRECISION (type))
 		newtype = TREE_TYPE (arg0);
 
@@ -579,7 +582,8 @@
 
 	CASE_FLT_FN (BUILT_IN_ROUND):
 	  /* Only convert in ISO C99 mode and with -fno-math-errno.  */
-	  if (!targetm.libc_has_function (function_c99_misc) || flag_errno_math)
+	  if (!targetm.libc_has_function (function_c99_misc)
+	      || flag_errno_math)
 	    break;
 	  if (outprec < TYPE_PRECISION (integer_type_node)
 	      || (outprec == TYPE_PRECISION (integer_type_node)
@@ -600,7 +604,8 @@
 	  gcc_fallthrough ();
 	CASE_FLT_FN (BUILT_IN_RINT):
 	  /* Only convert in ISO C99 mode and with -fno-math-errno.  */
-	  if (!targetm.libc_has_function (function_c99_misc) || flag_errno_math)
+	  if (!targetm.libc_has_function (function_c99_misc)
+	      || flag_errno_math)
 	    break;
 	  if (outprec < TYPE_PRECISION (integer_type_node)
 	      || (outprec == TYPE_PRECISION (integer_type_node)
@@ -615,13 +620,19 @@
 	  break;
 
 	CASE_FLT_FN (BUILT_IN_TRUNC):
-	  return convert_to_integer_1 (type, CALL_EXPR_ARG (s_expr, 0), dofold);
+	  if (call_expr_nargs (s_expr) != 1
+	      || !SCALAR_FLOAT_TYPE_P (TREE_TYPE (CALL_EXPR_ARG (s_expr, 0))))
+	    break;
+	  return convert_to_integer_1 (type, CALL_EXPR_ARG (s_expr, 0),
+				       dofold);
 
 	default:
 	  break;
 	}
 
-      if (fn)
+      if (fn
+	  && call_expr_nargs (s_expr) == 1
+	  && SCALAR_FLOAT_TYPE_P (TREE_TYPE (CALL_EXPR_ARG (s_expr, 0))))
         {
 	  tree newexpr = build_call_expr (fn, 1, CALL_EXPR_ARG (s_expr, 0));
 	  return convert_to_integer_1 (type, newexpr, dofold);
@@ -652,7 +663,9 @@
 	  break;
 	}
 
-      if (fn)
+      if (fn
+	  && call_expr_nargs (s_expr) == 1
+	  && SCALAR_FLOAT_TYPE_P (TREE_TYPE (CALL_EXPR_ARG (s_expr, 0))))
         {
 	  tree newexpr = build_call_expr (fn, 1, CALL_EXPR_ARG (s_expr, 0));
 	  return convert_to_integer_1 (type, newexpr, dofold);
Index: gcc/lto-streamer.h
===================================================================
--- a/src/gcc/lto-streamer.h	(.../tags/gcc_7_4_0_release)
+++ b/src/gcc/lto-streamer.h	(.../branches/gcc-7-branch)
@@ -129,7 +129,7 @@
      form followed by the data for the string.  */
 
 #define LTO_major_version 6
-#define LTO_minor_version 0
+#define LTO_minor_version 2
 
 typedef unsigned char	lto_decl_flags_t;
 
Index: libgfortran/runtime/backtrace.c
===================================================================
--- a/src/libgfortran/runtime/backtrace.c	(.../tags/gcc_7_4_0_release)
+++ b/src/libgfortran/runtime/backtrace.c	(.../branches/gcc-7-branch)
@@ -135,14 +135,23 @@
 void
 show_backtrace (bool in_signal_handler)
 {
+  /* Note that libbacktrace allows the state to be accessed from
+     multiple threads, so we don't need to use a TLS variable for the
+     state here.  */
+  static struct backtrace_state *lbstate_saved;
   struct backtrace_state *lbstate;
   struct mystate state = { 0, false, in_signal_handler };
- 
-  lbstate = backtrace_create_state (NULL, __gthread_active_p (),
-				    error_callback, NULL);
 
-  if (lbstate == NULL)
-    return;
+  lbstate = __atomic_load_n (&lbstate_saved, __ATOMIC_RELAXED);
+  if (!lbstate)
+    {
+      lbstate = backtrace_create_state (NULL, __gthread_active_p (),
+					error_callback, NULL);
+      if (lbstate)
+	__atomic_store_n (&lbstate_saved, lbstate, __ATOMIC_RELAXED);
+      else
+	return;
+    }
 
   if (!BACKTRACE_SUPPORTED || (in_signal_handler && BACKTRACE_USES_MALLOC))
     {
Index: libgfortran/ChangeLog
===================================================================
--- a/src/libgfortran/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/libgfortran/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,43 @@
+2019-04-16  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-03-25  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR libgfortran/79540
+	* io/write_float.def (build_float_string): Don't copy digits when
+	ndigits is negative.
+
+2019-02-03  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR libfortran/88678
+	Revert:
+	2016-11-16  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR libfortran/78314
+	* config/fpu-glibc.h (support_fpu_trap): Use feenableexcept.
+
+2019-02-03  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR libfortran/88678
+	* config/fpu-glibc.h (set_fpu_trap_exceptions): Clear stalled
+	exception flags before changing trap mode.  Optimize to call
+	feenableexcept and fedisableexcept only once.
+
+2019-01-13  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/88776
+	* io/list_read.c (namelist_read): Use nml_err_ret path on read error
+	not based on stdin_unit.
+	* io/open.c (newunit): Free format buffer if the unit specified is for
+	stdin, stdout, or stderr.
+
+2018-12-06  Janne Blomqvist  <jb@gcc.gnu.org>
+
+	Backport from trunk
+	PR libfortran/88137
+	* runtime/backtrace.c (show_backtrace): Store backtrace state in a
+	static variable, initialize once.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: libgfortran/config/fpu-glibc.h
===================================================================
--- a/src/libgfortran/config/fpu-glibc.h	(.../tags/gcc_7_4_0_release)
+++ b/src/libgfortran/config/fpu-glibc.h	(.../branches/gcc-7-branch)
@@ -39,48 +39,56 @@
 
 void set_fpu_trap_exceptions (int trap, int notrap)
 {
+  int mode_set = 0, mode_clr = 0;
+
 #ifdef FE_INVALID
   if (trap & GFC_FPE_INVALID)
-    feenableexcept (FE_INVALID);
+    mode_set |= FE_INVALID;
   if (notrap & GFC_FPE_INVALID)
-    fedisableexcept (FE_INVALID);
+    mode_clr |= FE_INVALID;
 #endif
 
 /* Some glibc targets (like alpha) have FE_DENORMAL, but not many.  */
 #ifdef FE_DENORMAL
   if (trap & GFC_FPE_DENORMAL)
-    feenableexcept (FE_DENORMAL);
+    mode_set |= FE_DENORMAL;
   if (notrap & GFC_FPE_DENORMAL)
-    fedisableexcept (FE_DENORMAL);
+    mode_clr |= FE_DENORMAL;
 #endif
 
 #ifdef FE_DIVBYZERO
   if (trap & GFC_FPE_ZERO)
-    feenableexcept (FE_DIVBYZERO);
+    mode_set |= FE_DIVBYZERO;
   if (notrap & GFC_FPE_ZERO)
-    fedisableexcept (FE_DIVBYZERO);
+    mode_clr |= FE_DIVBYZERO;
 #endif
 
 #ifdef FE_OVERFLOW
   if (trap & GFC_FPE_OVERFLOW)
-    feenableexcept (FE_OVERFLOW);
+    mode_set |= FE_OVERFLOW;
   if (notrap & GFC_FPE_OVERFLOW)
-    fedisableexcept (FE_OVERFLOW);
+    mode_clr |= FE_OVERFLOW;
 #endif
 
 #ifdef FE_UNDERFLOW
   if (trap & GFC_FPE_UNDERFLOW)
-    feenableexcept (FE_UNDERFLOW);
+    mode_set |= FE_UNDERFLOW;
   if (notrap & GFC_FPE_UNDERFLOW)
-    fedisableexcept (FE_UNDERFLOW);
+    mode_clr |= FE_UNDERFLOW;
 #endif
 
 #ifdef FE_INEXACT
   if (trap & GFC_FPE_INEXACT)
-    feenableexcept (FE_INEXACT);
+    mode_set |= FE_INEXACT;
   if (notrap & GFC_FPE_INEXACT)
-    fedisableexcept (FE_INEXACT);
+    mode_clr |= FE_INEXACT;
 #endif
+
+  /* Clear stalled exception flags.  */
+  feclearexcept (FE_ALL_EXCEPT);
+
+  feenableexcept (mode_set);
+  fedisableexcept (mode_clr);
 }
 
 
@@ -121,41 +129,7 @@
 int
 support_fpu_trap (int flag)
 {
-  int exceptions = 0;
-  int old;
-
-  if (!support_fpu_flag (flag))
-    return 0;
-
-#ifdef FE_INVALID
-  if (flag & GFC_FPE_INVALID) exceptions |= FE_INVALID;
-#endif
-
-#ifdef FE_DIVBYZERO
-  if (flag & GFC_FPE_ZERO) exceptions |= FE_DIVBYZERO;
-#endif
-
-#ifdef FE_OVERFLOW
-  if (flag & GFC_FPE_OVERFLOW) exceptions |= FE_OVERFLOW;
-#endif
-
-#ifdef FE_UNDERFLOW
-  if (flag & GFC_FPE_UNDERFLOW) exceptions |= FE_UNDERFLOW;
-#endif
-
-#ifdef FE_DENORMAL
-  if (flag & GFC_FPE_DENORMAL) exceptions |= FE_DENORMAL;
-#endif
-
-#ifdef FE_INEXACT
-  if (flag & GFC_FPE_INEXACT) exceptions |= FE_INEXACT;
-#endif
-
-  old = feenableexcept (exceptions);
-  if (old == -1)
-    return 0;
-  fedisableexcept (exceptions & ~old);
-  return 1;
+  return support_fpu_flag (flag);
 }
 
 
Index: libgfortran/io/open.c
===================================================================
--- a/src/libgfortran/io/open.c	(.../tags/gcc_7_4_0_release)
+++ b/src/libgfortran/io/open.c	(.../branches/gcc-7-branch)
@@ -529,6 +529,14 @@
   if (u2 != NULL)
     unlock_unit (u2);
 
+  /* If the unit specified is preconnected with a file specified to be open,
+     then clear the format buffer.  */
+  if ((opp->common.unit == options.stdin_unit ||
+       opp->common.unit == options.stdout_unit ||
+       opp->common.unit == options.stderr_unit)
+      && (opp->common.flags & IOPARM_OPEN_HAS_FILE) != 0)
+    fbuf_destroy (u);
+
   /* Open file.  */
 
   s = open_external (opp, flags);
Index: libgfortran/io/list_read.c
===================================================================
--- a/src/libgfortran/io/list_read.c	(.../tags/gcc_7_4_0_release)
+++ b/src/libgfortran/io/list_read.c	(.../branches/gcc-7-branch)
@@ -3613,11 +3613,7 @@
   while (!dtp->u.p.input_complete)
     {
       if (!nml_get_obj_data (dtp, &prev_nl, nml_err_msg, sizeof nml_err_msg))
-	{
-	  if (dtp->u.p.current_unit->unit_number != options.stdin_unit)
-	    goto nml_err_ret;
-	  generate_error (&dtp->common, LIBERROR_READ_VALUE, nml_err_msg);
-        }
+	goto nml_err_ret;
 
       /* Reset the previous namelist pointer if we know we are not going
 	 to be doing multiple reads within a single namelist object.  */
Index: libgfortran/io/write_float.def
===================================================================
--- a/src/libgfortran/io/write_float.def	(.../tags/gcc_7_4_0_release)
+++ b/src/libgfortran/io/write_float.def	(.../branches/gcc-7-branch)
@@ -620,7 +620,7 @@
     }
 
   /* Set digits after the decimal point, padding with zeros.  */
-  if (nafter > 0)
+  if (ndigits >= 0 && nafter > 0)
     {
       if (nafter > ndigits)
 	i = ndigits;
@@ -627,7 +627,8 @@
       else
 	i = nafter;
 
-      memcpy (put, digits, i);
+      if (i > 0)
+	memcpy (put, digits, i);
       while (i < nafter)
 	put[i++] = '0';
 
Index: libcpp/line-map.c
===================================================================
--- a/src/libcpp/line-map.c	(.../tags/gcc_7_4_0_release)
+++ b/src/libcpp/line-map.c	(.../branches/gcc-7-branch)
@@ -753,6 +753,11 @@
       if (line_delta < 0
 	  || last_line != ORDINARY_MAP_STARTING_LINE_NUMBER (map)
 	  || SOURCE_COLUMN (map, highest) >= (1U << (column_bits - range_bits))
+	  || ( /* We can't reuse the map if the line offset is sufficiently
+		  large to cause overflow when computing location_t values.  */
+	      (to_line - ORDINARY_MAP_STARTING_LINE_NUMBER (map))
+	      >= (((uint64_t) 1)
+		  << (CHAR_BIT * sizeof (linenum_type) - column_bits)))
 	  || range_bits < map->m_range_bits)
 	map = linemap_check_ordinary
 	        (const_cast <line_map *>
Index: libcpp/ChangeLog
===================================================================
--- a/src/libcpp/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/libcpp/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,22 @@
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-18  Martin Liska  <mliska@suse.cz>
+
+	PR c++/89383
+	* line-map.c (linemap_line_start): Use 1UL in order
+	to not overflow.
+
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-11  Martin Liska  <mliska@suse.cz>
+
+	PR lto/88147
+	* line-map.c (linemap_line_start): Don't reuse the existing line
+	map if the line offset is sufficiently large to cause overflow
+	when computing location_t values.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: fixincludes/ChangeLog
===================================================================
--- a/src/fixincludes/ChangeLog	(.../tags/gcc_7_4_0_release)
+++ b/src/fixincludes/ChangeLog	(.../branches/gcc-7-branch)
@@ -1,3 +1,60 @@
+2019-09-04  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-08-18  C.G. Dogan  <gcc+cgdogan.00@gmail.com>
+		    Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/83531
+	* inclhack.def (darwin_api_availability): New; strip leading
+	underscores from API_XXXX defines.
+	* fixincl.x: Regenerate.
+	* tests/base/os/availability.h: New file.
+
+2019-09-04  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-21  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* inclhack.def: Replace the complex test using __STRICT_ANSI__ and
+	__STDC_VERSION__ with a test using __DARWIN_NO_LONG_LONG.
+	Ensure that the top level math.h uses <> to wrap included headers
+	rather than "".
+	* fixincl.x: Regenerated.
+	* tests/base/architecture/ppc/math.h: Update test to include the
+	__DARWIN_NO_LONG_LONG case.
+
+2019-09-04  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-21  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* inclhack.def: Guard __has_attribute and __has_extension in
+	os/base.h.
+	Guard Apple blocks syntax in dispatch/object.h.
+	* fixincl.x: Regenerate.
+	* tests/base/dispatch/object.h: New file.
+	* tests/base/os/base.h: New file.
+
+2019-06-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-11  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR bootstrap/89864
+	* inclhack.def (darwin_ucred__Atomic): Do not supply test_text
+	for wrap fixes.
+	* fixincl.x: Regenerated.
+
+	Backport from mainline.
+	2019-04-18  Erik Schnetter  <schnetter@gmail.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+		    Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR bootstrap/89864
+	* inclhack.def (darwin_ucred__Atomic): New, work around _Atomic keyword
+	use in headers included by C++.
+	* fixincl.x: Regenerated.
+
 2018-12-06  Release Manager
 
 	* GCC 7.4.0 released.
Index: fixincludes/tests/base/dispatch/object.h
===================================================================
--- a/src/fixincludes/tests/base/dispatch/object.h	(.../tags/gcc_7_4_0_release)
+++ b/src/fixincludes/tests/base/dispatch/object.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,18 @@
+/*  DO NOT EDIT THIS FILE.
+
+    It has been auto-edited by fixincludes from:
+
+	"fixinc/tests/inc/dispatch/object.h"
+
+    This had to be done to correct non-standard usages in the
+    original, manufacturer supplied header file.  */
+
+
+
+#if defined( DARWIN_DISPATCH_OBJECT_1_CHECK )
+#if __BLOCKS__
+typedef void (^dispatch_block_t)(void);
+#endif
+
+__BEGIN_DECLS
+#endif  /* DARWIN_DISPATCH_OBJECT_1_CHECK */
Index: fixincludes/tests/base/os/availability.h
===================================================================
--- a/src/fixincludes/tests/base/os/availability.h	(.../tags/gcc_7_4_0_release)
+++ b/src/fixincludes/tests/base/os/availability.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,18 @@
+/*  DO NOT EDIT THIS FILE.
+
+    It has been auto-edited by fixincludes from:
+
+	"fixinc/tests/inc/os/availability.h"
+
+    This had to be done to correct non-standard usages in the
+    original, manufacturer supplied header file.  */
+
+
+
+#if defined( DARWIN_API_AVAILABILITY_CHECK )
+    #define API_AVAILABLE(...)
+    #define API_DEPRECATED(...)
+    #define API_DEPRECATED_WITH_REPLACEMENT(...)
+    #define API_UNAVAILABLE(...)
+
+#endif  /* DARWIN_API_AVAILABILITY_CHECK */
Index: fixincludes/tests/base/os/base.h
===================================================================
--- a/src/fixincludes/tests/base/os/base.h	(.../tags/gcc_7_4_0_release)
+++ b/src/fixincludes/tests/base/os/base.h	(.../branches/gcc-7-branch)
@@ -0,0 +1,20 @@
+/*  DO NOT EDIT THIS FILE.
+
+    It has been auto-edited by fixincludes from:
+
+	"fixinc/tests/inc/os/base.h"
+
+    This had to be done to correct non-standard usages in the
+    original, manufacturer supplied header file.  */
+
+
+
+#if defined( DARWIN_OS_BASE_1_CHECK )
+#define __has_attribute(x) 0
+#endif
+#ifndef __has_extension
+#define __has_extension(x) 0
+#endif
+
+#if __GNUC__
+#endif  /* DARWIN_OS_BASE_1_CHECK */
Index: fixincludes/tests/base/architecture/ppc/math.h
===================================================================
--- a/src/fixincludes/tests/base/architecture/ppc/math.h	(.../tags/gcc_7_4_0_release)
+++ b/src/fixincludes/tests/base/architecture/ppc/math.h	(.../branches/gcc-7-branch)
@@ -12,3 +12,8 @@
 #if defined( BROKEN_NAN_CHECK )
 #if 1
 #endif  /* BROKEN_NAN_CHECK */
+
+
+#if defined( DARWIN_LL_FUNCS_AVAIL_CHECK )
+#if !(__DARWIN_NO_LONG_LONG)
+#endif  /* DARWIN_LL_FUNCS_AVAIL_CHECK */
Index: fixincludes/fixincl.x
===================================================================
--- a/src/fixincludes/fixincl.x	(.../tags/gcc_7_4_0_release)
+++ b/src/fixincludes/fixincl.x	(.../branches/gcc-7-branch)
@@ -1,12 +1,12 @@
 /*  -*- buffer-read-only: t -*- vi: set ro:
- * 
+ *
  * DO NOT EDIT THIS FILE   (fixincl.x)
- * 
- * It has been AutoGen-ed  Saturday February 25, 2017 at 03:25:44 PM EST
+ *
+ * It has been AutoGen-ed  August 29, 2019 at 12:25:44 AM by AutoGen 5.17.4
  * From the definitions    inclhack.def
  * and the template file   fixincl
  */
-/* DO NOT SVN-MERGE THIS FILE, EITHER Sat 25 Feb 2017 15:25:44 EST
+/* DO NOT SVN-MERGE THIS FILE, EITHER Thu Aug 29 00:25:44 BST 2019
  *
  * You must regenerate it.  Use the ./genfixes script.
  *
@@ -15,7 +15,7 @@
  * certain ANSI-incompatible system header files which are fixed to work
  * correctly with ANSI C and placed in a directory that GNU C will search.
  *
- * This file contains 248 fixup descriptions.
+ * This file contains 253 fixup descriptions.
  *
  * See README for more information.
  *
@@ -269,6 +269,56 @@
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * *
  *
+ *  Description of Darwin_Api_Availability fix
+ */
+tSCC zDarwin_Api_AvailabilityName[] =
+     "darwin_api_availability";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zDarwin_Api_AvailabilityList[] =
+  "os/availability.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzDarwin_Api_AvailabilityMachs[] = {
+        "*-*-darwin*",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zDarwin_Api_AvailabilitySelect0[] =
+       " *#define __API_AVAILABLE.*\n\
+ *#define __API_DEPRECATED.*\n\
+ *#define __API_DEPRECATED_WITH_REPLACEMENT.*\n\
+ *#define __API_UNAVAILABLE.*\n";
+
+/*
+ *  content bypass pattern - skip fix if pattern found
+ */
+tSCC zDarwin_Api_AvailabilityBypass0[] =
+       "__IPHONE_OS_VERSION_MIN_REQUIRED";
+
+#define    DARWIN_API_AVAILABILITY_TEST_CT  2
+static tTestDesc aDarwin_Api_AvailabilityTests[] = {
+  { TT_NEGREP,   zDarwin_Api_AvailabilityBypass0, (regex_t*)NULL },
+  { TT_EGREP,    zDarwin_Api_AvailabilitySelect0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Darwin_Api_Availability
+ */
+static const char* apzDarwin_Api_AvailabilityPatch[] = {
+    "format",
+    "    #define API_AVAILABLE(...)\n\
+    #define API_DEPRECATED(...)\n\
+    #define API_DEPRECATED_WITH_REPLACEMENT(...)\n\
+    #define API_UNAVAILABLE(...)\n",
+    (char*)NULL };
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
  *  Description of Aab_Fd_Zero_Asm_Posix_Types_H fix
  */
 tSCC zAab_Fd_Zero_Asm_Posix_Types_HName[] =
@@ -2638,7 +2688,7 @@
  *  Machine/OS name selection pattern
  */
 tSCC* apzDarwin_9_Long_Double_Funcs_2Machs[] = {
-        "*-*-darwin7.9*",
+        "*-*-darwin*",
         (const char*)NULL };
 
 /*
@@ -2744,6 +2794,42 @@
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * *
  *
+ *  Description of Darwin_Ll_Funcs_Avail fix
+ */
+tSCC zDarwin_Ll_Funcs_AvailName[] =
+     "darwin_ll_funcs_avail";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zDarwin_Ll_Funcs_AvailList[] =
+  "architecture/ppc/math.h\0architecture/i386/math.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzDarwin_Ll_Funcs_AvailMachs[] = {
+        "*-*-darwin*",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zDarwin_Ll_Funcs_AvailSelect0[] =
+       "#if[^_]*__STDC_VERSION__[^_]*__STDC_VERSION__[^1]*199901L[^_]*__STRICT_ANSI__[^_]*__GNUC__[^)]*";
+
+#define    DARWIN_LL_FUNCS_AVAIL_TEST_CT  1
+static tTestDesc aDarwin_Ll_Funcs_AvailTests[] = {
+  { TT_EGREP,    zDarwin_Ll_Funcs_AvailSelect0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Darwin_Ll_Funcs_Avail
+ */
+static const char* apzDarwin_Ll_Funcs_AvailPatch[] = { sed_cmd_z,
+    "-e", "s/#if[^_]*__STDC_VERSION__[^_]*__STDC_VERSION__[^_]*199901L[^_]*__STRICT_ANSI__[^_]*__GNUC__[^\\)]*)/#if !(__DARWIN_NO_LONG_LONG)/",
+    (char*)NULL };
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
  *  Description of Darwin_Longjmp_Noreturn fix
  */
 tSCC zDarwin_Longjmp_NoreturnName[] =
@@ -2906,6 +2992,86 @@
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * *
  *
+ *  Description of Darwin_Os_Base_1 fix
+ */
+tSCC zDarwin_Os_Base_1Name[] =
+     "darwin_os_base_1";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zDarwin_Os_Base_1List[] =
+  "os/base.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzDarwin_Os_Base_1Machs[] = {
+        "*-*-darwin*",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zDarwin_Os_Base_1Select0[] =
+       "#define __has_attribute.*\n\
+#endif";
+
+#define    DARWIN_OS_BASE_1_TEST_CT  1
+static tTestDesc aDarwin_Os_Base_1Tests[] = {
+  { TT_EGREP,    zDarwin_Os_Base_1Select0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Darwin_Os_Base_1
+ */
+static const char* apzDarwin_Os_Base_1Patch[] = {
+    "format",
+    "%0\n\
+#ifndef __has_extension\n\
+#define __has_extension(x) 0\n\
+#endif",
+    (char*)NULL };
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
+ *  Description of Darwin_Dispatch_Object_1 fix
+ */
+tSCC zDarwin_Dispatch_Object_1Name[] =
+     "darwin_dispatch_object_1";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zDarwin_Dispatch_Object_1List[] =
+  "dispatch/object.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzDarwin_Dispatch_Object_1Machs[] = {
+        "*-*-darwin*",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zDarwin_Dispatch_Object_1Select0[] =
+       "typedef void.*\\^dispatch_block_t.*";
+
+#define    DARWIN_DISPATCH_OBJECT_1_TEST_CT  1
+static tTestDesc aDarwin_Dispatch_Object_1Tests[] = {
+  { TT_EGREP,    zDarwin_Dispatch_Object_1Select0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Darwin_Dispatch_Object_1
+ */
+static const char* apzDarwin_Dispatch_Object_1Patch[] = {
+    "format",
+    "#if __BLOCKS__\n\
+%0\n\
+#endif",
+    (char*)NULL };
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
  *  Description of Darwin_Private_Extern fix
  */
 tSCC zDarwin_Private_ExternName[] =
@@ -3262,6 +3428,48 @@
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * *
  *
+ *  Description of Darwin_Ucred__Atomic fix
+ */
+tSCC zDarwin_Ucred__AtomicName[] =
+     "darwin_ucred__Atomic";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zDarwin_Ucred__AtomicList[] =
+  "sys/ucred.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzDarwin_Ucred__AtomicMachs[] = {
+        "*-*-darwin*",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zDarwin_Ucred__AtomicSelect0[] =
+       "_Atomic";
+
+#define    DARWIN_UCRED__ATOMIC_TEST_CT  1
+static tTestDesc aDarwin_Ucred__AtomicTests[] = {
+  { TT_EGREP,    zDarwin_Ucred__AtomicSelect0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Darwin_Ucred__Atomic
+ */
+static const char* apzDarwin_Ucred__AtomicPatch[] = {
+    "wrap",
+    "#if (__STDC_VERSION__ < 201112L) || defined(__cplusplus)\n\
+# define _Atomic volatile\n\
+#endif\n",
+    "#if (__STDC_VERSION__ < 201112L) || defined(__cplusplus)\n\
+# undef _Atomic\n\
+#endif\n",
+    (char*)NULL };
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
  *  Description of Dec_Intern_Asm fix
  */
 tSCC zDec_Intern_AsmName[] =
@@ -10139,9 +10347,9 @@
  *
  *  List of all fixes
  */
-#define REGEX_COUNT          285
+#define REGEX_COUNT          291
 #define MACH_LIST_SIZE_LIMIT 187
-#define FIX_COUNT            248
+#define FIX_COUNT            253
 
 /*
  *  Enumerate the fixes
@@ -10150,6 +10358,7 @@
     AAB_AIX_STDIO_FIXIDX,
     AAB_AIX_FCNTL_FIXIDX,
     AAB_DARWIN7_9_LONG_DOUBLE_FUNCS_FIXIDX,
+    DARWIN_API_AVAILABILITY_FIXIDX,
     AAB_FD_ZERO_ASM_POSIX_TYPES_H_FIXIDX,
     AAB_FD_ZERO_GNU_TYPES_H_FIXIDX,
     AAB_FD_ZERO_SELECTBITS_H_FIXIDX,
@@ -10210,10 +10419,13 @@
     DARWIN_9_LONG_DOUBLE_FUNCS_2_FIXIDX,
     DARWIN_EXTERNC_FIXIDX,
     DARWIN_GCC4_BREAKAGE_FIXIDX,
+    DARWIN_LL_FUNCS_AVAIL_FIXIDX,
     DARWIN_LONGJMP_NORETURN_FIXIDX,
     DARWIN_OS_TRACE_1_FIXIDX,
     DARWIN_OS_TRACE_2_FIXIDX,
     DARWIN_OS_TRACE_3_FIXIDX,
+    DARWIN_OS_BASE_1_FIXIDX,
+    DARWIN_DISPATCH_OBJECT_1_FIXIDX,
     DARWIN_PRIVATE_EXTERN_FIXIDX,
     DARWIN_STDINT_1_FIXIDX,
     DARWIN_STDINT_2_FIXIDX,
@@ -10222,6 +10434,7 @@
     DARWIN_STDINT_5_FIXIDX,
     DARWIN_STDINT_6_FIXIDX,
     DARWIN_STDINT_7_FIXIDX,
+    DARWIN_UCRED__ATOMIC_FIXIDX,
     DEC_INTERN_ASM_FIXIDX,
     DJGPP_WCHAR_H_FIXIDX,
     ECD_CURSOR_FIXIDX,
@@ -10413,6 +10626,11 @@
      AAB_DARWIN7_9_LONG_DOUBLE_FUNCS_TEST_CT, FD_MACH_ONLY | FD_REPLACEMENT,
      aAab_Darwin7_9_Long_Double_FuncsTests,   apzAab_Darwin7_9_Long_Double_FuncsPatch, 0 },
 
+  {  zDarwin_Api_AvailabilityName,    zDarwin_Api_AvailabilityList,
+     apzDarwin_Api_AvailabilityMachs,
+     DARWIN_API_AVAILABILITY_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aDarwin_Api_AvailabilityTests,   apzDarwin_Api_AvailabilityPatch, 0 },
+
   {  zAab_Fd_Zero_Asm_Posix_Types_HName,    zAab_Fd_Zero_Asm_Posix_Types_HList,
      apzAab_Fd_Zero_Asm_Posix_Types_HMachs,
      AAB_FD_ZERO_ASM_POSIX_TYPES_H_TEST_CT, FD_MACH_ONLY | FD_REPLACEMENT,
@@ -10713,6 +10931,11 @@
      DARWIN_GCC4_BREAKAGE_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
      aDarwin_Gcc4_BreakageTests,   apzDarwin_Gcc4_BreakagePatch, 0 },
 
+  {  zDarwin_Ll_Funcs_AvailName,    zDarwin_Ll_Funcs_AvailList,
+     apzDarwin_Ll_Funcs_AvailMachs,
+     DARWIN_LL_FUNCS_AVAIL_TEST_CT, FD_MACH_ONLY,
+     aDarwin_Ll_Funcs_AvailTests,   apzDarwin_Ll_Funcs_AvailPatch, 0 },
+
   {  zDarwin_Longjmp_NoreturnName,    zDarwin_Longjmp_NoreturnList,
      apzDarwin_Longjmp_NoreturnMachs,
      DARWIN_LONGJMP_NORETURN_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
@@ -10733,6 +10956,16 @@
      DARWIN_OS_TRACE_3_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
      aDarwin_Os_Trace_3Tests,   apzDarwin_Os_Trace_3Patch, 0 },
 
+  {  zDarwin_Os_Base_1Name,    zDarwin_Os_Base_1List,
+     apzDarwin_Os_Base_1Machs,
+     DARWIN_OS_BASE_1_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aDarwin_Os_Base_1Tests,   apzDarwin_Os_Base_1Patch, 0 },
+
+  {  zDarwin_Dispatch_Object_1Name,    zDarwin_Dispatch_Object_1List,
+     apzDarwin_Dispatch_Object_1Machs,
+     DARWIN_DISPATCH_OBJECT_1_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aDarwin_Dispatch_Object_1Tests,   apzDarwin_Dispatch_Object_1Patch, 0 },
+
   {  zDarwin_Private_ExternName,    zDarwin_Private_ExternList,
      apzDarwin_Private_ExternMachs,
      DARWIN_PRIVATE_EXTERN_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
@@ -10773,6 +11006,11 @@
      DARWIN_STDINT_7_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
      aDarwin_Stdint_7Tests,   apzDarwin_Stdint_7Patch, 0 },
 
+  {  zDarwin_Ucred__AtomicName,    zDarwin_Ucred__AtomicList,
+     apzDarwin_Ucred__AtomicMachs,
+     DARWIN_UCRED__ATOMIC_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aDarwin_Ucred__AtomicTests,   apzDarwin_Ucred__AtomicPatch, 0 },
+
   {  zDec_Intern_AsmName,    zDec_Intern_AsmList,
      apzDec_Intern_AsmMachs,
      DEC_INTERN_ASM_TEST_CT, FD_MACH_ONLY,
Index: fixincludes/inclhack.def
===================================================================
--- a/src/fixincludes/inclhack.def	(.../tags/gcc_7_4_0_release)
+++ b/src/fixincludes/inclhack.def	(.../branches/gcc-7-branch)
@@ -195,6 +195,33 @@
 };
 
 /*
+ *  SDKs for 10.13 and 10.14 omit the definitions for API_AVAILABLE where
+ *  __attribute__((availability)) is not supported.
+ */
+fix = {
+    hackname  = darwin_api_availability;
+    mach      = "*-*-darwin*";
+    files     = os/availability.h;
+    bypass    = "__IPHONE_OS_VERSION_MIN_REQUIRED";
+    select    =
+    " *#define __API_AVAILABLE.*\n"
+    " *#define __API_DEPRECATED.*\n"
+    " *#define __API_DEPRECATED_WITH_REPLACEMENT.*\n"
+    " *#define __API_UNAVAILABLE.*\n";
+    c_fix     = format;
+    c_fix_arg =
+    "    #define API_AVAILABLE(...)\n"
+    "    #define API_DEPRECATED(...)\n"
+    "    #define API_DEPRECATED_WITH_REPLACEMENT(...)\n"
+    "    #define API_UNAVAILABLE(...)\n";
+    test_text =
+    "#define __API_AVAILABLE(...)\n"
+    "#define __API_DEPRECATED(...)\n"
+    "#define __API_DEPRECATED_WITH_REPLACEMENT(...)\n"
+    "#define __API_UNAVAILABLE(...)\n";
+};
+
+/*
  *  This fixes __FD_ZERO bug for linux 2.x.y (x <= 2 && y <= some n)
  */
 fix = {
@@ -1364,12 +1391,12 @@
 };
 
 /*
- *  For the AAB_darwin7_9_long_double_funcs fix to be useful,
- *  you have to not use "" includes.
+ *  For the AAB_darwin7_9_long_double_funcs fix (and later fixes for long long)
+ *  to be useful, the main math.h must use <> and not "" includes.
  */
 fix = {
     hackname  = darwin_9_long_double_funcs_2;
-    mach      = "*-*-darwin7.9*";
+    mach      = "*-*-darwin*";
     files     = math.h;
     select    = '#include[ \t]+\"';
     c_fix     = format;
@@ -1377,7 +1404,7 @@
   
     c_fix_arg = '([ \t]*#[ \t]*include[ \t]+)"([a-z0-9/]+)\.h"';
   
-    test_text = '#include "architecture/ppc/math.h"';
+    test_text = '#include <architecture/ppc/math.h>';
 };
 
 /*
@@ -1421,6 +1448,22 @@
 };
 
 /*
+ * math.h hides the long long functions that are available on the system for
+ * 10.5 and 10.6 SDKs, we expect to use them in G++ without specifying a value
+ * for __STDC_VERSION__, or switching __STRICT_ANSI__ off.
+ */
+fix = {
+  hackname  = darwin_ll_funcs_avail;
+  mach      = "*-*-darwin*";
+  files     = architecture/ppc/math.h, architecture/i386/math.h;
+  select    = "#if[^_]*__STDC_VERSION__[^_]*__STDC_VERSION__[^1]*199901L[^_]*"
+	      "__STRICT_ANSI__[^_]*__GNUC__[^\)]*";
+  sed       = "s/#if[^_]*__STDC_VERSION__[^_]*__STDC_VERSION__[^_]*199901L[^_]*"
+	      "__STRICT_ANSI__[^_]*__GNUC__[^\\)]*\)/#if\ !\(__DARWIN_NO_LONG_LONG\)/";
+  test_text = "#if\ !(__DARWIN_NO_LONG_LONG)";
+};
+
+/*
  *  Before Mac OS X 10.8 <i386/setjmp.h> doesn't mark longjump noreturn.
  */
 fix = {
@@ -1492,6 +1535,49 @@
 };
 
 /*
+ *  In macOS 10.10 <os/base.h>, doesn't have __has_extension guarded.
+ */
+fix = {
+  hackname  = darwin_os_base_1;
+  mach      = "*-*-darwin*";
+  files     = os/base.h;
+  select    = <<- OS_BASE_1_SEL
+#define __has_attribute.*
+#endif
+OS_BASE_1_SEL;
+  c_fix     = format;
+  c_fix_arg = <<- OS_BASE_1_FIX
+%0
+#ifndef __has_extension
+#define __has_extension(x) 0
+#endif
+OS_BASE_1_FIX;
+  test_text = <<- OS_BASE_1_TEST
+#define __has_attribute(x) 0
+#endif
+
+#if __GNUC__
+OS_BASE_1_TEST;
+};
+
+/*
+ *  In macOS 10.10 <dispatch/object.h>, has unguarded block syntax.
+ */
+fix = {
+  hackname  = darwin_dispatch_object_1;
+  mach      = "*-*-darwin*";
+  files     = dispatch/object.h;
+  select    = "typedef void.*\\^dispatch_block_t.*";
+  c_fix     = format;
+  c_fix_arg = "#if __BLOCKS__\n%0\n#endif";
+  test_text = <<- DISPATCH_OBJECT_1_TEST
+typedef void (^dispatch_block_t)(void);
+
+__BEGIN_DECLS
+DISPATCH_OBJECT_1_TEST;
+};
+
+/*
  *  __private_extern__ doesn't exist in FSF GCC.  Even if it did,
  *  why would you ever put it in a system header file?
  */
@@ -1688,6 +1774,25 @@
 		"#define UINTMAX_C(v) (v ## ULL)";
 };
 
+/*  The SDK included with XCode 10.2 has the file <sys/ucred.h> that uses the
+    C11 _Atomic keyword (exposing it to C++ code).  The work-around here follows
+    the header in declaring the entity volatile when _Atomic is not available.
+*/
+fix = {
+    hackname  = darwin_ucred__Atomic;
+    mach      = "*-*-darwin*";
+    files     = sys/ucred.h;
+    select    = "_Atomic";
+    c_fix     = wrap;
+    c_fix_arg = "#if (__STDC_VERSION__ < 201112L) || defined(__cplusplus)\n"
+		"# define _Atomic volatile\n"
+		"#endif\n";
+    c_fix_arg = "#if (__STDC_VERSION__ < 201112L) || defined(__cplusplus)\n"
+		"# undef _Atomic\n"
+		"#endif\n";
+    test_text = ""; /* Don't provide this for wrap fixes.  */
+};
+
 /*
  *  Fix <c_asm.h> on Digital UNIX V4.0:
  *  It contains a prototype for a DEC C internal asm() function,
